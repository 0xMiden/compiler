
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.33">
    
    
      
        <title>High-Level Intermediate Representation (HIR) - Miden Compiler Docs</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.3cba04c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#high-level-intermediate-representation-hir" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Miden Compiler Docs" class="md-header__button md-logo" aria-label="Miden Compiler Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Miden Compiler Docs
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              High-Level Intermediate Representation (HIR)
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="Share" aria-label="Share" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Miden Compiler Docs" class="md-nav__button md-logo" aria-label="Miden Compiler Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Miden Compiler Docs
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Getting started
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Usage
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Usage
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/midenc/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    midenc
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/cargo-miden/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    cargo miden
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
        
      
        
      
        
      
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Guides
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Guides
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../guides/rust_to_wasm/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Rust To WebAssembly
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../guides/wasm_to_masm/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    WebAssembly To Miden Assembly
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../guides/develop_miden_in_rust/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Developing Miden programs In Rust
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../guides/develop_miden_rollup_accounts_and_note_scripts_in_rust/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Developing Miden rollup accounts and note scripts In Rust
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../usage/debugger/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Debugging programs
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Compiler architecture
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Compiler architecture
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../overview/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Overview
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../frontends/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Supported front ends
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
      
        
      
        
      
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Appendices
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            Appendices
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../appendix/known-limitations/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Known limitations
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../appendix/calling-conventions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Calling conventions
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../appendix/canonabi-adhocabi-mismatch/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Canonical ABI vs Miden ABI
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduction" class="md-nav__link">
    <span class="md-ellipsis">
      Introduction
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#concepts" class="md-nav__link">
    <span class="md-ellipsis">
      Concepts
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Concepts">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#components" class="md-nav__link">
    <span class="md-ellipsis">
      Components
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#interfaces" class="md-nav__link">
    <span class="md-ellipsis">
      Interfaces
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modules" class="md-nav__link">
    <span class="md-ellipsis">
      Modules
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#functions" class="md-nav__link">
    <span class="md-ellipsis">
      Functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#global-variables" class="md-nav__link">
    <span class="md-ellipsis">
      Global Variables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#symbols-and-symbol-tables" class="md-nav__link">
    <span class="md-ellipsis">
      Symbols and Symbol Tables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operations" class="md-nav__link">
    <span class="md-ellipsis">
      Operations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regions" class="md-nav__link">
    <span class="md-ellipsis">
      Regions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#blocks" class="md-nav__link">
    <span class="md-ellipsis">
      Blocks
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#values" class="md-nav__link">
    <span class="md-ellipsis">
      Values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operands" class="md-nav__link">
    <span class="md-ellipsis">
      Operands
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#immediates" class="md-nav__link">
    <span class="md-ellipsis">
      Immediates
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#attributes" class="md-nav__link">
    <span class="md-ellipsis">
      Attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#traits" class="md-nav__link">
    <span class="md-ellipsis">
      Traits
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#successors-and-predecessors" class="md-nav__link">
    <span class="md-ellipsis">
      Successors and Predecessors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dominance-relation" class="md-nav__link">
    <span class="md-ellipsis">
      Dominance Relation
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#structure" class="md-nav__link">
    <span class="md-ellipsis">
      Structure
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Structure">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#passes" class="md-nav__link">
    <span class="md-ellipsis">
      Passes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Passes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#analyses" class="md-nav__link">
    <span class="md-ellipsis">
      Analyses
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rewrites" class="md-nav__link">
    <span class="md-ellipsis">
      Rewrites
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conversions" class="md-nav__link">
    <span class="md-ellipsis">
      Conversions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#usage" class="md-nav__link">
    <span class="md-ellipsis">
      Usage
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="high-level-intermediate-representation-hir">High-Level Intermediate Representation (HIR)<a class="headerlink" href="#high-level-intermediate-representation-hir" title="Link to this section">&para;</a></h1>
<p>This document describes the concepts, usage, and overall structure of the intermediate
representation used by <code>midenc</code>.</p>
<h2 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Link to this section">&para;</a></h2>
<p>TODO</p>
<h2 id="concepts">Concepts<a class="headerlink" href="#concepts" title="Link to this section">&para;</a></h2>
<h3 id="components">Components<a class="headerlink" href="#components" title="Link to this section">&para;</a></h3>
<p>A <em>component</em> is a named entity that encapsulates one or more <a href="#interfaces"><em>interfaces</em></a>, and comes
in two forms:</p>
<ul>
<li>An <em>executable</em> component, which has a statically-defined entrypoint, a function which initializes
and executes a program encapsulated by the component.</li>
<li>A <em>library</em> component, which exports one or more interfaces, and can be used as a dependency of
other components.</li>
</ul>
<p>We also commonly refer to executable components as <em>programs</em>, and library components as <em>libraries</em>,
which also correspond to the equivalent concepts in Miden Assembly. However, components are a more
general abstraction over programs and libraries, where the distinction is mostly one of intended
use and/or convention.</p>
<p>Components can have zero or more dependencies, which are expressed in the form of interfaces that
they require instances of at runtime. Thus any component that provides the interface can be used
to satisfy the dependency.</p>
<p>A component <em>instance</em> refers to a component that has had all of its dependencies resolved
concretely, and is thus fully-defined.</p>
<p>A component <em>definition</em> specifies four things:</p>
<ol>
<li>The name of the component</li>
<li>The interfaces it imports</li>
<li>The interfaces it exports</li>
<li>The <a href="#modules"><em>modules</em></a> which implement the exported interfaces concretely</li>
</ol>
<h3 id="interfaces">Interfaces<a class="headerlink" href="#interfaces" title="Link to this section">&para;</a></h3>
<p>An <em>interface</em> is a named entity that describes one or more <a href="#functions"><em>functions</em></a> that it
exports. Conceptually, an <em>interface</em> loosely corresponds to the notion of a module, in that both
a module and an interface define a namespace, in which one or more functions are exported.</p>
<p>However, an <em>interface</em>, unlike a module, is abstract, and does not have any internal structure.
It is more like a trait, in that it abstractly represents a set of named behaviors implemented by
some <a href="#components">component</a>.</p>
<h3 id="modules">Modules<a class="headerlink" href="#modules" title="Link to this section">&para;</a></h3>
<p>A module is primarily two things:</p>
<ol>
<li>A container for one or more functions belonging to a common namespace</li>
<li>A concrete implementation of one or more <a href="#interfaces">interfaces</a></li>
</ol>
<p>Functions within a module may be exported, and so a module always has an implicit interface
consisting of all of its exported functions. Functions which are <em>not</em> exported, are only visible
within the module, and do not form a part of the implicit interface of a module.</p>
<p>Module names are used to name the implicit interface of the module. Thus, within a component, both
imported interfaces, and the implicit interfaces of all modules it defines, can be used to resolve
function references in those modules.</p>
<p>A module defines a symbol table, whose entries are the functions defined in that module.</p>
<h3 id="functions">Functions<a class="headerlink" href="#functions" title="Link to this section">&para;</a></h3>
<p>A function is a special type of <a href="#operations"><em>operation</em></a>. It is special in the following ways:</p>
<ul>
<li>A function has a <a href="#symbols-and-symbol-tables"><em>symbol</em></a>, and thus declares an entry in the nearest
containing <a href="#symbols-and-symbol-tables"><em>symbol table</em></a>.</li>
<li>A function is <em>isolated from above</em>, i.e. the contents of the function cannot escape the function,
nor reference things outside the function, except via symbol table references. Thus entities such as
<a href="#values"><em>values</em></a> and <a href="#blocks"><em>blocks</em></a> are function-scoped, if not more narrowly scoped, in the
case of operations with nested <a href="#regions"><em>regions</em></a>.</li>
</ul>
<p>A function has an arbitrary set of parameters and results, corresponding to its type signature. A
function also has the notion of an <em>application binary interface</em> (ABI), which drives how code is
generated for both caller and callee. For example, a function may have a specific calling convention
as a whole, and specific parameters/results may have type-specific  semantics declared, such as
whether to zero- or sign-extend the value if the input is of a smaller range.</p>
<p>A function always consists of a single <a href="#regions"><em>region</em></a>, called the <em>body</em>, with at least one
<a href="#blocks"><em>block</em></a>, which is called the <em>entry block</em>. The block parameters of the entry block
always correspond to the function parameters, i.e. the arity and type of the block parameters must
match the function signature.</p>
<p>Additionally, a function has an additional constraint on its body, which is that all blocks in the
region must end with one of a restricted set of <em>terminator</em> operations: any branch operation, which
transfers control between blocks of the region; the <code>unreachable</code> operation, which will result in
aborting the program if executed; or the <code>return</code> operation, which must return the same arity and
type of values declared in the function signature.</p>
<h3 id="global-variables">Global Variables<a class="headerlink" href="#global-variables" title="Link to this section">&para;</a></h3>
<p>A global variable is a second special type of <a href="#operations"><em>operation</em></a>, after
<a href="#functions"><em>functions</em></a>:</p>
<ul>
<li>A global variable has a <a href="#symbols-and-symbol-tables"><em>symbol</em></a>, and declares an entry in the
nearest containing <a href="#symbols-and-symbol-tables"><em>symbol table</em></a>.</li>
<li>The <em>initializer</em> of a global variable is, like function bodies, <em>isolated from above</em>.</li>
</ul>
<p>A global variable may have an <em>initializer</em>, a single region/single block body which is implicitly
executed to initialize the value of the global variable. The initializer must be statically
evaluatable, i.e. a &ldquo;constant&rdquo; expression. In most cases, this will simply be a constant value, but
some limited forms of constant expressions are permitted.</p>
<h3 id="symbols-and-symbol-tables">Symbols and Symbol Tables<a class="headerlink" href="#symbols-and-symbol-tables" title="Link to this section">&para;</a></h3>
<p>A <em>symbol</em> is simply a named entity, e.g. a function <code>foo</code> is a symbol whose value is <code>foo</code>.
On their own, symbols aren&rsquo;t particularly useful. This is where the concept of a <em>symbol table</em>
becomes important.</p>
<p>A <em>symbol table</em> is a collection of uniqued symbols belonging to the same namespace, i.e. every
symbol has a single entry in the symbol table, regardless of entity type. Thus, it is not permitted
to have both a function and a global variable with the same name, in the same symbol table. If such
a thing needed to be allowed, perhaps because the namespace for functions and global variables are
separate, then you would use a per-entity symbol table.</p>
<p>For our purposes, a <em>module</em> defines a symbol table, and both functions and global variables share
that table. We do not currently use symbol tables for anything else.</p>
<h3 id="operations">Operations<a class="headerlink" href="#operations" title="Link to this section">&para;</a></h3>
<p>An <em>operation</em> is the most important entity in HIR, and the most abstract. In the <em>Regionalized
Value State Dependence Graph</em> paper, the entire representation described there consists of various
types of operations. In HIR, we do not go quite that abstract, however we do take a fair amount of
inspiration from that paper, as well as from MLIR.</p>
<p>Operations consist of the following pieces:</p>
<ul>
<li>Zero or more <a href="#regions"><em>regions</em></a> and their constituent <a href="#blocks"><em>blocks</em></a></li>
<li>Zero or more <a href="#operands"><em>operands</em></a>, i.e. arguments or inputs</li>
<li>Zero or more <em>results</em>, or outputs, one of the two ways that <a href="#values"><em>values</em></a> can be introduced</li>
<li>Zero or more <a href="#successors"><em>successors</em></a>, in the case of operations which transfer control to
another block in the same region.</li>
<li>Zero or more <a href="#attributes"><em>attributes</em></a>, the semantics of which depend on the operation.</li>
<li>Zero or more <a href="#traits"><em>traits</em></a>, implemented by the operation.</li>
</ul>
<p>An operation always belongs to a <em>block</em> when in use.</p>
<p>As you can see, this is a highly flexible concept. It is capable of representing modules and
functions, as well as primitive instructions. It can represent both structured and unstructured
control-flow. There is very little in terms of an IR that <em>can&rsquo;t</em> be represented using operations.</p>
<p>However, in our case, we use operations for five specific concepts:</p>
<ul>
<li>Functions (the first of two special ops)</li>
<li>Global Variables (the second of two special ops)</li>
<li>Structured Control Flow (if/then, do/while and for loops)</li>
<li>Unstructured Control Flow (br, cond_br, switch, ret)</li>
<li>Primitive Instructions (i.e. things which correspond to the target ISA, e.g. <code>add</code>, <code>call</code>, etc.)</li>
</ul>
<p>For the most part, the fact that functions and global variables are implemented using operations
is not particularly important. Instead, most operations you will interact with are of the other
three varieties. While we&rsquo;ve broken them up into three categories, for the most part, they aren&rsquo;t
actually significantly different. The primary difference is that the unstructured control-flow ops
are valid <em>terminators</em> for blocks, in multi-block regions, while the structured control-flow ops
are not, and only a few special cases of primitive ops are also valid terminators (namely the
<code>ret</code> and <code>unreachable</code> ops). For most primitive and structured control-flow ops, their behavior
appears very similar: they take some operands, perform some action, and possibly return some
results.</p>
<h3 id="regions">Regions<a class="headerlink" href="#regions" title="Link to this section">&para;</a></h3>
<p>A <em>region</em> encapsulates a control-flow graph (CFG) of one or more <a href="#blocks"><em>basic blocks</em></a>. In HIR,
the contents of a region are in <em>single-static assignment</em> (SSA) form, meaning that values may only
be defined once, definitions must <a href="#dominance-relation"><em>dominate</em></a> uses, and operations in the CFG
described by the region are executed one-by-one, from the entry block of the region, until control
exits the region (e.g. via <code>ret</code> or some other terminator instruction).</p>
<p>The order of operations in the region closely corresponds to their scheduling order, though the
code generator may reschedule operations when it is safe - and more efficient - to do so.</p>
<p>Operations in a region may introduce nested regions. For example, the body of a function consists
of a single region, and it might contain an <code>if</code> operation that defines two nested regions, one for
the true branch, and one for the false branch. Nested regions may access any <a href="#values"><em>values</em></a> in
an ancestor region, so long as those values dominate the operation that introduced the nested region.
The exception to this are operations which are <em>isolated from above</em>. The regions of such an
operation are not permitted to reference anything defined in an outer scope, except via
<a href="#symbols-and-symbol-tables"><em>symbols</em></a>. For example, <a href="#functions"><em>functions</em></a> are an operation
which is isolated from above.</p>
<p>The purpose of regions, is to allow for hierarchical/structured control flow operations. Without
them, representing structured control flow in the IR is difficult and error-prone, due to the
semantics of SSA CFGs, particularly with regards to analyses like dominance and loops. It is also
an important part of what makes <a href="#operations"><em>operations</em></a> such a powerful abstraction, as it
provides a way to generically represent the concept of something like a function body, without
needing to special-case them.</p>
<p>A region must always consist of at least one block (the entry block), but not all regions allow
multiple blocks. When multiple blocks are present, it implies the presence of unstructured control
flow, as the only way to transfer control between blocks is by using unstructured control flow
operations, such as <code>br</code>, <code>cond_br</code>, or <code>switch</code>. Structured control flow operations such as <code>if</code>,
introduce nested regions consisting of only a single block, as all control flow within a structured
control flow op, must itself be structured. The specific rules for a region depend on the semantics
of the containing operation.</p>
<h3 id="blocks">Blocks<a class="headerlink" href="#blocks" title="Link to this section">&para;</a></h3>
<p>A <em>block</em>, or <em>basic block</em>, is a set of one or more <a href="#operations"><em>operations</em></a> in which there is
no control flow, except via the block <em>terminator</em>, i.e. the last operation in the block, which is
responsible for transferring control to another block, exiting the current region (e.g. returning
from a function body), or terminating program execution in some way (e.g. <code>unreachable</code>).</p>
<p>A block may declare <em>block parameters</em>, the only other way to introduce <a href="#values"><em>values</em></a> into
the IR, aside from operation results. Predecessors of a block must ensure that they provide
arguments for all block parameters when transfering control to the block.</p>
<p>Blocks always belong to a <a href="#regions"><em>region</em></a>. The first block in a region is called the <em>entry
block</em>, and is special in that its block parameters (if any) correspond to whatever arguments
the region accepts. For example, the body of a function is a region, and the entry block in that
region must have a parameter list that exactly matches the arity and type of the parameters
declared in the function signature. In this way, the function parameters are materialized as
SSA values in the IR.</p>
<h3 id="values">Values<a class="headerlink" href="#values" title="Link to this section">&para;</a></h3>
<p>A <em>value</em> represents terms in a program, temporaries created to store data as it flows through the
program. In HIR, which is in SSA form, values are immutable - once created they cannot be changed
nor destroyed. This property of values allows them to be reused, rather than recomputed, when the
operation that produced them contains no side-effects, i.e. invoking the operation with the same
inputs must produce the same outputs. This forms the basis of one of the ways in which SSA IRs can
optimize programs.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
</div>
<blockquote>
<p>One way in which you can form an intuition for values in an SSA IR, is by thinking of them as
registers in a virtual machine with no limit to the number of machine registers. This corresponds
well to the fact that most values in an IR, are of a type which corresponds to something that can
fit in a typical machine register (e.g. 32-bit or 64-bit values, sometimes larger).</p>
<p>Values which cannot be held in actual machine registers, are usually managed in the form of heap
or stack-allocated memory, with various operations used to allocate, copy/move, or extract smaller
values from them. While not strictly required by the SSA representation, this is almost always
effectively enforced by the instruction set, which will only consist of instructions whose
operands and results are of a type that can be held in machine registers.</p>
</blockquote>
<p>Value <em>definitions</em> (aka &ldquo;defs&rdquo;) can be introduced in two ways:</p>
<ol>
<li>Block parameters. Most notably, the entry block for function bodies materializes the function
parameters as values via block parameters. Block parameters are also used at places in the CFG
where two definitions for a single value are joined together. For example, if the value assigned to
a variable in the source language is assigned conditionally, then in the IR, there will be a block
with a parameter corresponding to the value of that variable after it is assigned. All uses after
that point, would refer to that block parameter, rather than the value from a specific branch.
Similarly, loop-carried variables, such as an iteration count, are typically manifested as block
parameters of the block corresponding to the loop header.</li>
<li>Operation results. The most common way in which values are introduced.</li>
</ol>
<p>Values have <em>uses</em> corresponding to operands or successor arguments (special operands which are used
to satisfy successor block parameters). As a result, values also have <em>users</em>, corresponding to the
specific operation and operand forming a _use.</p>
<p>All <em>uses</em> of a value must be <a href="#dominance-relation"><em>dominated</em></a> by its <em>definition</em>. The IR is
invalid if this rule is ever violated.</p>
<h3 id="operands">Operands<a class="headerlink" href="#operands" title="Link to this section">&para;</a></h3>
<p>An <em>operand</em> is a <a href="#values"><em>value</em></a> or <a href="#immediates"><em>immediate</em></a> used as an argument to an
operation.</p>
<p>Beyond the semantics of any given operation, operand ordering is only significant in so far as it
is used as the order in which those items are expected to appear on the operand stack once lowered
to Miden Assembly. The earlier an operand appears in the list of operands for an operation, the
closer to the top of the operand stack it will appear.</p>
<p>Similarly, the ordering of operand results also correlates to the operand stack order after
lowering. Specifically, the earlier a result appears in the result list, the closer to the top of
the operand stack it will appear after the operation executes.</p>
<h3 id="immediates">Immediates<a class="headerlink" href="#immediates" title="Link to this section">&para;</a></h3>
<p>An <em>immediate</em> is a literal value, typically of integral type, used as an operand. Not all
operations support immediates, but those that do, will typically use them to attempt to perform
optimizations only possible when there is static information available about the operands. For
example, multiplying any number by 2, will always produce an even number, so a sequence such as
<code>mul.2 is_odd</code> can be folded to <code>false</code> at compile-time, allowing further optimizations to occur.</p>
<p>Immediates are separate from <em>constants</em>, in that immediates <em>are</em> constants, but specifically
constants which are valid operand values.</p>
<h3 id="attributes">Attributes<a class="headerlink" href="#attributes" title="Link to this section">&para;</a></h3>
<p>An <em>attribute</em> is (typically optional) metadata attached to an IR entity. In HIR, attributes can be
attached to functions, global variables, and operations.</p>
<p>Attributes are stored as a set of arbitrary key-value data, where values can be one of four types:</p>
<ul>
<li><code>unit</code>, Attributes of this value type are usually &ldquo;marker&rdquo; attributes, i.e. they convey their
information simply by being present.</li>
<li><code>bool</code>, Attributes of this value type are somewhat similar to those of <code>unit</code> type, but by
carrying a boolean value, they can be used to convey both positive and negative meaning. For
example, you might want to support explicit inlining with <code>#[inline(true)]</code>, and prevent any form
of inlining with <code>#[inline(false)]</code>. Here, <code>unit</code> would be insufficient to describe both options
under a single attribute.</li>
<li><code>int</code>, Attributes of this value type are used to convey numeric metadata. For example, inliner
thresholds, or some other kind of per-operation limits.</li>
<li><code>string</code>, Attributes of this value type are useed to convey arbitrary values. Most commonly
you might see this type with things that are enum-like, e.g. <code>#[cc(fast)]</code> to specify a particular
calling convention for a function.</li>
</ul>
<p>Some attributes are &ldquo;first-class&rdquo;, in that they are defined as part of an operation. For example,
the calling convention of a function is an intrinsic attribute of a function, and feels like a
native part of the <code>Function</code> API - rather than having to look up the attribute, and cast the value
to a more natural Rust type, you can simply call <code>function.calling_convention()</code>.</p>
<p>Attributes are not heavily used at this time, but are expected to serve more purposes in the future
as we increase the amount of information frontends need to convey to the compiler backend.</p>
<h3 id="traits">Traits<a class="headerlink" href="#traits" title="Link to this section">&para;</a></h3>
<p>A <em>trait</em> defines some behavior that can be implemented by an operation. This allows operations
to operated over generically in an analysis or rewrite, rather than having to handle every possible
concrete operation type. This makes passes less fragile to changes in the IR in general, and allows
the IR to be extended without having to update every single place where operations are handled.</p>
<p>An operation can be cast to a specific trait that it implements, and trait instances can be
downcast to the concrete operation type if known.</p>
<p>There are a handful of built-in traits, used to convey certain semantic information about the
operations they are attached to, and in particular, are used to validate those operations, for
example:</p>
<ul>
<li><code>IsolatedFromAbove</code>, a marker trait that indicates that regions of the operation it is attached to
cannot reference items from any parents, except via <a href="#symbols-and-symbol-tables"><em>symbols</em></a>.</li>
<li><code>Terminator</code>, a marker trait for operations which are valid block terminators</li>
<li><code>ReturnLike</code>, a trait that describes behavior shared by instructions that exit from an enclosing
region, &ldquo;returning&rdquo; the results of executing that region. The most notable of these is <code>ret</code>, but
<code>yield</code> used by the structured control flow ops is also return-like in nature.</li>
<li><code>BranchOp</code>, a trait that describes behavior shared by all unstructured control-flow branch
instructions, e.g. <code>br</code>, <code>cond_br</code>, and <code>switch</code>.</li>
<li><code>ConstantLike</code>, a marker trait for operations that produce a constant value</li>
<li><code>Commutative</code>, a marker trait for binary operations that exhibit commutativity, i.e. the order of
the operands can be swapped without changing semantics.</li>
</ul>
<p>There are others as well, responsible for aiding in type checking, decorating operations with the
types of side effects they do (or do not) exhibit, and more.</p>
<h3 id="successors-and-predecessors">Successors and Predecessors<a class="headerlink" href="#successors-and-predecessors" title="Link to this section">&para;</a></h3>
<p>The concept of <em>predecessor</em> and <em>successor</em> corresponds to a parent/child relationship in a
control-flow graph (CFG), where edges in the graph are directed, and describe the order in which
control flows through the program. If a node <span class="arithmatex">\(A\)</span> transfers control to a node <span class="arithmatex">\(B\)</span> after it is
finished executing, then <span class="arithmatex">\(A\)</span> is a <em>predecessor</em> of <span class="arithmatex">\(B\)</span>, and <span class="arithmatex">\(B\)</span> is a <em>successor</em> of <span class="arithmatex">\(A\)</span>.</p>
<p>Successors and predecessors can be looked at from two similar, but slightly different, perspectives:</p>
<ol>
<li>In terms of operations. In an SSA CFG, operations in a basic block are executed in order, and
thus the successor of an operation in the block, is the next operation to be executed in that block,
with the predecessor being the inverse of that relationship. At basic block boundaries, the
successor(s) of the <em>terminator</em> operation, are the set of operations to which control can be
transferred. Likewise, the predecessor(s) of the first operation in a block, are the set of
terminators which can transfer control to the containing block. This is the most precise, but is not
quite as intuitive as the alternative.</li>
<li>In terms of blocks. The successor(s) of a basic block, are the set of blocks to which control may
be transferred when exiting the block. Likewise, the precessor(s) of a block, are the set of blocks
which can transfer control to it. We are most frequently dealing with the concept of successors and
predecessors in terms of blocks, as it allows us to focus on the interesting parts of the CFG. For
example, the dominator tree and loop analyses, are constructed in terms of a block-oriented CFG,
since we can trivially derive dominance and loop information for individual ops from their
containing blocks.</li>
</ol>
<p>Typically, you will see successors as a pair of <code>(block_id, &amp;[value_id])</code>, i.e. the block to which
control is transferred, and the set of values being passed as block arguments. On the other hand,
predecessors are most often a pair of <code>(block_id, terminator_op_id)</code>, i.e. the block from which
control originates, and the specific operation responsible.</p>
<h3 id="dominance-relation">Dominance Relation<a class="headerlink" href="#dominance-relation" title="Link to this section">&para;</a></h3>
<p>In an SSA IR, the concept of <em>dominance</em> is of critical importance. Dominance is a property of the
relationship between two or more entities and their respective program points. For example, between
the use of a value as an operand for an operation, and the definition of that value; or between a
basic block and its successors. The dominance property is anti-symmetric, i.e. if <span class="arithmatex">\(A\)</span> dominates <span class="arithmatex">\(B\)</span>,
then <span class="arithmatex">\(B\)</span> cannot dominate <span class="arithmatex">\(A\)</span>, unless <span class="arithmatex">\(A = B\)</span>. Put simply:</p>
<blockquote>
<p>Given a control-flow graph <span class="arithmatex">\(G\)</span>, and a node <span class="arithmatex">\(A \in G\)</span>, then <span class="arithmatex">\(\forall B \in G\)</span>, <span class="arithmatex">\(A dom B\)</span> if all
paths to <span class="arithmatex">\(B\)</span> from the root of <span class="arithmatex">\(G\)</span>, pass through <span class="arithmatex">\(A\)</span>.</p>
<p>Furthermore, <span class="arithmatex">\(A\)</span> <em>strictly</em> dominates <span class="arithmatex">\(B\)</span>, if <span class="arithmatex">\(A \neq B\)</span>.</p>
</blockquote>
<p>An example of why dominance is an important property of a program, can be seen when considering the
meaning of a program like so (written in pseudocode):</p>
<div class="highlight"><pre><span></span><code>if (...) {
  var a = 1;
}

foo(a)
</code></pre></div>
<p>Here, the definition of <code>a</code> does not dominate its usage in the call to <code>foo</code>. If the conditional
branch is ever false, <code>a</code> is never defined, nor initialized - so what should happen when we reach
the call to <code>foo</code>?</p>
<p>In practice, of course, such a program is rarely possible to expresss in a high-level language,
however in a low-level CFG, it is possible to reference values which are defined somewhere in the
graph, but in such a way that is not <em>legal</em> according to the &ldquo;definitions must dominate uses&rdquo;
rule of SSA CFGs. The dominance property is what we use to validate the correctness of the IR, as
well as evaluate the range of valid transformations that can be applied to the IR. For example, we
might determine that it is valid to move an expression into a specific <code>if/then</code> branch, because
it is only used in that branch - the dominance property is how we determine that there are paths
through the program in which the result of the expression is unused, as well as what program points
represent the nearest point to one of its uses that still dominates <em>all</em> of the uses.</p>
<p>There is another useful notion of dominance, called <em>post-dominance</em>, which can be described much
like the regular notion of dominance, except in terms of paths to the exit of the CFG, rather than
paths from the entry:</p>
<blockquote>
<p>Given a control-flow graph <span class="arithmatex">\(G\)</span>, and a node $A \in <span class="arithmatex">\(G\)</span>, then <span class="arithmatex">\(\forall B \in G\)</span>, <span class="arithmatex">\(A pdom B\)</span> if all
paths through <span class="arithmatex">\(B\)</span> that exit the CFG, must flow through <span class="arithmatex">\(A\)</span> first.</p>
<p>Furthermore, <span class="arithmatex">\(A\)</span> <em>strictly</em> post-dominates <span class="arithmatex">\(B\)</span> if <span class="arithmatex">\(A \neq B\)</span>.</p>
</blockquote>
<p>The notion of post-dominance is important in determining the applicability of certain transformations,
in particular with loops.</p>
<h2 id="structure">Structure<a class="headerlink" href="#structure" title="Link to this section">&para;</a></h2>
<p>The hierarchy of HIR looks like so:</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="n">Component</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">Imports</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="k">Interface</span>
<span class="w">        </span><span class="err">|</span>
<span class="w">        </span><span class="n">v</span>
<span class="w">     </span><span class="n">Exports</span>
<span class="w">        </span><span class="err">|</span>
<span class="w">        </span><span class="n">v</span>
<span class="w">    </span><span class="k">Interface</span>
<span class="w">        </span><span class="err">|</span>
<span class="w">        </span><span class="n">v</span>
<span class="w">      </span><span class="k">Module</span><span class="w"> </span><span class="o">---------</span>
<span class="w">        </span><span class="err">|</span><span class="w">              </span><span class="err">|</span>
<span class="w">        </span><span class="n">v</span><span class="w">              </span><span class="n">v</span>
<span class="w">    </span><span class="n">Function</span><span class="o">/</span><span class="n">Op</span><span class="w">     </span><span class="k">Global</span><span class="w"> </span><span class="n">Variable</span>
<span class="w">        </span><span class="err">|</span>
<span class="w">        </span><span class="n">v</span>
<span class="w">   </span><span class="o">--</span><span class="w"> </span><span class="n">Region</span>
<span class="w">  </span><span class="err">|</span><span class="w">     </span><span class="err">|</span>
<span class="w">  </span><span class="err">|</span><span class="w">     </span><span class="n">v</span>
<span class="w">  </span><span class="err">|</span><span class="w">   </span><span class="n">Block</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="o">&lt;--</span>
<span class="w">  </span><span class="err">|</span><span class="w">     </span><span class="err">|</span><span class="w">        </span><span class="err">|</span><span class="w">      </span><span class="err">|</span>
<span class="w">  </span><span class="err">|</span><span class="w">     </span><span class="err">|</span><span class="w">        </span><span class="n">v</span><span class="w">      </span><span class="err">|</span>
<span class="w">  </span><span class="err">|</span><span class="w">     </span><span class="err">|</span><span class="w">      </span><span class="n">Operand</span><span class="w">  </span><span class="err">|</span>
<span class="w">  </span><span class="err">|</span><span class="w">     </span><span class="n">v</span><span class="w">        </span><span class="err">|</span><span class="w">      </span><span class="err">|</span>
<span class="w">   </span><span class="o">&gt;</span><span class="w"> </span><span class="n">Operation</span><span class="w"> </span><span class="o">&lt;-</span><span class="w">       </span><span class="err">|</span>
<span class="w">        </span><span class="err">|</span><span class="w">               </span><span class="err">|</span>
<span class="w">        </span><span class="n">v</span><span class="w">               </span><span class="err">|</span>
<span class="w">      </span><span class="n">Result</span><span class="w"> </span><span class="o">-----------</span>
</code></pre></div>

<p>In short:</p>
<ul>
<li>A <em>component</em> imports dependencies in the form of <em>interfaces</em></li>
<li>A <em>component</em> exports at least one <em>interface</em>.</li>
<li>An <em>interface</em> is concretely implemented with a <em>module</em>.</li>
<li>A <em>module</em> contains <em>function</em> and <em>global variable</em> definitions, and imports them from the set
of interfaces available to the component.</li>
<li>A <em>function</em>, as a type of <em>operation</em>, consists of a body <em>region</em>.</li>
<li>A <em>region</em> consists of at least one <em>block</em>, that may define <em>values</em> in the form of block
parameters.</li>
<li>A <em>block</em> consists of <em>operations</em>, whose results introduce new <em>values</em>, and whose operands are
<em>values</em> introduced either as block parameters or the results of previous operations.</li>
<li>An <em>operation</em> may contain nested <em>regions</em>, with associated blocks and operations.</li>
</ul>
<h3 id="passes">Passes<a class="headerlink" href="#passes" title="Link to this section">&para;</a></h3>
<p>A <em>pass</em> is effectively a fancy function with a specific signature and some constraints on its
semantics. There are three primary types of passes: <a href="#analyses"><em>analysis</em></a>,
<a href="#rewrites"><em>rewrite</em></a>, and <a href="#conversions"><em>conversion</em></a>. These three pass types have different
signatures and semantics, but play symbiotic roles in the compilation pipeline.</p>
<p>There are two abstractions over all passes, used and extended by the three types described above:</p>
<ul>
<li>The <code>Pass</code> trait, which provides an abstraction suitable for describing any type of compiler pass
used by <code>midenc</code>. It primarily exists to allow writing pass-generic helpers.</li>
<li>The <code>PassInfo</code> trait, which exists to provide a common interface for pass metadata, such as the
name, description, and command-line flag prefix. All passes must implement this trait.</li>
</ul>
<h4 id="analyses">Analyses<a class="headerlink" href="#analyses" title="Link to this section">&para;</a></h4>
<p>Analysis of the IR is expressed in the form of a specialized pass, an <code>Analysis</code>, and an
<code>AnalysisManager</code>, which is responsible for computing analyses on demand, caching them, and
invalidating the relevant parts of the cache when the IR changes. Analyses are expressed in terms
of a specific entity, such as <code>Function</code>, and are cached based on the unique identity of that
entity.</p>
<p>An <em>analysis</em> is responsible for computing some fact about the given IR entity it is given. Facts
typically include things such as: computing dominance, identifying loops and their various component
parts, reachability, liveness, identifying unused (i.e. dead) code, and much more.</p>
<p>To do this, analyses are given an immutable reference to the IR in question; a reference to the
current <code>AnalysisManager</code>, so that the results of other analyses can be consulted; and a reference
to the current compilation <code>Session</code> for access to configuration relevant to the analysis.</p>
<p>Analysis results are computed as an instance of <code>Self</code>. This provides structure to the analysis
results, and provides a place to implement helpful functionality for querying the results.</p>
<p>A well-written analysis should be based purely off the inputs given to <code>Analysis::analyze</code>, and
ideally be based on some formalism, so that properties of the analysis can be verified. Most of
the analyses in HIR today, are based on the formalisms underpinning <em>dataflow analysis</em>, e.g.
semi-join lattices.</p>
<h4 id="rewrites">Rewrites<a class="headerlink" href="#rewrites" title="Link to this section">&para;</a></h4>
<p><em>Rewrites</em> are a type of pass which mutate the IR entity to which they are applied. They can be
chained (via the <code>chain</code> method on the <code>RewritePass</code> trait) to form rewrite pipelines, called a
<code>RewriteSet</code>. A <code>RewriteSet</code> manages executing each rewrite in the set, and coordinating with the
<code>AnalysisManager</code> between rewrites.</p>
<p>Rewrites are given a mutable reference to the IR they should apply to; the current <code>AnalysisManager</code>
so that analyes can be consulted (or computed) to facilitate the rewrite; and the current
compilation <code>Session</code>, for configuration.</p>
<p>Rewrites must leave the IR in a valid state. Rewrites are also responsible for indicating, via the
<code>AnalysisManager</code>, which analyses can be preserved after applying the rewrite. A rewrite that makes
no changes, should mark all analyses preserved, to avoid recomputing the analysis results the next
time they are requested. If an analysis is not explicitly preserved by a rewrite, it will be
invalidated by the containing <code>RewriteSet</code>.</p>
<p>Rewrite passes written for a <code>Function</code>, can be adapted for application to a <code>Module</code>, using the
<code>ModuleRewriteAdapter</code>. This makes writing rewrites for use in the main compiler pipeline, as simple
as defining it for a <code>Function</code>, and then using the <code>ModuleRewriteAdapter</code> to add the rewrite to the
pipeline.</p>
<p>A well-written rewrite pass should only use data available in the IR itself, or analyses in the
provided <code>AnalysisManager</code>, to drive application of the rewrite. Additionally, rewrites should
focus on a single transformation, and rely on chaining rewrites to orchestrate more complex
transformations composed of multiple stages. Lastly, the rewrite should ideally have a logical
proof of its safety, or failing that, a basis in some formalism that can be suitably analyzed and/or
tested. If a rewrite cannot be described in such a way, it will be very difficult to provide
guarantees about the code produced by the transformation. This makes it hard to be confident
in the rewrite (and by extension, the compiler), and impossible to verify.</p>
<h4 id="conversions">Conversions<a class="headerlink" href="#conversions" title="Link to this section">&para;</a></h4>
<p><em>Conversions</em> are a type of pass which converts between intermediate representations, or more
abstractly, between <em>dialects</em>.</p>
<p>The concept of a dialect is focused primarily on semantics, and less so on concrete representations.
For example, source and target dialects might share the same underlying IR, with the target dialect
having a more restricted set of <em>legal</em> operations, possibly with stricter semantics.</p>
<p>This brings us to the concept of <em>legalization</em>, i.e. converting all <em>illegal</em> operations in the IR
into <em>legal</em> equivalents. Each dialect defines the set of operations which it considers legal. The
concept of legality is mostly important when the same underlying IR is used across multiple dialects,
as is the case with HIR.</p>
<p>There are two types of conversion passes in HIR: <em>dialect conversion</em>, and <em>translation</em>:</p>
<ul>
<li><em>Dialect conversion</em> is used at various points in the compilation pipeline to simplify the IR
for later passes. For example, Miden Assembly has no way to represent multi-way branches, such
as implemented by <code>switch</code>. At a certain point, we switch to a dialect where <code>switch</code> is illegal,
so that further passes can be written as if <code>switch</code> doesn&rsquo;t exist. Yet another dialect later in
the pipeline, makes all unstructured control flow illegal, in preparation for translation to
Miden Assembly, which has no unstructured control flow operators.</li>
<li><em>Translation</em> refers to a conversion from one IR to a completely different one. Currently, the
only translation we have, is the one responsible for translating from HIR to Miden Assembly. In
the future, we hope to also implement frontends as translations <em>to</em> HIR, but that is not currently
the case. Translations are currently implemented as simple passes that take in some IR as input,
and produce <em>whatever</em> as output.</li>
</ul>
<p>Dialect conversions are implemented in the form of generic <em>conversion infrastructure</em>. A dialect
conversion is described as a set of <em>conversion patterns</em>, which define what to do when a specific
operation is seen in the input IR; and the set of operations which are legal in the target dialect.
The conversion driver is responsible for visiting the IR, repetitively applying any matched
conversion patterns until a fixpoint is reached, i.e. no more patterns are matched, or a conversion
pattern fails to apply successfully. If any illegal operations are found which do not have
corresponding conversion patterns, then a legalization error is raised, and the conversion overall
fails.</p>
<h2 id="usage">Usage<a class="headerlink" href="#usage" title="Link to this section">&para;</a></h2>
<p>Let&rsquo;s get into the gritty details of how the compiler works, particularly in relation to HIR.</p>
<p>The entry point for compilation, generally speaking, is the <em>driver</em>. The driver is what is
responsible for collecting compiler inputs, including configuration, from the user, instantiating a
<code>Session</code>, and then invoking the compiler frontend with those items.</p>
<p>The first stage of compilation is <em>parsing</em>, in which each input is converted to HIR by an
appropriate frontend. For example, Wasm modules are loaded and translated to HIR using the Wasm
frontend. The purpose of this stage is to get all inputs into HIR form, for subsequent stages. The
only exception to this are MASM sources, which are assembled to MAST directly, and then set aside
until later in the pipeline when we go to assemble the final artifact.</p>
<p>The second stage of compilation is <em>semantic analysis</em>. This is the point where we validate the
HIR we have so far, and ensure that there are no obvious issues that will cause compilation to
fail unexpectedly later on. In some cases, this stage is skipped, as we have already validated the
IR in the frontend.</p>
<p>The third stage of compilation is <em>linking</em>. This is where we gather together all of the inputs,
as well as any compiler options that tell us what libraries to link against, and where to search
for them, and then ensure that there are no missing inputs, undefined symbols, or incompatible type
signatures. The output of this stage is a well-formed <a href="#components"><em>component</em></a>.</p>
<p>The fourth stage of compilation is <em>rewriting</em>, in which all of the rewrite passes we wish to
apply to the IR, are applied. You could also think of this stage as a combination of optimization
and preparing for codegen.</p>
<p>The fifth stage of compilation is <em>codegen</em>, where HIR is translated to Miden Assembly.</p>
<p>The final stage of compilation is <em>assembly</em>, where the Miden Assembly we produced, along with
any other Miden Assembly libraries, are assembled to MAST, and then packaged in the Miden package
format.</p>
<p>The <code>Session</code> object contains all of the important compiler configuration and exists for the
duration of a compiler invocation. In addition to this, there is a <code>Context</code> object, which is used
to allocate IR entities contained within a single <code>Module</code>. The context of each <code>Module</code> is further
subdivided by <code>Function</code>, in the form of <code>FunctionContext</code>, from which all function-local IR
entities are allocated. This ensures that each <code>Function</code> gets its own set of values, blocks, and
regions, while sharing <code>Module</code>-wide entities, such as constants and symbols.</p>
<p>Operations are allocated from the nearest <code>Context</code>, and use that context to allocate and access
IR entities used by the operation.</p>
<p>The <code>Context</code> object is pervasive, it is needed just about anywhere that IR entities are used, to
allow accessing data associated with those entities. Most entity references are integer ids, which
uniquely identify the entity, but provide no access to them without going through the <code>Context</code>.</p>
<p>This is a bit awkward, but is easier to work with in Rust. The alternative is to rely on
dynamically-checked interior mutability inside reference-counted allocations, e.g. <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>.
Not only is this similarly pervasive in terms of how APIs are structured, but it loses some of
the performance benefits of allocating IR objects close together on the heap.</p>
<p>The following is some example code in Rust, demonstrating how it might look to create a component
in HIR and work with it.</p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">midenc_hir</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="sd">/// Defining Ops</span>

<span class="sd">/// `Add` is a binary integral arithmetic operator, i.e. `+`</span>
<span class="sd">///</span>
<span class="sd">/// It consists of two operands, which must be of the same type, and produces a result that</span>
<span class="sd">/// is also of that type.</span>
<span class="sd">///</span>
<span class="sd">/// It supports various types of overflow semantics, see `Overflow`.</span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Add</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">op</span><span class="p">:</span><span class="w"> </span><span class="nc">Operation</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">impl</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="n">overflow</span><span class="p">:</span><span class="w"> </span><span class="nc">Overflow</span><span class="p">,</span><span class="w"> </span><span class="n">lhs</span><span class="p">:</span><span class="w"> </span><span class="nc">Operand</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">:</span><span class="w"> </span><span class="nc">Operand</span><span class="p">,</span><span class="w"> </span><span class="n">span</span><span class="p">:</span><span class="w"> </span><span class="nc">SourceSpan</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">OpId</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">ctrl_ty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="n">value_type</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">builder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OpBuilder</span><span class="p">::</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// Set the source span for this op</span>
<span class="w">        </span><span class="n">builder</span><span class="p">.</span><span class="n">with_span</span><span class="p">(</span><span class="n">span</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// We specify the concrete operand values</span>
<span class="w">        </span><span class="n">builder</span><span class="p">.</span><span class="n">with_operands</span><span class="p">([</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">]);</span>
<span class="w">        </span><span class="c1">// We specify results in terms of types, and the builder will materialize values</span>
<span class="w">        </span><span class="c1">// for the instruction results based on those types.</span>
<span class="w">        </span><span class="n">builder</span><span class="p">.</span><span class="n">with_results</span><span class="p">([</span><span class="n">ctrl_ty</span><span class="p">]);</span>
<span class="w">        </span><span class="c1">// We must also specify operation attributes, e.g. overflow behavior</span>
<span class="w">        </span><span class="c1">//</span>
<span class="w">        </span><span class="c1">// Attribute values must implement `AttributeValue`, a trait which represents the encoding</span>
<span class="w">        </span><span class="c1">// and decoding of a type as an attribute value.</span>
<span class="w">        </span><span class="n">builder</span><span class="p">.</span><span class="n">with_attribute</span><span class="p">(</span><span class="s">&quot;overflow&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">overflow</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// Add op traits that this type implements</span>
<span class="w">        </span><span class="n">builder</span><span class="p">.</span><span class="n">with_trait</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Commutative</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="n">builder</span><span class="p">.</span><span class="n">with_trait</span><span class="p">::</span><span class="o">&lt;</span><span class="n">SameTypeOperands</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="n">builder</span><span class="p">.</span><span class="n">with_trait</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Canonicalize</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="c1">// Instantiate the op</span>
<span class="w">        </span><span class="c1">//</span>
<span class="w">        </span><span class="c1">// NOTE: In order to use `OpBuilder`, `Self` must implement `Default` if it has any other</span>
<span class="w">        </span><span class="c1">// fields than the underlying `Operation`. This is because the `OpBuilder` will construct</span>
<span class="w">        </span><span class="c1">// a default instance of the type when allocating it, and according to Rust rules, any</span>
<span class="w">        </span><span class="c1">// subsequent reference to the type requires that all fields were properly initialized.</span>
<span class="w">        </span><span class="n">builder</span><span class="p">.</span><span class="n">build</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="sd">/// The `OpOperand` type abstracts over information about a given operand, such as whether it</span>
<span class="w">    </span><span class="sd">/// is a value or immediate, and its type. It also contains the link for the operand in the</span>
<span class="w">    </span><span class="sd">/// original `Value`&#39;s use list.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">lhs</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">OpOperand</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">op</span><span class="p">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">rhs</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">OpOperand</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">op</span><span class="p">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="sd">/// The `OpResult` type abstracts over information about a given result, such as whether it</span>
<span class="w">    </span><span class="sd">/// is a value or constant, and its type.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">result</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">OpResult</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">op</span><span class="p">.</span><span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="sd">/// Attributes of the op can be reified from the `AttributeSet` of the underlying `Operation`,</span>
<span class="w">    </span><span class="sd">/// using `get_attribute`, which will use the `AttributeValue` implementation for the type to</span>
<span class="w">    </span><span class="sd">/// reify it from the raw attribute data.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">overflow</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Overflow</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">op</span><span class="p">.</span><span class="n">get_attribute</span><span class="p">(</span><span class="s">&quot;overflow&quot;</span><span class="p">).</span><span class="n">unwrap_or_default</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="sd">/// All ops must implement this trait, but most implementations will look like this</span>
<span class="k">impl</span><span class="w"> </span><span class="n">Op</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">Id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OpId</span><span class="p">;</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">id</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Self</span><span class="p">::</span><span class="n">Id</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">op</span><span class="p">.</span><span class="n">key</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">name</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="nb">static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;add&quot;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">as_operation</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Operation</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">op</span><span class="p">}</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">as_operation_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Operation</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">op</span><span class="p">}</span>
<span class="p">}</span>
<span class="sd">/// Marker trait used to indicate an op exhibits the commutativity property</span>
<span class="k">impl</span><span class="w"> </span><span class="n">Commutative</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="p">{}</span>
<span class="sd">/// Marker trait used to indicate that operands of this op should all be the same type</span>
<span class="k">impl</span><span class="w"> </span><span class="n">SameTypeOperands</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="p">{}</span>
<span class="sd">/// Canonicalization is optional, but encouraged when an operation has a canonical form.</span>
<span class="sd">///</span>
<span class="sd">/// This is applied after transformations which introduce or modify an `Add` op, and ensures</span>
<span class="sd">/// that it is in canonical form.</span>
<span class="sd">///</span>
<span class="sd">/// Canonicalizations ensure that pattern-based rewrites can be expressed in terms of the</span>
<span class="sd">/// canonical form, rather than needing to account for all possible variations.</span>
<span class="k">impl</span><span class="w"> </span><span class="n">Canonicalize</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">canonicalize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// If `add` is given an immediate operand, always place it on the right-hand side</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">lhs</span><span class="p">().</span><span class="n">is_immediate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">rhs</span><span class="p">().</span><span class="n">is_immediate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">op</span><span class="p">.</span><span class="n">operands</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="sd">/// Ops can optionally implement [PrettyPrint] and [PrettyParser], to allow for a less verbose</span>
<span class="sd">/// textual representation. If not implemented, the op will be printed using the generic format</span>
<span class="sd">/// driven by the underlying `Operation`.</span>
<span class="k">impl</span><span class="w"> </span><span class="n">formatter</span><span class="p">::</span><span class="n">PrettyPrint</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">render</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">formatter</span><span class="p">::</span><span class="n">Document</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">use</span><span class="w"> </span><span class="n">formatter</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">opcode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">overflow</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Overflow</span><span class="p">::</span><span class="n">Unchecked</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">const_text</span><span class="p">(</span><span class="s">&quot;add&quot;</span><span class="p">),</span>
<span class="w">            </span><span class="n">Overflow</span><span class="p">::</span><span class="n">Checked</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">const_text</span><span class="p">(</span><span class="s">&quot;add.checked&quot;</span><span class="p">),</span>
<span class="w">            </span><span class="n">Overflow</span><span class="p">::</span><span class="n">Wrapping</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">const_text</span><span class="p">(</span><span class="s">&quot;add.wrapping&quot;</span><span class="p">),</span>
<span class="w">            </span><span class="n">Overflow</span><span class="p">::</span><span class="n">Overflowing</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">const_text</span><span class="p">(</span><span class="s">&quot;add.overflowing&quot;</span><span class="p">),</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="n">opcode</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">const_text</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">display</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">lhs</span><span class="p">())</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">const_text</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">display</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">rhs</span><span class="p">())</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="k">impl</span><span class="w"> </span><span class="n">parsing</span><span class="p">::</span><span class="n">PrettyParser</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">parse</span><span class="p">(</span><span class="n">s</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span><span class="p">,</span><span class="w"> </span><span class="n">Report</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">todo!</span><span class="p">(</span><span class="s">&quot;not shown here&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="sd">/// Constructing Components</span>

<span class="c1">// An interface can consist of functions, global variables, and potentially types in the future</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">std</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Interface</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="s">&quot;std&quot;</span><span class="p">);</span>
<span class="n">std</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&quot;math::u64/add_checked&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">FunctionType</span><span class="p">::</span><span class="n">new</span><span class="p">([</span><span class="n">Type</span><span class="p">::</span><span class="n">U64</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="p">::</span><span class="n">U64</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="n">Type</span><span class="p">::</span><span class="n">U64</span><span class="p">]));</span>

<span class="kd">let</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Interface</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">);</span>
<span class="n">test</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="s">&quot;run&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">FunctionType</span><span class="p">::</span><span class="n">new</span><span class="p">([],</span><span class="w"> </span><span class="p">[</span><span class="n">Type</span><span class="p">::</span><span class="n">U32</span><span class="p">]));</span>

<span class="c1">// A component is instantiated empty</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Component</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">);</span>

<span class="c1">// You must then declare the interfaces that it imports and exports</span>
<span class="n">component</span><span class="p">.</span><span class="n">import</span><span class="p">(</span><span class="n">std</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span>
<span class="n">component</span><span class="p">.</span><span class="n">export</span><span class="p">(</span><span class="n">test</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span>

<span class="c1">// Then, to actually define a component instance, you must define modules which implement</span>
<span class="c1">// the interfaces exported by the component</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Module</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">module</span><span class="p">.</span><span class="n">define</span><span class="p">(</span><span class="s">&quot;run&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">FunctionType</span><span class="p">::</span><span class="n">new</span><span class="p">([],</span><span class="w"> </span><span class="p">[</span><span class="n">Type</span><span class="p">::</span><span class="n">U32</span><span class="p">]));</span>
<span class="c1">//... build &#39;run&#39; function</span>

<span class="c1">// And add them to the component, like shown here. Here, `module` is added to the component as an</span>
<span class="c1">// implementation of the `test` interface</span>
<span class="n">component</span><span class="p">.</span><span class="n">implement</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">module</span><span class="p">);</span>

<span class="c1">// Modules can also be added to a component without using them to implement an interface,</span>
<span class="c1">// in which case they are only accessible from other modules in the same component, e.g.:</span>
<span class="kd">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Module</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">);</span>
<span class="c1">// Here, the &#39;foo&#39; module will only be accessible from the &#39;test&#39; module.</span>
<span class="n">component</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>

<span class="c1">// Lastly, during compilation, imports are resolved by linking against the components which</span>
<span class="c1">// implement them. The linker step identifies the concrete paths of each item that provides</span>
<span class="c1">// an imported symbol, and rewrites the generic interface path with the concrete path of the</span>
<span class="c1">// item it was resolved to.</span>

<span class="sd">/// Visiting IR</span>

<span class="c1">// Visiting the CFG</span>

<span class="kd">let</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="p">.</span><span class="n">body</span><span class="p">().</span><span class="n">entry</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">worklist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VecDeque</span><span class="p">::</span><span class="n">from_iter</span><span class="p">([</span><span class="n">entry</span><span class="p">]);</span>

<span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">worklist</span><span class="p">.</span><span class="n">pop_front</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Ignore blocks we&#39;ve already visited</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">visited</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">continue</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">terminator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">context</span><span class="p">.</span><span class="n">block</span><span class="p">(</span><span class="n">next</span><span class="p">).</span><span class="n">last</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// Visit all successors after this block, if the terminator branches to another block</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">branch</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">terminator</span><span class="p">.</span><span class="n">downcast_ref</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Branch</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">worklist</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">branch</span><span class="p">.</span><span class="n">successors</span><span class="p">().</span><span class="n">iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">succ</span><span class="o">|</span><span class="w"> </span><span class="n">succ</span><span class="p">.</span><span class="n">block</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Visit the operations in the block bottom-up</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">current_op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">terminator</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current_op</span><span class="p">.</span><span class="n">prev</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">current_op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Visiting uses of a value</span>

<span class="kd">let</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function</span><span class="p">.</span><span class="n">body</span><span class="p">().</span><span class="n">entry</span><span class="p">().</span><span class="n">first</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="p">.</span><span class="n">results</span><span class="p">().</span><span class="n">first</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="fm">assert!</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">is_used</span><span class="p">());</span>
<span class="k">for</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">uses</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">dbg!</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Applying a rewrite pattern to every match in a function body</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">FoldAdd</span><span class="p">;</span>
<span class="k">impl</span><span class="w"> </span><span class="n">RewritePattern</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">FoldAdd</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">matches</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">op</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Op</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">op</span><span class="p">.</span><span class="n">is</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Add</span><span class="o">&gt;</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">op</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="k">dyn</span><span class="w"> </span><span class="n">Op</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">RewritePatternResult</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">add_op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="p">.</span><span class="n">downcast_mut</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Add</span><span class="o">&gt;</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">add_op</span><span class="p">.</span><span class="n">lhs</span><span class="p">().</span><span class="n">as_immediate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">add_op</span><span class="p">.</span><span class="n">rhs</span><span class="p">().</span><span class="n">as_immediate</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rhs</span><span class="p">;</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">RewriteAction</span><span class="p">::</span><span class="n">ReplaceAllUsesWith</span><span class="p">(</span><span class="n">add_op</span><span class="p">.</span><span class="n">result</span><span class="p">().</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">));</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">RewriteAction</span><span class="p">::</span><span class="nb">None</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
      <div class="md-progress" data-md-component="progress" role="progressbar"></div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["search.suggest", "search.highlight", "search.share", "navigation.instant.progress", "navigation.tracking", "navigation.integration", "navigation.indexes", "navigation.path", "navigation.top", "navigation.footer", "toc.follow", "content.code.copy", "content.action.edit"], "search": "../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.af256bd8.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?version=4.8.0"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/contrib/auto-render.min.js"></script>
      
        <script src="../../js/open_in_new_tab.js"></script>
      
    
  </body>
</html>