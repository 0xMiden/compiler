use std::{env, fs, path::Path};

use proc_macro2::{Literal, Span};
use quote::quote;
use syn::{parse_macro_input, spanned::Spanned, FnArg, ItemFn, Pat, PatIdent};
use toml::Value;

const NOTE_SCRIPT_PACKAGE_VERSION: &str = "1.0.0";
const NOTE_SCRIPT_EXPORT: &str = "miden:base/note-script@1.0.0";

/// Expands the `#[note_script]` attribute by generating bindings and wiring the guest entry point.
pub fn expand(
    attr: proc_macro::TokenStream,
    item: proc_macro::TokenStream,
) -> proc_macro::TokenStream {
    if !attr.is_empty() {
        return syn::Error::new(Span::call_site(), "#[note_script] does not accept arguments")
            .into_compile_error()
            .into();
    }

    let input_fn = parse_macro_input!(item as ItemFn);

    let fn_ident = &input_fn.sig.ident;
    if fn_ident != "run" {
        return syn::Error::new(fn_ident.span(), "#[note_script] must be applied to `fn run`")
            .into_compile_error()
            .into();
    }

    if input_fn.sig.receiver().is_some() {
        return syn::Error::new(input_fn.sig.span(), "#[note_script] cannot be applied to methods")
            .into_compile_error()
            .into();
    }

    let mut call_args: Vec<syn::Ident> = Vec::new();
    for arg in &input_fn.sig.inputs {
        match arg {
            FnArg::Typed(pat_type) => match pat_type.pat.as_ref() {
                Pat::Ident(PatIdent { ident, .. }) => call_args.push(ident.clone()),
                other => {
                    return syn::Error::new(
                        other.span(),
                        "#[note_script] requires identifier arguments",
                    )
                    .into_compile_error()
                    .into();
                }
            },
            FnArg::Receiver(receiver) => {
                return syn::Error::new(receiver.span(), "unexpected receiver argument")
                    .into_compile_error()
                    .into();
            }
        }
    }

    let inline_wit = match build_note_script_wit(Span::call_site()) {
        Ok(wit) => wit,
        Err(err) => return err.into_compile_error().into(),
    };
    let inline_literal = Literal::string(&inline_wit);
    let struct_ident = quote::format_ident!("Struct");
    let guest_path: syn::Path =
        syn::parse_quote!(self::bindings::exports::miden::base::note_script::Guest);

    let fn_inputs = &input_fn.sig.inputs;
    let fn_output = &input_fn.sig.output;

    let call = if call_args.is_empty() {
        quote! { #fn_ident() }
    } else {
        quote! { #fn_ident(#(#call_args),*) }
    };

    let expanded = quote! {
        #input_fn

        ::miden::miden_generate!(inline = #inline_literal);
        self::bindings::export!(#struct_ident);

        /// Guest entry point generated by `#[note_script]`.
        pub struct #struct_ident;

        impl #guest_path for #struct_ident {
            fn run(#fn_inputs) #fn_output {
                #call;
            }
        }
    };

    expanded.into()
}

/// Constructs an inline WIT world for the note script using the consuming crate metadata.
fn build_note_script_wit(error_span: Span) -> Result<String, syn::Error> {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").map_err(|err| {
        syn::Error::new(error_span, format!("failed to read CARGO_MANIFEST_DIR: {err}"))
    })?;
    let manifest_path = Path::new(&manifest_dir).join("Cargo.toml");
    let manifest_content = fs::read_to_string(&manifest_path).map_err(|err| {
        syn::Error::new(
            error_span,
            format!("failed to read manifest '{}': {err}", manifest_path.display()),
        )
    })?;

    let manifest: Value = manifest_content.parse().map_err(|err| {
        syn::Error::new(
            error_span,
            format!("failed to parse manifest '{}': {err}", manifest_path.display()),
        )
    })?;

    let package_table = manifest
        .get("package")
        .and_then(Value::as_table)
        .ok_or_else(|| syn::Error::new(error_span, "manifest missing [package] table"))?;

    let crate_name = package_table
        .get("name")
        .and_then(Value::as_str)
        .ok_or_else(|| syn::Error::new(error_span, "manifest package missing `name`"))?;

    let component_package = package_table
        .get("metadata")
        .and_then(Value::as_table)
        .and_then(|meta| meta.get("component"))
        .and_then(Value::as_table)
        .and_then(|component| component.get("package"))
        .and_then(Value::as_str)
        .ok_or_else(|| {
            syn::Error::new(error_span, "manifest missing package.metadata.component.package")
        })?;

    let mut imports = collect_note_script_imports(&manifest_dir, package_table, error_span)?;
    imports.sort();

    let package_with_version = if component_package.contains('@') {
        component_package.to_string()
    } else {
        format!("{component_package}@{NOTE_SCRIPT_PACKAGE_VERSION}")
    };

    let world_name = format!("{}-world", crate_name.replace('_', "-"));

    let mut wit_source = String::new();
    wit_source.push_str(&format!("package {package_with_version};\n\n"));
    wit_source.push_str(&format!("world {world_name} {{\n"));
    for import in imports {
        wit_source.push_str("    import ");
        wit_source.push_str(&import);
        wit_source.push_str(";\n");
    }
    wit_source.push_str(&format!("    export {NOTE_SCRIPT_EXPORT};\n"));
    wit_source.push('}');
    wit_source.push('\n');

    Ok(wit_source)
}

/// Collects the imported interfaces declared under `package.metadata.miden.dependencies`.
fn collect_note_script_imports(
    manifest_dir: &str,
    package_table: &toml::value::Table,
    error_span: Span,
) -> Result<Vec<String>, syn::Error> {
    let dependencies = package_table
        .get("metadata")
        .and_then(Value::as_table)
        .and_then(|meta| meta.get("miden"))
        .and_then(Value::as_table)
        .and_then(|miden| miden.get("dependencies"))
        .and_then(Value::as_table);

    let mut imports = Vec::new();

    if let Some(dep_table) = dependencies {
        for (dep_name, dep_value) in dep_table.iter() {
            let dep_config = dep_value.as_table().ok_or_else(|| {
                syn::Error::new(
                    error_span,
                    format!(
                        "dependency '{dep_name}' under package.metadata.miden.dependencies must \
                         be a table"
                    ),
                )
            })?;

            let dependency_path =
                dep_config.get("path").and_then(Value::as_str).ok_or_else(|| {
                    syn::Error::new(
                        error_span,
                        format!(
                            "dependency '{dep_name}' under package.metadata.miden.dependencies is \
                             missing a 'path' entry"
                        ),
                    )
                })?;

            let absolute_path = Path::new(manifest_dir).join(dependency_path);
            let canonical = fs::canonicalize(&absolute_path).map_err(|err| {
                syn::Error::new(
                    error_span,
                    format!(
                        "failed to canonicalize dependency '{dep_name}' path '{}': {err}",
                        absolute_path.display()
                    ),
                )
            })?;

            let dependency_info = parse_dependency_wit(&canonical).map_err(|msg| {
                syn::Error::new(
                    error_span,
                    format!("failed to process WIT for dependency '{dep_name}': {msg}"),
                )
            })?;

            let version_suffix = dependency_info
                .version
                .as_ref()
                .map(|version| format!("@{version}"))
                .unwrap_or_default();

            let interface = dependency_info
                .exports
                .first()
                .ok_or_else(|| {
                    syn::Error::new(
                        error_span,
                        format!(
                            "dependency '{dep_name}' did not export any interfaces in its world \
                             definition"
                        ),
                    )
                })?
                .clone();

            imports.push(format!("{}/{interface}{version_suffix}", dependency_info.package));
        }
    }

    Ok(imports)
}

/// Minimal information parsed from a dependency's WIT world definition.
struct DependencyWit {
    package: String,
    version: Option<String>,
    exports: Vec<String>,
}

/// Parses a dependency directory (or file) to locate the first WIT world definition.
fn parse_dependency_wit(root: &Path) -> Result<DependencyWit, String> {
    if root.is_file() {
        return parse_wit_file(root)?.ok_or_else(|| {
            format!("WIT file '{}' does not contain a world export", root.display())
        });
    }

    let wit_dir = root.join("wit");
    if !wit_dir.exists() {
        return Err(format!("expected a 'wit' directory at '{}'", wit_dir.display()));
    }

    let mut entries = fs::read_dir(&wit_dir)
        .map_err(|err| format!("failed to read '{}': {err}", wit_dir.display()))?
        .collect::<Result<Vec<_>, _>>()
        .map_err(|err| format!("failed to iterate '{}': {err}", wit_dir.display()))?;

    entries.sort_by_key(|entry| entry.file_name());

    for entry in entries {
        let path = entry.path();
        if path.is_dir() {
            if path.file_name().is_some_and(|name| name == "deps") {
                continue;
            }
            continue;
        }

        if path.extension().and_then(|ext| ext.to_str()) != Some("wit") {
            continue;
        }

        if let Some(info) = parse_wit_file(&path)? {
            return Ok(info);
        }
    }

    Err(format!("no WIT world definition found in directory '{}'", wit_dir.display()))
}

/// Parses a single WIT file and extracts world metadata if present.
fn parse_wit_file(path: &Path) -> Result<Option<DependencyWit>, String> {
    let contents = fs::read_to_string(path)
        .map_err(|err| format!("failed to read WIT file '{}': {err}", path.display()))?;

    let (package, version) = match extract_package_identifier(&contents) {
        Some(parts) => parts,
        None => return Ok(None),
    };

    let exports = extract_world_exports(&contents);
    if exports.is_empty() {
        return Ok(None);
    }

    Ok(Some(DependencyWit {
        package,
        version,
        exports,
    }))
}

/// Extracts the WIT package identifier and optional version.
fn extract_package_identifier(contents: &str) -> Option<(String, Option<String>)> {
    for line in contents.lines() {
        let trimmed = strip_comment(line).trim_start();
        if let Some(rest) = trimmed.strip_prefix("package ") {
            let token = rest.trim_end_matches(';').trim();
            if let Some((name, version)) = token.split_once('@') {
                return Some((name.trim().to_string(), Some(version.trim().to_string())));
            }
            return Some((token.to_string(), None));
        }
    }
    None
}

/// Gathers all interfaces exported by the first world definition in the WIT content.
fn extract_world_exports(contents: &str) -> Vec<String> {
    let mut exports = Vec::new();

    for line in contents.lines() {
        let trimmed = strip_comment(line).trim();
        if let Some(rest) = trimmed.strip_prefix("export ") {
            let rest = rest.trim_end_matches(';').trim();
            let interface = match rest.split_once(':') {
                Some((_, interface)) => interface.trim(),
                None => rest,
            };
            if !interface.is_empty() {
                exports.push(interface.to_string());
            }
        }
    }

    exports
}

/// Removes line comments (`//`) from a WIT source line so it can be inspected safely.
fn strip_comment(line: &str) -> &str {
    match line.split_once("//") {
        Some((before, _)) => before,
        None => line,
    }
}
