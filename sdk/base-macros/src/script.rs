use std::{env, fs, path::Path};

use proc_macro2::{Literal, Span};
use quote::quote;
use syn::{parse_macro_input, spanned::Spanned, FnArg, ItemFn, Pat, PatIdent, Type};
use toml::Value;

use crate::{boilerplate::runtime_boilerplate, util::generated_wit_folder_at};

const SCRIPT_PACKAGE_VERSION: &str = "1.0.0";

/// Configuration describing the script macro expansion details.
pub(crate) struct ScriptConfig {
    /// Fully-qualified export interface emitted by the generated WIT world.
    pub export_interface: &'static str,
    /// Fully-qualified path to the guest trait implemented by the generated struct.
    pub guest_trait_path: &'static str,
}

/// Shared expansion logic used by both `#[note_script]` and `#[tx_script]`.
pub(crate) fn expand(
    attr: proc_macro::TokenStream,
    item: proc_macro::TokenStream,
    config: ScriptConfig,
) -> proc_macro::TokenStream {
    if !attr.is_empty() {
        return syn::Error::new(Span::call_site(), "this attribute does not accept arguments")
            .into_compile_error()
            .into();
    }

    let input_fn = parse_macro_input!(item as ItemFn);

    let fn_ident = &input_fn.sig.ident;
    if fn_ident != "run" {
        return syn::Error::new(fn_ident.span(), "this attribute must be applied to `fn run`")
            .into_compile_error()
            .into();
    }

    if input_fn.sig.receiver().is_some() {
        return syn::Error::new(input_fn.sig.span(), "this attribute cannot target methods")
            .into_compile_error()
            .into();
    }

    // Parse function arguments, separating the first trait-required argument from
    // additional "injected" arguments that will be instantiated by the macro.
    let parsed_args = match parse_fn_args(&input_fn) {
        Ok(args) => args,
        Err(err) => return err.into_compile_error().into(),
    };

    let inline_wit = match build_script_wit(Span::call_site(), config.export_interface) {
        Ok(wit) => wit,
        Err(err) => return err.into_compile_error().into(),
    };
    let inline_literal = Literal::string(&inline_wit);
    let struct_ident = quote::format_ident!("Struct");

    let fn_output = &input_fn.sig.output;

    // Build the call to the user's run function with all arguments
    let call = build_run_call(fn_ident, &parsed_args);

    let export_path: syn::Path = match syn::parse_str(config.guest_trait_path) {
        Ok(path) => path,
        Err(err) => {
            return syn::Error::new(
                Span::call_site(),
                format!("failed to parse guest trait path '{}': {err}", config.guest_trait_path),
            )
            .into_compile_error()
            .into();
        }
    };

    let runtime_boilerplate = runtime_boilerplate();

    // Generate the trait's fn signature (only includes the first arg if present)
    let trait_fn_inputs = &parsed_args.trait_fn_inputs;

    // Generate instantiation statements for injected wrapper structs
    let instantiations = &parsed_args.instantiations;

    let expanded = quote! {
        #runtime_boilerplate

        #input_fn

        ::miden::generate!(inline = #inline_literal);
        self::bindings::export!(#struct_ident);

        /// Guest entry point generated by the Miden script attribute.
        pub struct #struct_ident;

        impl #export_path for #struct_ident {
            fn run(#trait_fn_inputs) #fn_output {
                #(#instantiations)*
                #call;
            }
        }
    };

    expanded.into()
}

/// Parsed function arguments separated into trait-required and injected arguments.
struct ParsedFnArgs {
    /// The first argument (if any) that matches the trait signature (e.g., `arg: Word`).
    /// This is used in the generated trait impl signature.
    trait_fn_inputs: proc_macro2::TokenStream,
    /// Instantiation statements for injected wrapper structs.
    /// Each statement is like `let wallet = Type::default();`
    instantiations: Vec<proc_macro2::TokenStream>,
    /// All argument identifiers in order, for calling the user's function.
    all_arg_idents: Vec<syn::Ident>,
}

/// Parses function arguments, separating the first trait-required argument from
/// additional "injected" arguments whose types will be instantiated via `Default`.
fn parse_fn_args(input_fn: &ItemFn) -> syn::Result<ParsedFnArgs> {
    let mut trait_fn_inputs = proc_macro2::TokenStream::new();
    let mut instantiations = Vec::new();
    let mut all_arg_idents = Vec::new();

    for (idx, arg) in input_fn.sig.inputs.iter().enumerate() {
        match arg {
            FnArg::Typed(pat_type) => {
                let ident = match pat_type.pat.as_ref() {
                    Pat::Ident(PatIdent { ident, .. }) => ident.clone(),
                    other => {
                        return Err(syn::Error::new(
                            other.span(),
                            "function arguments must be simple identifiers",
                        ));
                    }
                };

                all_arg_idents.push(ident.clone());

                if idx == 0 {
                    // First argument is the trait-required argument (e.g., `arg: Word`)
                    trait_fn_inputs = quote! { #pat_type };
                } else {
                    // Additional arguments are injected wrapper structs
                    let ty = &pat_type.ty;
                    let instantiation = build_instantiation(&ident, ty);
                    instantiations.push(instantiation);
                }
            }
            FnArg::Receiver(receiver) => {
                return Err(syn::Error::new(receiver.span(), "unexpected receiver argument"));
            }
        }
    }

    Ok(ParsedFnArgs {
        trait_fn_inputs,
        instantiations,
        all_arg_idents,
    })
}

/// Builds an instantiation statement for an injected wrapper struct.
///
/// The type path is converted to use `crate::bindings::` prefix to reference
/// the generated bindings module.
fn build_instantiation(ident: &syn::Ident, ty: &Type) -> proc_macro2::TokenStream {
    // For now, we just call Default::default() on the type as-is.
    // The user is expected to use the full path or import the type.
    quote! {
        let #ident = <#ty as ::core::default::Default>::default();
    }
}

/// Builds the call expression to the user's run function with all arguments.
fn build_run_call(fn_ident: &syn::Ident, parsed_args: &ParsedFnArgs) -> proc_macro2::TokenStream {
    let args = &parsed_args.all_arg_idents;
    if args.is_empty() {
        quote! { #fn_ident() }
    } else {
        quote! { #fn_ident(#(#args),*) }
    }
}

fn build_script_wit(
    error_span: Span,
    export_interface: &'static str,
) -> Result<String, syn::Error> {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").map_err(|err| {
        syn::Error::new(error_span, format!("failed to read CARGO_MANIFEST_DIR: {err}"))
    })?;
    let manifest_path = Path::new(&manifest_dir).join("Cargo.toml");
    let manifest_content = fs::read_to_string(&manifest_path).map_err(|err| {
        syn::Error::new(
            error_span,
            format!("failed to read manifest '{}': {err}", manifest_path.display()),
        )
    })?;

    let manifest: Value = manifest_content.parse().map_err(|err| {
        syn::Error::new(
            error_span,
            format!("failed to parse manifest '{}': {err}", manifest_path.display()),
        )
    })?;

    let package_table = manifest
        .get("package")
        .and_then(Value::as_table)
        .ok_or_else(|| syn::Error::new(error_span, "manifest missing [package] table"))?;

    let crate_name = package_table
        .get("name")
        .and_then(Value::as_str)
        .ok_or_else(|| syn::Error::new(error_span, "manifest package missing `name`"))?;

    let component_package = package_table
        .get("metadata")
        .and_then(Value::as_table)
        .and_then(|meta| meta.get("component"))
        .and_then(Value::as_table)
        .and_then(|component| component.get("package"))
        .and_then(Value::as_str)
        .ok_or_else(|| {
            syn::Error::new(error_span, "manifest missing package.metadata.component.package")
        })?;

    let mut imports = collect_script_imports(&manifest_dir, package_table, error_span)?;
    imports.sort();

    let package_with_version = if component_package.contains('@') {
        component_package.to_string()
    } else {
        format!("{component_package}@{SCRIPT_PACKAGE_VERSION}")
    };

    let world_name = format!("{}-world", crate_name.replace('_', "-"));

    let mut wit_source = String::new();
    wit_source.push_str(&format!("package {package_with_version};\n\n"));
    wit_source.push_str(&format!("world {world_name} {{\n"));
    for import in imports {
        wit_source.push_str("    import ");
        wit_source.push_str(&import);
        wit_source.push_str(";\n");
    }
    wit_source.push_str(&format!("    export {export_interface};\n"));
    wit_source.push('}');
    wit_source.push('\n');

    Ok(wit_source)
}

fn collect_script_imports(
    manifest_dir: &str,
    package_table: &toml::value::Table,
    error_span: Span,
) -> Result<Vec<String>, syn::Error> {
    let dependencies = package_table
        .get("metadata")
        .and_then(Value::as_table)
        .and_then(|meta| meta.get("miden"))
        .and_then(Value::as_table)
        .and_then(|miden| miden.get("dependencies"))
        .and_then(Value::as_table);

    let mut imports = Vec::new();

    if let Some(dep_table) = dependencies {
        for (dep_name, dep_value) in dep_table.iter() {
            let dep_config = dep_value.as_table().ok_or_else(|| {
                syn::Error::new(
                    error_span,
                    format!(
                        "dependency '{dep_name}' under package.metadata.miden.dependencies must \
                         be a table"
                    ),
                )
            })?;

            let dependency_path =
                dep_config.get("path").and_then(Value::as_str).ok_or_else(|| {
                    syn::Error::new(
                        error_span,
                        format!(
                            "dependency '{dep_name}' under package.metadata.miden.dependencies is \
                             missing a 'path' entry"
                        ),
                    )
                })?;

            let absolute_path = Path::new(manifest_dir).join(dependency_path);
            let canonical = fs::canonicalize(&absolute_path).map_err(|err| {
                syn::Error::new(
                    error_span,
                    format!(
                        "failed to canonicalize dependency '{dep_name}' path '{}': {err}",
                        absolute_path.display()
                    ),
                )
            })?;

            let dependency_info = parse_dependency_wit(&canonical).map_err(|msg| {
                syn::Error::new(
                    error_span,
                    format!("failed to process WIT for dependency '{dep_name}': {msg}"),
                )
            })?;

            let version_suffix = dependency_info
                .version
                .as_ref()
                .map(|version| format!("@{version}"))
                .unwrap_or_default();

            let interface = dependency_info
                .exports
                .first()
                .ok_or_else(|| {
                    syn::Error::new(
                        error_span,
                        format!(
                            "dependency '{dep_name}' did not export any interfaces in its world \
                             definition"
                        ),
                    )
                })?
                .clone();

            imports.push(format!("{}/{interface}{version_suffix}", dependency_info.package));
        }
    }

    Ok(imports)
}

struct DependencyWit {
    package: String,
    version: Option<String>,
    exports: Vec<String>,
}

fn parse_dependency_wit(root: &Path) -> Result<DependencyWit, String> {
    if root.is_file() {
        return parse_wit_file(root)?.ok_or_else(|| {
            format!("WIT file '{}' does not contain a world export", root.display())
        });
    }

    let default_wit_dir = root.join("wit");
    let generated_wit_dir = generated_wit_folder_at(root)?;
    let wit_dirs = [default_wit_dir, generated_wit_dir];
    for wit_dir in &wit_dirs {
        if !wit_dir.exists() {
            continue;
        }
        let mut entries = fs::read_dir(wit_dir)
            .map_err(|err| format!("failed to read '{}': {err}", wit_dir.display()))?
            .collect::<Result<Vec<_>, _>>()
            .map_err(|err| format!("failed to iterate '{}': {err}", wit_dir.display()))?;

        entries.sort_by_key(|entry| entry.file_name());

        for entry in entries {
            let path = entry.path();
            if path.is_dir() {
                if path.file_name().is_some_and(|name| name == "deps") {
                    continue;
                }
                continue;
            }

            if path.extension().and_then(|ext| ext.to_str()) != Some("wit") {
                continue;
            }

            if let Some(info) = parse_wit_file(&path)? {
                return Ok(info);
            }
        }
    }

    Err(format!("no WIT world definition found in directories '{wit_dirs:?}'"))
}

fn parse_wit_file(path: &Path) -> Result<Option<DependencyWit>, String> {
    let contents = fs::read_to_string(path)
        .map_err(|err| format!("failed to read WIT file '{}': {err}", path.display()))?;

    let (package, version) = match extract_package_identifier(&contents) {
        Some(parts) => parts,
        None => return Ok(None),
    };

    let exports = extract_world_exports(&contents);
    if exports.is_empty() {
        return Ok(None);
    }

    Ok(Some(DependencyWit {
        package,
        version,
        exports,
    }))
}

fn extract_package_identifier(contents: &str) -> Option<(String, Option<String>)> {
    for line in contents.lines() {
        let trimmed = strip_comment(line).trim_start();
        if let Some(rest) = trimmed.strip_prefix("package ") {
            let token = rest.trim_end_matches(';').trim();
            if let Some((name, version)) = token.split_once('@') {
                return Some((name.trim().to_string(), Some(version.trim().to_string())));
            }
            return Some((token.to_string(), None));
        }
    }
    None
}

fn extract_world_exports(contents: &str) -> Vec<String> {
    let mut exports = Vec::new();

    for line in contents.lines() {
        let trimmed = strip_comment(line).trim();
        if let Some(rest) = trimmed.strip_prefix("export ") {
            let rest = rest.trim_end_matches(';').trim();
            let interface = match rest.split_once(':') {
                Some((_, interface)) => interface.trim(),
                None => rest,
            };
            if !interface.is_empty() {
                exports.push(interface.to_string());
            }
        }
    }

    exports
}

fn strip_comment(line: &str) -> &str {
    match line.split_once("//") {
        Some((before, _)) => before,
        None => line,
    }
}
