builtin.component root_ns:root@1.0.0 {
    builtin.module public @rust_sdk_stdlib_smt_get {
        private builtin.function @<miden_stdlib_sys::intrinsics::word::Word as core::cmp::PartialEq>::eq(v0: i32, v1: i32) -> i32 {
        ^block4(v0: i32, v1: i32):
            v5 = hir.bitcast v0 : u32;
            v6 = arith.constant 4 : u32;
            v7 = arith.mod v5, v6 : u32;
            hir.assertz v7 #[code = 250];
            v8 = hir.int_to_ptr v5 : ptr<byte, felt>;
            v9 = hir.load v8 : felt;
            v10 = hir.bitcast v1 : u32;
            v428 = arith.constant 4 : u32;
            v12 = arith.mod v10, v428 : u32;
            hir.assertz v12 #[code = 250];
            v13 = hir.int_to_ptr v10 : ptr<byte, felt>;
            v14 = hir.load v13 : felt;
            v3 = arith.constant 0 : i32;
            v17 = arith.constant 1 : i32;
            v15 = arith.eq v9, v14 : i1;
            v16 = hir.cast v15 : i32;
            v18 = arith.neq v16, v17 : i1;
            v19 = arith.zext v18 : u32;
            v20 = hir.bitcast v19 : i32;
            v22 = arith.neq v20, v3 : i1;
            v406 = scf.if v22 : i32 {
            ^block6:
                v427 = arith.constant 0 : i32;
                scf.yield v427;
            } else {
            ^block7:
                v426 = arith.constant 4 : u32;
                v23 = hir.bitcast v0 : u32;
                v25 = arith.add v23, v426 : u32 #[overflow = checked];
                v425 = arith.constant 4 : u32;
                v27 = arith.mod v25, v425 : u32;
                hir.assertz v27 #[code = 250];
                v28 = hir.int_to_ptr v25 : ptr<byte, felt>;
                v29 = hir.load v28 : felt;
                v424 = arith.constant 4 : u32;
                v30 = hir.bitcast v1 : u32;
                v32 = arith.add v30, v424 : u32 #[overflow = checked];
                v423 = arith.constant 4 : u32;
                v34 = arith.mod v32, v423 : u32;
                hir.assertz v34 #[code = 250];
                v35 = hir.int_to_ptr v32 : ptr<byte, felt>;
                v36 = hir.load v35 : felt;
                v421 = arith.constant 0 : i32;
                v422 = arith.constant 1 : i32;
                v37 = arith.eq v29, v36 : i1;
                v38 = hir.cast v37 : i32;
                v40 = arith.neq v38, v422 : i1;
                v41 = arith.zext v40 : u32;
                v42 = hir.bitcast v41 : i32;
                v44 = arith.neq v42, v421 : i1;
                v408 = scf.if v44 : i32 {
                ^block27:
                    v420 = arith.constant 0 : i32;
                    scf.yield v420;
                } else {
                ^block8:
                    v46 = arith.constant 8 : u32;
                    v45 = hir.bitcast v0 : u32;
                    v47 = arith.add v45, v46 : u32 #[overflow = checked];
                    v419 = arith.constant 4 : u32;
                    v49 = arith.mod v47, v419 : u32;
                    hir.assertz v49 #[code = 250];
                    v50 = hir.int_to_ptr v47 : ptr<byte, felt>;
                    v51 = hir.load v50 : felt;
                    v418 = arith.constant 8 : u32;
                    v52 = hir.bitcast v1 : u32;
                    v54 = arith.add v52, v418 : u32 #[overflow = checked];
                    v417 = arith.constant 4 : u32;
                    v56 = arith.mod v54, v417 : u32;
                    hir.assertz v56 #[code = 250];
                    v57 = hir.int_to_ptr v54 : ptr<byte, felt>;
                    v58 = hir.load v57 : felt;
                    v415 = arith.constant 0 : i32;
                    v416 = arith.constant 1 : i32;
                    v59 = arith.eq v51, v58 : i1;
                    v60 = hir.cast v59 : i32;
                    v62 = arith.neq v60, v416 : i1;
                    v63 = arith.zext v62 : u32;
                    v64 = hir.bitcast v63 : i32;
                    v66 = arith.neq v64, v415 : i1;
                    v409 = scf.if v66 : i32 {
                    ^block26:
                        v414 = arith.constant 0 : i32;
                        scf.yield v414;
                    } else {
                    ^block9:
                        v68 = arith.constant 12 : u32;
                        v67 = hir.bitcast v0 : u32;
                        v69 = arith.add v67, v68 : u32 #[overflow = checked];
                        v413 = arith.constant 4 : u32;
                        v71 = arith.mod v69, v413 : u32;
                        hir.assertz v71 #[code = 250];
                        v72 = hir.int_to_ptr v69 : ptr<byte, felt>;
                        v73 = hir.load v72 : felt;
                        v412 = arith.constant 12 : u32;
                        v74 = hir.bitcast v1 : u32;
                        v76 = arith.add v74, v412 : u32 #[overflow = checked];
                        v411 = arith.constant 4 : u32;
                        v78 = arith.mod v76, v411 : u32;
                        hir.assertz v78 #[code = 250];
                        v79 = hir.int_to_ptr v76 : ptr<byte, felt>;
                        v80 = hir.load v79 : felt;
                        v410 = arith.constant 1 : i32;
                        v81 = arith.eq v73, v80 : i1;
                        v82 = hir.cast v81 : i32;
                        v84 = arith.eq v82, v410 : i1;
                        v85 = arith.zext v84 : u32;
                        v86 = hir.bitcast v85 : i32;
                        scf.yield v86;
                    };
                    scf.yield v409;
                };
                scf.yield v408;
            };
            builtin.ret v406;
        };

        public builtin.function @entrypoint(v88: felt, v89: felt, v90: felt, v91: felt, v92: felt, v93: felt, v94: felt, v95: felt) {
        ^block10(v88: felt, v89: felt, v90: felt, v91: felt, v92: felt, v93: felt, v94: felt, v95: felt):
            v97 = builtin.global_symbol @root_ns:root@1.0.0/rust_sdk_stdlib_smt_get/__stack_pointer : ptr<byte, u8>
            v98 = hir.bitcast v97 : ptr<byte, i32>;
            v99 = hir.load v98 : i32;
            v102 = arith.constant -32 : i32;
            v100 = arith.constant 160 : i32;
            v101 = arith.sub v99, v100 : i32 #[overflow = wrapping];
            v103 = arith.band v101, v102 : i32;
            v104 = builtin.global_symbol @root_ns:root@1.0.0/rust_sdk_stdlib_smt_get/__stack_pointer : ptr<byte, u8>
            v105 = hir.bitcast v104 : ptr<byte, i32>;
            hir.store v105, v103;
            v107 = arith.constant 28 : u32;
            v106 = hir.bitcast v103 : u32;
            v108 = arith.add v106, v107 : u32 #[overflow = checked];
            v109 = arith.constant 4 : u32;
            v110 = arith.mod v108, v109 : u32;
            hir.assertz v110 #[code = 250];
            v111 = hir.int_to_ptr v108 : ptr<byte, felt>;
            hir.store v111, v95;
            v113 = arith.constant 24 : u32;
            v112 = hir.bitcast v103 : u32;
            v114 = arith.add v112, v113 : u32 #[overflow = checked];
            v464 = arith.constant 4 : u32;
            v116 = arith.mod v114, v464 : u32;
            hir.assertz v116 #[code = 250];
            v117 = hir.int_to_ptr v114 : ptr<byte, felt>;
            hir.store v117, v94;
            v119 = arith.constant 20 : u32;
            v118 = hir.bitcast v103 : u32;
            v120 = arith.add v118, v119 : u32 #[overflow = checked];
            v463 = arith.constant 4 : u32;
            v122 = arith.mod v120, v463 : u32;
            hir.assertz v122 #[code = 250];
            v123 = hir.int_to_ptr v120 : ptr<byte, felt>;
            hir.store v123, v93;
            v125 = arith.constant 16 : u32;
            v124 = hir.bitcast v103 : u32;
            v126 = arith.add v124, v125 : u32 #[overflow = checked];
            v462 = arith.constant 4 : u32;
            v128 = arith.mod v126, v462 : u32;
            hir.assertz v128 #[code = 250];
            v129 = hir.int_to_ptr v126 : ptr<byte, felt>;
            hir.store v129, v92;
            v130 = arith.constant 64 : i32;
            v131 = arith.add v103, v130 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_smt_get/std::collections::smt::get(v91, v90, v89, v88, v95, v94, v93, v92, v131)
            v133 = arith.constant 72 : u32;
            v132 = hir.bitcast v103 : u32;
            v134 = arith.add v132, v133 : u32 #[overflow = checked];
            v135 = arith.constant 8 : u32;
            v136 = arith.mod v134, v135 : u32;
            hir.assertz v136 #[code = 250];
            v137 = hir.int_to_ptr v134 : ptr<byte, i64>;
            v138 = hir.load v137 : i64;
            v140 = arith.constant 120 : u32;
            v139 = hir.bitcast v103 : u32;
            v141 = arith.add v139, v140 : u32 #[overflow = checked];
            v461 = arith.constant 8 : u32;
            v143 = arith.mod v141, v461 : u32;
            hir.assertz v143 #[code = 250];
            v144 = hir.int_to_ptr v141 : ptr<byte, i64>;
            hir.store v144, v138;
            v146 = arith.constant 64 : u32;
            v145 = hir.bitcast v103 : u32;
            v147 = arith.add v145, v146 : u32 #[overflow = checked];
            v460 = arith.constant 8 : u32;
            v149 = arith.mod v147, v460 : u32;
            hir.assertz v149 #[code = 250];
            v150 = hir.int_to_ptr v147 : ptr<byte, i64>;
            v151 = hir.load v150 : i64;
            v153 = arith.constant 112 : u32;
            v152 = hir.bitcast v103 : u32;
            v154 = arith.add v152, v153 : u32 #[overflow = checked];
            v459 = arith.constant 8 : u32;
            v156 = arith.mod v154, v459 : u32;
            hir.assertz v156 #[code = 250];
            v157 = hir.int_to_ptr v154 : ptr<byte, i64>;
            hir.store v157, v151;
            v159 = arith.constant 88 : u32;
            v158 = hir.bitcast v103 : u32;
            v160 = arith.add v158, v159 : u32 #[overflow = checked];
            v458 = arith.constant 8 : u32;
            v162 = arith.mod v160, v458 : u32;
            hir.assertz v162 #[code = 250];
            v163 = hir.int_to_ptr v160 : ptr<byte, i64>;
            v164 = hir.load v163 : i64;
            v166 = arith.constant 136 : u32;
            v165 = hir.bitcast v103 : u32;
            v167 = arith.add v165, v166 : u32 #[overflow = checked];
            v457 = arith.constant 8 : u32;
            v169 = arith.mod v167, v457 : u32;
            hir.assertz v169 #[code = 250];
            v170 = hir.int_to_ptr v167 : ptr<byte, i64>;
            hir.store v170, v164;
            v172 = arith.constant 80 : u32;
            v171 = hir.bitcast v103 : u32;
            v173 = arith.add v171, v172 : u32 #[overflow = checked];
            v456 = arith.constant 8 : u32;
            v175 = arith.mod v173, v456 : u32;
            hir.assertz v175 #[code = 250];
            v176 = hir.int_to_ptr v173 : ptr<byte, i64>;
            v177 = hir.load v176 : i64;
            v179 = arith.constant 128 : u32;
            v178 = hir.bitcast v103 : u32;
            v180 = arith.add v178, v179 : u32 #[overflow = checked];
            v455 = arith.constant 8 : u32;
            v182 = arith.mod v180, v455 : u32;
            hir.assertz v182 #[code = 250];
            v183 = hir.int_to_ptr v180 : ptr<byte, i64>;
            hir.store v183, v177;
            v186 = arith.constant 112 : i32;
            v187 = arith.add v103, v186 : i32 #[overflow = wrapping];
            v184 = arith.constant 32 : i32;
            v185 = arith.add v103, v184 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_smt_get/<miden_stdlib_sys::intrinsics::word::Word>::reverse(v185, v187)
            v190 = arith.constant 128 : i32;
            v191 = arith.add v103, v190 : i32 #[overflow = wrapping];
            v188 = arith.constant 144 : i32;
            v189 = arith.add v103, v188 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_smt_get/<miden_stdlib_sys::intrinsics::word::Word>::reverse(v189, v191)
            v195 = arith.constant 152 : u32;
            v194 = hir.bitcast v103 : u32;
            v196 = arith.add v194, v195 : u32 #[overflow = checked];
            v454 = arith.constant 8 : u32;
            v198 = arith.mod v196, v454 : u32;
            hir.assertz v198 #[code = 250];
            v199 = hir.int_to_ptr v196 : ptr<byte, i64>;
            v200 = hir.load v199 : i64;
            v192 = arith.constant 56 : i32;
            v193 = arith.add v103, v192 : i32 #[overflow = wrapping];
            v201 = hir.bitcast v193 : u32;
            v453 = arith.constant 8 : u32;
            v203 = arith.mod v201, v453 : u32;
            hir.assertz v203 #[code = 250];
            v204 = hir.int_to_ptr v201 : ptr<byte, i64>;
            hir.store v204, v200;
            v206 = arith.constant 144 : u32;
            v205 = hir.bitcast v103 : u32;
            v207 = arith.add v205, v206 : u32 #[overflow = checked];
            v452 = arith.constant 8 : u32;
            v209 = arith.mod v207, v452 : u32;
            hir.assertz v209 #[code = 250];
            v210 = hir.int_to_ptr v207 : ptr<byte, i64>;
            v211 = hir.load v210 : i64;
            v213 = arith.constant 48 : u32;
            v212 = hir.bitcast v103 : u32;
            v214 = arith.add v212, v213 : u32 #[overflow = checked];
            v451 = arith.constant 8 : u32;
            v216 = arith.mod v214, v451 : u32;
            hir.assertz v216 #[code = 250];
            v217 = hir.int_to_ptr v214 : ptr<byte, i64>;
            hir.store v217, v211;
            v227 = arith.constant 76 : u32;
            v226 = hir.bitcast v103 : u32;
            v228 = arith.add v226, v227 : u32 #[overflow = checked];
            v450 = arith.constant 4 : u32;
            v230 = arith.mod v228, v450 : u32;
            hir.assertz v230 #[code = 250];
            v224 = arith.constant 13 : i64;
            v225 = arith.trunc v224 : felt;
            v231 = hir.int_to_ptr v228 : ptr<byte, felt>;
            hir.store v231, v225;
            v449 = arith.constant 72 : u32;
            v232 = hir.bitcast v103 : u32;
            v234 = arith.add v232, v449 : u32 #[overflow = checked];
            v448 = arith.constant 4 : u32;
            v236 = arith.mod v234, v448 : u32;
            hir.assertz v236 #[code = 250];
            v222 = arith.constant 12 : i64;
            v223 = arith.trunc v222 : felt;
            v237 = hir.int_to_ptr v234 : ptr<byte, felt>;
            hir.store v237, v223;
            v239 = arith.constant 68 : u32;
            v238 = hir.bitcast v103 : u32;
            v240 = arith.add v238, v239 : u32 #[overflow = checked];
            v447 = arith.constant 4 : u32;
            v242 = arith.mod v240, v447 : u32;
            hir.assertz v242 #[code = 250];
            v220 = arith.constant 11 : i64;
            v221 = arith.trunc v220 : felt;
            v243 = hir.int_to_ptr v240 : ptr<byte, felt>;
            hir.store v243, v221;
            v446 = arith.constant 64 : u32;
            v244 = hir.bitcast v103 : u32;
            v246 = arith.add v244, v446 : u32 #[overflow = checked];
            v445 = arith.constant 4 : u32;
            v248 = arith.mod v246, v445 : u32;
            hir.assertz v248 #[code = 250];
            v218 = arith.constant 10 : i64;
            v219 = arith.trunc v218 : felt;
            v249 = hir.int_to_ptr v246 : ptr<byte, felt>;
            hir.store v249, v219;
            v443 = arith.constant 64 : i32;
            v253 = arith.add v103, v443 : i32 #[overflow = wrapping];
            v444 = arith.constant 32 : i32;
            v251 = arith.add v103, v444 : i32 #[overflow = wrapping];
            v254 = hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_smt_get/<miden_stdlib_sys::intrinsics::word::Word as core::cmp::PartialEq>::eq(v251, v253) : i32
            v442 = arith.constant 0 : i32;
            v96 = arith.constant 0 : i32;
            v256 = arith.eq v254, v96 : i1;
            v257 = arith.zext v256 : u32;
            v258 = hir.bitcast v257 : i32;
            v260 = arith.neq v258, v442 : i1;
            v433 = scf.if v260 : u32 {
            ^block32:
                v429 = arith.constant 0 : u32;
                scf.yield v429;
            } else {
            ^block13:
                v263 = arith.constant 16 : i32;
                v264 = arith.add v103, v263 : i32 #[overflow = wrapping];
                v261 = arith.constant 48 : i32;
                v262 = arith.add v103, v261 : i32 #[overflow = wrapping];
                v265 = hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_smt_get/<miden_stdlib_sys::intrinsics::word::Word as core::cmp::PartialEq>::eq(v262, v264) : i32
                v440 = arith.constant 0 : i32;
                v441 = arith.constant 0 : i32;
                v267 = arith.eq v265, v441 : i1;
                v268 = arith.zext v267 : u32;
                v269 = hir.bitcast v268 : i32;
                v271 = arith.neq v269, v440 : i1;
                scf.if v271{
                ^block31:
                    scf.yield ;
                } else {
                ^block14:
                    v272 = builtin.global_symbol @root_ns:root@1.0.0/rust_sdk_stdlib_smt_get/__stack_pointer : ptr<byte, u8>
                    v273 = hir.bitcast v272 : ptr<byte, i32>;
                    hir.store v273, v99;
                    scf.yield ;
                };
                v431 = arith.constant 1 : u32;
                v439 = arith.constant 0 : u32;
                v437 = cf.select v271, v439, v431 : u32;
                scf.yield v437;
            };
            v438 = arith.constant 0 : u32;
            v436 = arith.eq v433, v438 : i1;
            cf.cond_br v436 ^block12, ^block34;
        ^block12:
            ub.unreachable ;
        ^block34:
            builtin.ret ;
        };

        private builtin.function @<miden_stdlib_sys::intrinsics::word::Word>::reverse(v274: i32, v275: i32) {
        ^block15(v274: i32, v275: i32):
            v278 = builtin.global_symbol @root_ns:root@1.0.0/rust_sdk_stdlib_smt_get/__stack_pointer : ptr<byte, u8>
            v279 = hir.bitcast v278 : ptr<byte, i32>;
            v280 = hir.load v279 : i32;
            v281 = arith.constant 16 : i32;
            v282 = arith.sub v280, v281 : i32 #[overflow = wrapping];
            v284 = arith.constant 8 : u32;
            v283 = hir.bitcast v275 : u32;
            v285 = arith.add v283, v284 : u32 #[overflow = checked];
            v551 = arith.constant 8 : u32;
            v287 = arith.mod v285, v551 : u32;
            hir.assertz v287 #[code = 250];
            v288 = hir.int_to_ptr v285 : ptr<byte, i64>;
            v289 = hir.load v288 : i64;
            v550 = arith.constant 8 : u32;
            v290 = hir.bitcast v282 : u32;
            v292 = arith.add v290, v550 : u32 #[overflow = checked];
            v293 = arith.constant 4 : u32;
            v294 = arith.mod v292, v293 : u32;
            hir.assertz v294 #[code = 250];
            v295 = hir.int_to_ptr v292 : ptr<byte, i64>;
            hir.store v295, v289;
            v296 = hir.bitcast v275 : u32;
            v549 = arith.constant 8 : u32;
            v298 = arith.mod v296, v549 : u32;
            hir.assertz v298 #[code = 250];
            v299 = hir.int_to_ptr v296 : ptr<byte, i64>;
            v300 = hir.load v299 : i64;
            v301 = hir.bitcast v282 : u32;
            v548 = arith.constant 4 : u32;
            v303 = arith.mod v301, v548 : u32;
            hir.assertz v303 #[code = 250];
            v304 = hir.int_to_ptr v301 : ptr<byte, i64>;
            hir.store v304, v300;
            v305 = arith.constant 12 : i32;
            v306 = arith.add v282, v305 : i32 #[overflow = wrapping];
            v276 = arith.constant 0 : i32;
            v519, v520, v521, v522, v523, v524 = scf.while v276, v282, v306, v274 : i32, i32, i32, i32, i32, i32 {
            ^block44(v525: i32, v526: i32, v527: i32, v528: i32):
                v547 = arith.constant 0 : i32;
                v309 = arith.constant 8 : i32;
                v310 = arith.eq v525, v309 : i1;
                v311 = arith.zext v310 : u32;
                v312 = hir.bitcast v311 : i32;
                v314 = arith.neq v312, v547 : i1;
                v513, v514 = scf.if v314 : i32, i32 {
                ^block43:
                    v473 = ub.poison i32 : i32;
                    scf.yield v473, v473;
                } else {
                ^block20:
                    v316 = arith.add v526, v525 : i32 #[overflow = wrapping];
                    v317 = hir.bitcast v316 : u32;
                    v546 = arith.constant 4 : u32;
                    v319 = arith.mod v317, v546 : u32;
                    hir.assertz v319 #[code = 250];
                    v320 = hir.int_to_ptr v317 : ptr<byte, felt>;
                    v321 = hir.load v320 : felt;
                    v323 = hir.bitcast v527 : u32;
                    v545 = arith.constant 4 : u32;
                    v325 = arith.mod v323, v545 : u32;
                    hir.assertz v325 #[code = 250];
                    v326 = hir.int_to_ptr v323 : ptr<byte, i32>;
                    v327 = hir.load v326 : i32;
                    v328 = hir.bitcast v316 : u32;
                    v544 = arith.constant 4 : u32;
                    v330 = arith.mod v328, v544 : u32;
                    hir.assertz v330 #[code = 250];
                    v331 = hir.int_to_ptr v328 : ptr<byte, i32>;
                    hir.store v331, v327;
                    v332 = hir.bitcast v527 : u32;
                    v543 = arith.constant 4 : u32;
                    v334 = arith.mod v332, v543 : u32;
                    hir.assertz v334 #[code = 250];
                    v335 = hir.int_to_ptr v332 : ptr<byte, felt>;
                    hir.store v335, v321;
                    v338 = arith.constant -4 : i32;
                    v339 = arith.add v527, v338 : i32 #[overflow = wrapping];
                    v336 = arith.constant 4 : i32;
                    v337 = arith.add v525, v336 : i32 #[overflow = wrapping];
                    scf.yield v337, v339;
                };
                v541 = ub.poison i32 : i32;
                v516 = cf.select v314, v541, v528 : i32;
                v542 = ub.poison i32 : i32;
                v515 = cf.select v314, v542, v526 : i32;
                v472 = arith.constant 1 : u32;
                v465 = arith.constant 0 : u32;
                v518 = cf.select v314, v465, v472 : u32;
                v506 = arith.trunc v518 : i1;
                scf.condition v506, v513, v515, v514, v516, v526, v528;
            } do {
            ^block45(v529: i32, v530: i32, v531: i32, v532: i32, v533: i32, v534: i32):
                scf.yield v529, v530, v531, v532;
            };
            v540 = arith.constant 8 : u32;
            v341 = hir.bitcast v523 : u32;
            v343 = arith.add v341, v540 : u32 #[overflow = checked];
            v539 = arith.constant 4 : u32;
            v345 = arith.mod v343, v539 : u32;
            hir.assertz v345 #[code = 250];
            v346 = hir.int_to_ptr v343 : ptr<byte, i64>;
            v347 = hir.load v346 : i64;
            v538 = arith.constant 8 : u32;
            v348 = hir.bitcast v524 : u32;
            v350 = arith.add v348, v538 : u32 #[overflow = checked];
            v537 = arith.constant 8 : u32;
            v352 = arith.mod v350, v537 : u32;
            hir.assertz v352 #[code = 250];
            v353 = hir.int_to_ptr v350 : ptr<byte, i64>;
            hir.store v353, v347;
            v354 = hir.bitcast v523 : u32;
            v536 = arith.constant 4 : u32;
            v356 = arith.mod v354, v536 : u32;
            hir.assertz v356 #[code = 250];
            v357 = hir.int_to_ptr v354 : ptr<byte, i64>;
            v358 = hir.load v357 : i64;
            v359 = hir.bitcast v524 : u32;
            v535 = arith.constant 8 : u32;
            v361 = arith.mod v359, v535 : u32;
            hir.assertz v361 #[code = 250];
            v362 = hir.int_to_ptr v359 : ptr<byte, i64>;
            hir.store v362, v358;
            builtin.ret ;
        };

        private builtin.function @std::collections::smt::get(v363: felt, v364: felt, v365: felt, v366: felt, v367: felt, v368: felt, v369: felt, v370: felt, v371: i32) {
        ^block21(v363: felt, v364: felt, v365: felt, v366: felt, v367: felt, v368: felt, v369: felt, v370: felt, v371: i32):
            v372, v373, v374, v375, v376, v377, v378, v379 = hir.exec @std/collections/smt/get(v363, v364, v365, v366, v367, v368, v369, v370) : felt, felt, felt, felt, felt, felt, felt, felt
            v380 = hir.bitcast v371 : u32;
            v381 = hir.int_to_ptr v380 : ptr<byte, felt>;
            hir.store v381, v372;
            v382 = arith.constant 4 : u32;
            v383 = arith.add v380, v382 : u32 #[overflow = checked];
            v384 = hir.int_to_ptr v383 : ptr<byte, felt>;
            hir.store v384, v373;
            v385 = arith.constant 8 : u32;
            v386 = arith.add v380, v385 : u32 #[overflow = checked];
            v387 = hir.int_to_ptr v386 : ptr<byte, felt>;
            hir.store v387, v374;
            v388 = arith.constant 12 : u32;
            v389 = arith.add v380, v388 : u32 #[overflow = checked];
            v390 = hir.int_to_ptr v389 : ptr<byte, felt>;
            hir.store v390, v375;
            v391 = arith.constant 16 : u32;
            v392 = arith.add v380, v391 : u32 #[overflow = checked];
            v393 = hir.int_to_ptr v392 : ptr<byte, felt>;
            hir.store v393, v376;
            v394 = arith.constant 20 : u32;
            v395 = arith.add v380, v394 : u32 #[overflow = checked];
            v396 = hir.int_to_ptr v395 : ptr<byte, felt>;
            hir.store v396, v377;
            v397 = arith.constant 24 : u32;
            v398 = arith.add v380, v397 : u32 #[overflow = checked];
            v399 = hir.int_to_ptr v398 : ptr<byte, felt>;
            hir.store v399, v378;
            v400 = arith.constant 28 : u32;
            v401 = arith.add v380, v400 : u32 #[overflow = checked];
            v402 = hir.int_to_ptr v401 : ptr<byte, felt>;
            hir.store v402, v379;
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};