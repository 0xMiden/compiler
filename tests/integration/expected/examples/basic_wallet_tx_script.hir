builtin.component miden:base/transaction-script@1.0.0 {
    builtin.module public @basic_wallet_tx_script {
        private builtin.function @basic_wallet_tx_script::bindings::miden::basic_wallet::basic_wallet::move_asset_to_note::wit_import9(v0: felt, v1: felt, v2: felt, v3: felt, v4: felt) {
        ^block3(v0: felt, v1: felt, v2: felt, v3: felt, v4: felt):
            hir.call v0, v1, v2, v3, v4 #[callee = miden:basic-wallet/basic-wallet@1.0.0/move-asset-to-note] #[signature = (param felt) (param felt) (param felt) (param felt) (param felt)];
            builtin.ret ;
        };

        private builtin.function @__wasm_call_ctors() {
        ^block8:
            builtin.ret ;
        };

        private builtin.function @core::slice::index::slice_end_index_len_fail(v5: i32, v6: i32, v7: i32) {
        ^block10(v5: i32, v6: i32, v7: i32):
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/core::slice::<impl [T]>::copy_from_slice::len_mismatch_fail::do_panic::runtime(v5, v6, v7)
            ub.unreachable ;
        };

        private builtin.function @<alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index(v8: i32, v9: i32, v10: i32, v11: i32, v12: i32) {
        ^block12(v8: i32, v9: i32, v10: i32, v11: i32, v12: i32):
            v15 = arith.constant 8 : u32;
            v14 = hir.bitcast v9 : u32;
            v16 = arith.add v14, v15 : u32 #[overflow = checked];
            v17 = arith.constant 4 : u32;
            v18 = arith.mod v16, v17 : u32;
            hir.assertz v18 #[code = 250];
            v19 = hir.int_to_ptr v16 : ptr<byte, i32>;
            v20 = hir.load v19 : i32;
            v13 = arith.constant 0 : i32;
            v22 = hir.bitcast v20 : u32;
            v21 = hir.bitcast v11 : u32;
            v23 = arith.lte v21, v22 : i1;
            v24 = arith.zext v23 : u32;
            v25 = hir.bitcast v24 : i32;
            v27 = arith.neq v25, v13 : i1;
            cf.cond_br v27 ^block14, ^block15;
        ^block14:
            v915 = arith.constant 4 : u32;
            v29 = hir.bitcast v8 : u32;
            v31 = arith.add v29, v915 : u32 #[overflow = checked];
            v914 = arith.constant 4 : u32;
            v33 = arith.mod v31, v914 : u32;
            hir.assertz v33 #[code = 250];
            v28 = arith.sub v11, v10 : i32 #[overflow = wrapping];
            v34 = hir.int_to_ptr v31 : ptr<byte, i32>;
            hir.store v34, v28;
            v913 = arith.constant 4 : u32;
            v35 = hir.bitcast v9 : u32;
            v37 = arith.add v35, v913 : u32 #[overflow = checked];
            v912 = arith.constant 4 : u32;
            v39 = arith.mod v37, v912 : u32;
            hir.assertz v39 #[code = 250];
            v40 = hir.int_to_ptr v37 : ptr<byte, i32>;
            v41 = hir.load v40 : i32;
            v46 = hir.bitcast v8 : u32;
            v911 = arith.constant 4 : u32;
            v48 = arith.mod v46, v911 : u32;
            hir.assertz v48 #[code = 250];
            v909 = arith.constant 2 : u32;
            v44 = arith.shl v10, v909 : i32;
            v45 = arith.add v41, v44 : i32 #[overflow = wrapping];
            v49 = hir.int_to_ptr v46 : ptr<byte, i32>;
            hir.store v49, v45;
            builtin.ret ;
        ^block15:
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/core::slice::index::slice_end_index_len_fail(v11, v20, v12)
            ub.unreachable ;
        };

        private builtin.function @basic_wallet_tx_script::bindings::__link_custom_section_describing_imports() {
        ^block16:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc(v50: i32, v51: i32) -> i32 {
        ^block18(v50: i32, v51: i32):
            v53 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
            v54 = hir.bitcast v53 : ptr<byte, i32>;
            v55 = hir.load v54 : i32;
            v56 = arith.constant 1048688 : i32;
            v57 = arith.add v55, v56 : i32 #[overflow = wrapping];
            v58 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v57, v51, v50) : i32
            builtin.ret v58;
        };

        private builtin.function @__rustc::__rust_dealloc(v59: i32, v60: i32, v61: i32) {
        ^block20(v59: i32, v60: i32, v61: i32):
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v62: i32, v63: i32) -> i32 {
        ^block22(v62: i32, v63: i32):
            v65 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
            v66 = hir.bitcast v65 : ptr<byte, i32>;
            v67 = hir.load v66 : i32;
            v68 = arith.constant 1048688 : i32;
            v69 = arith.add v67, v68 : i32 #[overflow = wrapping];
            v70 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v69, v63, v62) : i32
            v924 = arith.constant 0 : i32;
            v71 = arith.constant 0 : i32;
            v72 = arith.eq v70, v71 : i1;
            v73 = arith.zext v72 : u32;
            v74 = hir.bitcast v73 : i32;
            v76 = arith.neq v74, v924 : i1;
            scf.if v76{
            ^block24:
                scf.yield ;
            } else {
            ^block25:
                v922 = arith.constant 0 : i32;
                v923 = arith.constant 0 : i32;
                v78 = arith.eq v62, v923 : i1;
                v79 = arith.zext v78 : u32;
                v80 = hir.bitcast v79 : i32;
                v82 = arith.neq v80, v922 : i1;
                scf.if v82{
                ^block122:
                    scf.yield ;
                } else {
                ^block26:
                    v916 = arith.constant 0 : u8;
                    v85 = hir.bitcast v62 : u32;
                    v86 = hir.bitcast v70 : u32;
                    v87 = hir.int_to_ptr v86 : ptr<byte, u8>;
                    hir.mem_set v87, v85, v916;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v70;
        };

        public builtin.function @miden:base/transaction-script@1.0.0#run(v89: felt, v90: felt, v91: felt, v92: felt) {
        ^block27(v89: felt, v90: felt, v91: felt, v92: felt):
            v97 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v98 = hir.bitcast v97 : ptr<byte, i32>;
            v99 = hir.load v98 : i32;
            v100 = arith.constant 80 : i32;
            v101 = arith.sub v99, v100 : i32 #[overflow = wrapping];
            v102 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v103 = hir.bitcast v102 : ptr<byte, i32>;
            hir.store v103, v101;
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/wit_bindgen_rt::run_ctors_once()
            v104 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/intrinsics::advice::adv_push_mapvaln(v92, v91, v90, v89) : felt
            v105 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/intrinsics::felt::as_u64(v104) : i64
            v107 = arith.constant 3 : i32;
            v106 = arith.trunc v105 : i32;
            v108 = arith.band v106, v107 : i32;
            v109 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/intrinsics::felt::from_u32(v108) : felt
            v93 = arith.constant 0 : i32;
            v111 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/intrinsics::felt::from_u32(v93) : felt
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/intrinsics::felt::assert_eq(v109, v111)
            v114 = arith.constant 2 : i64;
            v116 = hir.cast v114 : u32;
            v115 = hir.bitcast v105 : u64;
            v117 = arith.shr v115, v116 : u64;
            v118 = hir.bitcast v117 : i64;
            v119 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/intrinsics::felt::from_u64_unchecked(v118) : felt
            v120 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/intrinsics::felt::as_u64(v119) : i64
            v926 = arith.constant 2 : u32;
            v121 = arith.trunc v120 : i32;
            v124 = arith.shl v121, v926 : i32;
            v126 = arith.constant 4 : i32;
            v1002 = arith.constant 0 : i32;
            v112 = arith.constant 64 : i32;
            v113 = arith.add v101, v112 : i32 #[overflow = wrapping];
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/alloc::raw_vec::RawVecInner<A>::try_allocate_in(v113, v124, v1002, v126, v126)
            v129 = arith.constant 68 : u32;
            v128 = hir.bitcast v101 : u32;
            v130 = arith.add v128, v129 : u32 #[overflow = checked];
            v131 = arith.constant 4 : u32;
            v132 = arith.mod v130, v131 : u32;
            hir.assertz v132 #[code = 250];
            v133 = hir.int_to_ptr v130 : ptr<byte, i32>;
            v134 = hir.load v133 : i32;
            v136 = arith.constant 64 : u32;
            v135 = hir.bitcast v101 : u32;
            v137 = arith.add v135, v136 : u32 #[overflow = checked];
            v1001 = arith.constant 4 : u32;
            v139 = arith.mod v137, v1001 : u32;
            hir.assertz v139 #[code = 250];
            v140 = hir.int_to_ptr v137 : ptr<byte, i32>;
            v141 = hir.load v140 : i32;
            v1000 = arith.constant 0 : i32;
            v142 = arith.constant 1 : i32;
            v143 = arith.eq v141, v142 : i1;
            v144 = arith.zext v143 : u32;
            v145 = hir.bitcast v144 : i32;
            v147 = arith.neq v145, v1000 : i1;
            v931 = scf.if v147 : u32 {
            ^block30:
                v368 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
                v369 = hir.bitcast v368 : ptr<byte, i32>;
                v370 = hir.load v369 : i32;
                v372 = arith.constant 72 : u32;
                v371 = hir.bitcast v101 : u32;
                v373 = arith.add v371, v372 : u32 #[overflow = checked];
                v999 = arith.constant 4 : u32;
                v375 = arith.mod v373, v999 : u32;
                hir.assertz v375 #[code = 250];
                v376 = hir.int_to_ptr v373 : ptr<byte, i32>;
                v377 = hir.load v376 : i32;
                v378 = arith.constant 1048640 : i32;
                v379 = arith.add v370, v378 : i32 #[overflow = wrapping];
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/alloc::raw_vec::handle_error(v134, v377, v379)
                v927 = arith.constant 0 : u32;
                scf.yield v927;
            } else {
            ^block31:
                v998 = arith.constant 72 : u32;
                v148 = hir.bitcast v101 : u32;
                v150 = arith.add v148, v998 : u32 #[overflow = checked];
                v997 = arith.constant 4 : u32;
                v152 = arith.mod v150, v997 : u32;
                hir.assertz v152 #[code = 250];
                v153 = hir.int_to_ptr v150 : ptr<byte, i32>;
                v154 = hir.load v153 : i32;
                v996 = arith.constant 2 : u32;
                v156 = hir.bitcast v154 : u32;
                v158 = arith.shr v156, v996 : u32;
                v159 = hir.bitcast v158 : i32;
                v160 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/std::mem::pipe_preimage_to_memory(v119, v159, v92, v91, v90, v89) : i32
                v162 = arith.constant 28 : u32;
                v161 = hir.bitcast v101 : u32;
                v163 = arith.add v161, v162 : u32 #[overflow = checked];
                v995 = arith.constant 4 : u32;
                v165 = arith.mod v163, v995 : u32;
                hir.assertz v165 #[code = 250];
                v166 = hir.int_to_ptr v163 : ptr<byte, i32>;
                hir.store v166, v124;
                v168 = arith.constant 24 : u32;
                v167 = hir.bitcast v101 : u32;
                v169 = arith.add v167, v168 : u32 #[overflow = checked];
                v994 = arith.constant 4 : u32;
                v171 = arith.mod v169, v994 : u32;
                hir.assertz v171 #[code = 250];
                v172 = hir.int_to_ptr v169 : ptr<byte, i32>;
                hir.store v172, v154;
                v174 = arith.constant 20 : u32;
                v173 = hir.bitcast v101 : u32;
                v175 = arith.add v173, v174 : u32 #[overflow = checked];
                v993 = arith.constant 4 : u32;
                v177 = arith.mod v175, v993 : u32;
                hir.assertz v177 #[code = 250];
                v178 = hir.int_to_ptr v175 : ptr<byte, i32>;
                hir.store v178, v134;
                v991 = arith.constant 0 : i32;
                v992 = arith.constant 0 : i32;
                v180 = arith.eq v124, v992 : i1;
                v181 = arith.zext v180 : u32;
                v182 = hir.bitcast v181 : i32;
                v184 = arith.neq v182, v991 : i1;
                v933 = scf.if v184 : u32 {
                ^block127:
                    v990 = arith.constant 0 : u32;
                    scf.yield v990;
                } else {
                ^block32:
                    v185 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
                    v186 = hir.bitcast v185 : ptr<byte, i32>;
                    v187 = hir.load v186 : i32;
                    v189 = arith.constant 12 : u32;
                    v188 = hir.bitcast v154 : u32;
                    v190 = arith.add v188, v189 : u32 #[overflow = checked];
                    v989 = arith.constant 4 : u32;
                    v192 = arith.mod v190, v989 : u32;
                    hir.assertz v192 #[code = 250];
                    v193 = hir.int_to_ptr v190 : ptr<byte, felt>;
                    v194 = hir.load v193 : felt;
                    v196 = arith.constant 8 : u32;
                    v195 = hir.bitcast v154 : u32;
                    v197 = arith.add v195, v196 : u32 #[overflow = checked];
                    v988 = arith.constant 4 : u32;
                    v199 = arith.mod v197, v988 : u32;
                    hir.assertz v199 #[code = 250];
                    v200 = hir.int_to_ptr v197 : ptr<byte, felt>;
                    v201 = hir.load v200 : felt;
                    v987 = arith.constant 4 : u32;
                    v202 = hir.bitcast v154 : u32;
                    v204 = arith.add v202, v987 : u32 #[overflow = checked];
                    v986 = arith.constant 4 : u32;
                    v206 = arith.mod v204, v986 : u32;
                    hir.assertz v206 #[code = 250];
                    v207 = hir.int_to_ptr v204 : ptr<byte, felt>;
                    v208 = hir.load v207 : felt;
                    v209 = hir.bitcast v154 : u32;
                    v985 = arith.constant 4 : u32;
                    v211 = arith.mod v209, v985 : u32;
                    hir.assertz v211 #[code = 250];
                    v212 = hir.int_to_ptr v209 : ptr<byte, felt>;
                    v213 = hir.load v212 : felt;
                    v220 = arith.constant 1048656 : i32;
                    v221 = arith.add v187, v220 : i32 #[overflow = wrapping];
                    v983 = arith.constant 8 : i32;
                    v984 = arith.constant 4 : i32;
                    v216 = arith.constant 20 : i32;
                    v217 = arith.add v101, v216 : i32 #[overflow = wrapping];
                    v214 = arith.constant 8 : i32;
                    v215 = arith.add v101, v214 : i32 #[overflow = wrapping];
                    hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index(v215, v217, v984, v983, v221)
                    v982 = arith.constant 12 : u32;
                    v222 = hir.bitcast v101 : u32;
                    v224 = arith.add v222, v982 : u32 #[overflow = checked];
                    v981 = arith.constant 4 : u32;
                    v226 = arith.mod v224, v981 : u32;
                    hir.assertz v226 #[code = 250];
                    v227 = hir.int_to_ptr v224 : ptr<byte, i32>;
                    v228 = hir.load v227 : i32;
                    v979 = arith.constant 0 : i32;
                    v980 = arith.constant 4 : i32;
                    v230 = arith.neq v228, v980 : i1;
                    v231 = arith.zext v230 : u32;
                    v232 = hir.bitcast v231 : i32;
                    v234 = arith.neq v232, v979 : i1;
                    v935 = scf.if v234 : u32 {
                    ^block126:
                        v978 = arith.constant 0 : u32;
                        scf.yield v978;
                    } else {
                    ^block33:
                        v977 = arith.constant 8 : u32;
                        v235 = hir.bitcast v101 : u32;
                        v237 = arith.add v235, v977 : u32 #[overflow = checked];
                        v976 = arith.constant 4 : u32;
                        v239 = arith.mod v237, v976 : u32;
                        hir.assertz v239 #[code = 250];
                        v240 = hir.int_to_ptr v237 : ptr<byte, i32>;
                        v241 = hir.load v240 : i32;
                        v242 = hir.bitcast v241 : u32;
                        v975 = arith.constant 4 : u32;
                        v244 = arith.mod v242, v975 : u32;
                        hir.assertz v244 #[code = 250];
                        v245 = hir.int_to_ptr v242 : ptr<byte, i64>;
                        v246 = hir.load v245 : i64;
                        v974 = arith.constant 8 : i32;
                        v252 = arith.add v241, v974 : i32 #[overflow = wrapping];
                        v253 = hir.bitcast v252 : u32;
                        v973 = arith.constant 4 : u32;
                        v255 = arith.mod v253, v973 : u32;
                        hir.assertz v255 #[code = 250];
                        v256 = hir.int_to_ptr v253 : ptr<byte, i64>;
                        v257 = hir.load v256 : i64;
                        v972 = arith.constant 8 : i32;
                        v247 = arith.constant 32 : i32;
                        v248 = arith.add v101, v247 : i32 #[overflow = wrapping];
                        v250 = arith.add v248, v972 : i32 #[overflow = wrapping];
                        v258 = hir.bitcast v250 : u32;
                        v971 = arith.constant 8 : u32;
                        v260 = arith.mod v258, v971 : u32;
                        hir.assertz v260 #[code = 250];
                        v261 = hir.int_to_ptr v258 : ptr<byte, i64>;
                        hir.store v261, v257;
                        v263 = arith.constant 32 : u32;
                        v262 = hir.bitcast v101 : u32;
                        v264 = arith.add v262, v263 : u32 #[overflow = checked];
                        v970 = arith.constant 8 : u32;
                        v266 = arith.mod v264, v970 : u32;
                        hir.assertz v266 #[code = 250];
                        v267 = hir.int_to_ptr v264 : ptr<byte, i64>;
                        hir.store v267, v246;
                        v268 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
                        v269 = hir.bitcast v268 : ptr<byte, i32>;
                        v270 = hir.load v269 : i32;
                        v968 = arith.constant 32 : i32;
                        v274 = arith.add v101, v968 : i32 #[overflow = wrapping];
                        v969 = arith.constant 64 : i32;
                        v272 = arith.add v101, v969 : i32 #[overflow = wrapping];
                        hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<miden_base_sys::bindings::types::Asset as core::convert::From<[miden_stdlib_sys::intrinsics::felt::Felt; 4]>>::from(v272, v274)
                        v967 = arith.constant 64 : i32;
                        v276 = arith.add v101, v967 : i32 #[overflow = wrapping];
                        v277 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/miden_base_sys::bindings::tx::create_note(v213, v208, v201, v194, v276) : felt
                        v282 = arith.constant 1048672 : i32;
                        v283 = arith.add v270, v282 : i32 #[overflow = wrapping];
                        v281 = arith.constant 12 : i32;
                        v965 = arith.constant 8 : i32;
                        v966 = arith.constant 20 : i32;
                        v279 = arith.add v101, v966 : i32 #[overflow = wrapping];
                        hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index(v101, v279, v965, v281, v283)
                        v964 = arith.constant 4 : u32;
                        v284 = hir.bitcast v101 : u32;
                        v286 = arith.add v284, v964 : u32 #[overflow = checked];
                        v963 = arith.constant 4 : u32;
                        v288 = arith.mod v286, v963 : u32;
                        hir.assertz v288 #[code = 250];
                        v289 = hir.int_to_ptr v286 : ptr<byte, i32>;
                        v290 = hir.load v289 : i32;
                        v961 = arith.constant 0 : i32;
                        v962 = arith.constant 4 : i32;
                        v292 = arith.neq v290, v962 : i1;
                        v293 = arith.zext v292 : u32;
                        v294 = hir.bitcast v293 : i32;
                        v296 = arith.neq v294, v961 : i1;
                        scf.if v296{
                        ^block125:
                            scf.yield ;
                        } else {
                        ^block34:
                            v297 = hir.bitcast v101 : u32;
                            v960 = arith.constant 4 : u32;
                            v299 = arith.mod v297, v960 : u32;
                            hir.assertz v299 #[code = 250];
                            v300 = hir.int_to_ptr v297 : ptr<byte, i32>;
                            v301 = hir.load v300 : i32;
                            v302 = hir.bitcast v301 : u32;
                            v959 = arith.constant 4 : u32;
                            v304 = arith.mod v302, v959 : u32;
                            hir.assertz v304 #[code = 250];
                            v305 = hir.int_to_ptr v302 : ptr<byte, i64>;
                            v306 = hir.load v305 : i64;
                            v958 = arith.constant 8 : i32;
                            v312 = arith.add v301, v958 : i32 #[overflow = wrapping];
                            v313 = hir.bitcast v312 : u32;
                            v957 = arith.constant 4 : u32;
                            v315 = arith.mod v313, v957 : u32;
                            hir.assertz v315 #[code = 250];
                            v316 = hir.int_to_ptr v313 : ptr<byte, i64>;
                            v317 = hir.load v316 : i64;
                            v956 = arith.constant 8 : i32;
                            v307 = arith.constant 48 : i32;
                            v308 = arith.add v101, v307 : i32 #[overflow = wrapping];
                            v310 = arith.add v308, v956 : i32 #[overflow = wrapping];
                            v318 = hir.bitcast v310 : u32;
                            v955 = arith.constant 8 : u32;
                            v320 = arith.mod v318, v955 : u32;
                            hir.assertz v320 #[code = 250];
                            v321 = hir.int_to_ptr v318 : ptr<byte, i64>;
                            hir.store v321, v317;
                            v323 = arith.constant 48 : u32;
                            v322 = hir.bitcast v101 : u32;
                            v324 = arith.add v322, v323 : u32 #[overflow = checked];
                            v954 = arith.constant 8 : u32;
                            v326 = arith.mod v324, v954 : u32;
                            hir.assertz v326 #[code = 250];
                            v327 = hir.int_to_ptr v324 : ptr<byte, i64>;
                            hir.store v327, v306;
                            v952 = arith.constant 48 : i32;
                            v331 = arith.add v101, v952 : i32 #[overflow = wrapping];
                            v953 = arith.constant 64 : i32;
                            v329 = arith.add v101, v953 : i32 #[overflow = wrapping];
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<miden_base_sys::bindings::types::Asset as core::convert::From<[miden_stdlib_sys::intrinsics::felt::Felt; 4]>>::from(v329, v331)
                            v951 = arith.constant 64 : u32;
                            v332 = hir.bitcast v101 : u32;
                            v334 = arith.add v332, v951 : u32 #[overflow = checked];
                            v950 = arith.constant 4 : u32;
                            v336 = arith.mod v334, v950 : u32;
                            hir.assertz v336 #[code = 250];
                            v337 = hir.int_to_ptr v334 : ptr<byte, felt>;
                            v338 = hir.load v337 : felt;
                            v949 = arith.constant 68 : u32;
                            v339 = hir.bitcast v101 : u32;
                            v341 = arith.add v339, v949 : u32 #[overflow = checked];
                            v948 = arith.constant 4 : u32;
                            v343 = arith.mod v341, v948 : u32;
                            hir.assertz v343 #[code = 250];
                            v344 = hir.int_to_ptr v341 : ptr<byte, felt>;
                            v345 = hir.load v344 : felt;
                            v947 = arith.constant 72 : u32;
                            v346 = hir.bitcast v101 : u32;
                            v348 = arith.add v346, v947 : u32 #[overflow = checked];
                            v946 = arith.constant 4 : u32;
                            v350 = arith.mod v348, v946 : u32;
                            hir.assertz v350 #[code = 250];
                            v351 = hir.int_to_ptr v348 : ptr<byte, felt>;
                            v352 = hir.load v351 : felt;
                            v354 = arith.constant 76 : u32;
                            v353 = hir.bitcast v101 : u32;
                            v355 = arith.add v353, v354 : u32 #[overflow = checked];
                            v945 = arith.constant 4 : u32;
                            v357 = arith.mod v355, v945 : u32;
                            hir.assertz v357 #[code = 250];
                            v358 = hir.int_to_ptr v355 : ptr<byte, felt>;
                            v359 = hir.load v358 : felt;
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/basic_wallet_tx_script::bindings::miden::basic_wallet::basic_wallet::move_asset_to_note::wit_import9(v338, v345, v352, v359, v277)
                            v943 = arith.constant 4 : i32;
                            v944 = arith.constant 20 : i32;
                            v361 = arith.add v101, v944 : i32 #[overflow = wrapping];
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/alloc::raw_vec::RawVecInner<A>::deallocate(v361, v943, v943)
                            v942 = arith.constant 80 : i32;
                            v365 = arith.add v101, v942 : i32 #[overflow = wrapping];
                            v366 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
                            v367 = hir.bitcast v366 : ptr<byte, i32>;
                            hir.store v367, v365;
                            scf.yield ;
                        };
                        v929 = arith.constant 1 : u32;
                        v941 = arith.constant 0 : u32;
                        v939 = cf.select v296, v941, v929 : u32;
                        scf.yield v939;
                    };
                    scf.yield v935;
                };
                scf.yield v933;
            };
            v940 = arith.constant 0 : u32;
            v938 = arith.eq v931, v940 : i1;
            cf.cond_br v938 ^block29, ^block129;
        ^block29:
            ub.unreachable ;
        ^block129:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block35:
            builtin.ret ;
        };

        private builtin.function @wit_bindgen_rt::run_ctors_once() {
        ^block37:
            v381 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
            v382 = hir.bitcast v381 : ptr<byte, i32>;
            v383 = hir.load v382 : i32;
            v384 = arith.constant 1048692 : i32;
            v385 = arith.add v383, v384 : i32 #[overflow = wrapping];
            v386 = hir.bitcast v385 : u32;
            v387 = hir.int_to_ptr v386 : ptr<byte, u8>;
            v388 = hir.load v387 : u8;
            v380 = arith.constant 0 : i32;
            v389 = arith.zext v388 : u32;
            v390 = hir.bitcast v389 : i32;
            v392 = arith.neq v390, v380 : i1;
            scf.if v392{
            ^block39:
                scf.yield ;
            } else {
            ^block40:
                v393 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
                v394 = hir.bitcast v393 : ptr<byte, i32>;
                v395 = hir.load v394 : i32;
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__wasm_call_ctors()
                v1004 = arith.constant 1 : u8;
                v1006 = arith.constant 1048692 : i32;
                v397 = arith.add v395, v1006 : i32 #[overflow = wrapping];
                v401 = hir.bitcast v397 : u32;
                v402 = hir.int_to_ptr v401 : ptr<byte, u8>;
                hir.store v402, v1004;
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v403: i32, v404: i32, v405: i32) -> i32 {
        ^block41(v403: i32, v404: i32, v405: i32):
            v408 = arith.constant 16 : i32;
            v407 = arith.constant 0 : i32;
            v1008 = arith.constant 16 : u32;
            v410 = hir.bitcast v404 : u32;
            v412 = arith.gt v410, v1008 : i1;
            v413 = arith.zext v412 : u32;
            v414 = hir.bitcast v413 : i32;
            v416 = arith.neq v414, v407 : i1;
            v417 = cf.select v416, v404, v408 : i32;
            v1048 = arith.constant 0 : i32;
            v418 = arith.constant -1 : i32;
            v419 = arith.add v417, v418 : i32 #[overflow = wrapping];
            v420 = arith.band v417, v419 : i32;
            v422 = arith.neq v420, v1048 : i1;
            v1017, v1018 = scf.if v422 : i32, u32 {
            ^block137:
                v1009 = arith.constant 0 : u32;
                v1013 = ub.poison i32 : i32;
                scf.yield v1013, v1009;
            } else {
            ^block44:
                v424 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/core::ptr::alignment::Alignment::max(v404, v417) : i32
                v1047 = arith.constant 0 : i32;
                v423 = arith.constant -2147483648 : i32;
                v425 = arith.sub v423, v424 : i32 #[overflow = wrapping];
                v427 = hir.bitcast v425 : u32;
                v426 = hir.bitcast v405 : u32;
                v428 = arith.gt v426, v427 : i1;
                v429 = arith.zext v428 : u32;
                v430 = hir.bitcast v429 : i32;
                v432 = arith.neq v430, v1047 : i1;
                v1032 = scf.if v432 : i32 {
                ^block136:
                    v1046 = ub.poison i32 : i32;
                    scf.yield v1046;
                } else {
                ^block45:
                    v1044 = arith.constant 0 : i32;
                    v438 = arith.sub v1044, v424 : i32 #[overflow = wrapping];
                    v1045 = arith.constant -1 : i32;
                    v434 = arith.add v405, v424 : i32 #[overflow = wrapping];
                    v436 = arith.add v434, v1045 : i32 #[overflow = wrapping];
                    v439 = arith.band v436, v438 : i32;
                    v440 = hir.bitcast v403 : u32;
                    v441 = arith.constant 4 : u32;
                    v442 = arith.mod v440, v441 : u32;
                    hir.assertz v442 #[code = 250];
                    v443 = hir.int_to_ptr v440 : ptr<byte, i32>;
                    v444 = hir.load v443 : i32;
                    v1043 = arith.constant 0 : i32;
                    v446 = arith.neq v444, v1043 : i1;
                    scf.if v446{
                    ^block135:
                        scf.yield ;
                    } else {
                    ^block47:
                        v447 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/intrinsics::mem::heap_base() : i32
                        v448 = hir.mem_size  : u32;
                        v454 = hir.bitcast v403 : u32;
                        v1042 = arith.constant 4 : u32;
                        v456 = arith.mod v454, v1042 : u32;
                        hir.assertz v456 #[code = 250];
                        v1041 = arith.constant 16 : u32;
                        v449 = hir.bitcast v448 : i32;
                        v452 = arith.shl v449, v1041 : i32;
                        v453 = arith.add v447, v452 : i32 #[overflow = wrapping];
                        v457 = hir.int_to_ptr v454 : ptr<byte, i32>;
                        hir.store v457, v453;
                        scf.yield ;
                    };
                    v460 = hir.bitcast v403 : u32;
                    v1040 = arith.constant 4 : u32;
                    v462 = arith.mod v460, v1040 : u32;
                    hir.assertz v462 #[code = 250];
                    v463 = hir.int_to_ptr v460 : ptr<byte, i32>;
                    v464 = hir.load v463 : i32;
                    v1038 = arith.constant 0 : i32;
                    v1039 = arith.constant -1 : i32;
                    v466 = arith.bxor v464, v1039 : i32;
                    v468 = hir.bitcast v466 : u32;
                    v467 = hir.bitcast v439 : u32;
                    v469 = arith.gt v467, v468 : i1;
                    v470 = arith.zext v469 : u32;
                    v471 = hir.bitcast v470 : i32;
                    v473 = arith.neq v471, v1038 : i1;
                    v1031 = scf.if v473 : i32 {
                    ^block48:
                        v1037 = arith.constant 0 : i32;
                        scf.yield v1037;
                    } else {
                    ^block49:
                        v475 = hir.bitcast v403 : u32;
                        v1036 = arith.constant 4 : u32;
                        v477 = arith.mod v475, v1036 : u32;
                        hir.assertz v477 #[code = 250];
                        v474 = arith.add v464, v439 : i32 #[overflow = wrapping];
                        v478 = hir.int_to_ptr v475 : ptr<byte, i32>;
                        hir.store v478, v474;
                        v480 = arith.add v464, v424 : i32 #[overflow = wrapping];
                        scf.yield v480;
                    };
                    scf.yield v1031;
                };
                v1014 = arith.constant 1 : u32;
                v1035 = arith.constant 0 : u32;
                v1033 = cf.select v432, v1035, v1014 : u32;
                scf.yield v1032, v1033;
            };
            v1034 = arith.constant 0 : u32;
            v1030 = arith.eq v1018, v1034 : i1;
            cf.cond_br v1030 ^block43, ^block139(v1017);
        ^block43:
            ub.unreachable ;
        ^block139(v1010: i32):
            builtin.ret v1010;
        };

        private builtin.function @intrinsics::mem::heap_base() -> i32 {
        ^block50:
            v483 = hir.exec @intrinsics/mem/heap_base() : i32
            builtin.ret v483;
        };

        private builtin.function @miden_base_sys::bindings::tx::create_note(v485: felt, v486: felt, v487: felt, v488: felt, v489: i32) -> felt {
        ^block54(v485: felt, v486: felt, v487: felt, v488: felt, v489: i32):
            v492 = arith.constant 12 : u32;
            v491 = hir.bitcast v489 : u32;
            v493 = arith.add v491, v492 : u32 #[overflow = checked];
            v494 = arith.constant 4 : u32;
            v495 = arith.mod v493, v494 : u32;
            hir.assertz v495 #[code = 250];
            v496 = hir.int_to_ptr v493 : ptr<byte, felt>;
            v497 = hir.load v496 : felt;
            v499 = arith.constant 8 : u32;
            v498 = hir.bitcast v489 : u32;
            v500 = arith.add v498, v499 : u32 #[overflow = checked];
            v1052 = arith.constant 4 : u32;
            v502 = arith.mod v500, v1052 : u32;
            hir.assertz v502 #[code = 250];
            v503 = hir.int_to_ptr v500 : ptr<byte, felt>;
            v504 = hir.load v503 : felt;
            v1051 = arith.constant 4 : u32;
            v505 = hir.bitcast v489 : u32;
            v507 = arith.add v505, v1051 : u32 #[overflow = checked];
            v1050 = arith.constant 4 : u32;
            v509 = arith.mod v507, v1050 : u32;
            hir.assertz v509 #[code = 250];
            v510 = hir.int_to_ptr v507 : ptr<byte, felt>;
            v511 = hir.load v510 : felt;
            v512 = hir.bitcast v489 : u32;
            v1049 = arith.constant 4 : u32;
            v514 = arith.mod v512, v1049 : u32;
            hir.assertz v514 #[code = 250];
            v515 = hir.int_to_ptr v512 : ptr<byte, felt>;
            v516 = hir.load v515 : felt;
            v517 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/miden::tx::create_note(v485, v486, v487, v488, v497, v504, v511, v516) : felt
            builtin.ret v517;
        };

        private builtin.function @<miden_base_sys::bindings::types::Asset as core::convert::From<[miden_stdlib_sys::intrinsics::felt::Felt; 4]>>::from(v518: i32, v519: i32) {
        ^block56(v518: i32, v519: i32):
            v521 = arith.constant 8 : u32;
            v520 = hir.bitcast v519 : u32;
            v522 = arith.add v520, v521 : u32 #[overflow = checked];
            v523 = arith.constant 4 : u32;
            v524 = arith.mod v522, v523 : u32;
            hir.assertz v524 #[code = 250];
            v525 = hir.int_to_ptr v522 : ptr<byte, i64>;
            v526 = hir.load v525 : i64;
            v1056 = arith.constant 8 : u32;
            v527 = hir.bitcast v518 : u32;
            v529 = arith.add v527, v1056 : u32 #[overflow = checked];
            v1055 = arith.constant 8 : u32;
            v531 = arith.mod v529, v1055 : u32;
            hir.assertz v531 #[code = 250];
            v532 = hir.int_to_ptr v529 : ptr<byte, i64>;
            hir.store v532, v526;
            v533 = hir.bitcast v519 : u32;
            v1054 = arith.constant 4 : u32;
            v535 = arith.mod v533, v1054 : u32;
            hir.assertz v535 #[code = 250];
            v536 = hir.int_to_ptr v533 : ptr<byte, i64>;
            v537 = hir.load v536 : i64;
            v538 = hir.bitcast v518 : u32;
            v1053 = arith.constant 8 : u32;
            v540 = arith.mod v538, v1053 : u32;
            hir.assertz v540 #[code = 250];
            v541 = hir.int_to_ptr v538 : ptr<byte, i64>;
            hir.store v541, v537;
            builtin.ret ;
        };

        private builtin.function @miden::tx::create_note(v542: felt, v543: felt, v544: felt, v545: felt, v546: felt, v547: felt, v548: felt, v549: felt) -> felt {
        ^block58(v542: felt, v543: felt, v544: felt, v545: felt, v546: felt, v547: felt, v548: felt, v549: felt):
            v550 = hir.exec @miden/tx/create_note(v542, v543, v544, v545, v546, v547, v548, v549) : felt
            builtin.ret v550;
        };

        private builtin.function @intrinsics::felt::from_u64_unchecked(v552: i64) -> felt {
        ^block62(v552: i64):
            v553 = hir.cast v552 : felt;
            builtin.ret v553;
        };

        private builtin.function @intrinsics::felt::from_u32(v555: i32) -> felt {
        ^block64(v555: i32):
            v556 = hir.bitcast v555 : felt;
            builtin.ret v556;
        };

        private builtin.function @intrinsics::felt::as_u64(v558: felt) -> i64 {
        ^block66(v558: felt):
            v559 = hir.cast v558 : i64;
            builtin.ret v559;
        };

        private builtin.function @intrinsics::felt::assert_eq(v561: felt, v562: felt) {
        ^block68(v561: felt, v562: felt):
            hir.assert_eq v561, v562;
            builtin.ret ;
        };

        private builtin.function @intrinsics::advice::adv_push_mapvaln(v563: felt, v564: felt, v565: felt, v566: felt) -> felt {
        ^block70(v563: felt, v564: felt, v565: felt, v566: felt):
            v567 = hir.exec @intrinsics/advice/adv_push_mapvaln(v563, v564, v565, v566) : felt
            builtin.ret v567;
        };

        private builtin.function @std::mem::pipe_preimage_to_memory(v569: felt, v570: i32, v571: felt, v572: felt, v573: felt, v574: felt) -> i32 {
        ^block73(v569: felt, v570: i32, v571: felt, v572: felt, v573: felt, v574: felt):
            v575 = hir.exec @std/mem/pipe_preimage_to_memory(v569, v570, v571, v572, v573, v574) : i32
            builtin.ret v575;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v577: i32, v578: i32, v579: i32) {
        ^block77(v577: i32, v578: i32, v579: i32):
            v581 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v582 = hir.bitcast v581 : ptr<byte, i32>;
            v583 = hir.load v582 : i32;
            v584 = arith.constant 16 : i32;
            v585 = arith.sub v583, v584 : i32 #[overflow = wrapping];
            v586 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v587 = hir.bitcast v586 : ptr<byte, i32>;
            hir.store v587, v585;
            v588 = arith.constant 4 : i32;
            v589 = arith.add v585, v588 : i32 #[overflow = wrapping];
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/alloc::raw_vec::RawVecInner<A>::current_memory(v589, v577, v578, v579)
            v591 = arith.constant 8 : u32;
            v590 = hir.bitcast v585 : u32;
            v592 = arith.add v590, v591 : u32 #[overflow = checked];
            v593 = arith.constant 4 : u32;
            v594 = arith.mod v592, v593 : u32;
            hir.assertz v594 #[code = 250];
            v595 = hir.int_to_ptr v592 : ptr<byte, i32>;
            v596 = hir.load v595 : i32;
            v1063 = arith.constant 0 : i32;
            v580 = arith.constant 0 : i32;
            v598 = arith.eq v596, v580 : i1;
            v599 = arith.zext v598 : u32;
            v600 = hir.bitcast v599 : i32;
            v602 = arith.neq v600, v1063 : i1;
            scf.if v602{
            ^block143:
                scf.yield ;
            } else {
            ^block80:
                v1062 = arith.constant 4 : u32;
                v603 = hir.bitcast v585 : u32;
                v605 = arith.add v603, v1062 : u32 #[overflow = checked];
                v1061 = arith.constant 4 : u32;
                v607 = arith.mod v605, v1061 : u32;
                hir.assertz v607 #[code = 250];
                v608 = hir.int_to_ptr v605 : ptr<byte, i32>;
                v609 = hir.load v608 : i32;
                v611 = arith.constant 12 : u32;
                v610 = hir.bitcast v585 : u32;
                v612 = arith.add v610, v611 : u32 #[overflow = checked];
                v1060 = arith.constant 4 : u32;
                v614 = arith.mod v612, v1060 : u32;
                hir.assertz v614 #[code = 250];
                v615 = hir.int_to_ptr v612 : ptr<byte, i32>;
                v616 = hir.load v615 : i32;
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v609, v596, v616)
                scf.yield ;
            };
            v1059 = arith.constant 16 : i32;
            v619 = arith.add v585, v1059 : i32 #[overflow = wrapping];
            v620 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v621 = hir.bitcast v620 : ptr<byte, i32>;
            hir.store v621, v619;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::try_allocate_in(v622: i32, v623: i32, v624: i32, v625: i32, v626: i32) {
        ^block81(v622: i32, v623: i32, v624: i32, v625: i32, v626: i32):
            v629 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v630 = hir.bitcast v629 : ptr<byte, i32>;
            v631 = hir.load v630 : i32;
            v632 = arith.constant 16 : i32;
            v633 = arith.sub v631, v632 : i32 #[overflow = wrapping];
            v634 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v635 = hir.bitcast v634 : ptr<byte, i32>;
            hir.store v635, v633;
            v645 = hir.bitcast v623 : u32;
            v646 = arith.zext v645 : u64;
            v647 = hir.bitcast v646 : i64;
            v627 = arith.constant 0 : i32;
            v640 = arith.sub v627, v625 : i32 #[overflow = wrapping];
            v637 = arith.constant -1 : i32;
            v636 = arith.add v625, v626 : i32 #[overflow = wrapping];
            v638 = arith.add v636, v637 : i32 #[overflow = wrapping];
            v641 = arith.band v638, v640 : i32;
            v642 = hir.bitcast v641 : u32;
            v643 = arith.zext v642 : u64;
            v644 = hir.bitcast v643 : i64;
            v648 = arith.mul v644, v647 : i64 #[overflow = wrapping];
            v1167 = arith.constant 0 : i32;
            v649 = arith.constant 32 : i64;
            v651 = hir.cast v649 : u32;
            v650 = hir.bitcast v648 : u64;
            v652 = arith.shr v650, v651 : u64;
            v653 = hir.bitcast v652 : i64;
            v654 = arith.trunc v653 : i32;
            v656 = arith.neq v654, v1167 : i1;
            v1079, v1080, v1081, v1082, v1083, v1084 = scf.if v656 : i32, i32, i32, i32, i32, u32 {
            ^block145:
                v1064 = arith.constant 0 : u32;
                v1071 = ub.poison i32 : i32;
                scf.yield v622, v633, v1071, v1071, v1071, v1064;
            } else {
            ^block86:
                v657 = arith.trunc v648 : i32;
                v1166 = arith.constant 0 : i32;
                v658 = arith.constant -2147483648 : i32;
                v659 = arith.sub v658, v625 : i32 #[overflow = wrapping];
                v661 = hir.bitcast v659 : u32;
                v660 = hir.bitcast v657 : u32;
                v662 = arith.lte v660, v661 : i1;
                v663 = arith.zext v662 : u32;
                v664 = hir.bitcast v663 : i32;
                v666 = arith.neq v664, v1166 : i1;
                v1127 = scf.if v666 : i32 {
                ^block84:
                    v1165 = arith.constant 0 : i32;
                    v677 = arith.neq v657, v1165 : i1;
                    v1126 = scf.if v677 : i32 {
                    ^block88:
                        v1164 = arith.constant 0 : i32;
                        v693 = arith.neq v624, v1164 : i1;
                        v1125 = scf.if v693 : i32 {
                        ^block91:
                            v675 = arith.constant 1 : i32;
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/alloc::alloc::Global::alloc_impl(v633, v625, v657, v675)
                            v704 = hir.bitcast v633 : u32;
                            v749 = arith.constant 4 : u32;
                            v706 = arith.mod v704, v749 : u32;
                            hir.assertz v706 #[code = 250];
                            v707 = hir.int_to_ptr v704 : ptr<byte, i32>;
                            v708 = hir.load v707 : i32;
                            scf.yield v708;
                        } else {
                        ^block92:
                            v694 = arith.constant 8 : i32;
                            v695 = arith.add v633, v694 : i32 #[overflow = wrapping];
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v695, v625, v657)
                            v679 = arith.constant 8 : u32;
                            v696 = hir.bitcast v633 : u32;
                            v698 = arith.add v696, v679 : u32 #[overflow = checked];
                            v1163 = arith.constant 4 : u32;
                            v700 = arith.mod v698, v1163 : u32;
                            hir.assertz v700 #[code = 250];
                            v701 = hir.int_to_ptr v698 : ptr<byte, i32>;
                            v702 = hir.load v701 : i32;
                            scf.yield v702;
                        };
                        v1161 = arith.constant 0 : i32;
                        v1162 = arith.constant 0 : i32;
                        v711 = arith.eq v1125, v1162 : i1;
                        v712 = arith.zext v711 : u32;
                        v713 = hir.bitcast v712 : i32;
                        v715 = arith.neq v713, v1161 : i1;
                        scf.if v715{
                        ^block93:
                            v1160 = arith.constant 8 : u32;
                            v732 = hir.bitcast v622 : u32;
                            v734 = arith.add v732, v1160 : u32 #[overflow = checked];
                            v1159 = arith.constant 4 : u32;
                            v736 = arith.mod v734, v1159 : u32;
                            hir.assertz v736 #[code = 250];
                            v737 = hir.int_to_ptr v734 : ptr<byte, i32>;
                            hir.store v737, v657;
                            v1158 = arith.constant 4 : u32;
                            v739 = hir.bitcast v622 : u32;
                            v741 = arith.add v739, v1158 : u32 #[overflow = checked];
                            v1157 = arith.constant 4 : u32;
                            v743 = arith.mod v741, v1157 : u32;
                            hir.assertz v743 #[code = 250];
                            v744 = hir.int_to_ptr v741 : ptr<byte, i32>;
                            hir.store v744, v625;
                            scf.yield ;
                        } else {
                        ^block94:
                            v1156 = arith.constant 8 : u32;
                            v717 = hir.bitcast v622 : u32;
                            v719 = arith.add v717, v1156 : u32 #[overflow = checked];
                            v1155 = arith.constant 4 : u32;
                            v721 = arith.mod v719, v1155 : u32;
                            hir.assertz v721 #[code = 250];
                            v722 = hir.int_to_ptr v719 : ptr<byte, i32>;
                            hir.store v722, v1125;
                            v1154 = arith.constant 4 : u32;
                            v724 = hir.bitcast v622 : u32;
                            v726 = arith.add v724, v1154 : u32 #[overflow = checked];
                            v1153 = arith.constant 4 : u32;
                            v728 = arith.mod v726, v1153 : u32;
                            hir.assertz v728 #[code = 250];
                            v729 = hir.int_to_ptr v726 : ptr<byte, i32>;
                            hir.store v729, v623;
                            scf.yield ;
                        };
                        v1151 = arith.constant 0 : i32;
                        v1152 = arith.constant 1 : i32;
                        v1124 = cf.select v715, v1152, v1151 : i32;
                        scf.yield v1124;
                    } else {
                    ^block89:
                        v1150 = arith.constant 8 : u32;
                        v678 = hir.bitcast v622 : u32;
                        v680 = arith.add v678, v1150 : u32 #[overflow = checked];
                        v1149 = arith.constant 4 : u32;
                        v682 = arith.mod v680, v1149 : u32;
                        hir.assertz v682 #[code = 250];
                        v683 = hir.int_to_ptr v680 : ptr<byte, i32>;
                        hir.store v683, v625;
                        v1148 = arith.constant 4 : u32;
                        v686 = hir.bitcast v622 : u32;
                        v688 = arith.add v686, v1148 : u32 #[overflow = checked];
                        v1147 = arith.constant 4 : u32;
                        v690 = arith.mod v688, v1147 : u32;
                        hir.assertz v690 #[code = 250];
                        v1146 = arith.constant 0 : i32;
                        v691 = hir.int_to_ptr v688 : ptr<byte, i32>;
                        hir.store v691, v1146;
                        v1145 = arith.constant 0 : i32;
                        scf.yield v1145;
                    };
                    scf.yield v1126;
                } else {
                ^block87:
                    v1144 = ub.poison i32 : i32;
                    scf.yield v1144;
                };
                v1139 = arith.constant 0 : u32;
                v1072 = arith.constant 1 : u32;
                v1132 = cf.select v666, v1072, v1139 : u32;
                v1140 = ub.poison i32 : i32;
                v1131 = cf.select v666, v633, v1140 : i32;
                v1141 = ub.poison i32 : i32;
                v1130 = cf.select v666, v622, v1141 : i32;
                v1142 = ub.poison i32 : i32;
                v1129 = cf.select v666, v1142, v633 : i32;
                v1143 = ub.poison i32 : i32;
                v1128 = cf.select v666, v1143, v622 : i32;
                scf.yield v1128, v1129, v1130, v1127, v1131, v1132;
            };
            v1085, v1086, v1087 = scf.index_switch v1084 : i32, i32, i32 
            case 0 {
            ^block85:
                v1138 = arith.constant 4 : u32;
                v669 = hir.bitcast v1079 : u32;
                v671 = arith.add v669, v1138 : u32 #[overflow = checked];
                v1137 = arith.constant 4 : u32;
                v673 = arith.mod v671, v1137 : u32;
                hir.assertz v673 #[code = 250];
                v1136 = arith.constant 0 : i32;
                v674 = hir.int_to_ptr v671 : ptr<byte, i32>;
                hir.store v674, v1136;
                v1135 = arith.constant 1 : i32;
                scf.yield v1079, v1135, v1080;
            }
            default {
            ^block149:
                scf.yield v1081, v1082, v1083;
            };
            v748 = hir.bitcast v1085 : u32;
            v1134 = arith.constant 4 : u32;
            v750 = arith.mod v748, v1134 : u32;
            hir.assertz v750 #[code = 250];
            v751 = hir.int_to_ptr v748 : ptr<byte, i32>;
            hir.store v751, v1086;
            v1133 = arith.constant 16 : i32;
            v756 = arith.add v1087, v1133 : i32 #[overflow = wrapping];
            v757 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v758 = hir.bitcast v757 : ptr<byte, i32>;
            hir.store v758, v756;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v759: i32, v760: i32, v761: i32) {
        ^block95(v759: i32, v760: i32, v761: i32):
            v763 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v764 = hir.bitcast v763 : ptr<byte, i32>;
            v765 = hir.load v764 : i32;
            v766 = arith.constant 16 : i32;
            v767 = arith.sub v765, v766 : i32 #[overflow = wrapping];
            v768 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v769 = hir.bitcast v768 : ptr<byte, i32>;
            hir.store v769, v767;
            v762 = arith.constant 0 : i32;
            v770 = arith.constant 8 : i32;
            v771 = arith.add v767, v770 : i32 #[overflow = wrapping];
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/alloc::alloc::Global::alloc_impl(v771, v760, v761, v762)
            v774 = arith.constant 12 : u32;
            v773 = hir.bitcast v767 : u32;
            v775 = arith.add v773, v774 : u32 #[overflow = checked];
            v776 = arith.constant 4 : u32;
            v777 = arith.mod v775, v776 : u32;
            hir.assertz v777 #[code = 250];
            v778 = hir.int_to_ptr v775 : ptr<byte, i32>;
            v779 = hir.load v778 : i32;
            v781 = arith.constant 8 : u32;
            v780 = hir.bitcast v767 : u32;
            v782 = arith.add v780, v781 : u32 #[overflow = checked];
            v1172 = arith.constant 4 : u32;
            v784 = arith.mod v782, v1172 : u32;
            hir.assertz v784 #[code = 250];
            v785 = hir.int_to_ptr v782 : ptr<byte, i32>;
            v786 = hir.load v785 : i32;
            v787 = hir.bitcast v759 : u32;
            v1171 = arith.constant 4 : u32;
            v789 = arith.mod v787, v1171 : u32;
            hir.assertz v789 #[code = 250];
            v790 = hir.int_to_ptr v787 : ptr<byte, i32>;
            hir.store v790, v786;
            v1170 = arith.constant 4 : u32;
            v791 = hir.bitcast v759 : u32;
            v793 = arith.add v791, v1170 : u32 #[overflow = checked];
            v1169 = arith.constant 4 : u32;
            v795 = arith.mod v793, v1169 : u32;
            hir.assertz v795 #[code = 250];
            v796 = hir.int_to_ptr v793 : ptr<byte, i32>;
            hir.store v796, v779;
            v1168 = arith.constant 16 : i32;
            v798 = arith.add v767, v1168 : i32 #[overflow = wrapping];
            v799 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v800 = hir.bitcast v799 : ptr<byte, i32>;
            hir.store v800, v798;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v801: i32, v802: i32, v803: i32, v804: i32) {
        ^block97(v801: i32, v802: i32, v803: i32, v804: i32):
            v1188 = arith.constant 0 : i32;
            v805 = arith.constant 0 : i32;
            v806 = arith.eq v803, v805 : i1;
            v807 = arith.zext v806 : u32;
            v808 = hir.bitcast v807 : i32;
            v810 = arith.neq v808, v1188 : i1;
            v1184 = scf.if v810 : i32 {
            ^block152:
                scf.yield v802;
            } else {
            ^block100:
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__rustc::__rust_no_alloc_shim_is_unstable_v2()
                v1187 = arith.constant 0 : i32;
                v812 = arith.neq v804, v1187 : i1;
                v1183 = scf.if v812 : i32 {
                ^block101:
                    v814 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__rustc::__rust_alloc_zeroed(v803, v802) : i32
                    scf.yield v814;
                } else {
                ^block102:
                    v813 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__rustc::__rust_alloc(v803, v802) : i32
                    scf.yield v813;
                };
                scf.yield v1183;
            };
            v818 = arith.constant 4 : u32;
            v817 = hir.bitcast v801 : u32;
            v819 = arith.add v817, v818 : u32 #[overflow = checked];
            v1186 = arith.constant 4 : u32;
            v821 = arith.mod v819, v1186 : u32;
            hir.assertz v821 #[code = 250];
            v822 = hir.int_to_ptr v819 : ptr<byte, i32>;
            hir.store v822, v803;
            v824 = hir.bitcast v801 : u32;
            v1185 = arith.constant 4 : u32;
            v826 = arith.mod v824, v1185 : u32;
            hir.assertz v826 #[code = 250];
            v827 = hir.int_to_ptr v824 : ptr<byte, i32>;
            hir.store v827, v1184;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v828: i32, v829: i32, v830: i32, v831: i32) {
        ^block103(v828: i32, v829: i32, v830: i32, v831: i32):
            v1214 = arith.constant 0 : i32;
            v832 = arith.constant 0 : i32;
            v836 = arith.eq v831, v832 : i1;
            v837 = arith.zext v836 : u32;
            v838 = hir.bitcast v837 : i32;
            v840 = arith.neq v838, v1214 : i1;
            v1201, v1202 = scf.if v840 : i32, i32 {
            ^block156:
                v1213 = arith.constant 0 : i32;
                v834 = arith.constant 4 : i32;
                scf.yield v834, v1213;
            } else {
            ^block106:
                v841 = hir.bitcast v829 : u32;
                v876 = arith.constant 4 : u32;
                v843 = arith.mod v841, v876 : u32;
                hir.assertz v843 #[code = 250];
                v844 = hir.int_to_ptr v841 : ptr<byte, i32>;
                v845 = hir.load v844 : i32;
                v1211 = arith.constant 0 : i32;
                v1212 = arith.constant 0 : i32;
                v847 = arith.eq v845, v1212 : i1;
                v848 = arith.zext v847 : u32;
                v849 = hir.bitcast v848 : i32;
                v851 = arith.neq v849, v1211 : i1;
                v1199 = scf.if v851 : i32 {
                ^block155:
                    v1210 = arith.constant 0 : i32;
                    scf.yield v1210;
                } else {
                ^block107:
                    v1209 = arith.constant 4 : u32;
                    v852 = hir.bitcast v828 : u32;
                    v854 = arith.add v852, v1209 : u32 #[overflow = checked];
                    v1208 = arith.constant 4 : u32;
                    v856 = arith.mod v854, v1208 : u32;
                    hir.assertz v856 #[code = 250];
                    v857 = hir.int_to_ptr v854 : ptr<byte, i32>;
                    hir.store v857, v830;
                    v1207 = arith.constant 4 : u32;
                    v858 = hir.bitcast v829 : u32;
                    v860 = arith.add v858, v1207 : u32 #[overflow = checked];
                    v1206 = arith.constant 4 : u32;
                    v862 = arith.mod v860, v1206 : u32;
                    hir.assertz v862 #[code = 250];
                    v863 = hir.int_to_ptr v860 : ptr<byte, i32>;
                    v864 = hir.load v863 : i32;
                    v865 = hir.bitcast v828 : u32;
                    v1205 = arith.constant 4 : u32;
                    v867 = arith.mod v865, v1205 : u32;
                    hir.assertz v867 #[code = 250];
                    v868 = hir.int_to_ptr v865 : ptr<byte, i32>;
                    hir.store v868, v864;
                    v869 = arith.mul v845, v831 : i32 #[overflow = wrapping];
                    scf.yield v869;
                };
                v870 = arith.constant 8 : i32;
                v1204 = arith.constant 4 : i32;
                v1200 = cf.select v851, v1204, v870 : i32;
                scf.yield v1200, v1199;
            };
            v873 = arith.add v828, v1201 : i32 #[overflow = wrapping];
            v875 = hir.bitcast v873 : u32;
            v1203 = arith.constant 4 : u32;
            v877 = arith.mod v875, v1203 : u32;
            hir.assertz v877 #[code = 250];
            v878 = hir.int_to_ptr v875 : ptr<byte, i32>;
            hir.store v878, v1202;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v879: i32, v880: i32, v881: i32) {
        ^block108(v879: i32, v880: i32, v881: i32):
            v1216 = arith.constant 0 : i32;
            v882 = arith.constant 0 : i32;
            v883 = arith.eq v881, v882 : i1;
            v884 = arith.zext v883 : u32;
            v885 = hir.bitcast v884 : i32;
            v887 = arith.neq v885, v1216 : i1;
            scf.if v887{
            ^block110:
                scf.yield ;
            } else {
            ^block111:
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__rustc::__rust_dealloc(v879, v881, v880)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v888: i32, v889: i32, v890: i32) {
        ^block112(v888: i32, v889: i32, v890: i32):
            ub.unreachable ;
        };

        private builtin.function @core::slice::<impl [T]>::copy_from_slice::len_mismatch_fail::do_panic::runtime(v891: i32, v892: i32, v893: i32) {
        ^block114(v891: i32, v892: i32, v893: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v894: i32, v895: i32) -> i32 {
        ^block116(v894: i32, v895: i32):
            v902 = arith.constant 0 : i32;
            v898 = hir.bitcast v895 : u32;
            v897 = hir.bitcast v894 : u32;
            v899 = arith.gt v897, v898 : i1;
            v900 = arith.zext v899 : u32;
            v901 = hir.bitcast v900 : i32;
            v903 = arith.neq v901, v902 : i1;
            v904 = cf.select v903, v894, v895 : i32;
            builtin.ret v904;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.global_variable private @#GOT.data.internal.__memory_base : i32 {
            builtin.ret_imm 0;
        };

        builtin.segment readonly @1048576 = 0x0073722e62696c2f6372730073722e6d656d2f62696c6474732f6372732f302e352e302d7379732d62696c6474732d6e6564696d;

        builtin.segment @1048628 = 0x000000250000003d0000000a0010002900000029000000350000000a0010002900000021000000970000002800100000000000010000000100000001;
    };

    public builtin.function @run(v905: felt, v906: felt, v907: felt, v908: felt) {
    ^block118(v905: felt, v906: felt, v907: felt, v908: felt):
        hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/miden:base/transaction-script@1.0.0#run(v905, v906, v907, v908)
        builtin.ret ;
    };
};