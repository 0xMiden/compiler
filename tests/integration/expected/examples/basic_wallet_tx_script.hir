builtin.component miden:base/transaction-script@1.0.0 {
    builtin.module public @basic_wallet_tx_script {
        private builtin.function @miden_stdlib_sys::stdlib::mem::extern_pipe_preimage_to_memory(v0: felt, v1: i32, v2: felt, v3: felt, v4: felt, v5: felt) -> i32 {
        ^block5(v0: felt, v1: i32, v2: felt, v3: felt, v4: felt, v5: felt):
            v6 = hir.exec @std/mem/pipe_preimage_to_memory(v0, v1, v2, v3, v4, v5) : i32
            builtin.ret v6;
        };

        private builtin.function @basic_wallet_tx_script::bindings::miden::basic_wallet::basic_wallet::move_asset_to_note::wit_import9(v8: felt, v9: felt, v10: felt, v11: felt, v12: felt) {
        ^block9(v8: felt, v9: felt, v10: felt, v11: felt, v12: felt):
            hir.call v8, v9, v10, v11, v12 #[callee = miden:basic-wallet/basic-wallet@1.0.0/move-asset-to-note] #[signature = (param felt) (param felt) (param felt) (param felt) (param felt)];
            builtin.ret ;
        };

        private builtin.function @miden_base_sys::bindings::tx::extern_tx_create_note(v13: felt, v14: felt, v15: felt, v16: felt, v17: felt, v18: felt, v19: felt, v20: felt) -> felt {
        ^block13(v13: felt, v14: felt, v15: felt, v16: felt, v17: felt, v18: felt, v19: felt, v20: felt):
            v21 = hir.exec @miden/tx/create_note(v13, v14, v15, v16, v17, v18, v19, v20) : felt
            builtin.ret v21;
        };

        private builtin.function @__wasm_call_ctors() {
        ^block19:
            builtin.ret ;
        };

        private builtin.function @core::slice::index::slice_end_index_len_fail(v23: i32, v24: i32, v25: i32) {
        ^block21(v23: i32, v24: i32, v25: i32):
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/core::slice::<impl [T]>::copy_from_slice::len_mismatch_fail::do_panic::runtime(v23, v24, v25)
            ub.unreachable ;
        };

        private builtin.function @<alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index(v26: i32, v27: i32, v28: i32, v29: i32, v30: i32) {
        ^block23(v26: i32, v27: i32, v28: i32, v29: i32, v30: i32):
            v33 = arith.constant 8 : u32;
            v32 = hir.bitcast v27 : u32;
            v34 = arith.add v32, v33 : u32 #[overflow = checked];
            v35 = arith.constant 4 : u32;
            v36 = arith.mod v34, v35 : u32;
            hir.assertz v36 #[code = 250];
            v37 = hir.int_to_ptr v34 : ptr<byte, i32>;
            v38 = hir.load v37 : i32;
            v31 = arith.constant 0 : i32;
            v40 = hir.bitcast v38 : u32;
            v39 = hir.bitcast v29 : u32;
            v41 = arith.lte v39, v40 : i1;
            v42 = arith.zext v41 : u32;
            v43 = hir.bitcast v42 : i32;
            v45 = arith.neq v43, v31 : i1;
            cf.cond_br v45 ^block25, ^block26;
        ^block25:
            v896 = arith.constant 4 : u32;
            v47 = hir.bitcast v26 : u32;
            v49 = arith.add v47, v896 : u32 #[overflow = checked];
            v895 = arith.constant 4 : u32;
            v51 = arith.mod v49, v895 : u32;
            hir.assertz v51 #[code = 250];
            v46 = arith.sub v29, v28 : i32 #[overflow = wrapping];
            v52 = hir.int_to_ptr v49 : ptr<byte, i32>;
            hir.store v52, v46;
            v894 = arith.constant 4 : u32;
            v53 = hir.bitcast v27 : u32;
            v55 = arith.add v53, v894 : u32 #[overflow = checked];
            v893 = arith.constant 4 : u32;
            v57 = arith.mod v55, v893 : u32;
            hir.assertz v57 #[code = 250];
            v58 = hir.int_to_ptr v55 : ptr<byte, i32>;
            v59 = hir.load v58 : i32;
            v64 = hir.bitcast v26 : u32;
            v892 = arith.constant 4 : u32;
            v66 = arith.mod v64, v892 : u32;
            hir.assertz v66 #[code = 250];
            v890 = arith.constant 2 : u32;
            v62 = arith.shl v28, v890 : i32;
            v63 = arith.add v59, v62 : i32 #[overflow = wrapping];
            v67 = hir.int_to_ptr v64 : ptr<byte, i32>;
            hir.store v67, v63;
            builtin.ret ;
        ^block26:
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/core::slice::index::slice_end_index_len_fail(v29, v38, v30)
            ub.unreachable ;
        };

        private builtin.function @basic_wallet_tx_script::bindings::__link_custom_section_describing_imports() {
        ^block27:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc(v68: i32, v69: i32) -> i32 {
        ^block29(v68: i32, v69: i32):
            v71 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
            v72 = hir.bitcast v71 : ptr<byte, i32>;
            v73 = hir.load v72 : i32;
            v74 = arith.constant 1048728 : i32;
            v75 = arith.add v73, v74 : i32 #[overflow = wrapping];
            v76 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v75, v69, v68) : i32
            builtin.ret v76;
        };

        private builtin.function @__rustc::__rust_dealloc(v77: i32, v78: i32, v79: i32) {
        ^block31(v77: i32, v78: i32, v79: i32):
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v80: i32, v81: i32) -> i32 {
        ^block33(v80: i32, v81: i32):
            v83 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
            v84 = hir.bitcast v83 : ptr<byte, i32>;
            v85 = hir.load v84 : i32;
            v86 = arith.constant 1048728 : i32;
            v87 = arith.add v85, v86 : i32 #[overflow = wrapping];
            v88 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v87, v81, v80) : i32
            v905 = arith.constant 0 : i32;
            v89 = arith.constant 0 : i32;
            v90 = arith.eq v88, v89 : i1;
            v91 = arith.zext v90 : u32;
            v92 = hir.bitcast v91 : i32;
            v94 = arith.neq v92, v905 : i1;
            scf.if v94{
            ^block35:
                scf.yield ;
            } else {
            ^block36:
                v903 = arith.constant 0 : i32;
                v904 = arith.constant 0 : i32;
                v96 = arith.eq v80, v904 : i1;
                v97 = arith.zext v96 : u32;
                v98 = hir.bitcast v97 : i32;
                v100 = arith.neq v98, v903 : i1;
                scf.if v100{
                ^block110:
                    scf.yield ;
                } else {
                ^block37:
                    v897 = arith.constant 0 : u8;
                    v103 = hir.bitcast v80 : u32;
                    v104 = hir.bitcast v88 : u32;
                    v105 = hir.int_to_ptr v104 : ptr<byte, u8>;
                    hir.mem_set v105, v103, v897;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v88;
        };

        public builtin.function @miden:base/transaction-script@1.0.0#run(v107: felt, v108: felt, v109: felt, v110: felt) {
        ^block38(v107: felt, v108: felt, v109: felt, v110: felt):
            v115 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v116 = hir.bitcast v115 : ptr<byte, i32>;
            v117 = hir.load v116 : i32;
            v118 = arith.constant 80 : i32;
            v119 = arith.sub v117, v118 : i32 #[overflow = wrapping];
            v120 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v121 = hir.bitcast v120 : ptr<byte, i32>;
            hir.store v121, v119;
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/wit_bindgen_rt::run_ctors_once()
            v122 = hir.exec @intrinsics/advice/adv_push_mapvaln(v110, v109, v108, v107) : felt
            v123 = hir.cast v122 : i64;
            v908 = arith.constant 0 : felt;
            v125 = arith.constant 3 : i32;
            v124 = arith.trunc v123 : i32;
            v126 = arith.band v124, v125 : i32;
            v127 = hir.bitcast v126 : felt;
            hir.assert_eq v127, v908;
            v132 = arith.constant 2 : i64;
            v134 = hir.cast v132 : u32;
            v133 = hir.bitcast v123 : u64;
            v135 = arith.shr v133, v134 : u64;
            v136 = hir.bitcast v135 : i64;
            v137 = hir.cast v136 : felt;
            v907 = arith.constant 2 : u32;
            v138 = hir.cast v137 : i64;
            v139 = arith.trunc v138 : i32;
            v142 = arith.shl v139, v907 : i32;
            v144 = arith.constant 4 : i32;
            v111 = arith.constant 0 : i32;
            v130 = arith.constant 64 : i32;
            v131 = arith.add v119, v130 : i32 #[overflow = wrapping];
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/alloc::raw_vec::RawVecInner<A>::try_allocate_in(v131, v142, v111, v144, v144)
            v147 = arith.constant 68 : u32;
            v146 = hir.bitcast v119 : u32;
            v148 = arith.add v146, v147 : u32 #[overflow = checked];
            v149 = arith.constant 4 : u32;
            v150 = arith.mod v148, v149 : u32;
            hir.assertz v150 #[code = 250];
            v151 = hir.int_to_ptr v148 : ptr<byte, i32>;
            v152 = hir.load v151 : i32;
            v154 = arith.constant 64 : u32;
            v153 = hir.bitcast v119 : u32;
            v155 = arith.add v153, v154 : u32 #[overflow = checked];
            v983 = arith.constant 4 : u32;
            v157 = arith.mod v155, v983 : u32;
            hir.assertz v157 #[code = 250];
            v158 = hir.int_to_ptr v155 : ptr<byte, i32>;
            v159 = hir.load v158 : i32;
            v982 = arith.constant 0 : i32;
            v160 = arith.constant 1 : i32;
            v161 = arith.eq v159, v160 : i1;
            v162 = arith.zext v161 : u32;
            v163 = hir.bitcast v162 : i32;
            v165 = arith.neq v163, v982 : i1;
            v913 = scf.if v165 : u32 {
            ^block41:
                v386 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
                v387 = hir.bitcast v386 : ptr<byte, i32>;
                v388 = hir.load v387 : i32;
                v390 = arith.constant 72 : u32;
                v389 = hir.bitcast v119 : u32;
                v391 = arith.add v389, v390 : u32 #[overflow = checked];
                v981 = arith.constant 4 : u32;
                v393 = arith.mod v391, v981 : u32;
                hir.assertz v393 #[code = 250];
                v394 = hir.int_to_ptr v391 : ptr<byte, i32>;
                v395 = hir.load v394 : i32;
                v396 = arith.constant 1048680 : i32;
                v397 = arith.add v388, v396 : i32 #[overflow = wrapping];
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/alloc::raw_vec::handle_error(v152, v395, v397)
                v909 = arith.constant 0 : u32;
                scf.yield v909;
            } else {
            ^block42:
                v980 = arith.constant 72 : u32;
                v166 = hir.bitcast v119 : u32;
                v168 = arith.add v166, v980 : u32 #[overflow = checked];
                v979 = arith.constant 4 : u32;
                v170 = arith.mod v168, v979 : u32;
                hir.assertz v170 #[code = 250];
                v171 = hir.int_to_ptr v168 : ptr<byte, i32>;
                v172 = hir.load v171 : i32;
                v978 = arith.constant 2 : u32;
                v174 = hir.bitcast v172 : u32;
                v176 = arith.shr v174, v978 : u32;
                v177 = hir.bitcast v176 : i32;
                v178 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/miden_stdlib_sys::stdlib::mem::extern_pipe_preimage_to_memory(v137, v177, v110, v109, v108, v107) : i32
                v180 = arith.constant 28 : u32;
                v179 = hir.bitcast v119 : u32;
                v181 = arith.add v179, v180 : u32 #[overflow = checked];
                v977 = arith.constant 4 : u32;
                v183 = arith.mod v181, v977 : u32;
                hir.assertz v183 #[code = 250];
                v184 = hir.int_to_ptr v181 : ptr<byte, i32>;
                hir.store v184, v142;
                v186 = arith.constant 24 : u32;
                v185 = hir.bitcast v119 : u32;
                v187 = arith.add v185, v186 : u32 #[overflow = checked];
                v976 = arith.constant 4 : u32;
                v189 = arith.mod v187, v976 : u32;
                hir.assertz v189 #[code = 250];
                v190 = hir.int_to_ptr v187 : ptr<byte, i32>;
                hir.store v190, v172;
                v192 = arith.constant 20 : u32;
                v191 = hir.bitcast v119 : u32;
                v193 = arith.add v191, v192 : u32 #[overflow = checked];
                v975 = arith.constant 4 : u32;
                v195 = arith.mod v193, v975 : u32;
                hir.assertz v195 #[code = 250];
                v196 = hir.int_to_ptr v193 : ptr<byte, i32>;
                hir.store v196, v152;
                v973 = arith.constant 0 : i32;
                v974 = arith.constant 0 : i32;
                v198 = arith.eq v142, v974 : i1;
                v199 = arith.zext v198 : u32;
                v200 = hir.bitcast v199 : i32;
                v202 = arith.neq v200, v973 : i1;
                v915 = scf.if v202 : u32 {
                ^block115:
                    v972 = arith.constant 0 : u32;
                    scf.yield v972;
                } else {
                ^block43:
                    v203 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
                    v204 = hir.bitcast v203 : ptr<byte, i32>;
                    v205 = hir.load v204 : i32;
                    v207 = arith.constant 12 : u32;
                    v206 = hir.bitcast v172 : u32;
                    v208 = arith.add v206, v207 : u32 #[overflow = checked];
                    v971 = arith.constant 4 : u32;
                    v210 = arith.mod v208, v971 : u32;
                    hir.assertz v210 #[code = 250];
                    v211 = hir.int_to_ptr v208 : ptr<byte, felt>;
                    v212 = hir.load v211 : felt;
                    v214 = arith.constant 8 : u32;
                    v213 = hir.bitcast v172 : u32;
                    v215 = arith.add v213, v214 : u32 #[overflow = checked];
                    v970 = arith.constant 4 : u32;
                    v217 = arith.mod v215, v970 : u32;
                    hir.assertz v217 #[code = 250];
                    v218 = hir.int_to_ptr v215 : ptr<byte, felt>;
                    v219 = hir.load v218 : felt;
                    v969 = arith.constant 4 : u32;
                    v220 = hir.bitcast v172 : u32;
                    v222 = arith.add v220, v969 : u32 #[overflow = checked];
                    v968 = arith.constant 4 : u32;
                    v224 = arith.mod v222, v968 : u32;
                    hir.assertz v224 #[code = 250];
                    v225 = hir.int_to_ptr v222 : ptr<byte, felt>;
                    v226 = hir.load v225 : felt;
                    v227 = hir.bitcast v172 : u32;
                    v967 = arith.constant 4 : u32;
                    v229 = arith.mod v227, v967 : u32;
                    hir.assertz v229 #[code = 250];
                    v230 = hir.int_to_ptr v227 : ptr<byte, felt>;
                    v231 = hir.load v230 : felt;
                    v238 = arith.constant 1048696 : i32;
                    v239 = arith.add v205, v238 : i32 #[overflow = wrapping];
                    v965 = arith.constant 8 : i32;
                    v966 = arith.constant 4 : i32;
                    v234 = arith.constant 20 : i32;
                    v235 = arith.add v119, v234 : i32 #[overflow = wrapping];
                    v232 = arith.constant 8 : i32;
                    v233 = arith.add v119, v232 : i32 #[overflow = wrapping];
                    hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index(v233, v235, v966, v965, v239)
                    v964 = arith.constant 12 : u32;
                    v240 = hir.bitcast v119 : u32;
                    v242 = arith.add v240, v964 : u32 #[overflow = checked];
                    v963 = arith.constant 4 : u32;
                    v244 = arith.mod v242, v963 : u32;
                    hir.assertz v244 #[code = 250];
                    v245 = hir.int_to_ptr v242 : ptr<byte, i32>;
                    v246 = hir.load v245 : i32;
                    v961 = arith.constant 0 : i32;
                    v962 = arith.constant 4 : i32;
                    v248 = arith.neq v246, v962 : i1;
                    v249 = arith.zext v248 : u32;
                    v250 = hir.bitcast v249 : i32;
                    v252 = arith.neq v250, v961 : i1;
                    v917 = scf.if v252 : u32 {
                    ^block114:
                        v960 = arith.constant 0 : u32;
                        scf.yield v960;
                    } else {
                    ^block44:
                        v959 = arith.constant 8 : u32;
                        v253 = hir.bitcast v119 : u32;
                        v255 = arith.add v253, v959 : u32 #[overflow = checked];
                        v958 = arith.constant 4 : u32;
                        v257 = arith.mod v255, v958 : u32;
                        hir.assertz v257 #[code = 250];
                        v258 = hir.int_to_ptr v255 : ptr<byte, i32>;
                        v259 = hir.load v258 : i32;
                        v260 = hir.bitcast v259 : u32;
                        v957 = arith.constant 4 : u32;
                        v262 = arith.mod v260, v957 : u32;
                        hir.assertz v262 #[code = 250];
                        v263 = hir.int_to_ptr v260 : ptr<byte, i64>;
                        v264 = hir.load v263 : i64;
                        v956 = arith.constant 8 : i32;
                        v270 = arith.add v259, v956 : i32 #[overflow = wrapping];
                        v271 = hir.bitcast v270 : u32;
                        v955 = arith.constant 4 : u32;
                        v273 = arith.mod v271, v955 : u32;
                        hir.assertz v273 #[code = 250];
                        v274 = hir.int_to_ptr v271 : ptr<byte, i64>;
                        v275 = hir.load v274 : i64;
                        v954 = arith.constant 8 : i32;
                        v265 = arith.constant 32 : i32;
                        v266 = arith.add v119, v265 : i32 #[overflow = wrapping];
                        v268 = arith.add v266, v954 : i32 #[overflow = wrapping];
                        v276 = hir.bitcast v268 : u32;
                        v953 = arith.constant 8 : u32;
                        v278 = arith.mod v276, v953 : u32;
                        hir.assertz v278 #[code = 250];
                        v279 = hir.int_to_ptr v276 : ptr<byte, i64>;
                        hir.store v279, v275;
                        v281 = arith.constant 32 : u32;
                        v280 = hir.bitcast v119 : u32;
                        v282 = arith.add v280, v281 : u32 #[overflow = checked];
                        v952 = arith.constant 8 : u32;
                        v284 = arith.mod v282, v952 : u32;
                        hir.assertz v284 #[code = 250];
                        v285 = hir.int_to_ptr v282 : ptr<byte, i64>;
                        hir.store v285, v264;
                        v286 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
                        v287 = hir.bitcast v286 : ptr<byte, i32>;
                        v288 = hir.load v287 : i32;
                        v950 = arith.constant 32 : i32;
                        v292 = arith.add v119, v950 : i32 #[overflow = wrapping];
                        v951 = arith.constant 64 : i32;
                        v290 = arith.add v119, v951 : i32 #[overflow = wrapping];
                        hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<miden_base_sys::bindings::types::Asset as core::convert::From<[miden_stdlib_sys::intrinsics::felt::Felt; 4]>>::from(v290, v292)
                        v949 = arith.constant 64 : i32;
                        v294 = arith.add v119, v949 : i32 #[overflow = wrapping];
                        v295 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/miden_base_sys::bindings::tx::create_note(v231, v226, v219, v212, v294) : felt
                        v300 = arith.constant 1048712 : i32;
                        v301 = arith.add v288, v300 : i32 #[overflow = wrapping];
                        v299 = arith.constant 12 : i32;
                        v947 = arith.constant 8 : i32;
                        v948 = arith.constant 20 : i32;
                        v297 = arith.add v119, v948 : i32 #[overflow = wrapping];
                        hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index(v119, v297, v947, v299, v301)
                        v946 = arith.constant 4 : u32;
                        v302 = hir.bitcast v119 : u32;
                        v304 = arith.add v302, v946 : u32 #[overflow = checked];
                        v945 = arith.constant 4 : u32;
                        v306 = arith.mod v304, v945 : u32;
                        hir.assertz v306 #[code = 250];
                        v307 = hir.int_to_ptr v304 : ptr<byte, i32>;
                        v308 = hir.load v307 : i32;
                        v943 = arith.constant 0 : i32;
                        v944 = arith.constant 4 : i32;
                        v310 = arith.neq v308, v944 : i1;
                        v311 = arith.zext v310 : u32;
                        v312 = hir.bitcast v311 : i32;
                        v314 = arith.neq v312, v943 : i1;
                        scf.if v314{
                        ^block113:
                            scf.yield ;
                        } else {
                        ^block45:
                            v315 = hir.bitcast v119 : u32;
                            v942 = arith.constant 4 : u32;
                            v317 = arith.mod v315, v942 : u32;
                            hir.assertz v317 #[code = 250];
                            v318 = hir.int_to_ptr v315 : ptr<byte, i32>;
                            v319 = hir.load v318 : i32;
                            v320 = hir.bitcast v319 : u32;
                            v941 = arith.constant 4 : u32;
                            v322 = arith.mod v320, v941 : u32;
                            hir.assertz v322 #[code = 250];
                            v323 = hir.int_to_ptr v320 : ptr<byte, i64>;
                            v324 = hir.load v323 : i64;
                            v940 = arith.constant 8 : i32;
                            v330 = arith.add v319, v940 : i32 #[overflow = wrapping];
                            v331 = hir.bitcast v330 : u32;
                            v939 = arith.constant 4 : u32;
                            v333 = arith.mod v331, v939 : u32;
                            hir.assertz v333 #[code = 250];
                            v334 = hir.int_to_ptr v331 : ptr<byte, i64>;
                            v335 = hir.load v334 : i64;
                            v938 = arith.constant 8 : i32;
                            v325 = arith.constant 48 : i32;
                            v326 = arith.add v119, v325 : i32 #[overflow = wrapping];
                            v328 = arith.add v326, v938 : i32 #[overflow = wrapping];
                            v336 = hir.bitcast v328 : u32;
                            v937 = arith.constant 8 : u32;
                            v338 = arith.mod v336, v937 : u32;
                            hir.assertz v338 #[code = 250];
                            v339 = hir.int_to_ptr v336 : ptr<byte, i64>;
                            hir.store v339, v335;
                            v341 = arith.constant 48 : u32;
                            v340 = hir.bitcast v119 : u32;
                            v342 = arith.add v340, v341 : u32 #[overflow = checked];
                            v936 = arith.constant 8 : u32;
                            v344 = arith.mod v342, v936 : u32;
                            hir.assertz v344 #[code = 250];
                            v345 = hir.int_to_ptr v342 : ptr<byte, i64>;
                            hir.store v345, v324;
                            v934 = arith.constant 48 : i32;
                            v349 = arith.add v119, v934 : i32 #[overflow = wrapping];
                            v935 = arith.constant 64 : i32;
                            v347 = arith.add v119, v935 : i32 #[overflow = wrapping];
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<miden_base_sys::bindings::types::Asset as core::convert::From<[miden_stdlib_sys::intrinsics::felt::Felt; 4]>>::from(v347, v349)
                            v933 = arith.constant 64 : u32;
                            v350 = hir.bitcast v119 : u32;
                            v352 = arith.add v350, v933 : u32 #[overflow = checked];
                            v932 = arith.constant 4 : u32;
                            v354 = arith.mod v352, v932 : u32;
                            hir.assertz v354 #[code = 250];
                            v355 = hir.int_to_ptr v352 : ptr<byte, felt>;
                            v356 = hir.load v355 : felt;
                            v931 = arith.constant 68 : u32;
                            v357 = hir.bitcast v119 : u32;
                            v359 = arith.add v357, v931 : u32 #[overflow = checked];
                            v930 = arith.constant 4 : u32;
                            v361 = arith.mod v359, v930 : u32;
                            hir.assertz v361 #[code = 250];
                            v362 = hir.int_to_ptr v359 : ptr<byte, felt>;
                            v363 = hir.load v362 : felt;
                            v929 = arith.constant 72 : u32;
                            v364 = hir.bitcast v119 : u32;
                            v366 = arith.add v364, v929 : u32 #[overflow = checked];
                            v928 = arith.constant 4 : u32;
                            v368 = arith.mod v366, v928 : u32;
                            hir.assertz v368 #[code = 250];
                            v369 = hir.int_to_ptr v366 : ptr<byte, felt>;
                            v370 = hir.load v369 : felt;
                            v372 = arith.constant 76 : u32;
                            v371 = hir.bitcast v119 : u32;
                            v373 = arith.add v371, v372 : u32 #[overflow = checked];
                            v927 = arith.constant 4 : u32;
                            v375 = arith.mod v373, v927 : u32;
                            hir.assertz v375 #[code = 250];
                            v376 = hir.int_to_ptr v373 : ptr<byte, felt>;
                            v377 = hir.load v376 : felt;
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/basic_wallet_tx_script::bindings::miden::basic_wallet::basic_wallet::move_asset_to_note::wit_import9(v356, v363, v370, v377, v295)
                            v925 = arith.constant 4 : i32;
                            v926 = arith.constant 20 : i32;
                            v379 = arith.add v119, v926 : i32 #[overflow = wrapping];
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/alloc::raw_vec::RawVecInner<A>::deallocate(v379, v925, v925)
                            v924 = arith.constant 80 : i32;
                            v383 = arith.add v119, v924 : i32 #[overflow = wrapping];
                            v384 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
                            v385 = hir.bitcast v384 : ptr<byte, i32>;
                            hir.store v385, v383;
                            scf.yield ;
                        };
                        v911 = arith.constant 1 : u32;
                        v923 = arith.constant 0 : u32;
                        v921 = cf.select v314, v923, v911 : u32;
                        scf.yield v921;
                    };
                    scf.yield v917;
                };
                scf.yield v915;
            };
            v922 = arith.constant 0 : u32;
            v920 = arith.eq v913, v922 : i1;
            cf.cond_br v920 ^block40, ^block117;
        ^block40:
            ub.unreachable ;
        ^block117:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block46:
            builtin.ret ;
        };

        private builtin.function @wit_bindgen_rt::run_ctors_once() {
        ^block48:
            v399 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
            v400 = hir.bitcast v399 : ptr<byte, i32>;
            v401 = hir.load v400 : i32;
            v402 = arith.constant 1048732 : i32;
            v403 = arith.add v401, v402 : i32 #[overflow = wrapping];
            v404 = hir.bitcast v403 : u32;
            v405 = hir.int_to_ptr v404 : ptr<byte, u8>;
            v406 = hir.load v405 : u8;
            v398 = arith.constant 0 : i32;
            v407 = arith.zext v406 : u32;
            v408 = hir.bitcast v407 : i32;
            v410 = arith.neq v408, v398 : i1;
            scf.if v410{
            ^block50:
                scf.yield ;
            } else {
            ^block51:
                v411 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
                v412 = hir.bitcast v411 : ptr<byte, i32>;
                v413 = hir.load v412 : i32;
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__wasm_call_ctors()
                v985 = arith.constant 1 : u8;
                v987 = arith.constant 1048732 : i32;
                v415 = arith.add v413, v987 : i32 #[overflow = wrapping];
                v419 = hir.bitcast v415 : u32;
                v420 = hir.int_to_ptr v419 : ptr<byte, u8>;
                hir.store v420, v985;
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v421: i32, v422: i32, v423: i32) -> i32 {
        ^block52(v421: i32, v422: i32, v423: i32):
            v426 = arith.constant 16 : i32;
            v425 = arith.constant 0 : i32;
            v989 = arith.constant 16 : u32;
            v428 = hir.bitcast v422 : u32;
            v430 = arith.gt v428, v989 : i1;
            v431 = arith.zext v430 : u32;
            v432 = hir.bitcast v431 : i32;
            v434 = arith.neq v432, v425 : i1;
            v435 = cf.select v434, v422, v426 : i32;
            v1028 = arith.constant 0 : i32;
            v436 = arith.constant -1 : i32;
            v437 = arith.add v435, v436 : i32 #[overflow = wrapping];
            v438 = arith.band v435, v437 : i32;
            v440 = arith.neq v438, v1028 : i1;
            v998, v999 = scf.if v440 : i32, u32 {
            ^block125:
                v990 = arith.constant 0 : u32;
                v994 = ub.poison i32 : i32;
                scf.yield v994, v990;
            } else {
            ^block55:
                v442 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/core::ptr::alignment::Alignment::max(v422, v435) : i32
                v1027 = arith.constant 0 : i32;
                v441 = arith.constant -2147483648 : i32;
                v443 = arith.sub v441, v442 : i32 #[overflow = wrapping];
                v445 = hir.bitcast v443 : u32;
                v444 = hir.bitcast v423 : u32;
                v446 = arith.gt v444, v445 : i1;
                v447 = arith.zext v446 : u32;
                v448 = hir.bitcast v447 : i32;
                v450 = arith.neq v448, v1027 : i1;
                v1013 = scf.if v450 : i32 {
                ^block124:
                    v1026 = ub.poison i32 : i32;
                    scf.yield v1026;
                } else {
                ^block56:
                    v1024 = arith.constant 0 : i32;
                    v456 = arith.sub v1024, v442 : i32 #[overflow = wrapping];
                    v1025 = arith.constant -1 : i32;
                    v452 = arith.add v423, v442 : i32 #[overflow = wrapping];
                    v454 = arith.add v452, v1025 : i32 #[overflow = wrapping];
                    v457 = arith.band v454, v456 : i32;
                    v458 = hir.bitcast v421 : u32;
                    v459 = arith.constant 4 : u32;
                    v460 = arith.mod v458, v459 : u32;
                    hir.assertz v460 #[code = 250];
                    v461 = hir.int_to_ptr v458 : ptr<byte, i32>;
                    v462 = hir.load v461 : i32;
                    v1023 = arith.constant 0 : i32;
                    v464 = arith.neq v462, v1023 : i1;
                    scf.if v464{
                    ^block123:
                        scf.yield ;
                    } else {
                    ^block58:
                        v465 = hir.exec @intrinsics/mem/heap_base() : i32
                        v466 = hir.mem_size  : u32;
                        v472 = hir.bitcast v421 : u32;
                        v1022 = arith.constant 4 : u32;
                        v474 = arith.mod v472, v1022 : u32;
                        hir.assertz v474 #[code = 250];
                        v1021 = arith.constant 16 : u32;
                        v467 = hir.bitcast v466 : i32;
                        v470 = arith.shl v467, v1021 : i32;
                        v471 = arith.add v465, v470 : i32 #[overflow = wrapping];
                        v475 = hir.int_to_ptr v472 : ptr<byte, i32>;
                        hir.store v475, v471;
                        scf.yield ;
                    };
                    v478 = hir.bitcast v421 : u32;
                    v1020 = arith.constant 4 : u32;
                    v480 = arith.mod v478, v1020 : u32;
                    hir.assertz v480 #[code = 250];
                    v481 = hir.int_to_ptr v478 : ptr<byte, i32>;
                    v482 = hir.load v481 : i32;
                    v1019 = arith.constant 0 : i32;
                    v486 = hir.bitcast v457 : u32;
                    v476 = arith.constant 268435456 : i32;
                    v483 = arith.sub v476, v482 : i32 #[overflow = wrapping];
                    v485 = hir.bitcast v483 : u32;
                    v487 = arith.lt v485, v486 : i1;
                    v488 = arith.zext v487 : u32;
                    v489 = hir.bitcast v488 : i32;
                    v491 = arith.neq v489, v1019 : i1;
                    v1012 = scf.if v491 : i32 {
                    ^block59:
                        v1018 = arith.constant 0 : i32;
                        scf.yield v1018;
                    } else {
                    ^block60:
                        v493 = hir.bitcast v421 : u32;
                        v1017 = arith.constant 4 : u32;
                        v495 = arith.mod v493, v1017 : u32;
                        hir.assertz v495 #[code = 250];
                        v492 = arith.add v482, v457 : i32 #[overflow = wrapping];
                        v496 = hir.int_to_ptr v493 : ptr<byte, i32>;
                        hir.store v496, v492;
                        v498 = arith.add v482, v442 : i32 #[overflow = wrapping];
                        scf.yield v498;
                    };
                    scf.yield v1012;
                };
                v995 = arith.constant 1 : u32;
                v1016 = arith.constant 0 : u32;
                v1014 = cf.select v450, v1016, v995 : u32;
                scf.yield v1013, v1014;
            };
            v1015 = arith.constant 0 : u32;
            v1011 = arith.eq v999, v1015 : i1;
            cf.cond_br v1011 ^block54, ^block127(v998);
        ^block54:
            ub.unreachable ;
        ^block127(v991: i32):
            builtin.ret v991;
        };

        private builtin.function @miden_base_sys::bindings::tx::create_note(v501: felt, v502: felt, v503: felt, v504: felt, v505: i32) -> felt {
        ^block61(v501: felt, v502: felt, v503: felt, v504: felt, v505: i32):
            v508 = arith.constant 12 : u32;
            v507 = hir.bitcast v505 : u32;
            v509 = arith.add v507, v508 : u32 #[overflow = checked];
            v510 = arith.constant 4 : u32;
            v511 = arith.mod v509, v510 : u32;
            hir.assertz v511 #[code = 250];
            v512 = hir.int_to_ptr v509 : ptr<byte, felt>;
            v513 = hir.load v512 : felt;
            v515 = arith.constant 8 : u32;
            v514 = hir.bitcast v505 : u32;
            v516 = arith.add v514, v515 : u32 #[overflow = checked];
            v1032 = arith.constant 4 : u32;
            v518 = arith.mod v516, v1032 : u32;
            hir.assertz v518 #[code = 250];
            v519 = hir.int_to_ptr v516 : ptr<byte, felt>;
            v520 = hir.load v519 : felt;
            v1031 = arith.constant 4 : u32;
            v521 = hir.bitcast v505 : u32;
            v523 = arith.add v521, v1031 : u32 #[overflow = checked];
            v1030 = arith.constant 4 : u32;
            v525 = arith.mod v523, v1030 : u32;
            hir.assertz v525 #[code = 250];
            v526 = hir.int_to_ptr v523 : ptr<byte, felt>;
            v527 = hir.load v526 : felt;
            v528 = hir.bitcast v505 : u32;
            v1029 = arith.constant 4 : u32;
            v530 = arith.mod v528, v1029 : u32;
            hir.assertz v530 #[code = 250];
            v531 = hir.int_to_ptr v528 : ptr<byte, felt>;
            v532 = hir.load v531 : felt;
            v533 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/miden_base_sys::bindings::tx::extern_tx_create_note(v501, v502, v503, v504, v513, v520, v527, v532) : felt
            builtin.ret v533;
        };

        private builtin.function @<miden_base_sys::bindings::types::Asset as core::convert::From<[miden_stdlib_sys::intrinsics::felt::Felt; 4]>>::from(v534: i32, v535: i32) {
        ^block63(v534: i32, v535: i32):
            v537 = arith.constant 8 : u32;
            v536 = hir.bitcast v535 : u32;
            v538 = arith.add v536, v537 : u32 #[overflow = checked];
            v539 = arith.constant 4 : u32;
            v540 = arith.mod v538, v539 : u32;
            hir.assertz v540 #[code = 250];
            v541 = hir.int_to_ptr v538 : ptr<byte, i64>;
            v542 = hir.load v541 : i64;
            v1036 = arith.constant 8 : u32;
            v543 = hir.bitcast v534 : u32;
            v545 = arith.add v543, v1036 : u32 #[overflow = checked];
            v1035 = arith.constant 8 : u32;
            v547 = arith.mod v545, v1035 : u32;
            hir.assertz v547 #[code = 250];
            v548 = hir.int_to_ptr v545 : ptr<byte, i64>;
            hir.store v548, v542;
            v549 = hir.bitcast v535 : u32;
            v1034 = arith.constant 4 : u32;
            v551 = arith.mod v549, v1034 : u32;
            hir.assertz v551 #[code = 250];
            v552 = hir.int_to_ptr v549 : ptr<byte, i64>;
            v553 = hir.load v552 : i64;
            v554 = hir.bitcast v534 : u32;
            v1033 = arith.constant 8 : u32;
            v556 = arith.mod v554, v1033 : u32;
            hir.assertz v556 #[code = 250];
            v557 = hir.int_to_ptr v554 : ptr<byte, i64>;
            hir.store v557, v553;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v558: i32, v559: i32, v560: i32) {
        ^block65(v558: i32, v559: i32, v560: i32):
            v562 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v563 = hir.bitcast v562 : ptr<byte, i32>;
            v564 = hir.load v563 : i32;
            v565 = arith.constant 16 : i32;
            v566 = arith.sub v564, v565 : i32 #[overflow = wrapping];
            v567 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v568 = hir.bitcast v567 : ptr<byte, i32>;
            hir.store v568, v566;
            v569 = arith.constant 4 : i32;
            v570 = arith.add v566, v569 : i32 #[overflow = wrapping];
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/alloc::raw_vec::RawVecInner<A>::current_memory(v570, v558, v559, v560)
            v572 = arith.constant 8 : u32;
            v571 = hir.bitcast v566 : u32;
            v573 = arith.add v571, v572 : u32 #[overflow = checked];
            v574 = arith.constant 4 : u32;
            v575 = arith.mod v573, v574 : u32;
            hir.assertz v575 #[code = 250];
            v576 = hir.int_to_ptr v573 : ptr<byte, i32>;
            v577 = hir.load v576 : i32;
            v1043 = arith.constant 0 : i32;
            v561 = arith.constant 0 : i32;
            v579 = arith.eq v577, v561 : i1;
            v580 = arith.zext v579 : u32;
            v581 = hir.bitcast v580 : i32;
            v583 = arith.neq v581, v1043 : i1;
            scf.if v583{
            ^block131:
                scf.yield ;
            } else {
            ^block68:
                v1042 = arith.constant 4 : u32;
                v584 = hir.bitcast v566 : u32;
                v586 = arith.add v584, v1042 : u32 #[overflow = checked];
                v1041 = arith.constant 4 : u32;
                v588 = arith.mod v586, v1041 : u32;
                hir.assertz v588 #[code = 250];
                v589 = hir.int_to_ptr v586 : ptr<byte, i32>;
                v590 = hir.load v589 : i32;
                v592 = arith.constant 12 : u32;
                v591 = hir.bitcast v566 : u32;
                v593 = arith.add v591, v592 : u32 #[overflow = checked];
                v1040 = arith.constant 4 : u32;
                v595 = arith.mod v593, v1040 : u32;
                hir.assertz v595 #[code = 250];
                v596 = hir.int_to_ptr v593 : ptr<byte, i32>;
                v597 = hir.load v596 : i32;
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v590, v577, v597)
                scf.yield ;
            };
            v1039 = arith.constant 16 : i32;
            v600 = arith.add v566, v1039 : i32 #[overflow = wrapping];
            v601 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v602 = hir.bitcast v601 : ptr<byte, i32>;
            hir.store v602, v600;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::try_allocate_in(v603: i32, v604: i32, v605: i32, v606: i32, v607: i32) {
        ^block69(v603: i32, v604: i32, v605: i32, v606: i32, v607: i32):
            v610 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v611 = hir.bitcast v610 : ptr<byte, i32>;
            v612 = hir.load v611 : i32;
            v613 = arith.constant 16 : i32;
            v614 = arith.sub v612, v613 : i32 #[overflow = wrapping];
            v615 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v616 = hir.bitcast v615 : ptr<byte, i32>;
            hir.store v616, v614;
            v626 = hir.bitcast v604 : u32;
            v627 = arith.zext v626 : u64;
            v628 = hir.bitcast v627 : i64;
            v608 = arith.constant 0 : i32;
            v621 = arith.sub v608, v606 : i32 #[overflow = wrapping];
            v618 = arith.constant -1 : i32;
            v617 = arith.add v606, v607 : i32 #[overflow = wrapping];
            v619 = arith.add v617, v618 : i32 #[overflow = wrapping];
            v622 = arith.band v619, v621 : i32;
            v623 = hir.bitcast v622 : u32;
            v624 = arith.zext v623 : u64;
            v625 = hir.bitcast v624 : i64;
            v629 = arith.mul v625, v628 : i64 #[overflow = wrapping];
            v1147 = arith.constant 0 : i32;
            v630 = arith.constant 32 : i64;
            v632 = hir.cast v630 : u32;
            v631 = hir.bitcast v629 : u64;
            v633 = arith.shr v631, v632 : u64;
            v634 = hir.bitcast v633 : i64;
            v635 = arith.trunc v634 : i32;
            v637 = arith.neq v635, v1147 : i1;
            v1059, v1060, v1061, v1062, v1063, v1064 = scf.if v637 : i32, i32, i32, i32, i32, u32 {
            ^block133:
                v1044 = arith.constant 0 : u32;
                v1051 = ub.poison i32 : i32;
                scf.yield v603, v614, v1051, v1051, v1051, v1044;
            } else {
            ^block74:
                v638 = arith.trunc v629 : i32;
                v1146 = arith.constant 0 : i32;
                v639 = arith.constant -2147483648 : i32;
                v640 = arith.sub v639, v606 : i32 #[overflow = wrapping];
                v642 = hir.bitcast v640 : u32;
                v641 = hir.bitcast v638 : u32;
                v643 = arith.lte v641, v642 : i1;
                v644 = arith.zext v643 : u32;
                v645 = hir.bitcast v644 : i32;
                v647 = arith.neq v645, v1146 : i1;
                v1107 = scf.if v647 : i32 {
                ^block72:
                    v1145 = arith.constant 0 : i32;
                    v658 = arith.neq v638, v1145 : i1;
                    v1106 = scf.if v658 : i32 {
                    ^block76:
                        v1144 = arith.constant 0 : i32;
                        v674 = arith.neq v605, v1144 : i1;
                        v1105 = scf.if v674 : i32 {
                        ^block79:
                            v656 = arith.constant 1 : i32;
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/alloc::alloc::Global::alloc_impl(v614, v606, v638, v656)
                            v685 = hir.bitcast v614 : u32;
                            v730 = arith.constant 4 : u32;
                            v687 = arith.mod v685, v730 : u32;
                            hir.assertz v687 #[code = 250];
                            v688 = hir.int_to_ptr v685 : ptr<byte, i32>;
                            v689 = hir.load v688 : i32;
                            scf.yield v689;
                        } else {
                        ^block80:
                            v675 = arith.constant 8 : i32;
                            v676 = arith.add v614, v675 : i32 #[overflow = wrapping];
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v676, v606, v638)
                            v660 = arith.constant 8 : u32;
                            v677 = hir.bitcast v614 : u32;
                            v679 = arith.add v677, v660 : u32 #[overflow = checked];
                            v1143 = arith.constant 4 : u32;
                            v681 = arith.mod v679, v1143 : u32;
                            hir.assertz v681 #[code = 250];
                            v682 = hir.int_to_ptr v679 : ptr<byte, i32>;
                            v683 = hir.load v682 : i32;
                            scf.yield v683;
                        };
                        v1141 = arith.constant 0 : i32;
                        v1142 = arith.constant 0 : i32;
                        v692 = arith.eq v1105, v1142 : i1;
                        v693 = arith.zext v692 : u32;
                        v694 = hir.bitcast v693 : i32;
                        v696 = arith.neq v694, v1141 : i1;
                        scf.if v696{
                        ^block81:
                            v1140 = arith.constant 8 : u32;
                            v713 = hir.bitcast v603 : u32;
                            v715 = arith.add v713, v1140 : u32 #[overflow = checked];
                            v1139 = arith.constant 4 : u32;
                            v717 = arith.mod v715, v1139 : u32;
                            hir.assertz v717 #[code = 250];
                            v718 = hir.int_to_ptr v715 : ptr<byte, i32>;
                            hir.store v718, v638;
                            v1138 = arith.constant 4 : u32;
                            v720 = hir.bitcast v603 : u32;
                            v722 = arith.add v720, v1138 : u32 #[overflow = checked];
                            v1137 = arith.constant 4 : u32;
                            v724 = arith.mod v722, v1137 : u32;
                            hir.assertz v724 #[code = 250];
                            v725 = hir.int_to_ptr v722 : ptr<byte, i32>;
                            hir.store v725, v606;
                            scf.yield ;
                        } else {
                        ^block82:
                            v1136 = arith.constant 8 : u32;
                            v698 = hir.bitcast v603 : u32;
                            v700 = arith.add v698, v1136 : u32 #[overflow = checked];
                            v1135 = arith.constant 4 : u32;
                            v702 = arith.mod v700, v1135 : u32;
                            hir.assertz v702 #[code = 250];
                            v703 = hir.int_to_ptr v700 : ptr<byte, i32>;
                            hir.store v703, v1105;
                            v1134 = arith.constant 4 : u32;
                            v705 = hir.bitcast v603 : u32;
                            v707 = arith.add v705, v1134 : u32 #[overflow = checked];
                            v1133 = arith.constant 4 : u32;
                            v709 = arith.mod v707, v1133 : u32;
                            hir.assertz v709 #[code = 250];
                            v710 = hir.int_to_ptr v707 : ptr<byte, i32>;
                            hir.store v710, v604;
                            scf.yield ;
                        };
                        v1131 = arith.constant 0 : i32;
                        v1132 = arith.constant 1 : i32;
                        v1104 = cf.select v696, v1132, v1131 : i32;
                        scf.yield v1104;
                    } else {
                    ^block77:
                        v1130 = arith.constant 8 : u32;
                        v659 = hir.bitcast v603 : u32;
                        v661 = arith.add v659, v1130 : u32 #[overflow = checked];
                        v1129 = arith.constant 4 : u32;
                        v663 = arith.mod v661, v1129 : u32;
                        hir.assertz v663 #[code = 250];
                        v664 = hir.int_to_ptr v661 : ptr<byte, i32>;
                        hir.store v664, v606;
                        v1128 = arith.constant 4 : u32;
                        v667 = hir.bitcast v603 : u32;
                        v669 = arith.add v667, v1128 : u32 #[overflow = checked];
                        v1127 = arith.constant 4 : u32;
                        v671 = arith.mod v669, v1127 : u32;
                        hir.assertz v671 #[code = 250];
                        v1126 = arith.constant 0 : i32;
                        v672 = hir.int_to_ptr v669 : ptr<byte, i32>;
                        hir.store v672, v1126;
                        v1125 = arith.constant 0 : i32;
                        scf.yield v1125;
                    };
                    scf.yield v1106;
                } else {
                ^block75:
                    v1124 = ub.poison i32 : i32;
                    scf.yield v1124;
                };
                v1119 = arith.constant 0 : u32;
                v1052 = arith.constant 1 : u32;
                v1112 = cf.select v647, v1052, v1119 : u32;
                v1120 = ub.poison i32 : i32;
                v1111 = cf.select v647, v614, v1120 : i32;
                v1121 = ub.poison i32 : i32;
                v1110 = cf.select v647, v603, v1121 : i32;
                v1122 = ub.poison i32 : i32;
                v1109 = cf.select v647, v1122, v614 : i32;
                v1123 = ub.poison i32 : i32;
                v1108 = cf.select v647, v1123, v603 : i32;
                scf.yield v1108, v1109, v1110, v1107, v1111, v1112;
            };
            v1065, v1066, v1067 = scf.index_switch v1064 : i32, i32, i32 
            case 0 {
            ^block73:
                v1118 = arith.constant 4 : u32;
                v650 = hir.bitcast v1059 : u32;
                v652 = arith.add v650, v1118 : u32 #[overflow = checked];
                v1117 = arith.constant 4 : u32;
                v654 = arith.mod v652, v1117 : u32;
                hir.assertz v654 #[code = 250];
                v1116 = arith.constant 0 : i32;
                v655 = hir.int_to_ptr v652 : ptr<byte, i32>;
                hir.store v655, v1116;
                v1115 = arith.constant 1 : i32;
                scf.yield v1059, v1115, v1060;
            }
            default {
            ^block137:
                scf.yield v1061, v1062, v1063;
            };
            v729 = hir.bitcast v1065 : u32;
            v1114 = arith.constant 4 : u32;
            v731 = arith.mod v729, v1114 : u32;
            hir.assertz v731 #[code = 250];
            v732 = hir.int_to_ptr v729 : ptr<byte, i32>;
            hir.store v732, v1066;
            v1113 = arith.constant 16 : i32;
            v737 = arith.add v1067, v1113 : i32 #[overflow = wrapping];
            v738 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v739 = hir.bitcast v738 : ptr<byte, i32>;
            hir.store v739, v737;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v740: i32, v741: i32, v742: i32) {
        ^block83(v740: i32, v741: i32, v742: i32):
            v744 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v745 = hir.bitcast v744 : ptr<byte, i32>;
            v746 = hir.load v745 : i32;
            v747 = arith.constant 16 : i32;
            v748 = arith.sub v746, v747 : i32 #[overflow = wrapping];
            v749 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v750 = hir.bitcast v749 : ptr<byte, i32>;
            hir.store v750, v748;
            v743 = arith.constant 0 : i32;
            v751 = arith.constant 8 : i32;
            v752 = arith.add v748, v751 : i32 #[overflow = wrapping];
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/alloc::alloc::Global::alloc_impl(v752, v741, v742, v743)
            v755 = arith.constant 12 : u32;
            v754 = hir.bitcast v748 : u32;
            v756 = arith.add v754, v755 : u32 #[overflow = checked];
            v757 = arith.constant 4 : u32;
            v758 = arith.mod v756, v757 : u32;
            hir.assertz v758 #[code = 250];
            v759 = hir.int_to_ptr v756 : ptr<byte, i32>;
            v760 = hir.load v759 : i32;
            v762 = arith.constant 8 : u32;
            v761 = hir.bitcast v748 : u32;
            v763 = arith.add v761, v762 : u32 #[overflow = checked];
            v1152 = arith.constant 4 : u32;
            v765 = arith.mod v763, v1152 : u32;
            hir.assertz v765 #[code = 250];
            v766 = hir.int_to_ptr v763 : ptr<byte, i32>;
            v767 = hir.load v766 : i32;
            v768 = hir.bitcast v740 : u32;
            v1151 = arith.constant 4 : u32;
            v770 = arith.mod v768, v1151 : u32;
            hir.assertz v770 #[code = 250];
            v771 = hir.int_to_ptr v768 : ptr<byte, i32>;
            hir.store v771, v767;
            v1150 = arith.constant 4 : u32;
            v772 = hir.bitcast v740 : u32;
            v774 = arith.add v772, v1150 : u32 #[overflow = checked];
            v1149 = arith.constant 4 : u32;
            v776 = arith.mod v774, v1149 : u32;
            hir.assertz v776 #[code = 250];
            v777 = hir.int_to_ptr v774 : ptr<byte, i32>;
            hir.store v777, v760;
            v1148 = arith.constant 16 : i32;
            v779 = arith.add v748, v1148 : i32 #[overflow = wrapping];
            v780 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v781 = hir.bitcast v780 : ptr<byte, i32>;
            hir.store v781, v779;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v782: i32, v783: i32, v784: i32, v785: i32) {
        ^block85(v782: i32, v783: i32, v784: i32, v785: i32):
            v1168 = arith.constant 0 : i32;
            v786 = arith.constant 0 : i32;
            v787 = arith.eq v784, v786 : i1;
            v788 = arith.zext v787 : u32;
            v789 = hir.bitcast v788 : i32;
            v791 = arith.neq v789, v1168 : i1;
            v1164 = scf.if v791 : i32 {
            ^block140:
                scf.yield v783;
            } else {
            ^block88:
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__rustc::__rust_no_alloc_shim_is_unstable_v2()
                v1167 = arith.constant 0 : i32;
                v793 = arith.neq v785, v1167 : i1;
                v1163 = scf.if v793 : i32 {
                ^block89:
                    v795 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__rustc::__rust_alloc_zeroed(v784, v783) : i32
                    scf.yield v795;
                } else {
                ^block90:
                    v794 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__rustc::__rust_alloc(v784, v783) : i32
                    scf.yield v794;
                };
                scf.yield v1163;
            };
            v799 = arith.constant 4 : u32;
            v798 = hir.bitcast v782 : u32;
            v800 = arith.add v798, v799 : u32 #[overflow = checked];
            v1166 = arith.constant 4 : u32;
            v802 = arith.mod v800, v1166 : u32;
            hir.assertz v802 #[code = 250];
            v803 = hir.int_to_ptr v800 : ptr<byte, i32>;
            hir.store v803, v784;
            v805 = hir.bitcast v782 : u32;
            v1165 = arith.constant 4 : u32;
            v807 = arith.mod v805, v1165 : u32;
            hir.assertz v807 #[code = 250];
            v808 = hir.int_to_ptr v805 : ptr<byte, i32>;
            hir.store v808, v1164;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v809: i32, v810: i32, v811: i32, v812: i32) {
        ^block91(v809: i32, v810: i32, v811: i32, v812: i32):
            v1194 = arith.constant 0 : i32;
            v813 = arith.constant 0 : i32;
            v817 = arith.eq v812, v813 : i1;
            v818 = arith.zext v817 : u32;
            v819 = hir.bitcast v818 : i32;
            v821 = arith.neq v819, v1194 : i1;
            v1181, v1182 = scf.if v821 : i32, i32 {
            ^block144:
                v1193 = arith.constant 0 : i32;
                v815 = arith.constant 4 : i32;
                scf.yield v815, v1193;
            } else {
            ^block94:
                v822 = hir.bitcast v810 : u32;
                v857 = arith.constant 4 : u32;
                v824 = arith.mod v822, v857 : u32;
                hir.assertz v824 #[code = 250];
                v825 = hir.int_to_ptr v822 : ptr<byte, i32>;
                v826 = hir.load v825 : i32;
                v1191 = arith.constant 0 : i32;
                v1192 = arith.constant 0 : i32;
                v828 = arith.eq v826, v1192 : i1;
                v829 = arith.zext v828 : u32;
                v830 = hir.bitcast v829 : i32;
                v832 = arith.neq v830, v1191 : i1;
                v1179 = scf.if v832 : i32 {
                ^block143:
                    v1190 = arith.constant 0 : i32;
                    scf.yield v1190;
                } else {
                ^block95:
                    v1189 = arith.constant 4 : u32;
                    v833 = hir.bitcast v809 : u32;
                    v835 = arith.add v833, v1189 : u32 #[overflow = checked];
                    v1188 = arith.constant 4 : u32;
                    v837 = arith.mod v835, v1188 : u32;
                    hir.assertz v837 #[code = 250];
                    v838 = hir.int_to_ptr v835 : ptr<byte, i32>;
                    hir.store v838, v811;
                    v1187 = arith.constant 4 : u32;
                    v839 = hir.bitcast v810 : u32;
                    v841 = arith.add v839, v1187 : u32 #[overflow = checked];
                    v1186 = arith.constant 4 : u32;
                    v843 = arith.mod v841, v1186 : u32;
                    hir.assertz v843 #[code = 250];
                    v844 = hir.int_to_ptr v841 : ptr<byte, i32>;
                    v845 = hir.load v844 : i32;
                    v846 = hir.bitcast v809 : u32;
                    v1185 = arith.constant 4 : u32;
                    v848 = arith.mod v846, v1185 : u32;
                    hir.assertz v848 #[code = 250];
                    v849 = hir.int_to_ptr v846 : ptr<byte, i32>;
                    hir.store v849, v845;
                    v850 = arith.mul v826, v812 : i32 #[overflow = wrapping];
                    scf.yield v850;
                };
                v851 = arith.constant 8 : i32;
                v1184 = arith.constant 4 : i32;
                v1180 = cf.select v832, v1184, v851 : i32;
                scf.yield v1180, v1179;
            };
            v854 = arith.add v809, v1181 : i32 #[overflow = wrapping];
            v856 = hir.bitcast v854 : u32;
            v1183 = arith.constant 4 : u32;
            v858 = arith.mod v856, v1183 : u32;
            hir.assertz v858 #[code = 250];
            v859 = hir.int_to_ptr v856 : ptr<byte, i32>;
            hir.store v859, v1182;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v860: i32, v861: i32, v862: i32) {
        ^block96(v860: i32, v861: i32, v862: i32):
            v1196 = arith.constant 0 : i32;
            v863 = arith.constant 0 : i32;
            v864 = arith.eq v862, v863 : i1;
            v865 = arith.zext v864 : u32;
            v866 = hir.bitcast v865 : i32;
            v868 = arith.neq v866, v1196 : i1;
            scf.if v868{
            ^block98:
                scf.yield ;
            } else {
            ^block99:
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__rustc::__rust_dealloc(v860, v862, v861)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v869: i32, v870: i32, v871: i32) {
        ^block100(v869: i32, v870: i32, v871: i32):
            ub.unreachable ;
        };

        private builtin.function @core::slice::<impl [T]>::copy_from_slice::len_mismatch_fail::do_panic::runtime(v872: i32, v873: i32, v874: i32) {
        ^block102(v872: i32, v873: i32, v874: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v875: i32, v876: i32) -> i32 {
        ^block104(v875: i32, v876: i32):
            v883 = arith.constant 0 : i32;
            v879 = hir.bitcast v876 : u32;
            v878 = hir.bitcast v875 : u32;
            v880 = arith.gt v878, v879 : i1;
            v881 = arith.zext v880 : u32;
            v882 = hir.bitcast v881 : i32;
            v884 = arith.neq v882, v883 : i1;
            v885 = cf.select v884, v875, v876 : i32;
            builtin.ret v885;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.global_variable private @#GOT.data.internal.__memory_base : i32 {
            builtin.ret_imm 0;
        };

        builtin.segment @1048576 = 0x000000000000000000000025000000330000000a00100029000000290000002b0000000a0010002900000021000000980000002800100000000000010000000100000001000000010000000100000001000000010000000100000001000000010000000100000001000000010073722e62696c2f6372730073722e6d656d2f62696c6474732f6372732f352e312e302d7379732d62696c6474732d6e6564696d;
    };

    public builtin.function @run(v886: felt, v887: felt, v888: felt, v889: felt) {
    ^block106(v886: felt, v887: felt, v888: felt, v889: felt):
        hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/miden:base/transaction-script@1.0.0#run(v886, v887, v888, v889)
        builtin.ret ;
    };
};