builtin.component miden:base/transaction-script@1.0.0 {
    builtin.module public @basic_wallet_tx_script {
        private builtin.function @basic_wallet_tx_script::bindings::miden::basic_wallet::basic_wallet::move_asset_to_note::wit_import9(v0: felt, v1: felt, v2: felt, v3: felt, v4: felt) {
        ^block3(v0: felt, v1: felt, v2: felt, v3: felt, v4: felt):
            hir.call v0, v1, v2, v3, v4 #[callee = miden:basic-wallet/basic-wallet@0.1.0/move-asset-to-note] #[signature = (param felt) (param felt) (param felt) (param felt) (param felt)];
            builtin.ret ;
        };

        private builtin.function @__wasm_call_ctors() {
        ^block10:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc(v5: i32, v6: i32) -> i32 {
        ^block12(v5: i32, v6: i32):
            v8 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
            v9 = hir.bitcast v8 : ptr<byte, i32>;
            v10 = hir.load v9 : i32;
            v11 = arith.constant 1048616 : i32;
            v12 = arith.add v10, v11 : i32 #[overflow = wrapping];
            v13 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v12, v6, v5) : i32
            builtin.ret v13;
        };

        private builtin.function @__rustc::__rust_dealloc(v14: i32, v15: i32, v16: i32) {
        ^block14(v14: i32, v15: i32, v16: i32):
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v17: i32, v18: i32) -> i32 {
        ^block16(v17: i32, v18: i32):
            v20 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
            v21 = hir.bitcast v20 : ptr<byte, i32>;
            v22 = hir.load v21 : i32;
            v23 = arith.constant 1048616 : i32;
            v24 = arith.add v22, v23 : i32 #[overflow = wrapping];
            v25 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v24, v18, v17) : i32
            v900 = arith.constant 0 : i32;
            v26 = arith.constant 0 : i32;
            v27 = arith.eq v25, v26 : i1;
            v28 = arith.zext v27 : u32;
            v29 = hir.bitcast v28 : i32;
            v31 = arith.neq v29, v900 : i1;
            scf.if v31{
            ^block18:
                scf.yield ;
            } else {
            ^block19:
                v898 = arith.constant 0 : i32;
                v899 = arith.constant 0 : i32;
                v33 = arith.eq v17, v899 : i1;
                v34 = arith.zext v33 : u32;
                v35 = hir.bitcast v34 : i32;
                v37 = arith.neq v35, v898 : i1;
                scf.if v37{
                ^block119:
                    scf.yield ;
                } else {
                ^block20:
                    v892 = arith.constant 0 : u8;
                    v40 = hir.bitcast v17 : u32;
                    v41 = hir.bitcast v25 : u32;
                    v42 = hir.int_to_ptr v41 : ptr<byte, u8>;
                    hir.mem_set v42, v40, v892;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v25;
        };

        private builtin.function @basic_wallet_tx_script::bindings::__link_custom_section_describing_imports() {
        ^block21:
            builtin.ret ;
        };

        private builtin.function @core::slice::index::slice_index_fail(v44: i32, v45: i32, v46: i32) {
        ^block23(v44: i32, v45: i32, v46: i32):
            v52 = arith.constant 0 : i32;
            v48 = hir.bitcast v46 : u32;
            v47 = hir.bitcast v44 : u32;
            v49 = arith.gt v47, v48 : i1;
            v50 = arith.zext v49 : u32;
            v51 = hir.bitcast v50 : i32;
            v53 = arith.neq v51, v52 : i1;
            scf.if v53{
            ^block26:
                v66 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
                v67 = hir.bitcast v66 : ptr<byte, i32>;
                v68 = hir.load v67 : i32;
                v74 = arith.constant 1048600 : i32;
                v70 = arith.add v68, v74 : i32 #[overflow = wrapping];
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/core::slice::index::slice_index_fail::do_panic::runtime(v44, v46, v70)
                scf.yield ;
            } else {
            ^block27:
                v904 = arith.constant 0 : i32;
                v55 = hir.bitcast v46 : u32;
                v54 = hir.bitcast v45 : u32;
                v56 = arith.gt v54, v55 : i1;
                v57 = arith.zext v56 : u32;
                v58 = hir.bitcast v57 : i32;
                v60 = arith.neq v58, v904 : i1;
                scf.if v60{
                ^block25:
                    v71 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
                    v72 = hir.bitcast v71 : ptr<byte, i32>;
                    v73 = hir.load v72 : i32;
                    v903 = arith.constant 1048600 : i32;
                    v75 = arith.add v73, v903 : i32 #[overflow = wrapping];
                    hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/core::slice::index::slice_index_fail::do_panic::runtime(v45, v46, v75)
                    scf.yield ;
                } else {
                ^block28:
                    v61 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
                    v62 = hir.bitcast v61 : ptr<byte, i32>;
                    v63 = hir.load v62 : i32;
                    v902 = arith.constant 1048600 : i32;
                    v65 = arith.add v63, v902 : i32 #[overflow = wrapping];
                    hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/core::slice::index::slice_index_fail::do_panic::runtime(v45, v46, v65)
                    scf.yield ;
                };
                scf.yield ;
            };
            ub.unreachable ;
        };

        private builtin.function @<alloc::vec::Vec<miden_field::wasm32::Felt> as core::ops::index::Index<core::ops::range::Range<usize>>>::index(v76: i32, v77: i32, v78: i32, v79: i32) {
        ^block29(v76: i32, v77: i32, v78: i32, v79: i32):
            v82 = arith.constant 8 : u32;
            v81 = hir.bitcast v77 : u32;
            v83 = arith.add v81, v82 : u32 #[overflow = checked];
            v84 = arith.constant 4 : u32;
            v85 = arith.mod v83, v84 : u32;
            hir.assertz v85 #[code = 250];
            v86 = hir.int_to_ptr v83 : ptr<byte, i32>;
            v87 = hir.load v86 : i32;
            v80 = arith.constant 0 : i32;
            v89 = hir.bitcast v87 : u32;
            v88 = hir.bitcast v79 : u32;
            v90 = arith.lte v88, v89 : i1;
            v91 = arith.zext v90 : u32;
            v92 = hir.bitcast v91 : i32;
            v94 = arith.neq v92, v80 : i1;
            cf.cond_br v94 ^block31, ^block32;
        ^block31:
            v911 = arith.constant 4 : u32;
            v96 = hir.bitcast v76 : u32;
            v98 = arith.add v96, v911 : u32 #[overflow = checked];
            v910 = arith.constant 4 : u32;
            v100 = arith.mod v98, v910 : u32;
            hir.assertz v100 #[code = 250];
            v95 = arith.sub v79, v78 : i32 #[overflow = wrapping];
            v101 = hir.int_to_ptr v98 : ptr<byte, i32>;
            hir.store v101, v95;
            v909 = arith.constant 4 : u32;
            v102 = hir.bitcast v77 : u32;
            v104 = arith.add v102, v909 : u32 #[overflow = checked];
            v908 = arith.constant 4 : u32;
            v106 = arith.mod v104, v908 : u32;
            hir.assertz v106 #[code = 250];
            v107 = hir.int_to_ptr v104 : ptr<byte, i32>;
            v108 = hir.load v107 : i32;
            v113 = hir.bitcast v76 : u32;
            v907 = arith.constant 4 : u32;
            v115 = arith.mod v113, v907 : u32;
            hir.assertz v115 #[code = 250];
            v905 = arith.constant 2 : u32;
            v111 = arith.shl v78, v905 : i32;
            v112 = arith.add v108, v111 : i32 #[overflow = wrapping];
            v116 = hir.int_to_ptr v113 : ptr<byte, i32>;
            hir.store v116, v112;
            builtin.ret ;
        ^block32:
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/core::slice::index::slice_index_fail(v78, v79, v87)
            ub.unreachable ;
        };

        private builtin.function @miden:base/transaction-script@1.0.0#run(v117: felt, v118: felt, v119: felt, v120: felt) {
        ^block33(v117: felt, v118: felt, v119: felt, v120: felt):
            v125 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v126 = hir.bitcast v125 : ptr<byte, i32>;
            v127 = hir.load v126 : i32;
            v128 = arith.constant 80 : i32;
            v129 = arith.sub v127, v128 : i32 #[overflow = wrapping];
            v130 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v131 = hir.bitcast v130 : ptr<byte, i32>;
            hir.store v131, v129;
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/wit_bindgen::rt::run_ctors_once()
            v132 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/intrinsics::advice::adv_push_mapvaln(v120, v119, v118, v117) : felt
            v133 = hir.cast v132 : i64;
            v914 = arith.constant 0 : felt;
            v135 = arith.constant 3 : i32;
            v134 = arith.trunc v133 : i32;
            v136 = arith.band v134, v135 : i32;
            v137 = hir.bitcast v136 : felt;
            hir.assert_eq v137, v914;
            v142 = arith.constant 2 : i64;
            v144 = hir.cast v142 : u32;
            v143 = hir.bitcast v133 : u64;
            v145 = arith.shr v143, v144 : u64;
            v146 = hir.bitcast v145 : i64;
            v147 = arith.trunc v146 : felt;
            v913 = arith.constant 2 : u32;
            v148 = hir.cast v147 : i64;
            v149 = arith.trunc v148 : i32;
            v152 = arith.shl v149, v913 : i32;
            v154 = arith.constant 4 : i32;
            v121 = arith.constant 0 : i32;
            v140 = arith.constant 64 : i32;
            v141 = arith.add v129, v140 : i32 #[overflow = wrapping];
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::raw_vec::RawVecInner>::try_allocate_in(v141, v152, v121, v154, v154)
            v157 = arith.constant 68 : u32;
            v156 = hir.bitcast v129 : u32;
            v158 = arith.add v156, v157 : u32 #[overflow = checked];
            v159 = arith.constant 4 : u32;
            v160 = arith.mod v158, v159 : u32;
            hir.assertz v160 #[code = 250];
            v161 = hir.int_to_ptr v158 : ptr<byte, i32>;
            v162 = hir.load v161 : i32;
            v164 = arith.constant 64 : u32;
            v163 = hir.bitcast v129 : u32;
            v165 = arith.add v163, v164 : u32 #[overflow = checked];
            v983 = arith.constant 4 : u32;
            v167 = arith.mod v165, v983 : u32;
            hir.assertz v167 #[code = 250];
            v168 = hir.int_to_ptr v165 : ptr<byte, i32>;
            v169 = hir.load v168 : i32;
            v982 = arith.constant 0 : i32;
            v170 = arith.constant 1 : i32;
            v171 = arith.eq v169, v170 : i1;
            v172 = arith.zext v171 : u32;
            v173 = hir.bitcast v172 : i32;
            v175 = arith.neq v173, v982 : i1;
            v919 = scf.if v175 : u32 {
            ^block36:
                v373 = arith.constant 72 : u32;
                v372 = hir.bitcast v129 : u32;
                v374 = arith.add v372, v373 : u32 #[overflow = checked];
                v981 = arith.constant 4 : u32;
                v376 = arith.mod v374, v981 : u32;
                hir.assertz v376 #[code = 250];
                v377 = hir.int_to_ptr v374 : ptr<byte, i32>;
                v378 = hir.load v377 : i32;
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/alloc::raw_vec::handle_error(v162, v378)
                v915 = arith.constant 0 : u32;
                scf.yield v915;
            } else {
            ^block37:
                v980 = arith.constant 72 : u32;
                v176 = hir.bitcast v129 : u32;
                v178 = arith.add v176, v980 : u32 #[overflow = checked];
                v979 = arith.constant 4 : u32;
                v180 = arith.mod v178, v979 : u32;
                hir.assertz v180 #[code = 250];
                v181 = hir.int_to_ptr v178 : ptr<byte, i32>;
                v182 = hir.load v181 : i32;
                v978 = arith.constant 2 : u32;
                v184 = hir.bitcast v182 : u32;
                v186 = arith.shr v184, v978 : u32;
                v187 = hir.bitcast v186 : i32;
                v188 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/miden::core::mem::pipe_preimage_to_memory(v147, v187, v120, v119, v118, v117) : i32
                v190 = arith.constant 28 : u32;
                v189 = hir.bitcast v129 : u32;
                v191 = arith.add v189, v190 : u32 #[overflow = checked];
                v977 = arith.constant 4 : u32;
                v193 = arith.mod v191, v977 : u32;
                hir.assertz v193 #[code = 250];
                v194 = hir.int_to_ptr v191 : ptr<byte, i32>;
                hir.store v194, v152;
                v196 = arith.constant 24 : u32;
                v195 = hir.bitcast v129 : u32;
                v197 = arith.add v195, v196 : u32 #[overflow = checked];
                v976 = arith.constant 4 : u32;
                v199 = arith.mod v197, v976 : u32;
                hir.assertz v199 #[code = 250];
                v200 = hir.int_to_ptr v197 : ptr<byte, i32>;
                hir.store v200, v182;
                v202 = arith.constant 20 : u32;
                v201 = hir.bitcast v129 : u32;
                v203 = arith.add v201, v202 : u32 #[overflow = checked];
                v975 = arith.constant 4 : u32;
                v205 = arith.mod v203, v975 : u32;
                hir.assertz v205 #[code = 250];
                v206 = hir.int_to_ptr v203 : ptr<byte, i32>;
                hir.store v206, v162;
                v973 = arith.constant 0 : i32;
                v974 = arith.constant 0 : i32;
                v208 = arith.eq v152, v974 : i1;
                v209 = arith.zext v208 : u32;
                v210 = hir.bitcast v209 : i32;
                v212 = arith.neq v210, v973 : i1;
                v921 = scf.if v212 : u32 {
                ^block128:
                    v972 = arith.constant 0 : u32;
                    scf.yield v972;
                } else {
                ^block38:
                    v971 = arith.constant 4 : u32;
                    v213 = hir.bitcast v182 : u32;
                    v215 = arith.add v213, v971 : u32 #[overflow = checked];
                    v970 = arith.constant 4 : u32;
                    v217 = arith.mod v215, v970 : u32;
                    hir.assertz v217 #[code = 250];
                    v218 = hir.int_to_ptr v215 : ptr<byte, felt>;
                    v219 = hir.load v218 : felt;
                    v220 = hir.bitcast v182 : u32;
                    v969 = arith.constant 4 : u32;
                    v222 = arith.mod v220, v969 : u32;
                    hir.assertz v222 #[code = 250];
                    v223 = hir.int_to_ptr v220 : ptr<byte, felt>;
                    v224 = hir.load v223 : felt;
                    v230 = arith.constant 6 : i32;
                    v150 = arith.constant 2 : i32;
                    v227 = arith.constant 20 : i32;
                    v228 = arith.add v129, v227 : i32 #[overflow = wrapping];
                    v225 = arith.constant 8 : i32;
                    v226 = arith.add v129, v225 : i32 #[overflow = wrapping];
                    hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::vec::Vec<miden_field::wasm32::Felt> as core::ops::index::Index<core::ops::range::Range<usize>>>::index(v226, v228, v150, v230)
                    v232 = arith.constant 12 : u32;
                    v231 = hir.bitcast v129 : u32;
                    v233 = arith.add v231, v232 : u32 #[overflow = checked];
                    v968 = arith.constant 4 : u32;
                    v235 = arith.mod v233, v968 : u32;
                    hir.assertz v235 #[code = 250];
                    v236 = hir.int_to_ptr v233 : ptr<byte, i32>;
                    v237 = hir.load v236 : i32;
                    v966 = arith.constant 0 : i32;
                    v967 = arith.constant 4 : i32;
                    v239 = arith.neq v237, v967 : i1;
                    v240 = arith.zext v239 : u32;
                    v241 = hir.bitcast v240 : i32;
                    v243 = arith.neq v241, v966 : i1;
                    v923 = scf.if v243 : u32 {
                    ^block127:
                        v965 = arith.constant 0 : u32;
                        scf.yield v965;
                    } else {
                    ^block39:
                        v249 = arith.constant 8 : u32;
                        v248 = hir.bitcast v129 : u32;
                        v250 = arith.add v248, v249 : u32 #[overflow = checked];
                        v964 = arith.constant 4 : u32;
                        v252 = arith.mod v250, v964 : u32;
                        hir.assertz v252 #[code = 250];
                        v253 = hir.int_to_ptr v250 : ptr<byte, i32>;
                        v254 = hir.load v253 : i32;
                        v963 = arith.constant 8 : i32;
                        v256 = arith.add v254, v963 : i32 #[overflow = wrapping];
                        v257 = hir.bitcast v256 : u32;
                        v962 = arith.constant 4 : u32;
                        v259 = arith.mod v257, v962 : u32;
                        hir.assertz v259 #[code = 250];
                        v260 = hir.int_to_ptr v257 : ptr<byte, i64>;
                        v261 = hir.load v260 : i64;
                        v961 = arith.constant 8 : i32;
                        v244 = arith.constant 32 : i32;
                        v245 = arith.add v129, v244 : i32 #[overflow = wrapping];
                        v247 = arith.add v245, v961 : i32 #[overflow = wrapping];
                        v262 = hir.bitcast v247 : u32;
                        v960 = arith.constant 8 : u32;
                        v264 = arith.mod v262, v960 : u32;
                        hir.assertz v264 #[code = 250];
                        v265 = hir.int_to_ptr v262 : ptr<byte, i64>;
                        hir.store v265, v261;
                        v266 = hir.bitcast v254 : u32;
                        v959 = arith.constant 4 : u32;
                        v268 = arith.mod v266, v959 : u32;
                        hir.assertz v268 #[code = 250];
                        v269 = hir.int_to_ptr v266 : ptr<byte, i64>;
                        v270 = hir.load v269 : i64;
                        v272 = arith.constant 32 : u32;
                        v271 = hir.bitcast v129 : u32;
                        v273 = arith.add v271, v272 : u32 #[overflow = checked];
                        v958 = arith.constant 8 : u32;
                        v275 = arith.mod v273, v958 : u32;
                        hir.assertz v275 #[code = 250];
                        v276 = hir.int_to_ptr v273 : ptr<byte, i64>;
                        hir.store v276, v270;
                        v956 = arith.constant 32 : i32;
                        v280 = arith.add v129, v956 : i32 #[overflow = wrapping];
                        v957 = arith.constant 64 : i32;
                        v278 = arith.add v129, v957 : i32 #[overflow = wrapping];
                        hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<miden_base_sys::bindings::types::Asset as core::convert::From<[miden_field::wasm32::Felt; 4]>>::from(v278, v280)
                        v955 = arith.constant 64 : i32;
                        v282 = arith.add v129, v955 : i32 #[overflow = wrapping];
                        v283 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/miden_base_sys::bindings::output_note::create(v224, v219, v282) : felt
                        v287 = arith.constant 10 : i32;
                        v953 = arith.constant 6 : i32;
                        v954 = arith.constant 20 : i32;
                        v285 = arith.add v129, v954 : i32 #[overflow = wrapping];
                        hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::vec::Vec<miden_field::wasm32::Felt> as core::ops::index::Index<core::ops::range::Range<usize>>>::index(v129, v285, v953, v287)
                        v952 = arith.constant 4 : u32;
                        v288 = hir.bitcast v129 : u32;
                        v290 = arith.add v288, v952 : u32 #[overflow = checked];
                        v951 = arith.constant 4 : u32;
                        v292 = arith.mod v290, v951 : u32;
                        hir.assertz v292 #[code = 250];
                        v293 = hir.int_to_ptr v290 : ptr<byte, i32>;
                        v294 = hir.load v293 : i32;
                        v949 = arith.constant 0 : i32;
                        v950 = arith.constant 4 : i32;
                        v296 = arith.neq v294, v950 : i1;
                        v297 = arith.zext v296 : u32;
                        v298 = hir.bitcast v297 : i32;
                        v300 = arith.neq v298, v949 : i1;
                        scf.if v300{
                        ^block126:
                            scf.yield ;
                        } else {
                        ^block40:
                            v305 = hir.bitcast v129 : u32;
                            v948 = arith.constant 4 : u32;
                            v307 = arith.mod v305, v948 : u32;
                            hir.assertz v307 #[code = 250];
                            v308 = hir.int_to_ptr v305 : ptr<byte, i32>;
                            v309 = hir.load v308 : i32;
                            v947 = arith.constant 8 : i32;
                            v311 = arith.add v309, v947 : i32 #[overflow = wrapping];
                            v312 = hir.bitcast v311 : u32;
                            v946 = arith.constant 4 : u32;
                            v314 = arith.mod v312, v946 : u32;
                            hir.assertz v314 #[code = 250];
                            v315 = hir.int_to_ptr v312 : ptr<byte, i64>;
                            v316 = hir.load v315 : i64;
                            v945 = arith.constant 8 : i32;
                            v301 = arith.constant 48 : i32;
                            v302 = arith.add v129, v301 : i32 #[overflow = wrapping];
                            v304 = arith.add v302, v945 : i32 #[overflow = wrapping];
                            v317 = hir.bitcast v304 : u32;
                            v944 = arith.constant 8 : u32;
                            v319 = arith.mod v317, v944 : u32;
                            hir.assertz v319 #[code = 250];
                            v320 = hir.int_to_ptr v317 : ptr<byte, i64>;
                            hir.store v320, v316;
                            v321 = hir.bitcast v309 : u32;
                            v943 = arith.constant 4 : u32;
                            v323 = arith.mod v321, v943 : u32;
                            hir.assertz v323 #[code = 250];
                            v324 = hir.int_to_ptr v321 : ptr<byte, i64>;
                            v325 = hir.load v324 : i64;
                            v327 = arith.constant 48 : u32;
                            v326 = hir.bitcast v129 : u32;
                            v328 = arith.add v326, v327 : u32 #[overflow = checked];
                            v942 = arith.constant 8 : u32;
                            v330 = arith.mod v328, v942 : u32;
                            hir.assertz v330 #[code = 250];
                            v331 = hir.int_to_ptr v328 : ptr<byte, i64>;
                            hir.store v331, v325;
                            v940 = arith.constant 48 : i32;
                            v335 = arith.add v129, v940 : i32 #[overflow = wrapping];
                            v941 = arith.constant 64 : i32;
                            v333 = arith.add v129, v941 : i32 #[overflow = wrapping];
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<miden_base_sys::bindings::types::Asset as core::convert::From<[miden_field::wasm32::Felt; 4]>>::from(v333, v335)
                            v939 = arith.constant 64 : u32;
                            v336 = hir.bitcast v129 : u32;
                            v338 = arith.add v336, v939 : u32 #[overflow = checked];
                            v938 = arith.constant 4 : u32;
                            v340 = arith.mod v338, v938 : u32;
                            hir.assertz v340 #[code = 250];
                            v341 = hir.int_to_ptr v338 : ptr<byte, felt>;
                            v342 = hir.load v341 : felt;
                            v937 = arith.constant 68 : u32;
                            v343 = hir.bitcast v129 : u32;
                            v345 = arith.add v343, v937 : u32 #[overflow = checked];
                            v936 = arith.constant 4 : u32;
                            v347 = arith.mod v345, v936 : u32;
                            hir.assertz v347 #[code = 250];
                            v348 = hir.int_to_ptr v345 : ptr<byte, felt>;
                            v349 = hir.load v348 : felt;
                            v935 = arith.constant 72 : u32;
                            v350 = hir.bitcast v129 : u32;
                            v352 = arith.add v350, v935 : u32 #[overflow = checked];
                            v934 = arith.constant 4 : u32;
                            v354 = arith.mod v352, v934 : u32;
                            hir.assertz v354 #[code = 250];
                            v355 = hir.int_to_ptr v352 : ptr<byte, felt>;
                            v356 = hir.load v355 : felt;
                            v358 = arith.constant 76 : u32;
                            v357 = hir.bitcast v129 : u32;
                            v359 = arith.add v357, v358 : u32 #[overflow = checked];
                            v933 = arith.constant 4 : u32;
                            v361 = arith.mod v359, v933 : u32;
                            hir.assertz v361 #[code = 250];
                            v362 = hir.int_to_ptr v359 : ptr<byte, felt>;
                            v363 = hir.load v362 : felt;
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/basic_wallet_tx_script::bindings::miden::basic_wallet::basic_wallet::move_asset_to_note::wit_import9(v342, v349, v356, v363, v283)
                            v932 = arith.constant 20 : i32;
                            v365 = arith.add v129, v932 : i32 #[overflow = wrapping];
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::vec::Vec<miden_field::wasm32::Felt> as core::ops::drop::Drop>::drop(v365)
                            v931 = arith.constant 20 : i32;
                            v367 = arith.add v129, v931 : i32 #[overflow = wrapping];
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::raw_vec::RawVec<miden_field::wasm32::Felt> as core::ops::drop::Drop>::drop(v367)
                            v930 = arith.constant 80 : i32;
                            v369 = arith.add v129, v930 : i32 #[overflow = wrapping];
                            v370 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
                            v371 = hir.bitcast v370 : ptr<byte, i32>;
                            hir.store v371, v369;
                            scf.yield ;
                        };
                        v917 = arith.constant 1 : u32;
                        v929 = arith.constant 0 : u32;
                        v927 = cf.select v300, v929, v917 : u32;
                        scf.yield v927;
                    };
                    scf.yield v923;
                };
                scf.yield v921;
            };
            v928 = arith.constant 0 : u32;
            v926 = arith.eq v919, v928 : i1;
            cf.cond_br v926 ^block35, ^block130;
        ^block35:
            ub.unreachable ;
        ^block130:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block41:
            builtin.ret ;
        };

        private builtin.function @wit_bindgen::rt::run_ctors_once() {
        ^block43:
            v380 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
            v381 = hir.bitcast v380 : ptr<byte, i32>;
            v382 = hir.load v381 : i32;
            v383 = arith.constant 1048620 : i32;
            v384 = arith.add v382, v383 : i32 #[overflow = wrapping];
            v385 = hir.bitcast v384 : u32;
            v386 = hir.int_to_ptr v385 : ptr<byte, u8>;
            v387 = hir.load v386 : u8;
            v379 = arith.constant 0 : i32;
            v388 = arith.zext v387 : u32;
            v389 = hir.bitcast v388 : i32;
            v391 = arith.neq v389, v379 : i1;
            scf.if v391{
            ^block45:
                scf.yield ;
            } else {
            ^block46:
                v392 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
                v393 = hir.bitcast v392 : ptr<byte, i32>;
                v394 = hir.load v393 : i32;
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__wasm_call_ctors()
                v985 = arith.constant 1 : u8;
                v987 = arith.constant 1048620 : i32;
                v396 = arith.add v394, v987 : i32 #[overflow = wrapping];
                v400 = hir.bitcast v396 : u32;
                v401 = hir.int_to_ptr v400 : ptr<byte, u8>;
                hir.store v401, v985;
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v402: i32, v403: i32, v404: i32) -> i32 {
        ^block47(v402: i32, v403: i32, v404: i32):
            v407 = arith.constant 16 : i32;
            v406 = arith.constant 0 : i32;
            v989 = arith.constant 16 : u32;
            v409 = hir.bitcast v403 : u32;
            v411 = arith.gt v409, v989 : i1;
            v412 = arith.zext v411 : u32;
            v413 = hir.bitcast v412 : i32;
            v415 = arith.neq v413, v406 : i1;
            v416 = cf.select v415, v403, v407 : i32;
            v1029 = arith.constant 0 : i32;
            v417 = arith.constant -1 : i32;
            v418 = arith.add v416, v417 : i32 #[overflow = wrapping];
            v419 = arith.band v416, v418 : i32;
            v421 = arith.neq v419, v1029 : i1;
            v998, v999 = scf.if v421 : i32, u32 {
            ^block138:
                v990 = arith.constant 0 : u32;
                v994 = ub.poison i32 : i32;
                scf.yield v994, v990;
            } else {
            ^block50:
                v423 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<core::ptr::alignment::Alignment>::max(v403, v416) : i32
                v1028 = arith.constant 0 : i32;
                v422 = arith.constant -2147483648 : i32;
                v424 = arith.sub v422, v423 : i32 #[overflow = wrapping];
                v426 = hir.bitcast v424 : u32;
                v425 = hir.bitcast v404 : u32;
                v427 = arith.gt v425, v426 : i1;
                v428 = arith.zext v427 : u32;
                v429 = hir.bitcast v428 : i32;
                v431 = arith.neq v429, v1028 : i1;
                v1013 = scf.if v431 : i32 {
                ^block137:
                    v1027 = ub.poison i32 : i32;
                    scf.yield v1027;
                } else {
                ^block51:
                    v1025 = arith.constant 0 : i32;
                    v437 = arith.sub v1025, v423 : i32 #[overflow = wrapping];
                    v1026 = arith.constant -1 : i32;
                    v433 = arith.add v404, v423 : i32 #[overflow = wrapping];
                    v435 = arith.add v433, v1026 : i32 #[overflow = wrapping];
                    v438 = arith.band v435, v437 : i32;
                    v439 = hir.bitcast v402 : u32;
                    v440 = arith.constant 4 : u32;
                    v441 = arith.mod v439, v440 : u32;
                    hir.assertz v441 #[code = 250];
                    v442 = hir.int_to_ptr v439 : ptr<byte, i32>;
                    v443 = hir.load v442 : i32;
                    v1024 = arith.constant 0 : i32;
                    v445 = arith.neq v443, v1024 : i1;
                    scf.if v445{
                    ^block136:
                        scf.yield ;
                    } else {
                    ^block53:
                        v446 = hir.exec @intrinsics/mem/heap_base() : u32
                        v447 = hir.mem_size  : u32;
                        v455 = hir.bitcast v402 : u32;
                        v1023 = arith.constant 4 : u32;
                        v457 = arith.mod v455, v1023 : u32;
                        hir.assertz v457 #[code = 250];
                        v1022 = arith.constant 16 : u32;
                        v448 = hir.bitcast v447 : i32;
                        v451 = arith.shl v448, v1022 : i32;
                        v452 = hir.bitcast v451 : u32;
                        v453 = arith.add v446, v452 : u32 #[overflow = wrapping];
                        v454 = hir.bitcast v453 : i32;
                        v458 = hir.int_to_ptr v455 : ptr<byte, i32>;
                        hir.store v458, v454;
                        scf.yield ;
                    };
                    v461 = hir.bitcast v402 : u32;
                    v1021 = arith.constant 4 : u32;
                    v463 = arith.mod v461, v1021 : u32;
                    hir.assertz v463 #[code = 250];
                    v464 = hir.int_to_ptr v461 : ptr<byte, i32>;
                    v465 = hir.load v464 : i32;
                    v1019 = arith.constant 0 : i32;
                    v1020 = arith.constant -1 : i32;
                    v467 = arith.bxor v465, v1020 : i32;
                    v469 = hir.bitcast v467 : u32;
                    v468 = hir.bitcast v438 : u32;
                    v470 = arith.gt v468, v469 : i1;
                    v471 = arith.zext v470 : u32;
                    v472 = hir.bitcast v471 : i32;
                    v474 = arith.neq v472, v1019 : i1;
                    v1012 = scf.if v474 : i32 {
                    ^block54:
                        v1018 = arith.constant 0 : i32;
                        scf.yield v1018;
                    } else {
                    ^block55:
                        v476 = hir.bitcast v402 : u32;
                        v1017 = arith.constant 4 : u32;
                        v478 = arith.mod v476, v1017 : u32;
                        hir.assertz v478 #[code = 250];
                        v475 = arith.add v465, v438 : i32 #[overflow = wrapping];
                        v479 = hir.int_to_ptr v476 : ptr<byte, i32>;
                        hir.store v479, v475;
                        v481 = arith.add v465, v423 : i32 #[overflow = wrapping];
                        scf.yield v481;
                    };
                    scf.yield v1012;
                };
                v995 = arith.constant 1 : u32;
                v1016 = arith.constant 0 : u32;
                v1014 = cf.select v431, v1016, v995 : u32;
                scf.yield v1013, v1014;
            };
            v1015 = arith.constant 0 : u32;
            v1011 = arith.eq v999, v1015 : i1;
            cf.cond_br v1011 ^block49, ^block140(v998);
        ^block49:
            ub.unreachable ;
        ^block140(v991: i32):
            builtin.ret v991;
        };

        private builtin.function @<alloc::raw_vec::RawVec<miden_field::wasm32::Felt> as core::ops::drop::Drop>::drop(v484: i32) {
        ^block56(v484: i32):
            v485 = arith.constant 4 : i32;
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::raw_vec::RawVecInner>::deallocate(v484, v485, v485)
            builtin.ret ;
        };

        private builtin.function @miden_base_sys::bindings::output_note::create(v487: felt, v488: felt, v489: i32) -> felt {
        ^block58(v487: felt, v488: felt, v489: i32):
            v492 = arith.constant 12 : u32;
            v491 = hir.bitcast v489 : u32;
            v493 = arith.add v491, v492 : u32 #[overflow = checked];
            v494 = arith.constant 4 : u32;
            v495 = arith.mod v493, v494 : u32;
            hir.assertz v495 #[code = 250];
            v496 = hir.int_to_ptr v493 : ptr<byte, felt>;
            v497 = hir.load v496 : felt;
            v499 = arith.constant 8 : u32;
            v498 = hir.bitcast v489 : u32;
            v500 = arith.add v498, v499 : u32 #[overflow = checked];
            v1033 = arith.constant 4 : u32;
            v502 = arith.mod v500, v1033 : u32;
            hir.assertz v502 #[code = 250];
            v503 = hir.int_to_ptr v500 : ptr<byte, felt>;
            v504 = hir.load v503 : felt;
            v1032 = arith.constant 4 : u32;
            v505 = hir.bitcast v489 : u32;
            v507 = arith.add v505, v1032 : u32 #[overflow = checked];
            v1031 = arith.constant 4 : u32;
            v509 = arith.mod v507, v1031 : u32;
            hir.assertz v509 #[code = 250];
            v510 = hir.int_to_ptr v507 : ptr<byte, felt>;
            v511 = hir.load v510 : felt;
            v512 = hir.bitcast v489 : u32;
            v1030 = arith.constant 4 : u32;
            v514 = arith.mod v512, v1030 : u32;
            hir.assertz v514 #[code = 250];
            v515 = hir.int_to_ptr v512 : ptr<byte, felt>;
            v516 = hir.load v515 : felt;
            v517 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/miden::protocol::output_note::create(v487, v488, v497, v504, v511, v516) : felt
            builtin.ret v517;
        };

        private builtin.function @<miden_base_sys::bindings::types::Asset as core::convert::From<[miden_field::wasm32::Felt; 4]>>::from(v518: i32, v519: i32) {
        ^block60(v518: i32, v519: i32):
            v521 = arith.constant 8 : u32;
            v520 = hir.bitcast v519 : u32;
            v522 = arith.add v520, v521 : u32 #[overflow = checked];
            v523 = arith.constant 4 : u32;
            v524 = arith.mod v522, v523 : u32;
            hir.assertz v524 #[code = 250];
            v525 = hir.int_to_ptr v522 : ptr<byte, i64>;
            v526 = hir.load v525 : i64;
            v1037 = arith.constant 8 : u32;
            v527 = hir.bitcast v518 : u32;
            v529 = arith.add v527, v1037 : u32 #[overflow = checked];
            v1036 = arith.constant 8 : u32;
            v531 = arith.mod v529, v1036 : u32;
            hir.assertz v531 #[code = 250];
            v532 = hir.int_to_ptr v529 : ptr<byte, i64>;
            hir.store v532, v526;
            v533 = hir.bitcast v519 : u32;
            v1035 = arith.constant 4 : u32;
            v535 = arith.mod v533, v1035 : u32;
            hir.assertz v535 #[code = 250];
            v536 = hir.int_to_ptr v533 : ptr<byte, i64>;
            v537 = hir.load v536 : i64;
            v538 = hir.bitcast v518 : u32;
            v1034 = arith.constant 8 : u32;
            v540 = arith.mod v538, v1034 : u32;
            hir.assertz v540 #[code = 250];
            v541 = hir.int_to_ptr v538 : ptr<byte, i64>;
            hir.store v541, v537;
            builtin.ret ;
        };

        private builtin.function @<alloc::vec::Vec<miden_field::wasm32::Felt> as core::ops::drop::Drop>::drop(v542: i32) {
        ^block62(v542: i32):
            builtin.ret ;
        };

        private builtin.function @intrinsics::advice::adv_push_mapvaln(v543: felt, v544: felt, v545: felt, v546: felt) -> felt {
        ^block64(v543: felt, v544: felt, v545: felt, v546: felt):
            v547 = hir.exec @intrinsics/advice/adv_push_mapvaln(v543, v544, v545, v546) : felt
            builtin.ret v547;
        };

        private builtin.function @miden::core::mem::pipe_preimage_to_memory(v549: felt, v550: i32, v551: felt, v552: felt, v553: felt, v554: felt) -> i32 {
        ^block67(v549: felt, v550: i32, v551: felt, v552: felt, v553: felt, v554: felt):
            v555 = hir.exec @miden/core/mem/pipe_preimage_to_memory(v549, v550, v551, v552, v553, v554) : i32
            builtin.ret v555;
        };

        private builtin.function @<alloc::alloc::Global>::alloc_impl(v557: i32, v558: i32, v559: i32, v560: i32) {
        ^block72(v557: i32, v558: i32, v559: i32, v560: i32):
            v1053 = arith.constant 0 : i32;
            v561 = arith.constant 0 : i32;
            v562 = arith.eq v559, v561 : i1;
            v563 = arith.zext v562 : u32;
            v564 = hir.bitcast v563 : i32;
            v566 = arith.neq v564, v1053 : i1;
            v1049 = scf.if v566 : i32 {
            ^block144:
                scf.yield v558;
            } else {
            ^block75:
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__rustc::__rust_no_alloc_shim_is_unstable_v2()
                v1052 = arith.constant 0 : i32;
                v568 = arith.neq v560, v1052 : i1;
                v1048 = scf.if v568 : i32 {
                ^block76:
                    v570 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__rustc::__rust_alloc_zeroed(v559, v558) : i32
                    scf.yield v570;
                } else {
                ^block77:
                    v569 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__rustc::__rust_alloc(v559, v558) : i32
                    scf.yield v569;
                };
                scf.yield v1048;
            };
            v574 = arith.constant 4 : u32;
            v573 = hir.bitcast v557 : u32;
            v575 = arith.add v573, v574 : u32 #[overflow = checked];
            v1051 = arith.constant 4 : u32;
            v577 = arith.mod v575, v1051 : u32;
            hir.assertz v577 #[code = 250];
            v578 = hir.int_to_ptr v575 : ptr<byte, i32>;
            hir.store v578, v559;
            v580 = hir.bitcast v557 : u32;
            v1050 = arith.constant 4 : u32;
            v582 = arith.mod v580, v1050 : u32;
            hir.assertz v582 #[code = 250];
            v583 = hir.int_to_ptr v580 : ptr<byte, i32>;
            hir.store v583, v1049;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::deallocate(v584: i32, v585: i32, v586: i32) {
        ^block78(v584: i32, v585: i32, v586: i32):
            v588 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v589 = hir.bitcast v588 : ptr<byte, i32>;
            v590 = hir.load v589 : i32;
            v591 = arith.constant 16 : i32;
            v592 = arith.sub v590, v591 : i32 #[overflow = wrapping];
            v593 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v594 = hir.bitcast v593 : ptr<byte, i32>;
            hir.store v594, v592;
            v595 = arith.constant 4 : i32;
            v596 = arith.add v592, v595 : i32 #[overflow = wrapping];
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::raw_vec::RawVecInner>::current_memory(v596, v584, v585, v586)
            v598 = arith.constant 8 : u32;
            v597 = hir.bitcast v592 : u32;
            v599 = arith.add v597, v598 : u32 #[overflow = checked];
            v600 = arith.constant 4 : u32;
            v601 = arith.mod v599, v600 : u32;
            hir.assertz v601 #[code = 250];
            v602 = hir.int_to_ptr v599 : ptr<byte, i32>;
            v603 = hir.load v602 : i32;
            v1060 = arith.constant 0 : i32;
            v587 = arith.constant 0 : i32;
            v605 = arith.eq v603, v587 : i1;
            v606 = arith.zext v605 : u32;
            v607 = hir.bitcast v606 : i32;
            v609 = arith.neq v607, v1060 : i1;
            scf.if v609{
            ^block147:
                scf.yield ;
            } else {
            ^block81:
                v1059 = arith.constant 4 : u32;
                v610 = hir.bitcast v592 : u32;
                v612 = arith.add v610, v1059 : u32 #[overflow = checked];
                v1058 = arith.constant 4 : u32;
                v614 = arith.mod v612, v1058 : u32;
                hir.assertz v614 #[code = 250];
                v615 = hir.int_to_ptr v612 : ptr<byte, i32>;
                v616 = hir.load v615 : i32;
                v618 = arith.constant 12 : u32;
                v617 = hir.bitcast v592 : u32;
                v619 = arith.add v617, v618 : u32 #[overflow = checked];
                v1057 = arith.constant 4 : u32;
                v621 = arith.mod v619, v1057 : u32;
                hir.assertz v621 #[code = 250];
                v622 = hir.int_to_ptr v619 : ptr<byte, i32>;
                v623 = hir.load v622 : i32;
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v616, v603, v623)
                scf.yield ;
            };
            v1056 = arith.constant 16 : i32;
            v626 = arith.add v592, v1056 : i32 #[overflow = wrapping];
            v627 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v628 = hir.bitcast v627 : ptr<byte, i32>;
            hir.store v628, v626;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::current_memory(v629: i32, v630: i32, v631: i32, v632: i32) {
        ^block82(v629: i32, v630: i32, v631: i32, v632: i32):
            v1086 = arith.constant 0 : i32;
            v633 = arith.constant 0 : i32;
            v637 = arith.eq v632, v633 : i1;
            v638 = arith.zext v637 : u32;
            v639 = hir.bitcast v638 : i32;
            v641 = arith.neq v639, v1086 : i1;
            v1073, v1074 = scf.if v641 : i32, i32 {
            ^block150:
                v1085 = arith.constant 0 : i32;
                v635 = arith.constant 4 : i32;
                scf.yield v635, v1085;
            } else {
            ^block85:
                v642 = hir.bitcast v630 : u32;
                v677 = arith.constant 4 : u32;
                v644 = arith.mod v642, v677 : u32;
                hir.assertz v644 #[code = 250];
                v645 = hir.int_to_ptr v642 : ptr<byte, i32>;
                v646 = hir.load v645 : i32;
                v1083 = arith.constant 0 : i32;
                v1084 = arith.constant 0 : i32;
                v648 = arith.eq v646, v1084 : i1;
                v649 = arith.zext v648 : u32;
                v650 = hir.bitcast v649 : i32;
                v652 = arith.neq v650, v1083 : i1;
                v1071 = scf.if v652 : i32 {
                ^block149:
                    v1082 = arith.constant 0 : i32;
                    scf.yield v1082;
                } else {
                ^block86:
                    v1081 = arith.constant 4 : u32;
                    v653 = hir.bitcast v629 : u32;
                    v655 = arith.add v653, v1081 : u32 #[overflow = checked];
                    v1080 = arith.constant 4 : u32;
                    v657 = arith.mod v655, v1080 : u32;
                    hir.assertz v657 #[code = 250];
                    v658 = hir.int_to_ptr v655 : ptr<byte, i32>;
                    hir.store v658, v631;
                    v1079 = arith.constant 4 : u32;
                    v659 = hir.bitcast v630 : u32;
                    v661 = arith.add v659, v1079 : u32 #[overflow = checked];
                    v1078 = arith.constant 4 : u32;
                    v663 = arith.mod v661, v1078 : u32;
                    hir.assertz v663 #[code = 250];
                    v664 = hir.int_to_ptr v661 : ptr<byte, i32>;
                    v665 = hir.load v664 : i32;
                    v666 = hir.bitcast v629 : u32;
                    v1077 = arith.constant 4 : u32;
                    v668 = arith.mod v666, v1077 : u32;
                    hir.assertz v668 #[code = 250];
                    v669 = hir.int_to_ptr v666 : ptr<byte, i32>;
                    hir.store v669, v665;
                    v670 = arith.mul v646, v632 : i32 #[overflow = wrapping];
                    scf.yield v670;
                };
                v671 = arith.constant 8 : i32;
                v1076 = arith.constant 4 : i32;
                v1072 = cf.select v652, v1076, v671 : i32;
                scf.yield v1072, v1071;
            };
            v674 = arith.add v629, v1073 : i32 #[overflow = wrapping];
            v676 = hir.bitcast v674 : u32;
            v1075 = arith.constant 4 : u32;
            v678 = arith.mod v676, v1075 : u32;
            hir.assertz v678 #[code = 250];
            v679 = hir.int_to_ptr v676 : ptr<byte, i32>;
            hir.store v679, v1074;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v680: i32, v681: i32, v682: i32) {
        ^block87(v680: i32, v681: i32, v682: i32):
            v1088 = arith.constant 0 : i32;
            v683 = arith.constant 0 : i32;
            v684 = arith.eq v682, v683 : i1;
            v685 = arith.zext v684 : u32;
            v686 = hir.bitcast v685 : i32;
            v688 = arith.neq v686, v1088 : i1;
            scf.if v688{
            ^block89:
                scf.yield ;
            } else {
            ^block90:
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__rustc::__rust_dealloc(v680, v682, v681)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v689: i32, v690: i32, v691: i32) {
        ^block91(v689: i32, v690: i32, v691: i32):
            v693 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v694 = hir.bitcast v693 : ptr<byte, i32>;
            v695 = hir.load v694 : i32;
            v696 = arith.constant 16 : i32;
            v697 = arith.sub v695, v696 : i32 #[overflow = wrapping];
            v698 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v699 = hir.bitcast v698 : ptr<byte, i32>;
            hir.store v699, v697;
            v692 = arith.constant 0 : i32;
            v700 = arith.constant 8 : i32;
            v701 = arith.add v697, v700 : i32 #[overflow = wrapping];
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::alloc::Global>::alloc_impl(v701, v690, v691, v692)
            v704 = arith.constant 12 : u32;
            v703 = hir.bitcast v697 : u32;
            v705 = arith.add v703, v704 : u32 #[overflow = checked];
            v706 = arith.constant 4 : u32;
            v707 = arith.mod v705, v706 : u32;
            hir.assertz v707 #[code = 250];
            v708 = hir.int_to_ptr v705 : ptr<byte, i32>;
            v709 = hir.load v708 : i32;
            v711 = arith.constant 8 : u32;
            v710 = hir.bitcast v697 : u32;
            v712 = arith.add v710, v711 : u32 #[overflow = checked];
            v1093 = arith.constant 4 : u32;
            v714 = arith.mod v712, v1093 : u32;
            hir.assertz v714 #[code = 250];
            v715 = hir.int_to_ptr v712 : ptr<byte, i32>;
            v716 = hir.load v715 : i32;
            v717 = hir.bitcast v689 : u32;
            v1092 = arith.constant 4 : u32;
            v719 = arith.mod v717, v1092 : u32;
            hir.assertz v719 #[code = 250];
            v720 = hir.int_to_ptr v717 : ptr<byte, i32>;
            hir.store v720, v716;
            v1091 = arith.constant 4 : u32;
            v721 = hir.bitcast v689 : u32;
            v723 = arith.add v721, v1091 : u32 #[overflow = checked];
            v1090 = arith.constant 4 : u32;
            v725 = arith.mod v723, v1090 : u32;
            hir.assertz v725 #[code = 250];
            v726 = hir.int_to_ptr v723 : ptr<byte, i32>;
            hir.store v726, v709;
            v1089 = arith.constant 16 : i32;
            v728 = arith.add v697, v1089 : i32 #[overflow = wrapping];
            v729 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v730 = hir.bitcast v729 : ptr<byte, i32>;
            hir.store v730, v728;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::try_allocate_in(v731: i32, v732: i32, v733: i32, v734: i32, v735: i32) {
        ^block93(v731: i32, v732: i32, v733: i32, v734: i32, v735: i32):
            v738 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v739 = hir.bitcast v738 : ptr<byte, i32>;
            v740 = hir.load v739 : i32;
            v741 = arith.constant 16 : i32;
            v742 = arith.sub v740, v741 : i32 #[overflow = wrapping];
            v743 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v744 = hir.bitcast v743 : ptr<byte, i32>;
            hir.store v744, v742;
            v754 = hir.bitcast v732 : u32;
            v755 = arith.zext v754 : u64;
            v756 = hir.bitcast v755 : i64;
            v736 = arith.constant 0 : i32;
            v749 = arith.sub v736, v734 : i32 #[overflow = wrapping];
            v746 = arith.constant -1 : i32;
            v745 = arith.add v734, v735 : i32 #[overflow = wrapping];
            v747 = arith.add v745, v746 : i32 #[overflow = wrapping];
            v750 = arith.band v747, v749 : i32;
            v751 = hir.bitcast v750 : u32;
            v752 = arith.zext v751 : u64;
            v753 = hir.bitcast v752 : i64;
            v757 = arith.mul v753, v756 : i64 #[overflow = wrapping];
            v1196 = arith.constant 0 : i32;
            v758 = arith.constant 32 : i64;
            v760 = hir.cast v758 : u32;
            v759 = hir.bitcast v757 : u64;
            v761 = arith.shr v759, v760 : u64;
            v762 = hir.bitcast v761 : i64;
            v763 = arith.trunc v762 : i32;
            v765 = arith.neq v763, v1196 : i1;
            v1109, v1110, v1111, v1112, v1113, v1114 = scf.if v765 : i32, i32, i32, i32, i32, u32 {
            ^block154:
                v1094 = arith.constant 0 : u32;
                v1101 = ub.poison i32 : i32;
                scf.yield v731, v742, v1101, v1101, v1101, v1094;
            } else {
            ^block98:
                v766 = arith.trunc v757 : i32;
                v1195 = arith.constant 0 : i32;
                v767 = arith.constant -2147483648 : i32;
                v768 = arith.sub v767, v734 : i32 #[overflow = wrapping];
                v770 = hir.bitcast v768 : u32;
                v769 = hir.bitcast v766 : u32;
                v771 = arith.lte v769, v770 : i1;
                v772 = arith.zext v771 : u32;
                v773 = hir.bitcast v772 : i32;
                v775 = arith.neq v773, v1195 : i1;
                v1157 = scf.if v775 : i32 {
                ^block96:
                    v1194 = arith.constant 0 : i32;
                    v786 = arith.neq v766, v1194 : i1;
                    v1156 = scf.if v786 : i32 {
                    ^block100:
                        v1193 = arith.constant 0 : i32;
                        v802 = arith.neq v733, v1193 : i1;
                        v1155 = scf.if v802 : i32 {
                        ^block103:
                            v784 = arith.constant 1 : i32;
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::alloc::Global>::alloc_impl(v742, v734, v766, v784)
                            v813 = hir.bitcast v742 : u32;
                            v854 = arith.constant 4 : u32;
                            v815 = arith.mod v813, v854 : u32;
                            hir.assertz v815 #[code = 250];
                            v816 = hir.int_to_ptr v813 : ptr<byte, i32>;
                            v817 = hir.load v816 : i32;
                            scf.yield v817;
                        } else {
                        ^block104:
                            v803 = arith.constant 8 : i32;
                            v804 = arith.add v742, v803 : i32 #[overflow = wrapping];
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v804, v734, v766)
                            v788 = arith.constant 8 : u32;
                            v805 = hir.bitcast v742 : u32;
                            v807 = arith.add v805, v788 : u32 #[overflow = checked];
                            v1192 = arith.constant 4 : u32;
                            v809 = arith.mod v807, v1192 : u32;
                            hir.assertz v809 #[code = 250];
                            v810 = hir.int_to_ptr v807 : ptr<byte, i32>;
                            v811 = hir.load v810 : i32;
                            scf.yield v811;
                        };
                        v1191 = arith.constant 0 : i32;
                        v820 = arith.neq v1155, v1191 : i1;
                        scf.if v820{
                        ^block105:
                            v1190 = arith.constant 8 : u32;
                            v837 = hir.bitcast v731 : u32;
                            v839 = arith.add v837, v1190 : u32 #[overflow = checked];
                            v1189 = arith.constant 4 : u32;
                            v841 = arith.mod v839, v1189 : u32;
                            hir.assertz v841 #[code = 250];
                            v842 = hir.int_to_ptr v839 : ptr<byte, i32>;
                            hir.store v842, v1155;
                            v1188 = arith.constant 4 : u32;
                            v844 = hir.bitcast v731 : u32;
                            v846 = arith.add v844, v1188 : u32 #[overflow = checked];
                            v1187 = arith.constant 4 : u32;
                            v848 = arith.mod v846, v1187 : u32;
                            hir.assertz v848 #[code = 250];
                            v849 = hir.int_to_ptr v846 : ptr<byte, i32>;
                            hir.store v849, v732;
                            scf.yield ;
                        } else {
                        ^block106:
                            v1186 = arith.constant 8 : u32;
                            v823 = hir.bitcast v731 : u32;
                            v825 = arith.add v823, v1186 : u32 #[overflow = checked];
                            v1185 = arith.constant 4 : u32;
                            v827 = arith.mod v825, v1185 : u32;
                            hir.assertz v827 #[code = 250];
                            v828 = hir.int_to_ptr v825 : ptr<byte, i32>;
                            hir.store v828, v766;
                            v1184 = arith.constant 4 : u32;
                            v830 = hir.bitcast v731 : u32;
                            v832 = arith.add v830, v1184 : u32 #[overflow = checked];
                            v1183 = arith.constant 4 : u32;
                            v834 = arith.mod v832, v1183 : u32;
                            hir.assertz v834 #[code = 250];
                            v835 = hir.int_to_ptr v832 : ptr<byte, i32>;
                            hir.store v835, v734;
                            scf.yield ;
                        };
                        v1181 = arith.constant 1 : i32;
                        v1182 = arith.constant 0 : i32;
                        v1154 = cf.select v820, v1182, v1181 : i32;
                        scf.yield v1154;
                    } else {
                    ^block101:
                        v1180 = arith.constant 8 : u32;
                        v787 = hir.bitcast v731 : u32;
                        v789 = arith.add v787, v1180 : u32 #[overflow = checked];
                        v1179 = arith.constant 4 : u32;
                        v791 = arith.mod v789, v1179 : u32;
                        hir.assertz v791 #[code = 250];
                        v792 = hir.int_to_ptr v789 : ptr<byte, i32>;
                        hir.store v792, v734;
                        v1178 = arith.constant 4 : u32;
                        v795 = hir.bitcast v731 : u32;
                        v797 = arith.add v795, v1178 : u32 #[overflow = checked];
                        v1177 = arith.constant 4 : u32;
                        v799 = arith.mod v797, v1177 : u32;
                        hir.assertz v799 #[code = 250];
                        v1176 = arith.constant 0 : i32;
                        v800 = hir.int_to_ptr v797 : ptr<byte, i32>;
                        hir.store v800, v1176;
                        v1175 = arith.constant 0 : i32;
                        scf.yield v1175;
                    };
                    scf.yield v1156;
                } else {
                ^block99:
                    v1174 = ub.poison i32 : i32;
                    scf.yield v1174;
                };
                v1169 = arith.constant 0 : u32;
                v1102 = arith.constant 1 : u32;
                v1162 = cf.select v775, v1102, v1169 : u32;
                v1170 = ub.poison i32 : i32;
                v1161 = cf.select v775, v742, v1170 : i32;
                v1171 = ub.poison i32 : i32;
                v1160 = cf.select v775, v731, v1171 : i32;
                v1172 = ub.poison i32 : i32;
                v1159 = cf.select v775, v1172, v742 : i32;
                v1173 = ub.poison i32 : i32;
                v1158 = cf.select v775, v1173, v731 : i32;
                scf.yield v1158, v1159, v1160, v1157, v1161, v1162;
            };
            v1115, v1116, v1117 = scf.index_switch v1114 : i32, i32, i32 
            case 0 {
            ^block97:
                v1168 = arith.constant 4 : u32;
                v778 = hir.bitcast v1109 : u32;
                v780 = arith.add v778, v1168 : u32 #[overflow = checked];
                v1167 = arith.constant 4 : u32;
                v782 = arith.mod v780, v1167 : u32;
                hir.assertz v782 #[code = 250];
                v1166 = arith.constant 0 : i32;
                v783 = hir.int_to_ptr v780 : ptr<byte, i32>;
                hir.store v783, v1166;
                v1165 = arith.constant 1 : i32;
                scf.yield v1109, v1165, v1110;
            }
            default {
            ^block158:
                scf.yield v1111, v1112, v1113;
            };
            v853 = hir.bitcast v1115 : u32;
            v1164 = arith.constant 4 : u32;
            v855 = arith.mod v853, v1164 : u32;
            hir.assertz v855 #[code = 250];
            v856 = hir.int_to_ptr v853 : ptr<byte, i32>;
            hir.store v856, v1116;
            v1163 = arith.constant 16 : i32;
            v861 = arith.add v1117, v1163 : i32 #[overflow = wrapping];
            v862 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v863 = hir.bitcast v862 : ptr<byte, i32>;
            hir.store v863, v861;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v864: i32, v865: i32) {
        ^block107(v864: i32, v865: i32):
            ub.unreachable ;
        };

        private builtin.function @core::slice::index::slice_index_fail::do_panic::runtime(v866: i32, v867: i32, v868: i32) {
        ^block109(v866: i32, v867: i32, v868: i32):
            ub.unreachable ;
        };

        private builtin.function @<core::ptr::alignment::Alignment>::max(v869: i32, v870: i32) -> i32 {
        ^block111(v869: i32, v870: i32):
            v877 = arith.constant 0 : i32;
            v873 = hir.bitcast v870 : u32;
            v872 = hir.bitcast v869 : u32;
            v874 = arith.gt v872, v873 : i1;
            v875 = arith.zext v874 : u32;
            v876 = hir.bitcast v875 : i32;
            v878 = arith.neq v876, v877 : i1;
            v879 = cf.select v878, v869, v870 : i32;
            builtin.ret v879;
        };

        private builtin.function @miden::protocol::output_note::create(v880: felt, v881: felt, v882: felt, v883: felt, v884: felt, v885: felt) -> felt {
        ^block113(v880: felt, v881: felt, v882: felt, v883: felt, v884: felt, v885: felt):
            v886 = hir.exec @miden/protocol/output_note/create(v880, v881, v882, v883, v884, v885) : felt
            builtin.ret v886;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.global_variable private @#GOT.data.internal.__memory_base : i32 {
            builtin.ret_imm 0;
        };

        builtin.segment readonly @1048576 = 0x003e64657463616465723c;

        builtin.segment @1048588 = 0x00000000000000000000000a00100000000000010000000100000001;
    };

    public builtin.function @run(v888: felt, v889: felt, v890: felt, v891: felt) {
    ^block117(v888: felt, v889: felt, v890: felt, v891: felt):
        hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/miden:base/transaction-script@1.0.0#run(v888, v889, v890, v891)
        builtin.ret ;
    };
};