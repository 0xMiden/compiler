builtin.component miden:base/transaction-script@1.0.0 {
    builtin.module public @basic_wallet_tx_script {
        private builtin.function @basic_wallet_tx_script::bindings::miden::basic_wallet::basic_wallet::move_asset_to_note::wit_import9(v0: felt, v1: felt, v2: felt, v3: felt, v4: felt) {
        ^block3(v0: felt, v1: felt, v2: felt, v3: felt, v4: felt):
            hir.call v0, v1, v2, v3, v4 #[callee = miden:basic-wallet/basic-wallet@0.1.0/move-asset-to-note] #[signature = (param felt) (param felt) (param felt) (param felt) (param felt)];
            builtin.ret ;
        };

        private builtin.function @__wasm_call_ctors() {
        ^block8:
            builtin.ret ;
        };

        private builtin.function @core::slice::index::slice_end_index_len_fail(v5: i32, v6: i32) {
        ^block10(v5: i32, v6: i32):
            v7 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
            v8 = hir.bitcast v7 : ptr<byte, i32>;
            v9 = hir.load v8 : i32;
            v10 = arith.constant 1048600 : i32;
            v11 = arith.add v9, v10 : i32 #[overflow = wrapping];
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/core::slice::<impl [T]>::copy_from_slice::len_mismatch_fail::do_panic::runtime(v5, v6, v11)
            ub.unreachable ;
        };

        private builtin.function @<alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index(v12: i32, v13: i32, v14: i32, v15: i32) {
        ^block12(v12: i32, v13: i32, v14: i32, v15: i32):
            v18 = arith.constant 8 : u32;
            v17 = hir.bitcast v13 : u32;
            v19 = arith.add v17, v18 : u32 #[overflow = checked];
            v20 = arith.constant 4 : u32;
            v21 = arith.mod v19, v20 : u32;
            hir.assertz v21 #[code = 250];
            v22 = hir.int_to_ptr v19 : ptr<byte, i32>;
            v23 = hir.load v22 : i32;
            v16 = arith.constant 0 : i32;
            v25 = hir.bitcast v23 : u32;
            v24 = hir.bitcast v15 : u32;
            v26 = arith.lte v24, v25 : i1;
            v27 = arith.zext v26 : u32;
            v28 = hir.bitcast v27 : i32;
            v30 = arith.neq v28, v16 : i1;
            cf.cond_br v30 ^block14, ^block15;
        ^block14:
            v908 = arith.constant 4 : u32;
            v32 = hir.bitcast v12 : u32;
            v34 = arith.add v32, v908 : u32 #[overflow = checked];
            v907 = arith.constant 4 : u32;
            v36 = arith.mod v34, v907 : u32;
            hir.assertz v36 #[code = 250];
            v31 = arith.sub v15, v14 : i32 #[overflow = wrapping];
            v37 = hir.int_to_ptr v34 : ptr<byte, i32>;
            hir.store v37, v31;
            v906 = arith.constant 4 : u32;
            v38 = hir.bitcast v13 : u32;
            v40 = arith.add v38, v906 : u32 #[overflow = checked];
            v905 = arith.constant 4 : u32;
            v42 = arith.mod v40, v905 : u32;
            hir.assertz v42 #[code = 250];
            v43 = hir.int_to_ptr v40 : ptr<byte, i32>;
            v44 = hir.load v43 : i32;
            v49 = hir.bitcast v12 : u32;
            v904 = arith.constant 4 : u32;
            v51 = arith.mod v49, v904 : u32;
            hir.assertz v51 #[code = 250];
            v902 = arith.constant 2 : u32;
            v47 = arith.shl v14, v902 : i32;
            v48 = arith.add v44, v47 : i32 #[overflow = wrapping];
            v52 = hir.int_to_ptr v49 : ptr<byte, i32>;
            hir.store v52, v48;
            builtin.ret ;
        ^block15:
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/core::slice::index::slice_end_index_len_fail(v15, v23)
            ub.unreachable ;
        };

        private builtin.function @__rustc::__rust_alloc(v53: i32, v54: i32) -> i32 {
        ^block16(v53: i32, v54: i32):
            v56 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
            v57 = hir.bitcast v56 : ptr<byte, i32>;
            v58 = hir.load v57 : i32;
            v59 = arith.constant 1048616 : i32;
            v60 = arith.add v58, v59 : i32 #[overflow = wrapping];
            v61 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v60, v54, v53) : i32
            builtin.ret v61;
        };

        private builtin.function @__rustc::__rust_dealloc(v62: i32, v63: i32, v64: i32) {
        ^block18(v62: i32, v63: i32, v64: i32):
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v65: i32, v66: i32) -> i32 {
        ^block20(v65: i32, v66: i32):
            v68 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
            v69 = hir.bitcast v68 : ptr<byte, i32>;
            v70 = hir.load v69 : i32;
            v71 = arith.constant 1048616 : i32;
            v72 = arith.add v70, v71 : i32 #[overflow = wrapping];
            v73 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v72, v66, v65) : i32
            v917 = arith.constant 0 : i32;
            v74 = arith.constant 0 : i32;
            v75 = arith.eq v73, v74 : i1;
            v76 = arith.zext v75 : u32;
            v77 = hir.bitcast v76 : i32;
            v79 = arith.neq v77, v917 : i1;
            scf.if v79{
            ^block22:
                scf.yield ;
            } else {
            ^block23:
                v915 = arith.constant 0 : i32;
                v916 = arith.constant 0 : i32;
                v81 = arith.eq v65, v916 : i1;
                v82 = arith.zext v81 : u32;
                v83 = hir.bitcast v82 : i32;
                v85 = arith.neq v83, v915 : i1;
                scf.if v85{
                ^block122:
                    scf.yield ;
                } else {
                ^block24:
                    v909 = arith.constant 0 : u8;
                    v88 = hir.bitcast v65 : u32;
                    v89 = hir.bitcast v73 : u32;
                    v90 = hir.int_to_ptr v89 : ptr<byte, u8>;
                    hir.mem_set v90, v88, v909;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v73;
        };

        private builtin.function @basic_wallet_tx_script::bindings::__link_custom_section_describing_imports() {
        ^block25:
            builtin.ret ;
        };

        private builtin.function @miden:base/transaction-script@1.0.0#run(v92: felt, v93: felt, v94: felt, v95: felt) {
        ^block27(v92: felt, v93: felt, v94: felt, v95: felt):
            v100 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v101 = hir.bitcast v100 : ptr<byte, i32>;
            v102 = hir.load v101 : i32;
            v103 = arith.constant 80 : i32;
            v104 = arith.sub v102, v103 : i32 #[overflow = wrapping];
            v105 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v106 = hir.bitcast v105 : ptr<byte, i32>;
            hir.store v106, v104;
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/wit_bindgen::rt::run_ctors_once()
            v107 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/intrinsics::advice::adv_push_mapvaln(v95, v94, v93, v92) : felt
            v108 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/intrinsics::felt::as_u64(v107) : i64
            v110 = arith.constant 3 : i32;
            v109 = arith.trunc v108 : i32;
            v111 = arith.band v109, v110 : i32;
            v112 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/intrinsics::felt::from_u32(v111) : felt
            v96 = arith.constant 0 : i32;
            v114 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/intrinsics::felt::from_u32(v96) : felt
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/intrinsics::felt::assert_eq(v112, v114)
            v117 = arith.constant 2 : i64;
            v119 = hir.cast v117 : u32;
            v118 = hir.bitcast v108 : u64;
            v120 = arith.shr v118, v119 : u64;
            v121 = hir.bitcast v120 : i64;
            v122 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/intrinsics::felt::from_u64_unchecked(v121) : felt
            v123 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/intrinsics::felt::as_u64(v122) : i64
            v919 = arith.constant 2 : u32;
            v124 = arith.trunc v123 : i32;
            v127 = arith.shl v124, v919 : i32;
            v129 = arith.constant 4 : i32;
            v995 = arith.constant 0 : i32;
            v115 = arith.constant 64 : i32;
            v116 = arith.add v104, v115 : i32 #[overflow = wrapping];
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/alloc::raw_vec::RawVecInner<A>::try_allocate_in(v116, v127, v995, v129, v129)
            v132 = arith.constant 68 : u32;
            v131 = hir.bitcast v104 : u32;
            v133 = arith.add v131, v132 : u32 #[overflow = checked];
            v134 = arith.constant 4 : u32;
            v135 = arith.mod v133, v134 : u32;
            hir.assertz v135 #[code = 250];
            v136 = hir.int_to_ptr v133 : ptr<byte, i32>;
            v137 = hir.load v136 : i32;
            v139 = arith.constant 64 : u32;
            v138 = hir.bitcast v104 : u32;
            v140 = arith.add v138, v139 : u32 #[overflow = checked];
            v994 = arith.constant 4 : u32;
            v142 = arith.mod v140, v994 : u32;
            hir.assertz v142 #[code = 250];
            v143 = hir.int_to_ptr v140 : ptr<byte, i32>;
            v144 = hir.load v143 : i32;
            v993 = arith.constant 0 : i32;
            v145 = arith.constant 1 : i32;
            v146 = arith.eq v144, v145 : i1;
            v147 = arith.zext v146 : u32;
            v148 = hir.bitcast v147 : i32;
            v150 = arith.neq v148, v993 : i1;
            v924 = scf.if v150 : u32 {
            ^block30:
                v361 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
                v362 = hir.bitcast v361 : ptr<byte, i32>;
                v363 = hir.load v362 : i32;
                v365 = arith.constant 72 : u32;
                v364 = hir.bitcast v104 : u32;
                v366 = arith.add v364, v365 : u32 #[overflow = checked];
                v992 = arith.constant 4 : u32;
                v368 = arith.mod v366, v992 : u32;
                hir.assertz v368 #[code = 250];
                v369 = hir.int_to_ptr v366 : ptr<byte, i32>;
                v370 = hir.load v369 : i32;
                v371 = arith.constant 1048600 : i32;
                v372 = arith.add v363, v371 : i32 #[overflow = wrapping];
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/alloc::raw_vec::handle_error(v137, v370, v372)
                v920 = arith.constant 0 : u32;
                scf.yield v920;
            } else {
            ^block31:
                v991 = arith.constant 72 : u32;
                v151 = hir.bitcast v104 : u32;
                v153 = arith.add v151, v991 : u32 #[overflow = checked];
                v990 = arith.constant 4 : u32;
                v155 = arith.mod v153, v990 : u32;
                hir.assertz v155 #[code = 250];
                v156 = hir.int_to_ptr v153 : ptr<byte, i32>;
                v157 = hir.load v156 : i32;
                v989 = arith.constant 2 : u32;
                v159 = hir.bitcast v157 : u32;
                v161 = arith.shr v159, v989 : u32;
                v162 = hir.bitcast v161 : i32;
                v163 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/std::mem::pipe_preimage_to_memory(v122, v162, v95, v94, v93, v92) : i32
                v165 = arith.constant 28 : u32;
                v164 = hir.bitcast v104 : u32;
                v166 = arith.add v164, v165 : u32 #[overflow = checked];
                v988 = arith.constant 4 : u32;
                v168 = arith.mod v166, v988 : u32;
                hir.assertz v168 #[code = 250];
                v169 = hir.int_to_ptr v166 : ptr<byte, i32>;
                hir.store v169, v127;
                v171 = arith.constant 24 : u32;
                v170 = hir.bitcast v104 : u32;
                v172 = arith.add v170, v171 : u32 #[overflow = checked];
                v987 = arith.constant 4 : u32;
                v174 = arith.mod v172, v987 : u32;
                hir.assertz v174 #[code = 250];
                v175 = hir.int_to_ptr v172 : ptr<byte, i32>;
                hir.store v175, v157;
                v177 = arith.constant 20 : u32;
                v176 = hir.bitcast v104 : u32;
                v178 = arith.add v176, v177 : u32 #[overflow = checked];
                v986 = arith.constant 4 : u32;
                v180 = arith.mod v178, v986 : u32;
                hir.assertz v180 #[code = 250];
                v181 = hir.int_to_ptr v178 : ptr<byte, i32>;
                hir.store v181, v137;
                v984 = arith.constant 0 : i32;
                v985 = arith.constant 0 : i32;
                v183 = arith.eq v127, v985 : i1;
                v184 = arith.zext v183 : u32;
                v185 = hir.bitcast v184 : i32;
                v187 = arith.neq v185, v984 : i1;
                v926 = scf.if v187 : u32 {
                ^block127:
                    v983 = arith.constant 0 : u32;
                    scf.yield v983;
                } else {
                ^block32:
                    v189 = arith.constant 12 : u32;
                    v188 = hir.bitcast v157 : u32;
                    v190 = arith.add v188, v189 : u32 #[overflow = checked];
                    v982 = arith.constant 4 : u32;
                    v192 = arith.mod v190, v982 : u32;
                    hir.assertz v192 #[code = 250];
                    v193 = hir.int_to_ptr v190 : ptr<byte, felt>;
                    v194 = hir.load v193 : felt;
                    v196 = arith.constant 8 : u32;
                    v195 = hir.bitcast v157 : u32;
                    v197 = arith.add v195, v196 : u32 #[overflow = checked];
                    v981 = arith.constant 4 : u32;
                    v199 = arith.mod v197, v981 : u32;
                    hir.assertz v199 #[code = 250];
                    v200 = hir.int_to_ptr v197 : ptr<byte, felt>;
                    v201 = hir.load v200 : felt;
                    v980 = arith.constant 4 : u32;
                    v202 = hir.bitcast v157 : u32;
                    v204 = arith.add v202, v980 : u32 #[overflow = checked];
                    v979 = arith.constant 4 : u32;
                    v206 = arith.mod v204, v979 : u32;
                    hir.assertz v206 #[code = 250];
                    v207 = hir.int_to_ptr v204 : ptr<byte, felt>;
                    v208 = hir.load v207 : felt;
                    v209 = hir.bitcast v157 : u32;
                    v978 = arith.constant 4 : u32;
                    v211 = arith.mod v209, v978 : u32;
                    hir.assertz v211 #[code = 250];
                    v212 = hir.int_to_ptr v209 : ptr<byte, felt>;
                    v213 = hir.load v212 : felt;
                    v976 = arith.constant 8 : i32;
                    v977 = arith.constant 4 : i32;
                    v216 = arith.constant 20 : i32;
                    v217 = arith.add v104, v216 : i32 #[overflow = wrapping];
                    v214 = arith.constant 8 : i32;
                    v215 = arith.add v104, v214 : i32 #[overflow = wrapping];
                    hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index(v215, v217, v977, v976)
                    v975 = arith.constant 12 : u32;
                    v220 = hir.bitcast v104 : u32;
                    v222 = arith.add v220, v975 : u32 #[overflow = checked];
                    v974 = arith.constant 4 : u32;
                    v224 = arith.mod v222, v974 : u32;
                    hir.assertz v224 #[code = 250];
                    v225 = hir.int_to_ptr v222 : ptr<byte, i32>;
                    v226 = hir.load v225 : i32;
                    v972 = arith.constant 0 : i32;
                    v973 = arith.constant 4 : i32;
                    v228 = arith.neq v226, v973 : i1;
                    v229 = arith.zext v228 : u32;
                    v230 = hir.bitcast v229 : i32;
                    v232 = arith.neq v230, v972 : i1;
                    v928 = scf.if v232 : u32 {
                    ^block126:
                        v971 = arith.constant 0 : u32;
                        scf.yield v971;
                    } else {
                    ^block33:
                        v970 = arith.constant 8 : u32;
                        v233 = hir.bitcast v104 : u32;
                        v235 = arith.add v233, v970 : u32 #[overflow = checked];
                        v969 = arith.constant 4 : u32;
                        v237 = arith.mod v235, v969 : u32;
                        hir.assertz v237 #[code = 250];
                        v238 = hir.int_to_ptr v235 : ptr<byte, i32>;
                        v239 = hir.load v238 : i32;
                        v240 = hir.bitcast v239 : u32;
                        v968 = arith.constant 4 : u32;
                        v242 = arith.mod v240, v968 : u32;
                        hir.assertz v242 #[code = 250];
                        v243 = hir.int_to_ptr v240 : ptr<byte, i64>;
                        v244 = hir.load v243 : i64;
                        v967 = arith.constant 8 : i32;
                        v250 = arith.add v239, v967 : i32 #[overflow = wrapping];
                        v251 = hir.bitcast v250 : u32;
                        v966 = arith.constant 4 : u32;
                        v253 = arith.mod v251, v966 : u32;
                        hir.assertz v253 #[code = 250];
                        v254 = hir.int_to_ptr v251 : ptr<byte, i64>;
                        v255 = hir.load v254 : i64;
                        v965 = arith.constant 8 : i32;
                        v245 = arith.constant 32 : i32;
                        v246 = arith.add v104, v245 : i32 #[overflow = wrapping];
                        v248 = arith.add v246, v965 : i32 #[overflow = wrapping];
                        v256 = hir.bitcast v248 : u32;
                        v964 = arith.constant 8 : u32;
                        v258 = arith.mod v256, v964 : u32;
                        hir.assertz v258 #[code = 250];
                        v259 = hir.int_to_ptr v256 : ptr<byte, i64>;
                        hir.store v259, v255;
                        v261 = arith.constant 32 : u32;
                        v260 = hir.bitcast v104 : u32;
                        v262 = arith.add v260, v261 : u32 #[overflow = checked];
                        v963 = arith.constant 8 : u32;
                        v264 = arith.mod v262, v963 : u32;
                        hir.assertz v264 #[code = 250];
                        v265 = hir.int_to_ptr v262 : ptr<byte, i64>;
                        hir.store v265, v244;
                        v961 = arith.constant 32 : i32;
                        v269 = arith.add v104, v961 : i32 #[overflow = wrapping];
                        v962 = arith.constant 64 : i32;
                        v267 = arith.add v104, v962 : i32 #[overflow = wrapping];
                        hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<miden_base_sys::bindings::types::Asset as core::convert::From<[miden_stdlib_sys::intrinsics::felt::Felt; 4]>>::from(v267, v269)
                        v960 = arith.constant 64 : i32;
                        v271 = arith.add v104, v960 : i32 #[overflow = wrapping];
                        v272 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/miden_base_sys::bindings::output_note::create(v213, v208, v201, v194, v271) : felt
                        v276 = arith.constant 12 : i32;
                        v958 = arith.constant 8 : i32;
                        v959 = arith.constant 20 : i32;
                        v274 = arith.add v104, v959 : i32 #[overflow = wrapping];
                        hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index(v104, v274, v958, v276)
                        v957 = arith.constant 4 : u32;
                        v277 = hir.bitcast v104 : u32;
                        v279 = arith.add v277, v957 : u32 #[overflow = checked];
                        v956 = arith.constant 4 : u32;
                        v281 = arith.mod v279, v956 : u32;
                        hir.assertz v281 #[code = 250];
                        v282 = hir.int_to_ptr v279 : ptr<byte, i32>;
                        v283 = hir.load v282 : i32;
                        v954 = arith.constant 0 : i32;
                        v955 = arith.constant 4 : i32;
                        v285 = arith.neq v283, v955 : i1;
                        v286 = arith.zext v285 : u32;
                        v287 = hir.bitcast v286 : i32;
                        v289 = arith.neq v287, v954 : i1;
                        scf.if v289{
                        ^block125:
                            scf.yield ;
                        } else {
                        ^block34:
                            v290 = hir.bitcast v104 : u32;
                            v953 = arith.constant 4 : u32;
                            v292 = arith.mod v290, v953 : u32;
                            hir.assertz v292 #[code = 250];
                            v293 = hir.int_to_ptr v290 : ptr<byte, i32>;
                            v294 = hir.load v293 : i32;
                            v295 = hir.bitcast v294 : u32;
                            v952 = arith.constant 4 : u32;
                            v297 = arith.mod v295, v952 : u32;
                            hir.assertz v297 #[code = 250];
                            v298 = hir.int_to_ptr v295 : ptr<byte, i64>;
                            v299 = hir.load v298 : i64;
                            v951 = arith.constant 8 : i32;
                            v305 = arith.add v294, v951 : i32 #[overflow = wrapping];
                            v306 = hir.bitcast v305 : u32;
                            v950 = arith.constant 4 : u32;
                            v308 = arith.mod v306, v950 : u32;
                            hir.assertz v308 #[code = 250];
                            v309 = hir.int_to_ptr v306 : ptr<byte, i64>;
                            v310 = hir.load v309 : i64;
                            v949 = arith.constant 8 : i32;
                            v300 = arith.constant 48 : i32;
                            v301 = arith.add v104, v300 : i32 #[overflow = wrapping];
                            v303 = arith.add v301, v949 : i32 #[overflow = wrapping];
                            v311 = hir.bitcast v303 : u32;
                            v948 = arith.constant 8 : u32;
                            v313 = arith.mod v311, v948 : u32;
                            hir.assertz v313 #[code = 250];
                            v314 = hir.int_to_ptr v311 : ptr<byte, i64>;
                            hir.store v314, v310;
                            v316 = arith.constant 48 : u32;
                            v315 = hir.bitcast v104 : u32;
                            v317 = arith.add v315, v316 : u32 #[overflow = checked];
                            v947 = arith.constant 8 : u32;
                            v319 = arith.mod v317, v947 : u32;
                            hir.assertz v319 #[code = 250];
                            v320 = hir.int_to_ptr v317 : ptr<byte, i64>;
                            hir.store v320, v299;
                            v945 = arith.constant 48 : i32;
                            v324 = arith.add v104, v945 : i32 #[overflow = wrapping];
                            v946 = arith.constant 64 : i32;
                            v322 = arith.add v104, v946 : i32 #[overflow = wrapping];
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<miden_base_sys::bindings::types::Asset as core::convert::From<[miden_stdlib_sys::intrinsics::felt::Felt; 4]>>::from(v322, v324)
                            v944 = arith.constant 64 : u32;
                            v325 = hir.bitcast v104 : u32;
                            v327 = arith.add v325, v944 : u32 #[overflow = checked];
                            v943 = arith.constant 4 : u32;
                            v329 = arith.mod v327, v943 : u32;
                            hir.assertz v329 #[code = 250];
                            v330 = hir.int_to_ptr v327 : ptr<byte, felt>;
                            v331 = hir.load v330 : felt;
                            v942 = arith.constant 68 : u32;
                            v332 = hir.bitcast v104 : u32;
                            v334 = arith.add v332, v942 : u32 #[overflow = checked];
                            v941 = arith.constant 4 : u32;
                            v336 = arith.mod v334, v941 : u32;
                            hir.assertz v336 #[code = 250];
                            v337 = hir.int_to_ptr v334 : ptr<byte, felt>;
                            v338 = hir.load v337 : felt;
                            v940 = arith.constant 72 : u32;
                            v339 = hir.bitcast v104 : u32;
                            v341 = arith.add v339, v940 : u32 #[overflow = checked];
                            v939 = arith.constant 4 : u32;
                            v343 = arith.mod v341, v939 : u32;
                            hir.assertz v343 #[code = 250];
                            v344 = hir.int_to_ptr v341 : ptr<byte, felt>;
                            v345 = hir.load v344 : felt;
                            v347 = arith.constant 76 : u32;
                            v346 = hir.bitcast v104 : u32;
                            v348 = arith.add v346, v347 : u32 #[overflow = checked];
                            v938 = arith.constant 4 : u32;
                            v350 = arith.mod v348, v938 : u32;
                            hir.assertz v350 #[code = 250];
                            v351 = hir.int_to_ptr v348 : ptr<byte, felt>;
                            v352 = hir.load v351 : felt;
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/basic_wallet_tx_script::bindings::miden::basic_wallet::basic_wallet::move_asset_to_note::wit_import9(v331, v338, v345, v352, v272)
                            v936 = arith.constant 4 : i32;
                            v937 = arith.constant 20 : i32;
                            v354 = arith.add v104, v937 : i32 #[overflow = wrapping];
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/alloc::raw_vec::RawVecInner<A>::deallocate(v354, v936, v936)
                            v935 = arith.constant 80 : i32;
                            v358 = arith.add v104, v935 : i32 #[overflow = wrapping];
                            v359 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
                            v360 = hir.bitcast v359 : ptr<byte, i32>;
                            hir.store v360, v358;
                            scf.yield ;
                        };
                        v922 = arith.constant 1 : u32;
                        v934 = arith.constant 0 : u32;
                        v932 = cf.select v289, v934, v922 : u32;
                        scf.yield v932;
                    };
                    scf.yield v928;
                };
                scf.yield v926;
            };
            v933 = arith.constant 0 : u32;
            v931 = arith.eq v924, v933 : i1;
            cf.cond_br v931 ^block29, ^block129;
        ^block29:
            ub.unreachable ;
        ^block129:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block35:
            builtin.ret ;
        };

        private builtin.function @wit_bindgen::rt::run_ctors_once() {
        ^block37:
            v374 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
            v375 = hir.bitcast v374 : ptr<byte, i32>;
            v376 = hir.load v375 : i32;
            v377 = arith.constant 1048620 : i32;
            v378 = arith.add v376, v377 : i32 #[overflow = wrapping];
            v379 = hir.bitcast v378 : u32;
            v380 = hir.int_to_ptr v379 : ptr<byte, u8>;
            v381 = hir.load v380 : u8;
            v373 = arith.constant 0 : i32;
            v382 = arith.zext v381 : u32;
            v383 = hir.bitcast v382 : i32;
            v385 = arith.neq v383, v373 : i1;
            scf.if v385{
            ^block39:
                scf.yield ;
            } else {
            ^block40:
                v386 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/GOT.data.internal.__memory_base : ptr<byte, u8>
                v387 = hir.bitcast v386 : ptr<byte, i32>;
                v388 = hir.load v387 : i32;
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__wasm_call_ctors()
                v997 = arith.constant 1 : u8;
                v999 = arith.constant 1048620 : i32;
                v390 = arith.add v388, v999 : i32 #[overflow = wrapping];
                v394 = hir.bitcast v390 : u32;
                v395 = hir.int_to_ptr v394 : ptr<byte, u8>;
                hir.store v395, v997;
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v396: i32, v397: i32, v398: i32) -> i32 {
        ^block41(v396: i32, v397: i32, v398: i32):
            v401 = arith.constant 16 : i32;
            v400 = arith.constant 0 : i32;
            v1001 = arith.constant 16 : u32;
            v403 = hir.bitcast v397 : u32;
            v405 = arith.gt v403, v1001 : i1;
            v406 = arith.zext v405 : u32;
            v407 = hir.bitcast v406 : i32;
            v409 = arith.neq v407, v400 : i1;
            v410 = cf.select v409, v397, v401 : i32;
            v1041 = arith.constant 0 : i32;
            v411 = arith.constant -1 : i32;
            v412 = arith.add v410, v411 : i32 #[overflow = wrapping];
            v413 = arith.band v410, v412 : i32;
            v415 = arith.neq v413, v1041 : i1;
            v1010, v1011 = scf.if v415 : i32, u32 {
            ^block137:
                v1002 = arith.constant 0 : u32;
                v1006 = ub.poison i32 : i32;
                scf.yield v1006, v1002;
            } else {
            ^block44:
                v417 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/core::ptr::alignment::Alignment::max(v397, v410) : i32
                v1040 = arith.constant 0 : i32;
                v416 = arith.constant -2147483648 : i32;
                v418 = arith.sub v416, v417 : i32 #[overflow = wrapping];
                v420 = hir.bitcast v418 : u32;
                v419 = hir.bitcast v398 : u32;
                v421 = arith.gt v419, v420 : i1;
                v422 = arith.zext v421 : u32;
                v423 = hir.bitcast v422 : i32;
                v425 = arith.neq v423, v1040 : i1;
                v1025 = scf.if v425 : i32 {
                ^block136:
                    v1039 = ub.poison i32 : i32;
                    scf.yield v1039;
                } else {
                ^block45:
                    v1037 = arith.constant 0 : i32;
                    v431 = arith.sub v1037, v417 : i32 #[overflow = wrapping];
                    v1038 = arith.constant -1 : i32;
                    v427 = arith.add v398, v417 : i32 #[overflow = wrapping];
                    v429 = arith.add v427, v1038 : i32 #[overflow = wrapping];
                    v432 = arith.band v429, v431 : i32;
                    v433 = hir.bitcast v396 : u32;
                    v434 = arith.constant 4 : u32;
                    v435 = arith.mod v433, v434 : u32;
                    hir.assertz v435 #[code = 250];
                    v436 = hir.int_to_ptr v433 : ptr<byte, i32>;
                    v437 = hir.load v436 : i32;
                    v1036 = arith.constant 0 : i32;
                    v439 = arith.neq v437, v1036 : i1;
                    scf.if v439{
                    ^block135:
                        scf.yield ;
                    } else {
                    ^block47:
                        v440 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/intrinsics::mem::heap_base() : i32
                        v441 = hir.mem_size  : u32;
                        v447 = hir.bitcast v396 : u32;
                        v1035 = arith.constant 4 : u32;
                        v449 = arith.mod v447, v1035 : u32;
                        hir.assertz v449 #[code = 250];
                        v1034 = arith.constant 16 : u32;
                        v442 = hir.bitcast v441 : i32;
                        v445 = arith.shl v442, v1034 : i32;
                        v446 = arith.add v440, v445 : i32 #[overflow = wrapping];
                        v450 = hir.int_to_ptr v447 : ptr<byte, i32>;
                        hir.store v450, v446;
                        scf.yield ;
                    };
                    v453 = hir.bitcast v396 : u32;
                    v1033 = arith.constant 4 : u32;
                    v455 = arith.mod v453, v1033 : u32;
                    hir.assertz v455 #[code = 250];
                    v456 = hir.int_to_ptr v453 : ptr<byte, i32>;
                    v457 = hir.load v456 : i32;
                    v1031 = arith.constant 0 : i32;
                    v1032 = arith.constant -1 : i32;
                    v459 = arith.bxor v457, v1032 : i32;
                    v461 = hir.bitcast v459 : u32;
                    v460 = hir.bitcast v432 : u32;
                    v462 = arith.gt v460, v461 : i1;
                    v463 = arith.zext v462 : u32;
                    v464 = hir.bitcast v463 : i32;
                    v466 = arith.neq v464, v1031 : i1;
                    v1024 = scf.if v466 : i32 {
                    ^block48:
                        v1030 = arith.constant 0 : i32;
                        scf.yield v1030;
                    } else {
                    ^block49:
                        v468 = hir.bitcast v396 : u32;
                        v1029 = arith.constant 4 : u32;
                        v470 = arith.mod v468, v1029 : u32;
                        hir.assertz v470 #[code = 250];
                        v467 = arith.add v457, v432 : i32 #[overflow = wrapping];
                        v471 = hir.int_to_ptr v468 : ptr<byte, i32>;
                        hir.store v471, v467;
                        v473 = arith.add v457, v417 : i32 #[overflow = wrapping];
                        scf.yield v473;
                    };
                    scf.yield v1024;
                };
                v1007 = arith.constant 1 : u32;
                v1028 = arith.constant 0 : u32;
                v1026 = cf.select v425, v1028, v1007 : u32;
                scf.yield v1025, v1026;
            };
            v1027 = arith.constant 0 : u32;
            v1023 = arith.eq v1011, v1027 : i1;
            cf.cond_br v1023 ^block43, ^block139(v1010);
        ^block43:
            ub.unreachable ;
        ^block139(v1003: i32):
            builtin.ret v1003;
        };

        private builtin.function @intrinsics::mem::heap_base() -> i32 {
        ^block50:
            v476 = hir.exec @intrinsics/mem/heap_base() : i32
            builtin.ret v476;
        };

        private builtin.function @miden_base_sys::bindings::output_note::create(v478: felt, v479: felt, v480: felt, v481: felt, v482: i32) -> felt {
        ^block54(v478: felt, v479: felt, v480: felt, v481: felt, v482: i32):
            v485 = arith.constant 12 : u32;
            v484 = hir.bitcast v482 : u32;
            v486 = arith.add v484, v485 : u32 #[overflow = checked];
            v487 = arith.constant 4 : u32;
            v488 = arith.mod v486, v487 : u32;
            hir.assertz v488 #[code = 250];
            v489 = hir.int_to_ptr v486 : ptr<byte, felt>;
            v490 = hir.load v489 : felt;
            v492 = arith.constant 8 : u32;
            v491 = hir.bitcast v482 : u32;
            v493 = arith.add v491, v492 : u32 #[overflow = checked];
            v1045 = arith.constant 4 : u32;
            v495 = arith.mod v493, v1045 : u32;
            hir.assertz v495 #[code = 250];
            v496 = hir.int_to_ptr v493 : ptr<byte, felt>;
            v497 = hir.load v496 : felt;
            v1044 = arith.constant 4 : u32;
            v498 = hir.bitcast v482 : u32;
            v500 = arith.add v498, v1044 : u32 #[overflow = checked];
            v1043 = arith.constant 4 : u32;
            v502 = arith.mod v500, v1043 : u32;
            hir.assertz v502 #[code = 250];
            v503 = hir.int_to_ptr v500 : ptr<byte, felt>;
            v504 = hir.load v503 : felt;
            v505 = hir.bitcast v482 : u32;
            v1042 = arith.constant 4 : u32;
            v507 = arith.mod v505, v1042 : u32;
            hir.assertz v507 #[code = 250];
            v508 = hir.int_to_ptr v505 : ptr<byte, felt>;
            v509 = hir.load v508 : felt;
            v510 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/miden::output_note::create(v478, v479, v480, v481, v490, v497, v504, v509) : felt
            builtin.ret v510;
        };

        private builtin.function @<miden_base_sys::bindings::types::Asset as core::convert::From<[miden_stdlib_sys::intrinsics::felt::Felt; 4]>>::from(v511: i32, v512: i32) {
        ^block56(v511: i32, v512: i32):
            v514 = arith.constant 8 : u32;
            v513 = hir.bitcast v512 : u32;
            v515 = arith.add v513, v514 : u32 #[overflow = checked];
            v516 = arith.constant 4 : u32;
            v517 = arith.mod v515, v516 : u32;
            hir.assertz v517 #[code = 250];
            v518 = hir.int_to_ptr v515 : ptr<byte, i64>;
            v519 = hir.load v518 : i64;
            v1049 = arith.constant 8 : u32;
            v520 = hir.bitcast v511 : u32;
            v522 = arith.add v520, v1049 : u32 #[overflow = checked];
            v1048 = arith.constant 8 : u32;
            v524 = arith.mod v522, v1048 : u32;
            hir.assertz v524 #[code = 250];
            v525 = hir.int_to_ptr v522 : ptr<byte, i64>;
            hir.store v525, v519;
            v526 = hir.bitcast v512 : u32;
            v1047 = arith.constant 4 : u32;
            v528 = arith.mod v526, v1047 : u32;
            hir.assertz v528 #[code = 250];
            v529 = hir.int_to_ptr v526 : ptr<byte, i64>;
            v530 = hir.load v529 : i64;
            v531 = hir.bitcast v511 : u32;
            v1046 = arith.constant 8 : u32;
            v533 = arith.mod v531, v1046 : u32;
            hir.assertz v533 #[code = 250];
            v534 = hir.int_to_ptr v531 : ptr<byte, i64>;
            hir.store v534, v530;
            builtin.ret ;
        };

        private builtin.function @intrinsics::felt::from_u64_unchecked(v535: i64) -> felt {
        ^block58(v535: i64):
            v536 = hir.cast v535 : felt;
            builtin.ret v536;
        };

        private builtin.function @intrinsics::felt::from_u32(v538: i32) -> felt {
        ^block60(v538: i32):
            v539 = hir.bitcast v538 : felt;
            builtin.ret v539;
        };

        private builtin.function @intrinsics::felt::as_u64(v541: felt) -> i64 {
        ^block62(v541: felt):
            v542 = hir.cast v541 : i64;
            builtin.ret v542;
        };

        private builtin.function @intrinsics::felt::assert_eq(v544: felt, v545: felt) {
        ^block64(v544: felt, v545: felt):
            hir.assert_eq v544, v545;
            builtin.ret ;
        };

        private builtin.function @intrinsics::advice::adv_push_mapvaln(v546: felt, v547: felt, v548: felt, v549: felt) -> felt {
        ^block66(v546: felt, v547: felt, v548: felt, v549: felt):
            v550 = hir.exec @intrinsics/advice/adv_push_mapvaln(v546, v547, v548, v549) : felt
            builtin.ret v550;
        };

        private builtin.function @std::mem::pipe_preimage_to_memory(v552: felt, v553: i32, v554: felt, v555: felt, v556: felt, v557: felt) -> i32 {
        ^block69(v552: felt, v553: i32, v554: felt, v555: felt, v556: felt, v557: felt):
            v558 = hir.exec @std/mem/pipe_preimage_to_memory(v552, v553, v554, v555, v556, v557) : i32
            builtin.ret v558;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v560: i32, v561: i32, v562: i32) {
        ^block73(v560: i32, v561: i32, v562: i32):
            v564 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v565 = hir.bitcast v564 : ptr<byte, i32>;
            v566 = hir.load v565 : i32;
            v567 = arith.constant 16 : i32;
            v568 = arith.sub v566, v567 : i32 #[overflow = wrapping];
            v569 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v570 = hir.bitcast v569 : ptr<byte, i32>;
            hir.store v570, v568;
            v571 = arith.constant 4 : i32;
            v572 = arith.add v568, v571 : i32 #[overflow = wrapping];
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/alloc::raw_vec::RawVecInner<A>::current_memory(v572, v560, v561, v562)
            v574 = arith.constant 8 : u32;
            v573 = hir.bitcast v568 : u32;
            v575 = arith.add v573, v574 : u32 #[overflow = checked];
            v576 = arith.constant 4 : u32;
            v577 = arith.mod v575, v576 : u32;
            hir.assertz v577 #[code = 250];
            v578 = hir.int_to_ptr v575 : ptr<byte, i32>;
            v579 = hir.load v578 : i32;
            v1056 = arith.constant 0 : i32;
            v563 = arith.constant 0 : i32;
            v581 = arith.eq v579, v563 : i1;
            v582 = arith.zext v581 : u32;
            v583 = hir.bitcast v582 : i32;
            v585 = arith.neq v583, v1056 : i1;
            scf.if v585{
            ^block143:
                scf.yield ;
            } else {
            ^block76:
                v1055 = arith.constant 4 : u32;
                v586 = hir.bitcast v568 : u32;
                v588 = arith.add v586, v1055 : u32 #[overflow = checked];
                v1054 = arith.constant 4 : u32;
                v590 = arith.mod v588, v1054 : u32;
                hir.assertz v590 #[code = 250];
                v591 = hir.int_to_ptr v588 : ptr<byte, i32>;
                v592 = hir.load v591 : i32;
                v594 = arith.constant 12 : u32;
                v593 = hir.bitcast v568 : u32;
                v595 = arith.add v593, v594 : u32 #[overflow = checked];
                v1053 = arith.constant 4 : u32;
                v597 = arith.mod v595, v1053 : u32;
                hir.assertz v597 #[code = 250];
                v598 = hir.int_to_ptr v595 : ptr<byte, i32>;
                v599 = hir.load v598 : i32;
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v592, v579, v599)
                scf.yield ;
            };
            v1052 = arith.constant 16 : i32;
            v602 = arith.add v568, v1052 : i32 #[overflow = wrapping];
            v603 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v604 = hir.bitcast v603 : ptr<byte, i32>;
            hir.store v604, v602;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::try_allocate_in(v605: i32, v606: i32, v607: i32, v608: i32, v609: i32) {
        ^block77(v605: i32, v606: i32, v607: i32, v608: i32, v609: i32):
            v612 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v613 = hir.bitcast v612 : ptr<byte, i32>;
            v614 = hir.load v613 : i32;
            v615 = arith.constant 16 : i32;
            v616 = arith.sub v614, v615 : i32 #[overflow = wrapping];
            v617 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v618 = hir.bitcast v617 : ptr<byte, i32>;
            hir.store v618, v616;
            v628 = hir.bitcast v606 : u32;
            v629 = arith.zext v628 : u64;
            v630 = hir.bitcast v629 : i64;
            v610 = arith.constant 0 : i32;
            v623 = arith.sub v610, v608 : i32 #[overflow = wrapping];
            v620 = arith.constant -1 : i32;
            v619 = arith.add v608, v609 : i32 #[overflow = wrapping];
            v621 = arith.add v619, v620 : i32 #[overflow = wrapping];
            v624 = arith.band v621, v623 : i32;
            v625 = hir.bitcast v624 : u32;
            v626 = arith.zext v625 : u64;
            v627 = hir.bitcast v626 : i64;
            v631 = arith.mul v627, v630 : i64 #[overflow = wrapping];
            v1160 = arith.constant 0 : i32;
            v632 = arith.constant 32 : i64;
            v634 = hir.cast v632 : u32;
            v633 = hir.bitcast v631 : u64;
            v635 = arith.shr v633, v634 : u64;
            v636 = hir.bitcast v635 : i64;
            v637 = arith.trunc v636 : i32;
            v639 = arith.neq v637, v1160 : i1;
            v1072, v1073, v1074, v1075, v1076, v1077 = scf.if v639 : i32, i32, i32, i32, i32, u32 {
            ^block145:
                v1057 = arith.constant 0 : u32;
                v1064 = ub.poison i32 : i32;
                scf.yield v605, v616, v1064, v1064, v1064, v1057;
            } else {
            ^block82:
                v640 = arith.trunc v631 : i32;
                v1159 = arith.constant 0 : i32;
                v641 = arith.constant -2147483648 : i32;
                v642 = arith.sub v641, v608 : i32 #[overflow = wrapping];
                v644 = hir.bitcast v642 : u32;
                v643 = hir.bitcast v640 : u32;
                v645 = arith.lte v643, v644 : i1;
                v646 = arith.zext v645 : u32;
                v647 = hir.bitcast v646 : i32;
                v649 = arith.neq v647, v1159 : i1;
                v1120 = scf.if v649 : i32 {
                ^block80:
                    v1158 = arith.constant 0 : i32;
                    v660 = arith.neq v640, v1158 : i1;
                    v1119 = scf.if v660 : i32 {
                    ^block84:
                        v1157 = arith.constant 0 : i32;
                        v676 = arith.neq v607, v1157 : i1;
                        v1118 = scf.if v676 : i32 {
                        ^block87:
                            v658 = arith.constant 1 : i32;
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/alloc::alloc::Global::alloc_impl(v616, v608, v640, v658)
                            v687 = hir.bitcast v616 : u32;
                            v732 = arith.constant 4 : u32;
                            v689 = arith.mod v687, v732 : u32;
                            hir.assertz v689 #[code = 250];
                            v690 = hir.int_to_ptr v687 : ptr<byte, i32>;
                            v691 = hir.load v690 : i32;
                            scf.yield v691;
                        } else {
                        ^block88:
                            v677 = arith.constant 8 : i32;
                            v678 = arith.add v616, v677 : i32 #[overflow = wrapping];
                            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v678, v608, v640)
                            v662 = arith.constant 8 : u32;
                            v679 = hir.bitcast v616 : u32;
                            v681 = arith.add v679, v662 : u32 #[overflow = checked];
                            v1156 = arith.constant 4 : u32;
                            v683 = arith.mod v681, v1156 : u32;
                            hir.assertz v683 #[code = 250];
                            v684 = hir.int_to_ptr v681 : ptr<byte, i32>;
                            v685 = hir.load v684 : i32;
                            scf.yield v685;
                        };
                        v1154 = arith.constant 0 : i32;
                        v1155 = arith.constant 0 : i32;
                        v694 = arith.eq v1118, v1155 : i1;
                        v695 = arith.zext v694 : u32;
                        v696 = hir.bitcast v695 : i32;
                        v698 = arith.neq v696, v1154 : i1;
                        scf.if v698{
                        ^block89:
                            v1153 = arith.constant 8 : u32;
                            v715 = hir.bitcast v605 : u32;
                            v717 = arith.add v715, v1153 : u32 #[overflow = checked];
                            v1152 = arith.constant 4 : u32;
                            v719 = arith.mod v717, v1152 : u32;
                            hir.assertz v719 #[code = 250];
                            v720 = hir.int_to_ptr v717 : ptr<byte, i32>;
                            hir.store v720, v640;
                            v1151 = arith.constant 4 : u32;
                            v722 = hir.bitcast v605 : u32;
                            v724 = arith.add v722, v1151 : u32 #[overflow = checked];
                            v1150 = arith.constant 4 : u32;
                            v726 = arith.mod v724, v1150 : u32;
                            hir.assertz v726 #[code = 250];
                            v727 = hir.int_to_ptr v724 : ptr<byte, i32>;
                            hir.store v727, v608;
                            scf.yield ;
                        } else {
                        ^block90:
                            v1149 = arith.constant 8 : u32;
                            v700 = hir.bitcast v605 : u32;
                            v702 = arith.add v700, v1149 : u32 #[overflow = checked];
                            v1148 = arith.constant 4 : u32;
                            v704 = arith.mod v702, v1148 : u32;
                            hir.assertz v704 #[code = 250];
                            v705 = hir.int_to_ptr v702 : ptr<byte, i32>;
                            hir.store v705, v1118;
                            v1147 = arith.constant 4 : u32;
                            v707 = hir.bitcast v605 : u32;
                            v709 = arith.add v707, v1147 : u32 #[overflow = checked];
                            v1146 = arith.constant 4 : u32;
                            v711 = arith.mod v709, v1146 : u32;
                            hir.assertz v711 #[code = 250];
                            v712 = hir.int_to_ptr v709 : ptr<byte, i32>;
                            hir.store v712, v606;
                            scf.yield ;
                        };
                        v1144 = arith.constant 0 : i32;
                        v1145 = arith.constant 1 : i32;
                        v1117 = cf.select v698, v1145, v1144 : i32;
                        scf.yield v1117;
                    } else {
                    ^block85:
                        v1143 = arith.constant 8 : u32;
                        v661 = hir.bitcast v605 : u32;
                        v663 = arith.add v661, v1143 : u32 #[overflow = checked];
                        v1142 = arith.constant 4 : u32;
                        v665 = arith.mod v663, v1142 : u32;
                        hir.assertz v665 #[code = 250];
                        v666 = hir.int_to_ptr v663 : ptr<byte, i32>;
                        hir.store v666, v608;
                        v1141 = arith.constant 4 : u32;
                        v669 = hir.bitcast v605 : u32;
                        v671 = arith.add v669, v1141 : u32 #[overflow = checked];
                        v1140 = arith.constant 4 : u32;
                        v673 = arith.mod v671, v1140 : u32;
                        hir.assertz v673 #[code = 250];
                        v1139 = arith.constant 0 : i32;
                        v674 = hir.int_to_ptr v671 : ptr<byte, i32>;
                        hir.store v674, v1139;
                        v1138 = arith.constant 0 : i32;
                        scf.yield v1138;
                    };
                    scf.yield v1119;
                } else {
                ^block83:
                    v1137 = ub.poison i32 : i32;
                    scf.yield v1137;
                };
                v1132 = arith.constant 0 : u32;
                v1065 = arith.constant 1 : u32;
                v1125 = cf.select v649, v1065, v1132 : u32;
                v1133 = ub.poison i32 : i32;
                v1124 = cf.select v649, v616, v1133 : i32;
                v1134 = ub.poison i32 : i32;
                v1123 = cf.select v649, v605, v1134 : i32;
                v1135 = ub.poison i32 : i32;
                v1122 = cf.select v649, v1135, v616 : i32;
                v1136 = ub.poison i32 : i32;
                v1121 = cf.select v649, v1136, v605 : i32;
                scf.yield v1121, v1122, v1123, v1120, v1124, v1125;
            };
            v1078, v1079, v1080 = scf.index_switch v1077 : i32, i32, i32 
            case 0 {
            ^block81:
                v1131 = arith.constant 4 : u32;
                v652 = hir.bitcast v1072 : u32;
                v654 = arith.add v652, v1131 : u32 #[overflow = checked];
                v1130 = arith.constant 4 : u32;
                v656 = arith.mod v654, v1130 : u32;
                hir.assertz v656 #[code = 250];
                v1129 = arith.constant 0 : i32;
                v657 = hir.int_to_ptr v654 : ptr<byte, i32>;
                hir.store v657, v1129;
                v1128 = arith.constant 1 : i32;
                scf.yield v1072, v1128, v1073;
            }
            default {
            ^block149:
                scf.yield v1074, v1075, v1076;
            };
            v731 = hir.bitcast v1078 : u32;
            v1127 = arith.constant 4 : u32;
            v733 = arith.mod v731, v1127 : u32;
            hir.assertz v733 #[code = 250];
            v734 = hir.int_to_ptr v731 : ptr<byte, i32>;
            hir.store v734, v1079;
            v1126 = arith.constant 16 : i32;
            v739 = arith.add v1080, v1126 : i32 #[overflow = wrapping];
            v740 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v741 = hir.bitcast v740 : ptr<byte, i32>;
            hir.store v741, v739;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v742: i32, v743: i32, v744: i32) {
        ^block91(v742: i32, v743: i32, v744: i32):
            v746 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v747 = hir.bitcast v746 : ptr<byte, i32>;
            v748 = hir.load v747 : i32;
            v749 = arith.constant 16 : i32;
            v750 = arith.sub v748, v749 : i32 #[overflow = wrapping];
            v751 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v752 = hir.bitcast v751 : ptr<byte, i32>;
            hir.store v752, v750;
            v745 = arith.constant 0 : i32;
            v753 = arith.constant 8 : i32;
            v754 = arith.add v750, v753 : i32 #[overflow = wrapping];
            hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/alloc::alloc::Global::alloc_impl(v754, v743, v744, v745)
            v757 = arith.constant 12 : u32;
            v756 = hir.bitcast v750 : u32;
            v758 = arith.add v756, v757 : u32 #[overflow = checked];
            v759 = arith.constant 4 : u32;
            v760 = arith.mod v758, v759 : u32;
            hir.assertz v760 #[code = 250];
            v761 = hir.int_to_ptr v758 : ptr<byte, i32>;
            v762 = hir.load v761 : i32;
            v764 = arith.constant 8 : u32;
            v763 = hir.bitcast v750 : u32;
            v765 = arith.add v763, v764 : u32 #[overflow = checked];
            v1165 = arith.constant 4 : u32;
            v767 = arith.mod v765, v1165 : u32;
            hir.assertz v767 #[code = 250];
            v768 = hir.int_to_ptr v765 : ptr<byte, i32>;
            v769 = hir.load v768 : i32;
            v770 = hir.bitcast v742 : u32;
            v1164 = arith.constant 4 : u32;
            v772 = arith.mod v770, v1164 : u32;
            hir.assertz v772 #[code = 250];
            v773 = hir.int_to_ptr v770 : ptr<byte, i32>;
            hir.store v773, v769;
            v1163 = arith.constant 4 : u32;
            v774 = hir.bitcast v742 : u32;
            v776 = arith.add v774, v1163 : u32 #[overflow = checked];
            v1162 = arith.constant 4 : u32;
            v778 = arith.mod v776, v1162 : u32;
            hir.assertz v778 #[code = 250];
            v779 = hir.int_to_ptr v776 : ptr<byte, i32>;
            hir.store v779, v762;
            v1161 = arith.constant 16 : i32;
            v781 = arith.add v750, v1161 : i32 #[overflow = wrapping];
            v782 = builtin.global_symbol @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__stack_pointer : ptr<byte, u8>
            v783 = hir.bitcast v782 : ptr<byte, i32>;
            hir.store v783, v781;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v784: i32, v785: i32, v786: i32, v787: i32) {
        ^block93(v784: i32, v785: i32, v786: i32, v787: i32):
            v1181 = arith.constant 0 : i32;
            v788 = arith.constant 0 : i32;
            v789 = arith.eq v786, v788 : i1;
            v790 = arith.zext v789 : u32;
            v791 = hir.bitcast v790 : i32;
            v793 = arith.neq v791, v1181 : i1;
            v1177 = scf.if v793 : i32 {
            ^block152:
                scf.yield v785;
            } else {
            ^block96:
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__rustc::__rust_no_alloc_shim_is_unstable_v2()
                v1180 = arith.constant 0 : i32;
                v795 = arith.neq v787, v1180 : i1;
                v1176 = scf.if v795 : i32 {
                ^block97:
                    v797 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__rustc::__rust_alloc_zeroed(v786, v785) : i32
                    scf.yield v797;
                } else {
                ^block98:
                    v796 = hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__rustc::__rust_alloc(v786, v785) : i32
                    scf.yield v796;
                };
                scf.yield v1176;
            };
            v801 = arith.constant 4 : u32;
            v800 = hir.bitcast v784 : u32;
            v802 = arith.add v800, v801 : u32 #[overflow = checked];
            v1179 = arith.constant 4 : u32;
            v804 = arith.mod v802, v1179 : u32;
            hir.assertz v804 #[code = 250];
            v805 = hir.int_to_ptr v802 : ptr<byte, i32>;
            hir.store v805, v786;
            v807 = hir.bitcast v784 : u32;
            v1178 = arith.constant 4 : u32;
            v809 = arith.mod v807, v1178 : u32;
            hir.assertz v809 #[code = 250];
            v810 = hir.int_to_ptr v807 : ptr<byte, i32>;
            hir.store v810, v1177;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v811: i32, v812: i32, v813: i32, v814: i32) {
        ^block99(v811: i32, v812: i32, v813: i32, v814: i32):
            v1207 = arith.constant 0 : i32;
            v815 = arith.constant 0 : i32;
            v819 = arith.eq v814, v815 : i1;
            v820 = arith.zext v819 : u32;
            v821 = hir.bitcast v820 : i32;
            v823 = arith.neq v821, v1207 : i1;
            v1194, v1195 = scf.if v823 : i32, i32 {
            ^block156:
                v1206 = arith.constant 0 : i32;
                v817 = arith.constant 4 : i32;
                scf.yield v817, v1206;
            } else {
            ^block102:
                v824 = hir.bitcast v812 : u32;
                v859 = arith.constant 4 : u32;
                v826 = arith.mod v824, v859 : u32;
                hir.assertz v826 #[code = 250];
                v827 = hir.int_to_ptr v824 : ptr<byte, i32>;
                v828 = hir.load v827 : i32;
                v1204 = arith.constant 0 : i32;
                v1205 = arith.constant 0 : i32;
                v830 = arith.eq v828, v1205 : i1;
                v831 = arith.zext v830 : u32;
                v832 = hir.bitcast v831 : i32;
                v834 = arith.neq v832, v1204 : i1;
                v1192 = scf.if v834 : i32 {
                ^block155:
                    v1203 = arith.constant 0 : i32;
                    scf.yield v1203;
                } else {
                ^block103:
                    v1202 = arith.constant 4 : u32;
                    v835 = hir.bitcast v811 : u32;
                    v837 = arith.add v835, v1202 : u32 #[overflow = checked];
                    v1201 = arith.constant 4 : u32;
                    v839 = arith.mod v837, v1201 : u32;
                    hir.assertz v839 #[code = 250];
                    v840 = hir.int_to_ptr v837 : ptr<byte, i32>;
                    hir.store v840, v813;
                    v1200 = arith.constant 4 : u32;
                    v841 = hir.bitcast v812 : u32;
                    v843 = arith.add v841, v1200 : u32 #[overflow = checked];
                    v1199 = arith.constant 4 : u32;
                    v845 = arith.mod v843, v1199 : u32;
                    hir.assertz v845 #[code = 250];
                    v846 = hir.int_to_ptr v843 : ptr<byte, i32>;
                    v847 = hir.load v846 : i32;
                    v848 = hir.bitcast v811 : u32;
                    v1198 = arith.constant 4 : u32;
                    v850 = arith.mod v848, v1198 : u32;
                    hir.assertz v850 #[code = 250];
                    v851 = hir.int_to_ptr v848 : ptr<byte, i32>;
                    hir.store v851, v847;
                    v852 = arith.mul v828, v814 : i32 #[overflow = wrapping];
                    scf.yield v852;
                };
                v853 = arith.constant 8 : i32;
                v1197 = arith.constant 4 : i32;
                v1193 = cf.select v834, v1197, v853 : i32;
                scf.yield v1193, v1192;
            };
            v856 = arith.add v811, v1194 : i32 #[overflow = wrapping];
            v858 = hir.bitcast v856 : u32;
            v1196 = arith.constant 4 : u32;
            v860 = arith.mod v858, v1196 : u32;
            hir.assertz v860 #[code = 250];
            v861 = hir.int_to_ptr v858 : ptr<byte, i32>;
            hir.store v861, v1195;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v862: i32, v863: i32, v864: i32) {
        ^block104(v862: i32, v863: i32, v864: i32):
            v1209 = arith.constant 0 : i32;
            v865 = arith.constant 0 : i32;
            v866 = arith.eq v864, v865 : i1;
            v867 = arith.zext v866 : u32;
            v868 = hir.bitcast v867 : i32;
            v870 = arith.neq v868, v1209 : i1;
            scf.if v870{
            ^block106:
                scf.yield ;
            } else {
            ^block107:
                hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/__rustc::__rust_dealloc(v862, v864, v863)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v871: i32, v872: i32, v873: i32) {
        ^block108(v871: i32, v872: i32, v873: i32):
            ub.unreachable ;
        };

        private builtin.function @core::slice::<impl [T]>::copy_from_slice::len_mismatch_fail::do_panic::runtime(v874: i32, v875: i32, v876: i32) {
        ^block110(v874: i32, v875: i32, v876: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v877: i32, v878: i32) -> i32 {
        ^block112(v877: i32, v878: i32):
            v885 = arith.constant 0 : i32;
            v881 = hir.bitcast v878 : u32;
            v880 = hir.bitcast v877 : u32;
            v882 = arith.gt v880, v881 : i1;
            v883 = arith.zext v882 : u32;
            v884 = hir.bitcast v883 : i32;
            v886 = arith.neq v884, v885 : i1;
            v887 = cf.select v886, v877, v878 : i32;
            builtin.ret v887;
        };

        private builtin.function @miden::output_note::create(v888: felt, v889: felt, v890: felt, v891: felt, v892: felt, v893: felt, v894: felt, v895: felt) -> felt {
        ^block114(v888: felt, v889: felt, v890: felt, v891: felt, v892: felt, v893: felt, v894: felt, v895: felt):
            v896 = hir.exec @miden/output_note/create(v888, v889, v890, v891, v892, v893, v894, v895) : felt
            builtin.ret v896;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.global_variable private @#GOT.data.internal.__memory_base : i32 {
            builtin.ret_imm 0;
        };

        builtin.segment readonly @1048576 = 0x003e64657463616465723c;

        builtin.segment @1048588 = 0x00000000000000000000000a00100000000000010000000100000001;
    };

    public builtin.function @run(v898: felt, v899: felt, v900: felt, v901: felt) {
    ^block118(v898: felt, v899: felt, v900: felt, v901: felt):
        hir.exec @miden:base/transaction-script@1.0.0/basic_wallet_tx_script/miden:base/transaction-script@1.0.0#run(v898, v899, v900, v901)
        builtin.ret ;
    };
};