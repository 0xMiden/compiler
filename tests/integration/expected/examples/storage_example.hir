builtin.component miden:storage-example/foo@1.0.0 {
    builtin.module public @storage_example {
        private builtin.function @__wasm_call_ctors() {
        ^block5:
            builtin.ret ;
        };

        private builtin.function @storage_example::bindings::__link_custom_section_describing_imports() {
        ^block7:
            builtin.ret ;
        };

        private builtin.function @miden:storage-example/foo@1.0.0#get-asset-qty(v0: felt, v1: felt, v2: felt, v3: felt) -> felt {
        ^block9(v0: felt, v1: felt, v2: felt, v3: felt):
            v6 = builtin.global_symbol @miden:storage-example/foo@1.0.0/storage_example/__stack_pointer : ptr<byte, u8>
            v7 = hir.bitcast v6 : ptr<byte, i32>;
            v8 = hir.load v7 : i32;
            v9 = arith.constant 48 : i32;
            v10 = arith.sub v8, v9 : i32 #[overflow = wrapping];
            v11 = builtin.global_symbol @miden:storage-example/foo@1.0.0/storage_example/__stack_pointer : ptr<byte, u8>
            v12 = hir.bitcast v11 : ptr<byte, i32>;
            hir.store v12, v10;
            hir.exec @miden:storage-example/foo@1.0.0/storage_example/wit_bindgen::rt::run_ctors_once()
            v13 = arith.constant 1 : i32;
            v14 = hir.exec @miden:storage-example/foo@1.0.0/storage_example/<miden_felt::wasm32::Felt as core::convert::From<u8>>::from(v13) : felt
            v15 = arith.constant 16 : i32;
            v16 = arith.add v10, v15 : i32 #[overflow = wrapping];
            hir.exec @miden:storage-example/foo@1.0.0/storage_example/miden::active_account::get_map_item(v14, v3, v2, v1, v0, v16)
            v18 = arith.constant 24 : u32;
            v17 = hir.bitcast v10 : u32;
            v19 = arith.add v17, v18 : u32 #[overflow = checked];
            v20 = arith.constant 8 : u32;
            v21 = arith.mod v19, v20 : u32;
            hir.assertz v21 #[code = 250];
            v22 = hir.int_to_ptr v19 : ptr<byte, i64>;
            v23 = hir.load v22 : i64;
            v25 = arith.constant 40 : u32;
            v24 = hir.bitcast v10 : u32;
            v26 = arith.add v24, v25 : u32 #[overflow = checked];
            v505 = arith.constant 8 : u32;
            v28 = arith.mod v26, v505 : u32;
            hir.assertz v28 #[code = 250];
            v29 = hir.int_to_ptr v26 : ptr<byte, i64>;
            hir.store v29, v23;
            v31 = arith.constant 16 : u32;
            v30 = hir.bitcast v10 : u32;
            v32 = arith.add v30, v31 : u32 #[overflow = checked];
            v504 = arith.constant 8 : u32;
            v34 = arith.mod v32, v504 : u32;
            hir.assertz v34 #[code = 250];
            v35 = hir.int_to_ptr v32 : ptr<byte, i64>;
            v36 = hir.load v35 : i64;
            v38 = arith.constant 32 : u32;
            v37 = hir.bitcast v10 : u32;
            v39 = arith.add v37, v38 : u32 #[overflow = checked];
            v503 = arith.constant 8 : u32;
            v41 = arith.mod v39, v503 : u32;
            hir.assertz v41 #[code = 250];
            v42 = hir.int_to_ptr v39 : ptr<byte, i64>;
            hir.store v42, v36;
            v43 = arith.constant 32 : i32;
            v44 = arith.add v10, v43 : i32 #[overflow = wrapping];
            hir.exec @miden:storage-example/foo@1.0.0/storage_example/<miden_stdlib_sys::intrinsics::word::Word>::reverse(v10, v44)
            v46 = arith.constant 12 : u32;
            v45 = hir.bitcast v10 : u32;
            v47 = arith.add v45, v46 : u32 #[overflow = checked];
            v48 = arith.constant 4 : u32;
            v49 = arith.mod v47, v48 : u32;
            hir.assertz v49 #[code = 250];
            v50 = hir.int_to_ptr v47 : ptr<byte, felt>;
            v51 = hir.load v50 : felt;
            v502 = arith.constant 48 : i32;
            v53 = arith.add v10, v502 : i32 #[overflow = wrapping];
            v54 = builtin.global_symbol @miden:storage-example/foo@1.0.0/storage_example/__stack_pointer : ptr<byte, u8>
            v55 = hir.bitcast v54 : ptr<byte, i32>;
            hir.store v55, v53;
            builtin.ret v51;
        };

        private builtin.function @miden:storage-example/foo@1.0.0#set-asset-qty(v56: felt, v57: felt, v58: felt, v59: felt, v60: felt, v61: felt, v62: felt, v63: felt, v64: felt) {
        ^block11(v56: felt, v57: felt, v58: felt, v59: felt, v60: felt, v61: felt, v62: felt, v63: felt, v64: felt):
            v67 = builtin.global_symbol @miden:storage-example/foo@1.0.0/storage_example/__stack_pointer : ptr<byte, u8>
            v68 = hir.bitcast v67 : ptr<byte, i32>;
            v69 = hir.load v68 : i32;
            v70 = arith.constant 128 : i32;
            v71 = arith.sub v69, v70 : i32 #[overflow = wrapping];
            v72 = builtin.global_symbol @miden:storage-example/foo@1.0.0/storage_example/__stack_pointer : ptr<byte, u8>
            v73 = hir.bitcast v72 : ptr<byte, i32>;
            hir.store v73, v71;
            hir.exec @miden:storage-example/foo@1.0.0/storage_example/wit_bindgen::rt::run_ctors_once()
            v65 = arith.constant 0 : i32;
            v75 = hir.exec @miden:storage-example/foo@1.0.0/storage_example/<miden_felt::wasm32::Felt as core::convert::From<u8>>::from(v65) : felt
            hir.exec @miden:storage-example/foo@1.0.0/storage_example/miden::active_account::get_item(v75, v71)
            v77 = arith.constant 8 : u32;
            v76 = hir.bitcast v71 : u32;
            v78 = arith.add v76, v77 : u32 #[overflow = checked];
            v545 = arith.constant 8 : u32;
            v80 = arith.mod v78, v545 : u32;
            hir.assertz v80 #[code = 250];
            v81 = hir.int_to_ptr v78 : ptr<byte, i64>;
            v82 = hir.load v81 : i64;
            v84 = arith.constant 56 : u32;
            v83 = hir.bitcast v71 : u32;
            v85 = arith.add v83, v84 : u32 #[overflow = checked];
            v544 = arith.constant 8 : u32;
            v87 = arith.mod v85, v544 : u32;
            hir.assertz v87 #[code = 250];
            v88 = hir.int_to_ptr v85 : ptr<byte, i64>;
            hir.store v88, v82;
            v89 = hir.bitcast v71 : u32;
            v543 = arith.constant 8 : u32;
            v91 = arith.mod v89, v543 : u32;
            hir.assertz v91 #[code = 250];
            v92 = hir.int_to_ptr v89 : ptr<byte, i64>;
            v93 = hir.load v92 : i64;
            v95 = arith.constant 48 : u32;
            v94 = hir.bitcast v71 : u32;
            v96 = arith.add v94, v95 : u32 #[overflow = checked];
            v542 = arith.constant 8 : u32;
            v98 = arith.mod v96, v542 : u32;
            hir.assertz v98 #[code = 250];
            v99 = hir.int_to_ptr v96 : ptr<byte, i64>;
            hir.store v99, v93;
            v102 = arith.constant 48 : i32;
            v103 = arith.add v71, v102 : i32 #[overflow = wrapping];
            v100 = arith.constant 112 : i32;
            v101 = arith.add v71, v100 : i32 #[overflow = wrapping];
            hir.exec @miden:storage-example/foo@1.0.0/storage_example/<miden_stdlib_sys::intrinsics::word::Word>::reverse(v101, v103)
            v105 = arith.constant 116 : u32;
            v104 = hir.bitcast v71 : u32;
            v106 = arith.add v104, v105 : u32 #[overflow = checked];
            v107 = arith.constant 4 : u32;
            v108 = arith.mod v106, v107 : u32;
            hir.assertz v108 #[code = 250];
            v109 = hir.int_to_ptr v106 : ptr<byte, felt>;
            v110 = hir.load v109 : felt;
            v112 = arith.constant 120 : u32;
            v111 = hir.bitcast v71 : u32;
            v113 = arith.add v111, v112 : u32 #[overflow = checked];
            v541 = arith.constant 4 : u32;
            v115 = arith.mod v113, v541 : u32;
            hir.assertz v115 #[code = 250];
            v116 = hir.int_to_ptr v113 : ptr<byte, felt>;
            v117 = hir.load v116 : felt;
            v119 = arith.constant 124 : u32;
            v118 = hir.bitcast v71 : u32;
            v120 = arith.add v118, v119 : u32 #[overflow = checked];
            v540 = arith.constant 4 : u32;
            v122 = arith.mod v120, v540 : u32;
            hir.assertz v122 #[code = 250];
            v123 = hir.int_to_ptr v120 : ptr<byte, felt>;
            v124 = hir.load v123 : felt;
            v126 = arith.constant 112 : u32;
            v125 = hir.bitcast v71 : u32;
            v127 = arith.add v125, v126 : u32 #[overflow = checked];
            v539 = arith.constant 4 : u32;
            v129 = arith.mod v127, v539 : u32;
            hir.assertz v129 #[code = 250];
            v130 = hir.int_to_ptr v127 : ptr<byte, felt>;
            v131 = hir.load v130 : felt;
            v538 = arith.constant 0 : i32;
            v134 = arith.constant 1 : i32;
            v132 = arith.eq v56, v131 : i1;
            v133 = hir.cast v132 : i32;
            v135 = arith.neq v133, v134 : i1;
            v136 = arith.zext v135 : u32;
            v137 = hir.bitcast v136 : i32;
            v139 = arith.neq v137, v538 : i1;
            scf.if v139{
            ^block48:
                scf.yield ;
            } else {
            ^block14:
                v536 = arith.constant 0 : i32;
                v537 = arith.constant 1 : i32;
                v140 = arith.eq v57, v110 : i1;
                v141 = hir.cast v140 : i32;
                v143 = arith.neq v141, v537 : i1;
                v144 = arith.zext v143 : u32;
                v145 = hir.bitcast v144 : i32;
                v147 = arith.neq v145, v536 : i1;
                scf.if v147{
                ^block47:
                    scf.yield ;
                } else {
                ^block15:
                    v534 = arith.constant 0 : i32;
                    v535 = arith.constant 1 : i32;
                    v148 = arith.eq v58, v117 : i1;
                    v149 = hir.cast v148 : i32;
                    v151 = arith.neq v149, v535 : i1;
                    v152 = arith.zext v151 : u32;
                    v153 = hir.bitcast v152 : i32;
                    v155 = arith.neq v153, v534 : i1;
                    scf.if v155{
                    ^block46:
                        scf.yield ;
                    } else {
                    ^block16:
                        v532 = arith.constant 0 : i32;
                        v533 = arith.constant 1 : i32;
                        v156 = arith.eq v59, v124 : i1;
                        v157 = hir.cast v156 : i32;
                        v159 = arith.neq v157, v533 : i1;
                        v160 = arith.zext v159 : u32;
                        v161 = hir.bitcast v160 : i32;
                        v163 = arith.neq v161, v532 : i1;
                        scf.if v163{
                        ^block45:
                            scf.yield ;
                        } else {
                        ^block17:
                            v164 = arith.constant 32 : i32;
                            v165 = arith.add v71, v164 : i32 #[overflow = wrapping];
                            hir.exec @miden:storage-example/foo@1.0.0/storage_example/<miden_stdlib_sys::intrinsics::word::Word as core::convert::From<miden_felt::wasm32::Felt>>::from(v165, v64)
                            v531 = arith.constant 1 : i32;
                            v167 = hir.exec @miden:storage-example/foo@1.0.0/storage_example/<miden_felt::wasm32::Felt as core::convert::From<u8>>::from(v531) : felt
                            v169 = arith.constant 44 : u32;
                            v168 = hir.bitcast v71 : u32;
                            v170 = arith.add v168, v169 : u32 #[overflow = checked];
                            v530 = arith.constant 4 : u32;
                            v172 = arith.mod v170, v530 : u32;
                            hir.assertz v172 #[code = 250];
                            v173 = hir.int_to_ptr v170 : ptr<byte, felt>;
                            v174 = hir.load v173 : felt;
                            v176 = arith.constant 40 : u32;
                            v175 = hir.bitcast v71 : u32;
                            v177 = arith.add v175, v176 : u32 #[overflow = checked];
                            v529 = arith.constant 4 : u32;
                            v179 = arith.mod v177, v529 : u32;
                            hir.assertz v179 #[code = 250];
                            v180 = hir.int_to_ptr v177 : ptr<byte, felt>;
                            v181 = hir.load v180 : felt;
                            v183 = arith.constant 36 : u32;
                            v182 = hir.bitcast v71 : u32;
                            v184 = arith.add v182, v183 : u32 #[overflow = checked];
                            v528 = arith.constant 4 : u32;
                            v186 = arith.mod v184, v528 : u32;
                            hir.assertz v186 #[code = 250];
                            v187 = hir.int_to_ptr v184 : ptr<byte, felt>;
                            v188 = hir.load v187 : felt;
                            v190 = arith.constant 32 : u32;
                            v189 = hir.bitcast v71 : u32;
                            v191 = arith.add v189, v190 : u32 #[overflow = checked];
                            v527 = arith.constant 4 : u32;
                            v193 = arith.mod v191, v527 : u32;
                            hir.assertz v193 #[code = 250];
                            v194 = hir.int_to_ptr v191 : ptr<byte, felt>;
                            v195 = hir.load v194 : felt;
                            v526 = arith.constant 48 : i32;
                            v197 = arith.add v71, v526 : i32 #[overflow = wrapping];
                            hir.exec @miden:storage-example/foo@1.0.0/storage_example/miden::native_account::set_map_item(v167, v63, v62, v61, v60, v174, v181, v188, v195, v197)
                            v525 = arith.constant 56 : u32;
                            v198 = hir.bitcast v71 : u32;
                            v200 = arith.add v198, v525 : u32 #[overflow = checked];
                            v524 = arith.constant 8 : u32;
                            v202 = arith.mod v200, v524 : u32;
                            hir.assertz v202 #[code = 250];
                            v203 = hir.int_to_ptr v200 : ptr<byte, i64>;
                            v204 = hir.load v203 : i64;
                            v206 = arith.constant 88 : u32;
                            v205 = hir.bitcast v71 : u32;
                            v207 = arith.add v205, v206 : u32 #[overflow = checked];
                            v523 = arith.constant 8 : u32;
                            v209 = arith.mod v207, v523 : u32;
                            hir.assertz v209 #[code = 250];
                            v210 = hir.int_to_ptr v207 : ptr<byte, i64>;
                            hir.store v210, v204;
                            v522 = arith.constant 48 : u32;
                            v211 = hir.bitcast v71 : u32;
                            v213 = arith.add v211, v522 : u32 #[overflow = checked];
                            v521 = arith.constant 8 : u32;
                            v215 = arith.mod v213, v521 : u32;
                            hir.assertz v215 #[code = 250];
                            v216 = hir.int_to_ptr v213 : ptr<byte, i64>;
                            v217 = hir.load v216 : i64;
                            v219 = arith.constant 80 : u32;
                            v218 = hir.bitcast v71 : u32;
                            v220 = arith.add v218, v219 : u32 #[overflow = checked];
                            v520 = arith.constant 8 : u32;
                            v222 = arith.mod v220, v520 : u32;
                            hir.assertz v222 #[code = 250];
                            v223 = hir.int_to_ptr v220 : ptr<byte, i64>;
                            hir.store v223, v217;
                            v224 = arith.constant 72 : i32;
                            v225 = arith.add v71, v224 : i32 #[overflow = wrapping];
                            v226 = hir.bitcast v225 : u32;
                            v519 = arith.constant 8 : u32;
                            v228 = arith.mod v226, v519 : u32;
                            hir.assertz v228 #[code = 250];
                            v229 = hir.int_to_ptr v226 : ptr<byte, i64>;
                            v230 = hir.load v229 : i64;
                            v232 = arith.constant 104 : u32;
                            v231 = hir.bitcast v71 : u32;
                            v233 = arith.add v231, v232 : u32 #[overflow = checked];
                            v518 = arith.constant 8 : u32;
                            v235 = arith.mod v233, v518 : u32;
                            hir.assertz v235 #[code = 250];
                            v236 = hir.int_to_ptr v233 : ptr<byte, i64>;
                            hir.store v236, v230;
                            v238 = arith.constant 64 : u32;
                            v237 = hir.bitcast v71 : u32;
                            v239 = arith.add v237, v238 : u32 #[overflow = checked];
                            v517 = arith.constant 8 : u32;
                            v241 = arith.mod v239, v517 : u32;
                            hir.assertz v241 #[code = 250];
                            v242 = hir.int_to_ptr v239 : ptr<byte, i64>;
                            v243 = hir.load v242 : i64;
                            v245 = arith.constant 96 : u32;
                            v244 = hir.bitcast v71 : u32;
                            v246 = arith.add v244, v245 : u32 #[overflow = checked];
                            v516 = arith.constant 8 : u32;
                            v248 = arith.mod v246, v516 : u32;
                            hir.assertz v248 #[code = 250];
                            v249 = hir.int_to_ptr v246 : ptr<byte, i64>;
                            hir.store v249, v243;
                            v250 = arith.constant 80 : i32;
                            v251 = arith.add v71, v250 : i32 #[overflow = wrapping];
                            hir.exec @miden:storage-example/foo@1.0.0/storage_example/<miden_stdlib_sys::intrinsics::word::Word>::reverse(v71, v251)
                            v254 = arith.constant 96 : i32;
                            v255 = arith.add v71, v254 : i32 #[overflow = wrapping];
                            v515 = arith.constant 112 : i32;
                            v253 = arith.add v71, v515 : i32 #[overflow = wrapping];
                            hir.exec @miden:storage-example/foo@1.0.0/storage_example/<miden_stdlib_sys::intrinsics::word::Word>::reverse(v253, v255)
                            scf.yield ;
                        };
                        scf.yield ;
                    };
                    scf.yield ;
                };
                scf.yield ;
            };
            v514 = arith.constant 128 : i32;
            v258 = arith.add v71, v514 : i32 #[overflow = wrapping];
            v259 = builtin.global_symbol @miden:storage-example/foo@1.0.0/storage_example/__stack_pointer : ptr<byte, u8>
            v260 = hir.bitcast v259 : ptr<byte, i32>;
            hir.store v260, v258;
            builtin.ret ;
        };

        private builtin.function @wit_bindgen::rt::run_ctors_once() {
        ^block18:
            v262 = builtin.global_symbol @miden:storage-example/foo@1.0.0/storage_example/GOT.data.internal.__memory_base : ptr<byte, u8>
            v263 = hir.bitcast v262 : ptr<byte, i32>;
            v264 = hir.load v263 : i32;
            v265 = arith.constant 1048584 : i32;
            v266 = arith.add v264, v265 : i32 #[overflow = wrapping];
            v267 = hir.bitcast v266 : u32;
            v268 = hir.int_to_ptr v267 : ptr<byte, u8>;
            v269 = hir.load v268 : u8;
            v261 = arith.constant 0 : i32;
            v270 = arith.zext v269 : u32;
            v271 = hir.bitcast v270 : i32;
            v273 = arith.neq v271, v261 : i1;
            scf.if v273{
            ^block20:
                scf.yield ;
            } else {
            ^block21:
                v274 = builtin.global_symbol @miden:storage-example/foo@1.0.0/storage_example/GOT.data.internal.__memory_base : ptr<byte, u8>
                v275 = hir.bitcast v274 : ptr<byte, i32>;
                v276 = hir.load v275 : i32;
                hir.exec @miden:storage-example/foo@1.0.0/storage_example/__wasm_call_ctors()
                v547 = arith.constant 1 : u8;
                v549 = arith.constant 1048584 : i32;
                v278 = arith.add v276, v549 : i32 #[overflow = wrapping];
                v282 = hir.bitcast v278 : u32;
                v283 = hir.int_to_ptr v282 : ptr<byte, u8>;
                hir.store v283, v547;
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @<miden_stdlib_sys::intrinsics::word::Word>::reverse(v284: i32, v285: i32) {
        ^block22(v284: i32, v285: i32):
            v288 = builtin.global_symbol @miden:storage-example/foo@1.0.0/storage_example/__stack_pointer : ptr<byte, u8>
            v289 = hir.bitcast v288 : ptr<byte, i32>;
            v290 = hir.load v289 : i32;
            v291 = arith.constant 16 : i32;
            v292 = arith.sub v290, v291 : i32 #[overflow = wrapping];
            v294 = arith.constant 8 : u32;
            v293 = hir.bitcast v285 : u32;
            v295 = arith.add v293, v294 : u32 #[overflow = checked];
            v636 = arith.constant 8 : u32;
            v297 = arith.mod v295, v636 : u32;
            hir.assertz v297 #[code = 250];
            v298 = hir.int_to_ptr v295 : ptr<byte, i64>;
            v299 = hir.load v298 : i64;
            v635 = arith.constant 8 : u32;
            v300 = hir.bitcast v292 : u32;
            v302 = arith.add v300, v635 : u32 #[overflow = checked];
            v303 = arith.constant 4 : u32;
            v304 = arith.mod v302, v303 : u32;
            hir.assertz v304 #[code = 250];
            v305 = hir.int_to_ptr v302 : ptr<byte, i64>;
            hir.store v305, v299;
            v306 = hir.bitcast v285 : u32;
            v634 = arith.constant 8 : u32;
            v308 = arith.mod v306, v634 : u32;
            hir.assertz v308 #[code = 250];
            v309 = hir.int_to_ptr v306 : ptr<byte, i64>;
            v310 = hir.load v309 : i64;
            v311 = hir.bitcast v292 : u32;
            v633 = arith.constant 4 : u32;
            v313 = arith.mod v311, v633 : u32;
            hir.assertz v313 #[code = 250];
            v314 = hir.int_to_ptr v311 : ptr<byte, i64>;
            hir.store v314, v310;
            v315 = arith.constant 12 : i32;
            v316 = arith.add v292, v315 : i32 #[overflow = wrapping];
            v286 = arith.constant 0 : i32;
            v604, v605, v606, v607, v608, v609 = scf.while v286, v292, v316, v284 : i32, i32, i32, i32, i32, i32 {
            ^block61(v610: i32, v611: i32, v612: i32, v613: i32):
                v632 = arith.constant 0 : i32;
                v319 = arith.constant 8 : i32;
                v320 = arith.eq v610, v319 : i1;
                v321 = arith.zext v320 : u32;
                v322 = hir.bitcast v321 : i32;
                v324 = arith.neq v322, v632 : i1;
                v598, v599 = scf.if v324 : i32, i32 {
                ^block60:
                    v558 = ub.poison i32 : i32;
                    scf.yield v558, v558;
                } else {
                ^block27:
                    v326 = arith.add v611, v610 : i32 #[overflow = wrapping];
                    v327 = hir.bitcast v326 : u32;
                    v631 = arith.constant 4 : u32;
                    v329 = arith.mod v327, v631 : u32;
                    hir.assertz v329 #[code = 250];
                    v330 = hir.int_to_ptr v327 : ptr<byte, felt>;
                    v331 = hir.load v330 : felt;
                    v333 = hir.bitcast v612 : u32;
                    v630 = arith.constant 4 : u32;
                    v335 = arith.mod v333, v630 : u32;
                    hir.assertz v335 #[code = 250];
                    v336 = hir.int_to_ptr v333 : ptr<byte, i32>;
                    v337 = hir.load v336 : i32;
                    v338 = hir.bitcast v326 : u32;
                    v629 = arith.constant 4 : u32;
                    v340 = arith.mod v338, v629 : u32;
                    hir.assertz v340 #[code = 250];
                    v341 = hir.int_to_ptr v338 : ptr<byte, i32>;
                    hir.store v341, v337;
                    v342 = hir.bitcast v612 : u32;
                    v628 = arith.constant 4 : u32;
                    v344 = arith.mod v342, v628 : u32;
                    hir.assertz v344 #[code = 250];
                    v345 = hir.int_to_ptr v342 : ptr<byte, felt>;
                    hir.store v345, v331;
                    v348 = arith.constant -4 : i32;
                    v349 = arith.add v612, v348 : i32 #[overflow = wrapping];
                    v346 = arith.constant 4 : i32;
                    v347 = arith.add v610, v346 : i32 #[overflow = wrapping];
                    scf.yield v347, v349;
                };
                v626 = ub.poison i32 : i32;
                v601 = cf.select v324, v626, v613 : i32;
                v627 = ub.poison i32 : i32;
                v600 = cf.select v324, v627, v611 : i32;
                v557 = arith.constant 1 : u32;
                v550 = arith.constant 0 : u32;
                v603 = cf.select v324, v550, v557 : u32;
                v591 = arith.trunc v603 : i1;
                scf.condition v591, v598, v600, v599, v601, v611, v613;
            } do {
            ^block62(v614: i32, v615: i32, v616: i32, v617: i32, v618: i32, v619: i32):
                scf.yield v614, v615, v616, v617;
            };
            v625 = arith.constant 8 : u32;
            v351 = hir.bitcast v608 : u32;
            v353 = arith.add v351, v625 : u32 #[overflow = checked];
            v624 = arith.constant 4 : u32;
            v355 = arith.mod v353, v624 : u32;
            hir.assertz v355 #[code = 250];
            v356 = hir.int_to_ptr v353 : ptr<byte, i64>;
            v357 = hir.load v356 : i64;
            v623 = arith.constant 8 : u32;
            v358 = hir.bitcast v609 : u32;
            v360 = arith.add v358, v623 : u32 #[overflow = checked];
            v622 = arith.constant 8 : u32;
            v362 = arith.mod v360, v622 : u32;
            hir.assertz v362 #[code = 250];
            v363 = hir.int_to_ptr v360 : ptr<byte, i64>;
            hir.store v363, v357;
            v364 = hir.bitcast v608 : u32;
            v621 = arith.constant 4 : u32;
            v366 = arith.mod v364, v621 : u32;
            hir.assertz v366 #[code = 250];
            v367 = hir.int_to_ptr v364 : ptr<byte, i64>;
            v368 = hir.load v367 : i64;
            v369 = hir.bitcast v609 : u32;
            v620 = arith.constant 8 : u32;
            v371 = arith.mod v369, v620 : u32;
            hir.assertz v371 #[code = 250];
            v372 = hir.int_to_ptr v369 : ptr<byte, i64>;
            hir.store v372, v368;
            builtin.ret ;
        };

        private builtin.function @<miden_stdlib_sys::intrinsics::word::Word as core::convert::From<miden_felt::wasm32::Felt>>::from(v373: i32, v374: felt) {
        ^block28(v373: i32, v374: felt):
            v383 = arith.constant 12 : u32;
            v382 = hir.bitcast v373 : u32;
            v384 = arith.add v382, v383 : u32 #[overflow = checked];
            v385 = arith.constant 4 : u32;
            v386 = arith.mod v384, v385 : u32;
            hir.assertz v386 #[code = 250];
            v387 = hir.int_to_ptr v384 : ptr<byte, felt>;
            hir.store v387, v374;
            v389 = arith.constant 8 : u32;
            v388 = hir.bitcast v373 : u32;
            v390 = arith.add v388, v389 : u32 #[overflow = checked];
            v645 = arith.constant 4 : u32;
            v392 = arith.mod v390, v645 : u32;
            hir.assertz v392 #[code = 250];
            v639 = arith.constant 0 : felt;
            v393 = hir.int_to_ptr v390 : ptr<byte, felt>;
            hir.store v393, v639;
            v644 = arith.constant 4 : u32;
            v394 = hir.bitcast v373 : u32;
            v396 = arith.add v394, v644 : u32 #[overflow = checked];
            v643 = arith.constant 4 : u32;
            v398 = arith.mod v396, v643 : u32;
            hir.assertz v398 #[code = 250];
            v642 = arith.constant 0 : felt;
            v399 = hir.int_to_ptr v396 : ptr<byte, felt>;
            hir.store v399, v642;
            v400 = hir.bitcast v373 : u32;
            v641 = arith.constant 4 : u32;
            v402 = arith.mod v400, v641 : u32;
            hir.assertz v402 #[code = 250];
            v640 = arith.constant 0 : felt;
            v403 = hir.int_to_ptr v400 : ptr<byte, felt>;
            hir.store v403, v640;
            builtin.ret ;
        };

        private builtin.function @<miden_felt::wasm32::Felt as core::convert::From<u8>>::from(v404: i32) -> felt {
        ^block30(v404: i32):
            v406 = arith.constant 255 : i32;
            v407 = arith.band v404, v406 : i32;
            v408 = hir.bitcast v407 : felt;
            builtin.ret v408;
        };

        private builtin.function @miden::active_account::get_item(v409: felt, v410: i32) {
        ^block32(v409: felt, v410: i32):
            v411, v412, v413, v414 = hir.exec @miden/active_account/get_item(v409) : felt, felt, felt, felt
            v415 = hir.bitcast v410 : u32;
            v416 = hir.int_to_ptr v415 : ptr<byte, felt>;
            hir.store v416, v411;
            v417 = arith.constant 4 : u32;
            v418 = arith.add v415, v417 : u32 #[overflow = checked];
            v419 = hir.int_to_ptr v418 : ptr<byte, felt>;
            hir.store v419, v412;
            v420 = arith.constant 8 : u32;
            v421 = arith.add v415, v420 : u32 #[overflow = checked];
            v422 = hir.int_to_ptr v421 : ptr<byte, felt>;
            hir.store v422, v413;
            v423 = arith.constant 12 : u32;
            v424 = arith.add v415, v423 : u32 #[overflow = checked];
            v425 = hir.int_to_ptr v424 : ptr<byte, felt>;
            hir.store v425, v414;
            builtin.ret ;
        };

        private builtin.function @miden::active_account::get_map_item(v426: felt, v427: felt, v428: felt, v429: felt, v430: felt, v431: i32) {
        ^block36(v426: felt, v427: felt, v428: felt, v429: felt, v430: felt, v431: i32):
            v432, v433, v434, v435 = hir.exec @miden/active_account/get_map_item(v426, v427, v428, v429, v430) : felt, felt, felt, felt
            v436 = hir.bitcast v431 : u32;
            v437 = hir.int_to_ptr v436 : ptr<byte, felt>;
            hir.store v437, v432;
            v438 = arith.constant 4 : u32;
            v439 = arith.add v436, v438 : u32 #[overflow = checked];
            v440 = hir.int_to_ptr v439 : ptr<byte, felt>;
            hir.store v440, v433;
            v441 = arith.constant 8 : u32;
            v442 = arith.add v436, v441 : u32 #[overflow = checked];
            v443 = hir.int_to_ptr v442 : ptr<byte, felt>;
            hir.store v443, v434;
            v444 = arith.constant 12 : u32;
            v445 = arith.add v436, v444 : u32 #[overflow = checked];
            v446 = hir.int_to_ptr v445 : ptr<byte, felt>;
            hir.store v446, v435;
            builtin.ret ;
        };

        private builtin.function @miden::native_account::set_map_item(v447: felt, v448: felt, v449: felt, v450: felt, v451: felt, v452: felt, v453: felt, v454: felt, v455: felt, v456: i32) {
        ^block38(v447: felt, v448: felt, v449: felt, v450: felt, v451: felt, v452: felt, v453: felt, v454: felt, v455: felt, v456: i32):
            v457, v458, v459, v460, v461, v462, v463, v464 = hir.exec @miden/native_account/set_map_item(v447, v448, v449, v450, v451, v452, v453, v454, v455) : felt, felt, felt, felt, felt, felt, felt, felt
            v465 = hir.bitcast v456 : u32;
            v466 = hir.int_to_ptr v465 : ptr<byte, felt>;
            hir.store v466, v457;
            v467 = arith.constant 4 : u32;
            v468 = arith.add v465, v467 : u32 #[overflow = checked];
            v469 = hir.int_to_ptr v468 : ptr<byte, felt>;
            hir.store v469, v458;
            v470 = arith.constant 8 : u32;
            v471 = arith.add v465, v470 : u32 #[overflow = checked];
            v472 = hir.int_to_ptr v471 : ptr<byte, felt>;
            hir.store v472, v459;
            v473 = arith.constant 12 : u32;
            v474 = arith.add v465, v473 : u32 #[overflow = checked];
            v475 = hir.int_to_ptr v474 : ptr<byte, felt>;
            hir.store v475, v460;
            v476 = arith.constant 16 : u32;
            v477 = arith.add v465, v476 : u32 #[overflow = checked];
            v478 = hir.int_to_ptr v477 : ptr<byte, felt>;
            hir.store v478, v461;
            v479 = arith.constant 20 : u32;
            v480 = arith.add v465, v479 : u32 #[overflow = checked];
            v481 = hir.int_to_ptr v480 : ptr<byte, felt>;
            hir.store v481, v462;
            v482 = arith.constant 24 : u32;
            v483 = arith.add v465, v482 : u32 #[overflow = checked];
            v484 = hir.int_to_ptr v483 : ptr<byte, felt>;
            hir.store v484, v463;
            v485 = arith.constant 28 : u32;
            v486 = arith.add v465, v485 : u32 #[overflow = checked];
            v487 = hir.int_to_ptr v486 : ptr<byte, felt>;
            hir.store v487, v464;
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.global_variable private @#GOT.data.internal.__memory_base : i32 {
            builtin.ret_imm 0;
        };

        builtin.segment @1048576 = 0x0000000100000001;
    };

    public builtin.function @set-asset-qty(v488: felt, v489: felt, v490: felt, v491: felt, v492: felt, v493: felt, v494: felt, v495: felt, v496: felt) {
    ^block41(v488: felt, v489: felt, v490: felt, v491: felt, v492: felt, v493: felt, v494: felt, v495: felt, v496: felt):
        hir.exec @miden:storage-example/foo@1.0.0/storage_example/miden:storage-example/foo@1.0.0#set-asset-qty(v488, v489, v490, v491, v492, v493, v494, v495, v496)
        builtin.ret ;
    };

    public builtin.function @get-asset-qty(v497: felt, v498: felt, v499: felt, v500: felt) -> felt {
    ^block43(v497: felt, v498: felt, v499: felt, v500: felt):
        v501 = hir.exec @miden:storage-example/foo@1.0.0/storage_example/miden:storage-example/foo@1.0.0#get-asset-qty(v497, v498, v499, v500) : felt
        builtin.ret v501;
    };
};