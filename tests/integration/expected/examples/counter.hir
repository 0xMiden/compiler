builtin.component miden:counter-contract/counter@0.1.0 {
    builtin.module public @counter_contract {
        private builtin.function @miden_base_sys::bindings::storage::extern_get_storage_map_item(v0: felt, v1: felt, v2: felt, v3: felt, v4: felt, v5: i32) {
        ^block5(v0: felt, v1: felt, v2: felt, v3: felt, v4: felt, v5: i32):
            v6, v7, v8, v9 = hir.exec @miden/account/get_map_item(v0, v1, v2, v3, v4) : felt, felt, felt, felt
            v10 = hir.bitcast v5 : u32;
            v11 = hir.int_to_ptr v10 : ptr<byte, felt>;
            hir.store v11, v6;
            v12 = arith.constant 4 : u32;
            v13 = arith.add v10, v12 : u32 #[overflow = checked];
            v14 = hir.int_to_ptr v13 : ptr<byte, felt>;
            hir.store v14, v7;
            v15 = arith.constant 8 : u32;
            v16 = arith.add v10, v15 : u32 #[overflow = checked];
            v17 = hir.int_to_ptr v16 : ptr<byte, felt>;
            hir.store v17, v8;
            v18 = arith.constant 12 : u32;
            v19 = arith.add v10, v18 : u32 #[overflow = checked];
            v20 = hir.int_to_ptr v19 : ptr<byte, felt>;
            hir.store v20, v9;
            builtin.ret ;
        };

        private builtin.function @miden_base_sys::bindings::storage::extern_set_storage_map_item(v21: felt, v22: felt, v23: felt, v24: felt, v25: felt, v26: felt, v27: felt, v28: felt, v29: felt, v30: i32) {
        ^block9(v21: felt, v22: felt, v23: felt, v24: felt, v25: felt, v26: felt, v27: felt, v28: felt, v29: felt, v30: i32):
            v31, v32, v33, v34, v35, v36, v37, v38 = hir.exec @miden/account/set_map_item(v21, v22, v23, v24, v25, v26, v27, v28, v29) : felt, felt, felt, felt, felt, felt, felt, felt
            v39 = hir.bitcast v30 : u32;
            v40 = hir.int_to_ptr v39 : ptr<byte, felt>;
            hir.store v40, v31;
            v41 = arith.constant 4 : u32;
            v42 = arith.add v39, v41 : u32 #[overflow = checked];
            v43 = hir.int_to_ptr v42 : ptr<byte, felt>;
            hir.store v43, v32;
            v44 = arith.constant 8 : u32;
            v45 = arith.add v39, v44 : u32 #[overflow = checked];
            v46 = hir.int_to_ptr v45 : ptr<byte, felt>;
            hir.store v46, v33;
            v47 = arith.constant 12 : u32;
            v48 = arith.add v39, v47 : u32 #[overflow = checked];
            v49 = hir.int_to_ptr v48 : ptr<byte, felt>;
            hir.store v49, v34;
            v50 = arith.constant 16 : u32;
            v51 = arith.add v39, v50 : u32 #[overflow = checked];
            v52 = hir.int_to_ptr v51 : ptr<byte, felt>;
            hir.store v52, v35;
            v53 = arith.constant 20 : u32;
            v54 = arith.add v39, v53 : u32 #[overflow = checked];
            v55 = hir.int_to_ptr v54 : ptr<byte, felt>;
            hir.store v55, v36;
            v56 = arith.constant 24 : u32;
            v57 = arith.add v39, v56 : u32 #[overflow = checked];
            v58 = hir.int_to_ptr v57 : ptr<byte, felt>;
            hir.store v58, v37;
            v59 = arith.constant 28 : u32;
            v60 = arith.add v39, v59 : u32 #[overflow = checked];
            v61 = hir.int_to_ptr v60 : ptr<byte, felt>;
            hir.store v61, v38;
            builtin.ret ;
        };

        private builtin.function @__wasm_call_ctors() {
        ^block12:
            builtin.ret ;
        };

        private builtin.function @counter_contract::bindings::__link_custom_section_describing_imports() {
        ^block14:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc(v62: i32, v63: i32) -> i32 {
        ^block16(v62: i32, v63: i32):
            v65 = arith.constant 1048612 : i32;
            v66 = hir.exec @miden:counter-contract/counter@0.1.0/counter_contract/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v65, v63, v62) : i32
            builtin.ret v66;
        };

        private builtin.function @__rustc::__rust_realloc(v67: i32, v68: i32, v69: i32, v70: i32) -> i32 {
        ^block18(v67: i32, v68: i32, v69: i32, v70: i32):
            v72 = arith.constant 1048612 : i32;
            v73 = hir.exec @miden:counter-contract/counter@0.1.0/counter_contract/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v72, v69, v70) : i32
            v581 = arith.constant 0 : i32;
            v74 = arith.constant 0 : i32;
            v75 = arith.eq v73, v74 : i1;
            v76 = arith.zext v75 : u32;
            v77 = hir.bitcast v76 : i32;
            v79 = arith.neq v77, v581 : i1;
            v576 = scf.if v79 : i32 {
            ^block20:
                scf.yield v73;
            } else {
            ^block21:
                v580 = arith.constant 0 : i32;
                v81 = hir.bitcast v68 : u32;
                v80 = hir.bitcast v70 : u32;
                v82 = arith.lt v80, v81 : i1;
                v83 = arith.zext v82 : u32;
                v84 = hir.bitcast v83 : i32;
                v86 = arith.neq v84, v580 : i1;
                v87 = cf.select v86, v70, v68 : i32;
                v578 = arith.constant 0 : i32;
                v579 = arith.constant 0 : i32;
                v89 = arith.eq v87, v579 : i1;
                v90 = arith.zext v89 : u32;
                v91 = hir.bitcast v90 : i32;
                v93 = arith.neq v91, v578 : i1;
                v577 = scf.if v93 : i32 {
                ^block72:
                    scf.yield v73;
                } else {
                ^block22:
                    v94 = hir.bitcast v87 : u32;
                    v95 = hir.bitcast v73 : u32;
                    v96 = hir.int_to_ptr v95 : ptr<byte, u8>;
                    v97 = hir.bitcast v67 : u32;
                    v98 = hir.int_to_ptr v97 : ptr<byte, u8>;
                    hir.mem_cpy v98, v96, v94;
                    scf.yield v73;
                };
                scf.yield v577;
            };
            builtin.ret v576;
        };

        public builtin.function @miden:counter-contract/counter@0.1.0#get-count() -> felt {
        ^block23:
            v103 = builtin.global_symbol @miden:counter-contract/counter@0.1.0/counter_contract/__stack_pointer : ptr<byte, u8>
            v104 = hir.bitcast v103 : ptr<byte, i32>;
            v105 = hir.load v104 : i32;
            v108 = arith.constant -32 : i32;
            v106 = arith.constant 64 : i32;
            v107 = arith.sub v105, v106 : i32 #[overflow = wrapping];
            v109 = arith.band v107, v108 : i32;
            v110 = builtin.global_symbol @miden:counter-contract/counter@0.1.0/counter_contract/__stack_pointer : ptr<byte, u8>
            v111 = hir.bitcast v110 : ptr<byte, i32>;
            hir.store v111, v109;
            hir.exec @miden:counter-contract/counter@0.1.0/counter_contract/wit_bindgen_rt::run_ctors_once()
            v592 = ub.poison i32 : i32;
            v582 = arith.constant 0 : felt;
            v101 = arith.constant 0 : i32;
            v608, v609, v610, v611, v612, v613 = scf.while v101, v109, v582, v105, v592, v592 : i32, i32, felt, i32, i32, i32 {
            ^block26(v115: i32, v122: i32, v126: felt, v167: i32, v599: i32, v601: i32):
                v643 = arith.constant 0 : i32;
                v116 = arith.constant 16 : i32;
                v117 = arith.eq v115, v116 : i1;
                v118 = arith.zext v117 : u32;
                v119 = hir.bitcast v118 : i32;
                v121 = arith.neq v119, v643 : i1;
                v627, v628, v629, v630, v631, v632 = scf.if v121 : i32, i32, felt, i32, u32, u32 {
                ^block81:
                    v584 = arith.constant 0 : u32;
                    v591 = arith.constant 1 : u32;
                    v642 = ub.poison i32 : i32;
                    v593 = ub.poison felt : felt;
                    scf.yield v642, v642, v593, v642, v591, v584;
                } else {
                ^block28:
                    v157 = arith.constant 32 : i32;
                    v124 = arith.add v122, v157 : i32 #[overflow = wrapping];
                    v125 = arith.add v124, v115 : i32 #[overflow = wrapping];
                    v127 = hir.bitcast v125 : u32;
                    v136 = arith.constant 4 : u32;
                    v129 = arith.mod v127, v136 : u32;
                    hir.assertz v129 #[code = 250];
                    v130 = hir.int_to_ptr v127 : ptr<byte, felt>;
                    hir.store v130, v126;
                    v640 = arith.constant 1 : u32;
                    v641 = arith.constant 0 : u32;
                    v131 = arith.constant 4 : i32;
                    v132 = arith.add v115, v131 : i32 #[overflow = wrapping];
                    scf.yield v132, v122, v126, v167, v641, v640;
                };
                v626 = arith.trunc v632 : i1;
                scf.condition v626, v627, v628, v629, v630, v122, v167;
            } do {
            ^block80(v620: i32, v621: i32, v622: felt, v623: i32, v624: i32, v625: i32):
                scf.yield v620, v621, v622, v623, v624, v625;
            };
            v134 = arith.constant 40 : u32;
            v133 = hir.bitcast v612 : u32;
            v135 = arith.add v133, v134 : u32 #[overflow = checked];
            v639 = arith.constant 4 : u32;
            v137 = arith.mod v135, v639 : u32;
            hir.assertz v137 #[code = 250];
            v138 = hir.int_to_ptr v135 : ptr<byte, i64>;
            v139 = hir.load v138 : i64;
            v141 = arith.constant 8 : u32;
            v140 = hir.bitcast v612 : u32;
            v142 = arith.add v140, v141 : u32 #[overflow = checked];
            v638 = arith.constant 8 : u32;
            v144 = arith.mod v142, v638 : u32;
            hir.assertz v144 #[code = 250];
            v145 = hir.int_to_ptr v142 : ptr<byte, i64>;
            hir.store v145, v139;
            v147 = arith.constant 32 : u32;
            v146 = hir.bitcast v612 : u32;
            v148 = arith.add v146, v147 : u32 #[overflow = checked];
            v637 = arith.constant 4 : u32;
            v150 = arith.mod v148, v637 : u32;
            hir.assertz v150 #[code = 250];
            v151 = hir.int_to_ptr v148 : ptr<byte, i64>;
            v152 = hir.load v151 : i64;
            v153 = hir.bitcast v612 : u32;
            v636 = arith.constant 8 : u32;
            v155 = arith.mod v153, v636 : u32;
            hir.assertz v155 #[code = 250];
            v156 = hir.int_to_ptr v153 : ptr<byte, i64>;
            hir.store v156, v152;
            v634 = arith.constant 0 : i32;
            v635 = arith.constant 32 : i32;
            v158 = arith.add v612, v635 : i32 #[overflow = wrapping];
            hir.exec @miden:counter-contract/counter@0.1.0/counter_contract/miden_base_sys::bindings::storage::get_map_item(v158, v634, v612)
            v161 = arith.constant 44 : u32;
            v160 = hir.bitcast v612 : u32;
            v162 = arith.add v160, v161 : u32 #[overflow = checked];
            v633 = arith.constant 4 : u32;
            v164 = arith.mod v162, v633 : u32;
            hir.assertz v164 #[code = 250];
            v165 = hir.int_to_ptr v162 : ptr<byte, felt>;
            v166 = hir.load v165 : felt;
            v168 = builtin.global_symbol @miden:counter-contract/counter@0.1.0/counter_contract/__stack_pointer : ptr<byte, u8>
            v169 = hir.bitcast v168 : ptr<byte, i32>;
            hir.store v169, v613;
            builtin.ret v166;
        };

        public builtin.function @miden:counter-contract/counter@0.1.0#increment-count() -> felt {
        ^block29:
            v173 = builtin.global_symbol @miden:counter-contract/counter@0.1.0/counter_contract/__stack_pointer : ptr<byte, u8>
            v174 = hir.bitcast v173 : ptr<byte, i32>;
            v175 = hir.load v174 : i32;
            v178 = arith.constant -32 : i32;
            v176 = arith.constant 160 : i32;
            v177 = arith.sub v175, v176 : i32 #[overflow = wrapping];
            v179 = arith.band v177, v178 : i32;
            v180 = builtin.global_symbol @miden:counter-contract/counter@0.1.0/counter_contract/__stack_pointer : ptr<byte, u8>
            v181 = hir.bitcast v180 : ptr<byte, i32>;
            hir.store v181, v179;
            hir.exec @miden:counter-contract/counter@0.1.0/counter_contract/wit_bindgen_rt::run_ctors_once()
            v655 = ub.poison i32 : i32;
            v645 = arith.constant 0 : felt;
            v171 = arith.constant 0 : i32;
            v671, v672, v673, v674, v675, v676 = scf.while v171, v179, v645, v175, v655, v655 : i32, i32, felt, i32, i32, i32 {
            ^block32(v185: i32, v192: i32, v196: felt, v299: i32, v662: i32, v664: i32):
                v718 = arith.constant 0 : i32;
                v186 = arith.constant 16 : i32;
                v187 = arith.eq v185, v186 : i1;
                v188 = arith.zext v187 : u32;
                v189 = hir.bitcast v188 : i32;
                v191 = arith.neq v189, v718 : i1;
                v690, v691, v692, v693, v694, v695 = scf.if v191 : i32, i32, felt, i32, u32, u32 {
                ^block88:
                    v647 = arith.constant 0 : u32;
                    v654 = arith.constant 1 : u32;
                    v717 = ub.poison i32 : i32;
                    v656 = ub.poison felt : felt;
                    scf.yield v717, v717, v656, v717, v654, v647;
                } else {
                ^block34:
                    v227 = arith.constant 32 : i32;
                    v194 = arith.add v192, v227 : i32 #[overflow = wrapping];
                    v195 = arith.add v194, v185 : i32 #[overflow = wrapping];
                    v197 = hir.bitcast v195 : u32;
                    v206 = arith.constant 4 : u32;
                    v199 = arith.mod v197, v206 : u32;
                    hir.assertz v199 #[code = 250];
                    v200 = hir.int_to_ptr v197 : ptr<byte, felt>;
                    hir.store v200, v196;
                    v715 = arith.constant 1 : u32;
                    v716 = arith.constant 0 : u32;
                    v201 = arith.constant 4 : i32;
                    v202 = arith.add v185, v201 : i32 #[overflow = wrapping];
                    scf.yield v202, v192, v196, v299, v716, v715;
                };
                v689 = arith.trunc v695 : i1;
                scf.condition v689, v690, v691, v692, v693, v192, v299;
            } do {
            ^block87(v683: i32, v684: i32, v685: felt, v686: i32, v687: i32, v688: i32):
                scf.yield v683, v684, v685, v686, v687, v688;
            };
            v204 = arith.constant 40 : u32;
            v203 = hir.bitcast v675 : u32;
            v205 = arith.add v203, v204 : u32 #[overflow = checked];
            v714 = arith.constant 4 : u32;
            v207 = arith.mod v205, v714 : u32;
            hir.assertz v207 #[code = 250];
            v208 = hir.int_to_ptr v205 : ptr<byte, i64>;
            v209 = hir.load v208 : i64;
            v211 = arith.constant 8 : u32;
            v210 = hir.bitcast v675 : u32;
            v212 = arith.add v210, v211 : u32 #[overflow = checked];
            v713 = arith.constant 8 : u32;
            v214 = arith.mod v212, v713 : u32;
            hir.assertz v214 #[code = 250];
            v215 = hir.int_to_ptr v212 : ptr<byte, i64>;
            hir.store v215, v209;
            v217 = arith.constant 32 : u32;
            v216 = hir.bitcast v675 : u32;
            v218 = arith.add v216, v217 : u32 #[overflow = checked];
            v712 = arith.constant 4 : u32;
            v220 = arith.mod v218, v712 : u32;
            hir.assertz v220 #[code = 250];
            v221 = hir.int_to_ptr v218 : ptr<byte, i64>;
            v222 = hir.load v221 : i64;
            v223 = hir.bitcast v675 : u32;
            v711 = arith.constant 8 : u32;
            v225 = arith.mod v223, v711 : u32;
            hir.assertz v225 #[code = 250];
            v226 = hir.int_to_ptr v223 : ptr<byte, i64>;
            hir.store v226, v222;
            v709 = arith.constant 0 : i32;
            v710 = arith.constant 32 : i32;
            v228 = arith.add v675, v710 : i32 #[overflow = wrapping];
            hir.exec @miden:counter-contract/counter@0.1.0/counter_contract/miden_base_sys::bindings::storage::get_map_item(v228, v709, v675)
            v231 = arith.constant 44 : u32;
            v230 = hir.bitcast v675 : u32;
            v232 = arith.add v230, v231 : u32 #[overflow = checked];
            v708 = arith.constant 4 : u32;
            v234 = arith.mod v232, v708 : u32;
            hir.assertz v234 #[code = 250];
            v235 = hir.int_to_ptr v232 : ptr<byte, felt>;
            v236 = hir.load v235 : felt;
            v644 = arith.constant 1 : felt;
            v239 = arith.add v236, v644 : felt #[overflow = unchecked];
            v241 = arith.constant 24 : u32;
            v240 = hir.bitcast v675 : u32;
            v242 = arith.add v240, v241 : u32 #[overflow = checked];
            v707 = arith.constant 8 : u32;
            v244 = arith.mod v242, v707 : u32;
            hir.assertz v244 #[code = 250];
            v245 = hir.int_to_ptr v242 : ptr<byte, i64>;
            v246 = hir.load v245 : i64;
            v248 = arith.constant 120 : u32;
            v247 = hir.bitcast v675 : u32;
            v249 = arith.add v247, v248 : u32 #[overflow = checked];
            v706 = arith.constant 8 : u32;
            v251 = arith.mod v249, v706 : u32;
            hir.assertz v251 #[code = 250];
            v252 = hir.int_to_ptr v249 : ptr<byte, i64>;
            hir.store v252, v246;
            v254 = arith.constant 16 : u32;
            v253 = hir.bitcast v675 : u32;
            v255 = arith.add v253, v254 : u32 #[overflow = checked];
            v705 = arith.constant 8 : u32;
            v257 = arith.mod v255, v705 : u32;
            hir.assertz v257 #[code = 250];
            v258 = hir.int_to_ptr v255 : ptr<byte, i64>;
            v259 = hir.load v258 : i64;
            v261 = arith.constant 112 : u32;
            v260 = hir.bitcast v675 : u32;
            v262 = arith.add v260, v261 : u32 #[overflow = checked];
            v704 = arith.constant 8 : u32;
            v264 = arith.mod v262, v704 : u32;
            hir.assertz v264 #[code = 250];
            v265 = hir.int_to_ptr v262 : ptr<byte, i64>;
            hir.store v265, v259;
            v703 = arith.constant 8 : u32;
            v266 = hir.bitcast v675 : u32;
            v268 = arith.add v266, v703 : u32 #[overflow = checked];
            v702 = arith.constant 8 : u32;
            v270 = arith.mod v268, v702 : u32;
            hir.assertz v270 #[code = 250];
            v271 = hir.int_to_ptr v268 : ptr<byte, i64>;
            v272 = hir.load v271 : i64;
            v274 = arith.constant 104 : u32;
            v273 = hir.bitcast v675 : u32;
            v275 = arith.add v273, v274 : u32 #[overflow = checked];
            v701 = arith.constant 8 : u32;
            v277 = arith.mod v275, v701 : u32;
            hir.assertz v277 #[code = 250];
            v278 = hir.int_to_ptr v275 : ptr<byte, i64>;
            hir.store v278, v272;
            v279 = hir.bitcast v675 : u32;
            v700 = arith.constant 8 : u32;
            v281 = arith.mod v279, v700 : u32;
            hir.assertz v281 #[code = 250];
            v282 = hir.int_to_ptr v279 : ptr<byte, i64>;
            v283 = hir.load v282 : i64;
            v285 = arith.constant 96 : u32;
            v284 = hir.bitcast v675 : u32;
            v286 = arith.add v284, v285 : u32 #[overflow = checked];
            v699 = arith.constant 8 : u32;
            v288 = arith.mod v286, v699 : u32;
            hir.assertz v288 #[code = 250];
            v289 = hir.int_to_ptr v286 : ptr<byte, i64>;
            hir.store v289, v283;
            v290 = arith.constant 128 : i32;
            v291 = arith.add v675, v290 : i32 #[overflow = wrapping];
            hir.exec @miden:counter-contract/counter@0.1.0/counter_contract/<miden_stdlib_sys::intrinsics::word::Word as core::convert::From<miden_stdlib_sys::intrinsics::felt::Felt>>::from(v291, v239)
            v696 = arith.constant 128 : i32;
            v298 = arith.add v675, v696 : i32 #[overflow = wrapping];
            v295 = arith.constant 96 : i32;
            v296 = arith.add v675, v295 : i32 #[overflow = wrapping];
            v697 = arith.constant 0 : i32;
            v698 = arith.constant 32 : i32;
            v293 = arith.add v675, v698 : i32 #[overflow = wrapping];
            hir.exec @miden:counter-contract/counter@0.1.0/counter_contract/miden_base_sys::bindings::storage::set_map_item(v293, v697, v296, v298)
            v300 = builtin.global_symbol @miden:counter-contract/counter@0.1.0/counter_contract/__stack_pointer : ptr<byte, u8>
            v301 = hir.bitcast v300 : ptr<byte, i32>;
            hir.store v301, v676;
            builtin.ret v239;
        };

        public builtin.function @cabi_realloc_wit_bindgen_0_28_0(v302: i32, v303: i32, v304: i32, v305: i32) -> i32 {
        ^block35(v302: i32, v303: i32, v304: i32, v305: i32):
            v307 = hir.exec @miden:counter-contract/counter@0.1.0/counter_contract/wit_bindgen_rt::cabi_realloc(v302, v303, v304, v305) : i32
            builtin.ret v307;
        };

        private builtin.function @wit_bindgen_rt::cabi_realloc(v308: i32, v309: i32, v310: i32, v311: i32) -> i32 {
        ^block37(v308: i32, v309: i32, v310: i32, v311: i32):
            v313 = arith.constant 0 : i32;
            v314 = arith.neq v309, v313 : i1;
            v729, v730, v731 = scf.if v314 : i32, i32, u32 {
            ^block41:
                v329 = hir.exec @miden:counter-contract/counter@0.1.0/counter_contract/__rustc::__rust_realloc(v308, v309, v310, v311) : i32
                v720 = arith.constant 0 : u32;
                v724 = ub.poison i32 : i32;
                scf.yield v329, v724, v720;
            } else {
            ^block42:
                v754 = arith.constant 0 : i32;
                v755 = arith.constant 0 : i32;
                v316 = arith.eq v311, v755 : i1;
                v317 = arith.zext v316 : u32;
                v318 = hir.bitcast v317 : i32;
                v320 = arith.neq v318, v754 : i1;
                v740, v741, v742 = scf.if v320 : i32, i32, u32 {
                ^block89:
                    v725 = arith.constant 1 : u32;
                    v753 = ub.poison i32 : i32;
                    scf.yield v753, v310, v725;
                } else {
                ^block43:
                    v328 = hir.exec @miden:counter-contract/counter@0.1.0/counter_contract/__rustc::__rust_alloc(v311, v310) : i32
                    v751 = arith.constant 0 : u32;
                    v752 = ub.poison i32 : i32;
                    scf.yield v328, v752, v751;
                };
                scf.yield v740, v741, v742;
            };
            v736, v737 = scf.index_switch v731 : i32, u32 
            case 0 {
            ^block40:
                v749 = arith.constant 0 : i32;
                v332 = arith.neq v729, v749 : i1;
                v738, v739 = scf.if v332 : i32, u32 {
                ^block90:
                    v748 = arith.constant 0 : u32;
                    scf.yield v729, v748;
                } else {
                ^block44:
                    v746 = arith.constant 1 : u32;
                    v747 = ub.poison i32 : i32;
                    scf.yield v747, v746;
                };
                scf.yield v738, v739;
            }
            default {
            ^block96:
                v750 = arith.constant 0 : u32;
                scf.yield v730, v750;
            };
            v745 = arith.constant 0 : u32;
            v744 = arith.eq v737, v745 : i1;
            cf.cond_br v744 ^block91, ^block92;
        ^block91:
            builtin.ret v736;
        ^block92:
            ub.unreachable ;
        };

        private builtin.function @wit_bindgen_rt::run_ctors_once() {
        ^block45:
            v336 = arith.constant 1048617 : u32;
            v759 = arith.constant 0 : u32;
            v337 = arith.add v759, v336 : u32 #[overflow = checked];
            v338 = hir.int_to_ptr v337 : ptr<byte, u8>;
            v339 = hir.load v338 : u8;
            v334 = arith.constant 0 : i32;
            v340 = arith.zext v339 : u32;
            v341 = hir.bitcast v340 : i32;
            v343 = arith.neq v341, v334 : i1;
            scf.if v343{
            ^block47:
                scf.yield ;
            } else {
            ^block48:
                hir.exec @miden:counter-contract/counter@0.1.0/counter_contract/__wasm_call_ctors()
                v757 = arith.constant 1 : u8;
                v761 = arith.constant 1048617 : u32;
                v762 = arith.constant 0 : u32;
                v350 = arith.add v762, v761 : u32 #[overflow = checked];
                v351 = hir.int_to_ptr v350 : ptr<byte, u8>;
                hir.store v351, v757;
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v352: i32, v353: i32, v354: i32) -> i32 {
        ^block49(v352: i32, v353: i32, v354: i32):
            v357 = arith.constant 32 : i32;
            v356 = arith.constant 0 : i32;
            v764 = arith.constant 32 : u32;
            v359 = hir.bitcast v353 : u32;
            v361 = arith.gt v359, v764 : i1;
            v362 = arith.zext v361 : u32;
            v363 = hir.bitcast v362 : i32;
            v365 = arith.neq v363, v356 : i1;
            v366 = cf.select v365, v353, v357 : i32;
            v801 = arith.constant 0 : i32;
            v367 = arith.constant -1 : i32;
            v368 = arith.add v366, v367 : i32 #[overflow = wrapping];
            v369 = arith.band v366, v368 : i32;
            v371 = arith.neq v369, v801 : i1;
            v773, v774 = scf.if v371 : i32, u32 {
            ^block101:
                v765 = arith.constant 0 : u32;
                v769 = ub.poison i32 : i32;
                scf.yield v769, v765;
            } else {
            ^block52:
                v373 = hir.exec @miden:counter-contract/counter@0.1.0/counter_contract/core::ptr::alignment::Alignment::max(v353, v366) : i32
                v800 = arith.constant 0 : i32;
                v372 = arith.constant -2147483648 : i32;
                v374 = arith.sub v372, v373 : i32 #[overflow = wrapping];
                v376 = hir.bitcast v374 : u32;
                v375 = hir.bitcast v354 : u32;
                v377 = arith.gt v375, v376 : i1;
                v378 = arith.zext v377 : u32;
                v379 = hir.bitcast v378 : i32;
                v381 = arith.neq v379, v800 : i1;
                v777, v778 = scf.if v381 : i32, u32 {
                ^block100:
                    v798 = arith.constant 0 : u32;
                    v799 = ub.poison i32 : i32;
                    scf.yield v799, v798;
                } else {
                ^block53:
                    v796 = arith.constant 0 : i32;
                    v387 = arith.sub v796, v373 : i32 #[overflow = wrapping];
                    v797 = arith.constant -1 : i32;
                    v383 = arith.add v354, v373 : i32 #[overflow = wrapping];
                    v385 = arith.add v383, v797 : i32 #[overflow = wrapping];
                    v388 = arith.band v385, v387 : i32;
                    v389 = hir.bitcast v352 : u32;
                    v390 = arith.constant 4 : u32;
                    v391 = arith.mod v389, v390 : u32;
                    hir.assertz v391 #[code = 250];
                    v392 = hir.int_to_ptr v389 : ptr<byte, i32>;
                    v393 = hir.load v392 : i32;
                    v795 = arith.constant 0 : i32;
                    v395 = arith.neq v393, v795 : i1;
                    v779, v780, v781, v782 = scf.if v395 : i32, i32, i32, i32 {
                    ^block99:
                        v794 = arith.constant 0 : i32;
                        scf.yield v352, v388, v373, v794;
                    } else {
                    ^block55:
                        v396 = hir.exec @intrinsics/mem/heap_base() : i32
                        v397 = hir.mem_size  : u32;
                        v403 = hir.bitcast v352 : u32;
                        v793 = arith.constant 4 : u32;
                        v405 = arith.mod v403, v793 : u32;
                        hir.assertz v405 #[code = 250];
                        v763 = arith.constant 16 : u32;
                        v400 = arith.shl v397, v763 : u32;
                        v401 = hir.bitcast v400 : i32;
                        v402 = arith.add v396, v401 : i32 #[overflow = wrapping];
                        v406 = hir.int_to_ptr v403 : ptr<byte, i32>;
                        hir.store v406, v402;
                        v792 = arith.constant 0 : i32;
                        scf.yield v352, v388, v373, v792;
                    };
                    v409 = hir.bitcast v779 : u32;
                    v791 = arith.constant 4 : u32;
                    v411 = arith.mod v409, v791 : u32;
                    hir.assertz v411 #[code = 250];
                    v412 = hir.int_to_ptr v409 : ptr<byte, i32>;
                    v413 = hir.load v412 : i32;
                    v790 = arith.constant 0 : i32;
                    v417 = hir.bitcast v780 : u32;
                    v407 = arith.constant 268435456 : i32;
                    v414 = arith.sub v407, v413 : i32 #[overflow = wrapping];
                    v416 = hir.bitcast v414 : u32;
                    v418 = arith.lt v416, v417 : i1;
                    v419 = arith.zext v418 : u32;
                    v420 = hir.bitcast v419 : i32;
                    v422 = arith.neq v420, v790 : i1;
                    v783, v784 = scf.if v422 : i32, u32 {
                    ^block56:
                        v770 = arith.constant 1 : u32;
                        scf.yield v782, v770;
                    } else {
                    ^block57:
                        v424 = hir.bitcast v779 : u32;
                        v789 = arith.constant 4 : u32;
                        v426 = arith.mod v424, v789 : u32;
                        hir.assertz v426 #[code = 250];
                        v423 = arith.add v413, v780 : i32 #[overflow = wrapping];
                        v427 = hir.int_to_ptr v424 : ptr<byte, i32>;
                        hir.store v427, v423;
                        v788 = arith.constant 1 : u32;
                        v429 = arith.add v413, v781 : i32 #[overflow = wrapping];
                        scf.yield v429, v788;
                    };
                    scf.yield v783, v784;
                };
                scf.yield v777, v778;
            };
            v787 = arith.constant 0 : u32;
            v786 = arith.eq v774, v787 : i1;
            cf.cond_br v786 ^block51, ^block103(v773);
        ^block51:
            ub.unreachable ;
        ^block103(v766: i32):
            builtin.ret v766;
        };

        private builtin.function @miden_base_sys::bindings::storage::get_map_item(v432: i32, v433: i32, v434: i32) {
        ^block58(v432: i32, v433: i32, v434: i32):
            v438 = hir.bitcast v434 : u32;
            v439 = arith.constant 4 : u32;
            v440 = arith.mod v438, v439 : u32;
            hir.assertz v440 #[code = 250];
            v441 = hir.int_to_ptr v438 : ptr<byte, felt>;
            v442 = hir.load v441 : felt;
            v805 = arith.constant 4 : u32;
            v443 = hir.bitcast v434 : u32;
            v445 = arith.add v443, v805 : u32 #[overflow = checked];
            v804 = arith.constant 4 : u32;
            v447 = arith.mod v445, v804 : u32;
            hir.assertz v447 #[code = 250];
            v448 = hir.int_to_ptr v445 : ptr<byte, felt>;
            v449 = hir.load v448 : felt;
            v451 = arith.constant 8 : u32;
            v450 = hir.bitcast v434 : u32;
            v452 = arith.add v450, v451 : u32 #[overflow = checked];
            v803 = arith.constant 4 : u32;
            v454 = arith.mod v452, v803 : u32;
            hir.assertz v454 #[code = 250];
            v455 = hir.int_to_ptr v452 : ptr<byte, felt>;
            v456 = hir.load v455 : felt;
            v458 = arith.constant 12 : u32;
            v457 = hir.bitcast v434 : u32;
            v459 = arith.add v457, v458 : u32 #[overflow = checked];
            v802 = arith.constant 4 : u32;
            v461 = arith.mod v459, v802 : u32;
            hir.assertz v461 #[code = 250];
            v462 = hir.int_to_ptr v459 : ptr<byte, felt>;
            v463 = hir.load v462 : felt;
            v435 = arith.constant 255 : i32;
            v436 = arith.band v433, v435 : i32;
            v437 = hir.bitcast v436 : felt;
            hir.exec @miden:counter-contract/counter@0.1.0/counter_contract/miden_base_sys::bindings::storage::extern_get_storage_map_item(v437, v442, v449, v456, v463, v432)
            builtin.ret ;
        };

        private builtin.function @miden_base_sys::bindings::storage::set_map_item(v464: i32, v465: i32, v466: i32, v467: i32) {
        ^block60(v464: i32, v465: i32, v466: i32, v467: i32):
            v471 = hir.bitcast v466 : u32;
            v472 = arith.constant 4 : u32;
            v473 = arith.mod v471, v472 : u32;
            hir.assertz v473 #[code = 250];
            v474 = hir.int_to_ptr v471 : ptr<byte, felt>;
            v475 = hir.load v474 : felt;
            v816 = arith.constant 4 : u32;
            v476 = hir.bitcast v466 : u32;
            v478 = arith.add v476, v816 : u32 #[overflow = checked];
            v815 = arith.constant 4 : u32;
            v480 = arith.mod v478, v815 : u32;
            hir.assertz v480 #[code = 250];
            v481 = hir.int_to_ptr v478 : ptr<byte, felt>;
            v482 = hir.load v481 : felt;
            v484 = arith.constant 8 : u32;
            v483 = hir.bitcast v466 : u32;
            v485 = arith.add v483, v484 : u32 #[overflow = checked];
            v814 = arith.constant 4 : u32;
            v487 = arith.mod v485, v814 : u32;
            hir.assertz v487 #[code = 250];
            v488 = hir.int_to_ptr v485 : ptr<byte, felt>;
            v489 = hir.load v488 : felt;
            v491 = arith.constant 12 : u32;
            v490 = hir.bitcast v466 : u32;
            v492 = arith.add v490, v491 : u32 #[overflow = checked];
            v813 = arith.constant 4 : u32;
            v494 = arith.mod v492, v813 : u32;
            hir.assertz v494 #[code = 250];
            v495 = hir.int_to_ptr v492 : ptr<byte, felt>;
            v496 = hir.load v495 : felt;
            v497 = hir.bitcast v467 : u32;
            v812 = arith.constant 4 : u32;
            v499 = arith.mod v497, v812 : u32;
            hir.assertz v499 #[code = 250];
            v500 = hir.int_to_ptr v497 : ptr<byte, felt>;
            v501 = hir.load v500 : felt;
            v811 = arith.constant 4 : u32;
            v502 = hir.bitcast v467 : u32;
            v504 = arith.add v502, v811 : u32 #[overflow = checked];
            v810 = arith.constant 4 : u32;
            v506 = arith.mod v504, v810 : u32;
            hir.assertz v506 #[code = 250];
            v507 = hir.int_to_ptr v504 : ptr<byte, felt>;
            v508 = hir.load v507 : felt;
            v809 = arith.constant 8 : u32;
            v509 = hir.bitcast v467 : u32;
            v511 = arith.add v509, v809 : u32 #[overflow = checked];
            v808 = arith.constant 4 : u32;
            v513 = arith.mod v511, v808 : u32;
            hir.assertz v513 #[code = 250];
            v514 = hir.int_to_ptr v511 : ptr<byte, felt>;
            v515 = hir.load v514 : felt;
            v807 = arith.constant 12 : u32;
            v516 = hir.bitcast v467 : u32;
            v518 = arith.add v516, v807 : u32 #[overflow = checked];
            v806 = arith.constant 4 : u32;
            v520 = arith.mod v518, v806 : u32;
            hir.assertz v520 #[code = 250];
            v521 = hir.int_to_ptr v518 : ptr<byte, felt>;
            v522 = hir.load v521 : felt;
            v468 = arith.constant 255 : i32;
            v469 = arith.band v465, v468 : i32;
            v470 = hir.bitcast v469 : felt;
            hir.exec @miden:counter-contract/counter@0.1.0/counter_contract/miden_base_sys::bindings::storage::extern_set_storage_map_item(v470, v475, v482, v489, v496, v501, v508, v515, v522, v464)
            builtin.ret ;
        };

        private builtin.function @<miden_stdlib_sys::intrinsics::word::Word as core::convert::From<miden_stdlib_sys::intrinsics::felt::Felt>>::from(v523: i32, v524: felt) {
        ^block62(v523: i32, v524: felt):
            v533 = arith.constant 12 : u32;
            v532 = hir.bitcast v523 : u32;
            v534 = arith.add v532, v533 : u32 #[overflow = checked];
            v535 = arith.constant 4 : u32;
            v536 = arith.mod v534, v535 : u32;
            hir.assertz v536 #[code = 250];
            v537 = hir.int_to_ptr v534 : ptr<byte, felt>;
            hir.store v537, v524;
            v539 = arith.constant 8 : u32;
            v538 = hir.bitcast v523 : u32;
            v540 = arith.add v538, v539 : u32 #[overflow = checked];
            v825 = arith.constant 4 : u32;
            v542 = arith.mod v540, v825 : u32;
            hir.assertz v542 #[code = 250];
            v819 = arith.constant 0 : felt;
            v543 = hir.int_to_ptr v540 : ptr<byte, felt>;
            hir.store v543, v819;
            v824 = arith.constant 4 : u32;
            v544 = hir.bitcast v523 : u32;
            v546 = arith.add v544, v824 : u32 #[overflow = checked];
            v823 = arith.constant 4 : u32;
            v548 = arith.mod v546, v823 : u32;
            hir.assertz v548 #[code = 250];
            v822 = arith.constant 0 : felt;
            v549 = hir.int_to_ptr v546 : ptr<byte, felt>;
            hir.store v549, v822;
            v550 = hir.bitcast v523 : u32;
            v821 = arith.constant 4 : u32;
            v552 = arith.mod v550, v821 : u32;
            hir.assertz v552 #[code = 250];
            v820 = arith.constant 0 : felt;
            v553 = hir.int_to_ptr v550 : ptr<byte, felt>;
            hir.store v553, v820;
            builtin.ret ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v554: i32, v555: i32) -> i32 {
        ^block64(v554: i32, v555: i32):
            v562 = arith.constant 0 : i32;
            v558 = hir.bitcast v555 : u32;
            v557 = hir.bitcast v554 : u32;
            v559 = arith.gt v557, v558 : i1;
            v560 = arith.zext v559 : u32;
            v561 = hir.bitcast v560 : i32;
            v563 = arith.neq v561, v562 : i1;
            v564 = cf.select v563, v554, v555 : i32;
            builtin.ret v564;
        };

        public builtin.function @cabi_realloc(v565: i32, v566: i32, v567: i32, v568: i32) -> i32 {
        ^block66(v565: i32, v566: i32, v567: i32, v568: i32):
            v570 = hir.exec @miden:counter-contract/counter@0.1.0/counter_contract/cabi_realloc_wit_bindgen_0_28_0(v565, v566, v567, v568) : i32
            builtin.ret v570;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.segment readonly @1048576 = 0x000000020000000100000001000000010000000100000001000000010000000100000001;
    };

    public builtin.function @get-count() -> felt {
    ^block68:
        v571 = hir.exec @miden:counter-contract/counter@0.1.0/counter_contract/miden:counter-contract/counter@0.1.0#get-count() : felt
        builtin.ret v571;
    };

    public builtin.function @increment-count() -> felt {
    ^block70:
        v572 = hir.exec @miden:counter-contract/counter@0.1.0/counter_contract/miden:counter-contract/counter@0.1.0#increment-count() : felt
        builtin.ret v572;
    };
};