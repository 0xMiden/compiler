builtin.component miden:base/note-script@1.0.0 {
    builtin.module public @p2id {
        private builtin.function @p2id::bindings::miden::basic_wallet::basic_wallet::receive_asset::wit_import7(v0: felt, v1: felt, v2: felt, v3: felt) {
        ^block3(v0: felt, v1: felt, v2: felt, v3: felt):
            hir.call v0, v1, v2, v3 #[callee = miden:basic-wallet/basic-wallet@1.0.0/receive-asset] #[signature = (param felt) (param felt) (param felt) (param felt)];
            builtin.ret ;
        };

        private builtin.function @__wasm_call_ctors() {
        ^block8:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc(v4: i32, v5: i32) -> i32 {
        ^block10(v4: i32, v5: i32):
            v7 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
            v8 = hir.bitcast v7 : ptr<byte, i32>;
            v9 = hir.load v8 : i32;
            v10 = arith.constant 1048664 : i32;
            v11 = arith.add v9, v10 : i32 #[overflow = wrapping];
            v12 = hir.exec @miden:base/note-script@1.0.0/p2id/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v11, v5, v4) : i32
            builtin.ret v12;
        };

        private builtin.function @__rustc::__rust_dealloc(v13: i32, v14: i32, v15: i32) {
        ^block12(v13: i32, v14: i32, v15: i32):
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v16: i32, v17: i32) -> i32 {
        ^block14(v16: i32, v17: i32):
            v19 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
            v20 = hir.bitcast v19 : ptr<byte, i32>;
            v21 = hir.load v20 : i32;
            v22 = arith.constant 1048664 : i32;
            v23 = arith.add v21, v22 : i32 #[overflow = wrapping];
            v24 = hir.exec @miden:base/note-script@1.0.0/p2id/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v23, v17, v16) : i32
            v876 = arith.constant 0 : i32;
            v25 = arith.constant 0 : i32;
            v26 = arith.eq v24, v25 : i1;
            v27 = arith.zext v26 : u32;
            v28 = hir.bitcast v27 : i32;
            v30 = arith.neq v28, v876 : i1;
            scf.if v30{
            ^block16:
                scf.yield ;
            } else {
            ^block17:
                v874 = arith.constant 0 : i32;
                v875 = arith.constant 0 : i32;
                v32 = arith.eq v16, v875 : i1;
                v33 = arith.zext v32 : u32;
                v34 = hir.bitcast v33 : i32;
                v36 = arith.neq v34, v874 : i1;
                scf.if v36{
                ^block112:
                    scf.yield ;
                } else {
                ^block18:
                    v868 = arith.constant 0 : u8;
                    v39 = hir.bitcast v16 : u32;
                    v40 = hir.bitcast v24 : u32;
                    v41 = hir.int_to_ptr v40 : ptr<byte, u8>;
                    hir.mem_set v41, v39, v868;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v24;
        };

        private builtin.function @p2id::bindings::__link_custom_section_describing_imports() {
        ^block19:
            builtin.ret ;
        };

        private builtin.function @miden:base/note-script@1.0.0#run(v43: felt, v44: felt, v45: felt, v46: felt) {
        ^block21(v43: felt, v44: felt, v45: felt, v46: felt):
            v50 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v51 = hir.bitcast v50 : ptr<byte, i32>;
            v52 = hir.load v51 : i32;
            v53 = arith.constant 48 : i32;
            v54 = arith.sub v52, v53 : i32 #[overflow = wrapping];
            v55 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v56 = hir.bitcast v55 : ptr<byte, i32>;
            hir.store v56, v54;
            hir.exec @miden:base/note-script@1.0.0/p2id/wit_bindgen::rt::run_ctors_once()
            v57 = arith.constant 16 : i32;
            v58 = arith.add v54, v57 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/miden_base_sys::bindings::note::get_inputs(v58)
            v60 = arith.constant 24 : u32;
            v59 = hir.bitcast v54 : u32;
            v61 = arith.add v59, v60 : u32 #[overflow = checked];
            v62 = arith.constant 4 : u32;
            v63 = arith.mod v61, v62 : u32;
            hir.assertz v63 #[code = 250];
            v64 = hir.int_to_ptr v61 : ptr<byte, i32>;
            v65 = hir.load v64 : i32;
            v66 = hir.cast v65 : u32;
            v934 = scf.index_switch v66 : u32 
            case 0 {
            ^block117:
                v978 = arith.constant 1 : u32;
                scf.yield v978;
            }
            case 1 {
            ^block118:
                v977 = arith.constant 1 : u32;
                scf.yield v977;
            }
            default {
            ^block24:
                v68 = arith.constant 20 : u32;
                v67 = hir.bitcast v54 : u32;
                v69 = arith.add v67, v68 : u32 #[overflow = checked];
                v1011 = arith.constant 4 : u32;
                v71 = arith.mod v69, v1011 : u32;
                hir.assertz v71 #[code = 250];
                v72 = hir.int_to_ptr v69 : ptr<byte, i32>;
                v73 = hir.load v72 : i32;
                v1010 = arith.constant 4 : u32;
                v74 = hir.bitcast v73 : u32;
                v76 = arith.add v74, v1010 : u32 #[overflow = checked];
                v1009 = arith.constant 4 : u32;
                v78 = arith.mod v76, v1009 : u32;
                hir.assertz v78 #[code = 250];
                v79 = hir.int_to_ptr v76 : ptr<byte, felt>;
                v80 = hir.load v79 : felt;
                v81 = hir.bitcast v73 : u32;
                v1008 = arith.constant 4 : u32;
                v83 = arith.mod v81, v1008 : u32;
                hir.assertz v83 #[code = 250];
                v84 = hir.int_to_ptr v81 : ptr<byte, felt>;
                v85 = hir.load v84 : felt;
                v86 = arith.constant 8 : i32;
                v87 = arith.add v54, v86 : i32 #[overflow = wrapping];
                hir.exec @miden:base/note-script@1.0.0/p2id/miden_base_sys::bindings::account::get_id(v87)
                v89 = arith.constant 12 : u32;
                v88 = hir.bitcast v54 : u32;
                v90 = arith.add v88, v89 : u32 #[overflow = checked];
                v1007 = arith.constant 4 : u32;
                v92 = arith.mod v90, v1007 : u32;
                hir.assertz v92 #[code = 250];
                v93 = hir.int_to_ptr v90 : ptr<byte, felt>;
                v94 = hir.load v93 : felt;
                v96 = arith.constant 8 : u32;
                v95 = hir.bitcast v54 : u32;
                v97 = arith.add v95, v96 : u32 #[overflow = checked];
                v1006 = arith.constant 4 : u32;
                v99 = arith.mod v97, v1006 : u32;
                hir.assertz v99 #[code = 250];
                v100 = hir.int_to_ptr v97 : ptr<byte, felt>;
                v101 = hir.load v100 : felt;
                v102 = hir.exec @miden:base/note-script@1.0.0/p2id/intrinsics::felt::eq(v101, v85) : i32
                v47 = arith.constant 0 : i32;
                v103 = arith.constant 1 : i32;
                v104 = arith.neq v102, v103 : i1;
                v105 = arith.zext v104 : u32;
                v106 = hir.bitcast v105 : i32;
                v108 = arith.neq v106, v47 : i1;
                v936 = scf.if v108 : u32 {
                ^block116:
                    v886 = arith.constant 1 : u32;
                    scf.yield v886;
                } else {
                ^block25:
                    v109 = hir.exec @miden:base/note-script@1.0.0/p2id/intrinsics::felt::eq(v94, v80) : i32
                    v1004 = arith.constant 0 : i32;
                    v1005 = arith.constant 1 : i32;
                    v111 = arith.neq v109, v1005 : i1;
                    v112 = arith.zext v111 : u32;
                    v113 = hir.bitcast v112 : i32;
                    v115 = arith.neq v113, v1004 : i1;
                    scf.if v115{
                    ^block115:
                        scf.yield ;
                    } else {
                    ^block26:
                        v116 = arith.constant 28 : i32;
                        v117 = arith.add v54, v116 : i32 #[overflow = wrapping];
                        hir.exec @miden:base/note-script@1.0.0/p2id/miden_base_sys::bindings::note::get_assets(v117)
                        v119 = arith.constant 36 : u32;
                        v118 = hir.bitcast v54 : u32;
                        v120 = arith.add v118, v119 : u32 #[overflow = checked];
                        v1003 = arith.constant 4 : u32;
                        v122 = arith.mod v120, v1003 : u32;
                        hir.assertz v122 #[code = 250];
                        v123 = hir.int_to_ptr v120 : ptr<byte, i32>;
                        v124 = hir.load v123 : i32;
                        v129 = arith.constant 28 : u32;
                        v128 = hir.bitcast v54 : u32;
                        v130 = arith.add v128, v129 : u32 #[overflow = checked];
                        v1002 = arith.constant 4 : u32;
                        v132 = arith.mod v130, v1002 : u32;
                        hir.assertz v132 #[code = 250];
                        v133 = hir.int_to_ptr v130 : ptr<byte, i32>;
                        v134 = hir.load v133 : i32;
                        v136 = arith.constant 32 : u32;
                        v135 = hir.bitcast v54 : u32;
                        v137 = arith.add v135, v136 : u32 #[overflow = checked];
                        v1001 = arith.constant 4 : u32;
                        v139 = arith.mod v137, v1001 : u32;
                        hir.assertz v139 #[code = 250];
                        v140 = hir.int_to_ptr v137 : ptr<byte, i32>;
                        v141 = hir.load v140 : i32;
                        v1000 = arith.constant 4 : u32;
                        v127 = arith.shl v124, v1000 : i32;
                        v954, v955, v956, v957, v958, v959, v960, v961 = scf.while v127, v141, v54, v141, v134 : i32, i32, i32, i32, i32, i32, i32, i32 {
                        ^block130(v962: i32, v963: i32, v964: i32, v965: i32, v966: i32):
                            v998 = arith.constant 0 : i32;
                            v999 = arith.constant 0 : i32;
                            v144 = arith.eq v962, v999 : i1;
                            v145 = arith.zext v144 : u32;
                            v146 = hir.bitcast v145 : i32;
                            v148 = arith.neq v146, v998 : i1;
                            v947, v948 = scf.if v148 : i32, i32 {
                            ^block129:
                                v887 = ub.poison i32 : i32;
                                scf.yield v887, v887;
                            } else {
                            ^block30:
                                v150 = hir.bitcast v963 : u32;
                                v997 = arith.constant 4 : u32;
                                v152 = arith.mod v150, v997 : u32;
                                hir.assertz v152 #[code = 250];
                                v153 = hir.int_to_ptr v150 : ptr<byte, felt>;
                                v154 = hir.load v153 : felt;
                                v996 = arith.constant 4 : u32;
                                v155 = hir.bitcast v963 : u32;
                                v157 = arith.add v155, v996 : u32 #[overflow = checked];
                                v995 = arith.constant 4 : u32;
                                v159 = arith.mod v157, v995 : u32;
                                hir.assertz v159 #[code = 250];
                                v160 = hir.int_to_ptr v157 : ptr<byte, felt>;
                                v161 = hir.load v160 : felt;
                                v994 = arith.constant 8 : u32;
                                v162 = hir.bitcast v963 : u32;
                                v164 = arith.add v162, v994 : u32 #[overflow = checked];
                                v993 = arith.constant 4 : u32;
                                v166 = arith.mod v164, v993 : u32;
                                hir.assertz v166 #[code = 250];
                                v167 = hir.int_to_ptr v164 : ptr<byte, felt>;
                                v168 = hir.load v167 : felt;
                                v992 = arith.constant 12 : u32;
                                v169 = hir.bitcast v963 : u32;
                                v171 = arith.add v169, v992 : u32 #[overflow = checked];
                                v991 = arith.constant 4 : u32;
                                v173 = arith.mod v171, v991 : u32;
                                hir.assertz v173 #[code = 250];
                                v174 = hir.int_to_ptr v171 : ptr<byte, felt>;
                                v175 = hir.load v174 : felt;
                                hir.exec @miden:base/note-script@1.0.0/p2id/p2id::bindings::miden::basic_wallet::basic_wallet::receive_asset::wit_import7(v154, v161, v168, v175)
                                v990 = arith.constant 16 : i32;
                                v179 = arith.add v963, v990 : i32 #[overflow = wrapping];
                                v176 = arith.constant -16 : i32;
                                v177 = arith.add v962, v176 : i32 #[overflow = wrapping];
                                scf.yield v177, v179;
                            };
                            v986 = ub.poison i32 : i32;
                            v951 = cf.select v148, v986, v966 : i32;
                            v987 = ub.poison i32 : i32;
                            v950 = cf.select v148, v987, v965 : i32;
                            v988 = ub.poison i32 : i32;
                            v949 = cf.select v148, v988, v964 : i32;
                            v989 = arith.constant 1 : u32;
                            v878 = arith.constant 0 : u32;
                            v953 = cf.select v148, v878, v989 : u32;
                            v931 = arith.trunc v953 : i1;
                            scf.condition v931, v947, v948, v949, v950, v951, v964, v965, v966;
                        } do {
                        ^block131(v967: i32, v968: i32, v969: i32, v970: i32, v971: i32, v972: i32, v973: i32, v974: i32):
                            scf.yield v967, v968, v969, v970, v971;
                        };
                        v183 = arith.constant 44 : u32;
                        v182 = hir.bitcast v959 : u32;
                        v184 = arith.add v182, v183 : u32 #[overflow = checked];
                        v985 = arith.constant 4 : u32;
                        v186 = arith.mod v184, v985 : u32;
                        hir.assertz v186 #[code = 250];
                        v187 = hir.int_to_ptr v184 : ptr<byte, i32>;
                        hir.store v187, v960;
                        v190 = arith.constant 40 : u32;
                        v189 = hir.bitcast v959 : u32;
                        v191 = arith.add v189, v190 : u32 #[overflow = checked];
                        v984 = arith.constant 4 : u32;
                        v193 = arith.mod v191, v984 : u32;
                        hir.assertz v193 #[code = 250];
                        v194 = hir.int_to_ptr v191 : ptr<byte, i32>;
                        hir.store v194, v961;
                        v983 = arith.constant 16 : i32;
                        v195 = arith.constant 40 : i32;
                        v196 = arith.add v959, v195 : i32 #[overflow = wrapping];
                        hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::RawVecInner<A>::deallocate(v196, v983, v983)
                        v125 = arith.constant 4 : i32;
                        v982 = arith.constant 16 : i32;
                        v200 = arith.add v959, v982 : i32 #[overflow = wrapping];
                        hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::RawVecInner<A>::deallocate(v200, v125, v125)
                        v981 = arith.constant 48 : i32;
                        v204 = arith.add v959, v981 : i32 #[overflow = wrapping];
                        v205 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
                        v206 = hir.bitcast v205 : ptr<byte, i32>;
                        hir.store v206, v204;
                        scf.yield ;
                    };
                    v979 = arith.constant 0 : u32;
                    v980 = arith.constant 1 : u32;
                    v975 = cf.select v115, v980, v979 : u32;
                    scf.yield v975;
                };
                scf.yield v936;
            };
            v976 = arith.constant 0 : u32;
            v946 = arith.eq v934, v976 : i1;
            cf.cond_br v946 ^block120, ^block23;
        ^block23:
            ub.unreachable ;
        ^block120:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block31:
            builtin.ret ;
        };

        private builtin.function @wit_bindgen::rt::run_ctors_once() {
        ^block33:
            v208 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
            v209 = hir.bitcast v208 : ptr<byte, i32>;
            v210 = hir.load v209 : i32;
            v211 = arith.constant 1048668 : i32;
            v212 = arith.add v210, v211 : i32 #[overflow = wrapping];
            v213 = hir.bitcast v212 : u32;
            v214 = hir.int_to_ptr v213 : ptr<byte, u8>;
            v215 = hir.load v214 : u8;
            v207 = arith.constant 0 : i32;
            v216 = arith.zext v215 : u32;
            v217 = hir.bitcast v216 : i32;
            v219 = arith.neq v217, v207 : i1;
            scf.if v219{
            ^block35:
                scf.yield ;
            } else {
            ^block36:
                v220 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
                v221 = hir.bitcast v220 : ptr<byte, i32>;
                v222 = hir.load v221 : i32;
                hir.exec @miden:base/note-script@1.0.0/p2id/__wasm_call_ctors()
                v1013 = arith.constant 1 : u8;
                v1015 = arith.constant 1048668 : i32;
                v224 = arith.add v222, v1015 : i32 #[overflow = wrapping];
                v228 = hir.bitcast v224 : u32;
                v229 = hir.int_to_ptr v228 : ptr<byte, u8>;
                hir.store v229, v1013;
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v230: i32, v231: i32, v232: i32) -> i32 {
        ^block37(v230: i32, v231: i32, v232: i32):
            v235 = arith.constant 16 : i32;
            v234 = arith.constant 0 : i32;
            v1017 = arith.constant 16 : u32;
            v237 = hir.bitcast v231 : u32;
            v239 = arith.gt v237, v1017 : i1;
            v240 = arith.zext v239 : u32;
            v241 = hir.bitcast v240 : i32;
            v243 = arith.neq v241, v234 : i1;
            v244 = cf.select v243, v231, v235 : i32;
            v1057 = arith.constant 0 : i32;
            v245 = arith.constant -1 : i32;
            v246 = arith.add v244, v245 : i32 #[overflow = wrapping];
            v247 = arith.band v244, v246 : i32;
            v249 = arith.neq v247, v1057 : i1;
            v1026, v1027 = scf.if v249 : i32, u32 {
            ^block135:
                v1018 = arith.constant 0 : u32;
                v1022 = ub.poison i32 : i32;
                scf.yield v1022, v1018;
            } else {
            ^block40:
                v251 = hir.exec @miden:base/note-script@1.0.0/p2id/core::ptr::alignment::Alignment::max(v231, v244) : i32
                v1056 = arith.constant 0 : i32;
                v250 = arith.constant -2147483648 : i32;
                v252 = arith.sub v250, v251 : i32 #[overflow = wrapping];
                v254 = hir.bitcast v252 : u32;
                v253 = hir.bitcast v232 : u32;
                v255 = arith.gt v253, v254 : i1;
                v256 = arith.zext v255 : u32;
                v257 = hir.bitcast v256 : i32;
                v259 = arith.neq v257, v1056 : i1;
                v1041 = scf.if v259 : i32 {
                ^block134:
                    v1055 = ub.poison i32 : i32;
                    scf.yield v1055;
                } else {
                ^block41:
                    v1053 = arith.constant 0 : i32;
                    v265 = arith.sub v1053, v251 : i32 #[overflow = wrapping];
                    v1054 = arith.constant -1 : i32;
                    v261 = arith.add v232, v251 : i32 #[overflow = wrapping];
                    v263 = arith.add v261, v1054 : i32 #[overflow = wrapping];
                    v266 = arith.band v263, v265 : i32;
                    v267 = hir.bitcast v230 : u32;
                    v268 = arith.constant 4 : u32;
                    v269 = arith.mod v267, v268 : u32;
                    hir.assertz v269 #[code = 250];
                    v270 = hir.int_to_ptr v267 : ptr<byte, i32>;
                    v271 = hir.load v270 : i32;
                    v1052 = arith.constant 0 : i32;
                    v273 = arith.neq v271, v1052 : i1;
                    scf.if v273{
                    ^block133:
                        scf.yield ;
                    } else {
                    ^block43:
                        v274 = hir.exec @miden:base/note-script@1.0.0/p2id/intrinsics::mem::heap_base() : i32
                        v275 = hir.mem_size  : u32;
                        v281 = hir.bitcast v230 : u32;
                        v1051 = arith.constant 4 : u32;
                        v283 = arith.mod v281, v1051 : u32;
                        hir.assertz v283 #[code = 250];
                        v1050 = arith.constant 16 : u32;
                        v276 = hir.bitcast v275 : i32;
                        v279 = arith.shl v276, v1050 : i32;
                        v280 = arith.add v274, v279 : i32 #[overflow = wrapping];
                        v284 = hir.int_to_ptr v281 : ptr<byte, i32>;
                        hir.store v284, v280;
                        scf.yield ;
                    };
                    v287 = hir.bitcast v230 : u32;
                    v1049 = arith.constant 4 : u32;
                    v289 = arith.mod v287, v1049 : u32;
                    hir.assertz v289 #[code = 250];
                    v290 = hir.int_to_ptr v287 : ptr<byte, i32>;
                    v291 = hir.load v290 : i32;
                    v1047 = arith.constant 0 : i32;
                    v1048 = arith.constant -1 : i32;
                    v293 = arith.bxor v291, v1048 : i32;
                    v295 = hir.bitcast v293 : u32;
                    v294 = hir.bitcast v266 : u32;
                    v296 = arith.gt v294, v295 : i1;
                    v297 = arith.zext v296 : u32;
                    v298 = hir.bitcast v297 : i32;
                    v300 = arith.neq v298, v1047 : i1;
                    v1040 = scf.if v300 : i32 {
                    ^block44:
                        v1046 = arith.constant 0 : i32;
                        scf.yield v1046;
                    } else {
                    ^block45:
                        v302 = hir.bitcast v230 : u32;
                        v1045 = arith.constant 4 : u32;
                        v304 = arith.mod v302, v1045 : u32;
                        hir.assertz v304 #[code = 250];
                        v301 = arith.add v291, v266 : i32 #[overflow = wrapping];
                        v305 = hir.int_to_ptr v302 : ptr<byte, i32>;
                        hir.store v305, v301;
                        v307 = arith.add v291, v251 : i32 #[overflow = wrapping];
                        scf.yield v307;
                    };
                    scf.yield v1040;
                };
                v1023 = arith.constant 1 : u32;
                v1044 = arith.constant 0 : u32;
                v1042 = cf.select v259, v1044, v1023 : u32;
                scf.yield v1041, v1042;
            };
            v1043 = arith.constant 0 : u32;
            v1039 = arith.eq v1027, v1043 : i1;
            cf.cond_br v1039 ^block39, ^block137(v1026);
        ^block39:
            ub.unreachable ;
        ^block137(v1019: i32):
            builtin.ret v1019;
        };

        private builtin.function @intrinsics::mem::heap_base() -> i32 {
        ^block46:
            v310 = hir.exec @intrinsics/mem/heap_base() : i32
            builtin.ret v310;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::with_capacity_in(v312: i32, v313: i32, v314: i32, v315: i32) {
        ^block50(v312: i32, v313: i32, v314: i32, v315: i32):
            v317 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v318 = hir.bitcast v317 : ptr<byte, i32>;
            v319 = hir.load v318 : i32;
            v320 = arith.constant 16 : i32;
            v321 = arith.sub v319, v320 : i32 #[overflow = wrapping];
            v322 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v323 = hir.bitcast v322 : ptr<byte, i32>;
            hir.store v323, v321;
            v316 = arith.constant 0 : i32;
            v326 = arith.constant 256 : i32;
            v324 = arith.constant 4 : i32;
            v325 = arith.add v321, v324 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::RawVecInner<A>::try_allocate_in(v325, v326, v316, v313, v314)
            v329 = arith.constant 8 : u32;
            v328 = hir.bitcast v321 : u32;
            v330 = arith.add v328, v329 : u32 #[overflow = checked];
            v331 = arith.constant 4 : u32;
            v332 = arith.mod v330, v331 : u32;
            hir.assertz v332 #[code = 250];
            v333 = hir.int_to_ptr v330 : ptr<byte, i32>;
            v334 = hir.load v333 : i32;
            v1068 = arith.constant 4 : u32;
            v335 = hir.bitcast v321 : u32;
            v337 = arith.add v335, v1068 : u32 #[overflow = checked];
            v1067 = arith.constant 4 : u32;
            v339 = arith.mod v337, v1067 : u32;
            hir.assertz v339 #[code = 250];
            v340 = hir.int_to_ptr v337 : ptr<byte, i32>;
            v341 = hir.load v340 : i32;
            v1066 = arith.constant 0 : i32;
            v342 = arith.constant 1 : i32;
            v343 = arith.neq v341, v342 : i1;
            v344 = arith.zext v343 : u32;
            v345 = hir.bitcast v344 : i32;
            v347 = arith.neq v345, v1066 : i1;
            cf.cond_br v347 ^block52, ^block53;
        ^block52:
            v356 = arith.constant 12 : u32;
            v355 = hir.bitcast v321 : u32;
            v357 = arith.add v355, v356 : u32 #[overflow = checked];
            v1065 = arith.constant 4 : u32;
            v359 = arith.mod v357, v1065 : u32;
            hir.assertz v359 #[code = 250];
            v360 = hir.int_to_ptr v357 : ptr<byte, i32>;
            v361 = hir.load v360 : i32;
            v1064 = arith.constant 4 : u32;
            v362 = hir.bitcast v312 : u32;
            v364 = arith.add v362, v1064 : u32 #[overflow = checked];
            v1063 = arith.constant 4 : u32;
            v366 = arith.mod v364, v1063 : u32;
            hir.assertz v366 #[code = 250];
            v367 = hir.int_to_ptr v364 : ptr<byte, i32>;
            hir.store v367, v361;
            v368 = hir.bitcast v312 : u32;
            v1062 = arith.constant 4 : u32;
            v370 = arith.mod v368, v1062 : u32;
            hir.assertz v370 #[code = 250];
            v371 = hir.int_to_ptr v368 : ptr<byte, i32>;
            hir.store v371, v334;
            v1061 = arith.constant 16 : i32;
            v373 = arith.add v321, v1061 : i32 #[overflow = wrapping];
            v374 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v375 = hir.bitcast v374 : ptr<byte, i32>;
            hir.store v375, v373;
            builtin.ret ;
        ^block53:
            v1060 = arith.constant 12 : u32;
            v348 = hir.bitcast v321 : u32;
            v350 = arith.add v348, v1060 : u32 #[overflow = checked];
            v1059 = arith.constant 4 : u32;
            v352 = arith.mod v350, v1059 : u32;
            hir.assertz v352 #[code = 250];
            v353 = hir.int_to_ptr v350 : ptr<byte, i32>;
            v354 = hir.load v353 : i32;
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::handle_error(v334, v354, v315)
            ub.unreachable ;
        };

        private builtin.function @miden_base_sys::bindings::account::get_id(v376: i32) {
        ^block54(v376: i32):
            v378 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v379 = hir.bitcast v378 : ptr<byte, i32>;
            v380 = hir.load v379 : i32;
            v381 = arith.constant 16 : i32;
            v382 = arith.sub v380, v381 : i32 #[overflow = wrapping];
            v383 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v384 = hir.bitcast v383 : ptr<byte, i32>;
            hir.store v384, v382;
            v385 = arith.constant 8 : i32;
            v386 = arith.add v382, v385 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/miden::account::get_id(v386)
            v388 = arith.constant 8 : u32;
            v387 = hir.bitcast v382 : u32;
            v389 = arith.add v387, v388 : u32 #[overflow = checked];
            v390 = arith.constant 4 : u32;
            v391 = arith.mod v389, v390 : u32;
            hir.assertz v391 #[code = 250];
            v392 = hir.int_to_ptr v389 : ptr<byte, i64>;
            v393 = hir.load v392 : i64;
            v394 = hir.bitcast v376 : u32;
            v1070 = arith.constant 8 : u32;
            v396 = arith.mod v394, v1070 : u32;
            hir.assertz v396 #[code = 250];
            v397 = hir.int_to_ptr v394 : ptr<byte, i64>;
            hir.store v397, v393;
            v1069 = arith.constant 16 : i32;
            v399 = arith.add v382, v1069 : i32 #[overflow = wrapping];
            v400 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v401 = hir.bitcast v400 : ptr<byte, i32>;
            hir.store v401, v399;
            builtin.ret ;
        };

        private builtin.function @miden_base_sys::bindings::note::get_inputs(v402: i32) {
        ^block56(v402: i32):
            v404 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v405 = hir.bitcast v404 : ptr<byte, i32>;
            v406 = hir.load v405 : i32;
            v407 = arith.constant 16 : i32;
            v408 = arith.sub v406, v407 : i32 #[overflow = wrapping];
            v409 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v410 = hir.bitcast v409 : ptr<byte, i32>;
            hir.store v410, v408;
            v415 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
            v416 = hir.bitcast v415 : ptr<byte, i32>;
            v417 = hir.load v416 : i32;
            v418 = arith.constant 1048632 : i32;
            v419 = arith.add v417, v418 : i32 #[overflow = wrapping];
            v413 = arith.constant 4 : i32;
            v411 = arith.constant 8 : i32;
            v412 = arith.add v408, v411 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::RawVecInner<A>::with_capacity_in(v412, v413, v413, v419)
            v421 = arith.constant 8 : u32;
            v420 = hir.bitcast v408 : u32;
            v422 = arith.add v420, v421 : u32 #[overflow = checked];
            v423 = arith.constant 4 : u32;
            v424 = arith.mod v422, v423 : u32;
            hir.assertz v424 #[code = 250];
            v425 = hir.int_to_ptr v422 : ptr<byte, i32>;
            v426 = hir.load v425 : i32;
            v428 = arith.constant 12 : u32;
            v427 = hir.bitcast v408 : u32;
            v429 = arith.add v427, v428 : u32 #[overflow = checked];
            v1078 = arith.constant 4 : u32;
            v431 = arith.mod v429, v1078 : u32;
            hir.assertz v431 #[code = 250];
            v432 = hir.int_to_ptr v429 : ptr<byte, i32>;
            v433 = hir.load v432 : i32;
            v1071 = arith.constant 2 : u32;
            v435 = hir.bitcast v433 : u32;
            v437 = arith.shr v435, v1071 : u32;
            v438 = hir.bitcast v437 : i32;
            v439 = hir.exec @miden:base/note-script@1.0.0/p2id/miden::note::get_inputs(v438) : i32
            v1077 = arith.constant 8 : u32;
            v440 = hir.bitcast v402 : u32;
            v442 = arith.add v440, v1077 : u32 #[overflow = checked];
            v1076 = arith.constant 4 : u32;
            v444 = arith.mod v442, v1076 : u32;
            hir.assertz v444 #[code = 250];
            v445 = hir.int_to_ptr v442 : ptr<byte, i32>;
            hir.store v445, v439;
            v1075 = arith.constant 4 : u32;
            v446 = hir.bitcast v402 : u32;
            v448 = arith.add v446, v1075 : u32 #[overflow = checked];
            v1074 = arith.constant 4 : u32;
            v450 = arith.mod v448, v1074 : u32;
            hir.assertz v450 #[code = 250];
            v451 = hir.int_to_ptr v448 : ptr<byte, i32>;
            hir.store v451, v433;
            v452 = hir.bitcast v402 : u32;
            v1073 = arith.constant 4 : u32;
            v454 = arith.mod v452, v1073 : u32;
            hir.assertz v454 #[code = 250];
            v455 = hir.int_to_ptr v452 : ptr<byte, i32>;
            hir.store v455, v426;
            v1072 = arith.constant 16 : i32;
            v457 = arith.add v408, v1072 : i32 #[overflow = wrapping];
            v458 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v459 = hir.bitcast v458 : ptr<byte, i32>;
            hir.store v459, v457;
            builtin.ret ;
        };

        private builtin.function @miden_base_sys::bindings::note::get_assets(v460: i32) {
        ^block58(v460: i32):
            v462 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v463 = hir.bitcast v462 : ptr<byte, i32>;
            v464 = hir.load v463 : i32;
            v465 = arith.constant 16 : i32;
            v466 = arith.sub v464, v465 : i32 #[overflow = wrapping];
            v467 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v468 = hir.bitcast v467 : ptr<byte, i32>;
            hir.store v468, v466;
            v473 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
            v474 = hir.bitcast v473 : ptr<byte, i32>;
            v475 = hir.load v474 : i32;
            v476 = arith.constant 1048648 : i32;
            v477 = arith.add v475, v476 : i32 #[overflow = wrapping];
            v1087 = arith.constant 16 : i32;
            v469 = arith.constant 8 : i32;
            v470 = arith.add v466, v469 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::RawVecInner<A>::with_capacity_in(v470, v1087, v1087, v477)
            v479 = arith.constant 8 : u32;
            v478 = hir.bitcast v466 : u32;
            v480 = arith.add v478, v479 : u32 #[overflow = checked];
            v481 = arith.constant 4 : u32;
            v482 = arith.mod v480, v481 : u32;
            hir.assertz v482 #[code = 250];
            v483 = hir.int_to_ptr v480 : ptr<byte, i32>;
            v484 = hir.load v483 : i32;
            v486 = arith.constant 12 : u32;
            v485 = hir.bitcast v466 : u32;
            v487 = arith.add v485, v486 : u32 #[overflow = checked];
            v1086 = arith.constant 4 : u32;
            v489 = arith.mod v487, v1086 : u32;
            hir.assertz v489 #[code = 250];
            v490 = hir.int_to_ptr v487 : ptr<byte, i32>;
            v491 = hir.load v490 : i32;
            v1079 = arith.constant 2 : u32;
            v493 = hir.bitcast v491 : u32;
            v495 = arith.shr v493, v1079 : u32;
            v496 = hir.bitcast v495 : i32;
            v497 = hir.exec @miden:base/note-script@1.0.0/p2id/miden::note::get_assets(v496) : i32
            v1085 = arith.constant 8 : u32;
            v498 = hir.bitcast v460 : u32;
            v500 = arith.add v498, v1085 : u32 #[overflow = checked];
            v1084 = arith.constant 4 : u32;
            v502 = arith.mod v500, v1084 : u32;
            hir.assertz v502 #[code = 250];
            v503 = hir.int_to_ptr v500 : ptr<byte, i32>;
            hir.store v503, v497;
            v1083 = arith.constant 4 : u32;
            v504 = hir.bitcast v460 : u32;
            v506 = arith.add v504, v1083 : u32 #[overflow = checked];
            v1082 = arith.constant 4 : u32;
            v508 = arith.mod v506, v1082 : u32;
            hir.assertz v508 #[code = 250];
            v509 = hir.int_to_ptr v506 : ptr<byte, i32>;
            hir.store v509, v491;
            v510 = hir.bitcast v460 : u32;
            v1081 = arith.constant 4 : u32;
            v512 = arith.mod v510, v1081 : u32;
            hir.assertz v512 #[code = 250];
            v513 = hir.int_to_ptr v510 : ptr<byte, i32>;
            hir.store v513, v484;
            v1080 = arith.constant 16 : i32;
            v515 = arith.add v466, v1080 : i32 #[overflow = wrapping];
            v516 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v517 = hir.bitcast v516 : ptr<byte, i32>;
            hir.store v517, v515;
            builtin.ret ;
        };

        private builtin.function @intrinsics::felt::eq(v518: felt, v519: felt) -> i32 {
        ^block60(v518: felt, v519: felt):
            v520 = arith.eq v518, v519 : i1;
            v521 = hir.cast v520 : i32;
            builtin.ret v521;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v523: i32, v524: i32, v525: i32) {
        ^block62(v523: i32, v524: i32, v525: i32):
            v527 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v528 = hir.bitcast v527 : ptr<byte, i32>;
            v529 = hir.load v528 : i32;
            v530 = arith.constant 16 : i32;
            v531 = arith.sub v529, v530 : i32 #[overflow = wrapping];
            v532 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v533 = hir.bitcast v532 : ptr<byte, i32>;
            hir.store v533, v531;
            v534 = arith.constant 4 : i32;
            v535 = arith.add v531, v534 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::RawVecInner<A>::current_memory(v535, v523, v524, v525)
            v537 = arith.constant 8 : u32;
            v536 = hir.bitcast v531 : u32;
            v538 = arith.add v536, v537 : u32 #[overflow = checked];
            v539 = arith.constant 4 : u32;
            v540 = arith.mod v538, v539 : u32;
            hir.assertz v540 #[code = 250];
            v541 = hir.int_to_ptr v538 : ptr<byte, i32>;
            v542 = hir.load v541 : i32;
            v1094 = arith.constant 0 : i32;
            v526 = arith.constant 0 : i32;
            v544 = arith.eq v542, v526 : i1;
            v545 = arith.zext v544 : u32;
            v546 = hir.bitcast v545 : i32;
            v548 = arith.neq v546, v1094 : i1;
            scf.if v548{
            ^block143:
                scf.yield ;
            } else {
            ^block65:
                v1093 = arith.constant 4 : u32;
                v549 = hir.bitcast v531 : u32;
                v551 = arith.add v549, v1093 : u32 #[overflow = checked];
                v1092 = arith.constant 4 : u32;
                v553 = arith.mod v551, v1092 : u32;
                hir.assertz v553 #[code = 250];
                v554 = hir.int_to_ptr v551 : ptr<byte, i32>;
                v555 = hir.load v554 : i32;
                v557 = arith.constant 12 : u32;
                v556 = hir.bitcast v531 : u32;
                v558 = arith.add v556, v557 : u32 #[overflow = checked];
                v1091 = arith.constant 4 : u32;
                v560 = arith.mod v558, v1091 : u32;
                hir.assertz v560 #[code = 250];
                v561 = hir.int_to_ptr v558 : ptr<byte, i32>;
                v562 = hir.load v561 : i32;
                hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v555, v542, v562)
                scf.yield ;
            };
            v1090 = arith.constant 16 : i32;
            v565 = arith.add v531, v1090 : i32 #[overflow = wrapping];
            v566 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v567 = hir.bitcast v566 : ptr<byte, i32>;
            hir.store v567, v565;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::try_allocate_in(v568: i32, v569: i32, v570: i32, v571: i32, v572: i32) {
        ^block66(v568: i32, v569: i32, v570: i32, v571: i32, v572: i32):
            v575 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v576 = hir.bitcast v575 : ptr<byte, i32>;
            v577 = hir.load v576 : i32;
            v578 = arith.constant 16 : i32;
            v579 = arith.sub v577, v578 : i32 #[overflow = wrapping];
            v580 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v581 = hir.bitcast v580 : ptr<byte, i32>;
            hir.store v581, v579;
            v591 = hir.bitcast v569 : u32;
            v592 = arith.zext v591 : u64;
            v593 = hir.bitcast v592 : i64;
            v573 = arith.constant 0 : i32;
            v586 = arith.sub v573, v571 : i32 #[overflow = wrapping];
            v583 = arith.constant -1 : i32;
            v582 = arith.add v571, v572 : i32 #[overflow = wrapping];
            v584 = arith.add v582, v583 : i32 #[overflow = wrapping];
            v587 = arith.band v584, v586 : i32;
            v588 = hir.bitcast v587 : u32;
            v589 = arith.zext v588 : u64;
            v590 = hir.bitcast v589 : i64;
            v594 = arith.mul v590, v593 : i64 #[overflow = wrapping];
            v1198 = arith.constant 0 : i32;
            v595 = arith.constant 32 : i64;
            v597 = hir.cast v595 : u32;
            v596 = hir.bitcast v594 : u64;
            v598 = arith.shr v596, v597 : u64;
            v599 = hir.bitcast v598 : i64;
            v600 = arith.trunc v599 : i32;
            v602 = arith.neq v600, v1198 : i1;
            v1110, v1111, v1112, v1113, v1114, v1115 = scf.if v602 : i32, i32, i32, i32, i32, u32 {
            ^block145:
                v1095 = arith.constant 0 : u32;
                v1102 = ub.poison i32 : i32;
                scf.yield v568, v579, v1102, v1102, v1102, v1095;
            } else {
            ^block71:
                v603 = arith.trunc v594 : i32;
                v1197 = arith.constant 0 : i32;
                v604 = arith.constant -2147483648 : i32;
                v605 = arith.sub v604, v571 : i32 #[overflow = wrapping];
                v607 = hir.bitcast v605 : u32;
                v606 = hir.bitcast v603 : u32;
                v608 = arith.lte v606, v607 : i1;
                v609 = arith.zext v608 : u32;
                v610 = hir.bitcast v609 : i32;
                v612 = arith.neq v610, v1197 : i1;
                v1158 = scf.if v612 : i32 {
                ^block69:
                    v1196 = arith.constant 0 : i32;
                    v623 = arith.neq v603, v1196 : i1;
                    v1157 = scf.if v623 : i32 {
                    ^block73:
                        v1195 = arith.constant 0 : i32;
                        v639 = arith.neq v570, v1195 : i1;
                        v1156 = scf.if v639 : i32 {
                        ^block76:
                            v621 = arith.constant 1 : i32;
                            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::alloc::Global::alloc_impl(v579, v571, v603, v621)
                            v650 = hir.bitcast v579 : u32;
                            v695 = arith.constant 4 : u32;
                            v652 = arith.mod v650, v695 : u32;
                            hir.assertz v652 #[code = 250];
                            v653 = hir.int_to_ptr v650 : ptr<byte, i32>;
                            v654 = hir.load v653 : i32;
                            scf.yield v654;
                        } else {
                        ^block77:
                            v640 = arith.constant 8 : i32;
                            v641 = arith.add v579, v640 : i32 #[overflow = wrapping];
                            hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v641, v571, v603)
                            v625 = arith.constant 8 : u32;
                            v642 = hir.bitcast v579 : u32;
                            v644 = arith.add v642, v625 : u32 #[overflow = checked];
                            v1194 = arith.constant 4 : u32;
                            v646 = arith.mod v644, v1194 : u32;
                            hir.assertz v646 #[code = 250];
                            v647 = hir.int_to_ptr v644 : ptr<byte, i32>;
                            v648 = hir.load v647 : i32;
                            scf.yield v648;
                        };
                        v1192 = arith.constant 0 : i32;
                        v1193 = arith.constant 0 : i32;
                        v657 = arith.eq v1156, v1193 : i1;
                        v658 = arith.zext v657 : u32;
                        v659 = hir.bitcast v658 : i32;
                        v661 = arith.neq v659, v1192 : i1;
                        scf.if v661{
                        ^block78:
                            v1191 = arith.constant 8 : u32;
                            v678 = hir.bitcast v568 : u32;
                            v680 = arith.add v678, v1191 : u32 #[overflow = checked];
                            v1190 = arith.constant 4 : u32;
                            v682 = arith.mod v680, v1190 : u32;
                            hir.assertz v682 #[code = 250];
                            v683 = hir.int_to_ptr v680 : ptr<byte, i32>;
                            hir.store v683, v603;
                            v1189 = arith.constant 4 : u32;
                            v685 = hir.bitcast v568 : u32;
                            v687 = arith.add v685, v1189 : u32 #[overflow = checked];
                            v1188 = arith.constant 4 : u32;
                            v689 = arith.mod v687, v1188 : u32;
                            hir.assertz v689 #[code = 250];
                            v690 = hir.int_to_ptr v687 : ptr<byte, i32>;
                            hir.store v690, v571;
                            scf.yield ;
                        } else {
                        ^block79:
                            v1187 = arith.constant 8 : u32;
                            v663 = hir.bitcast v568 : u32;
                            v665 = arith.add v663, v1187 : u32 #[overflow = checked];
                            v1186 = arith.constant 4 : u32;
                            v667 = arith.mod v665, v1186 : u32;
                            hir.assertz v667 #[code = 250];
                            v668 = hir.int_to_ptr v665 : ptr<byte, i32>;
                            hir.store v668, v1156;
                            v1185 = arith.constant 4 : u32;
                            v670 = hir.bitcast v568 : u32;
                            v672 = arith.add v670, v1185 : u32 #[overflow = checked];
                            v1184 = arith.constant 4 : u32;
                            v674 = arith.mod v672, v1184 : u32;
                            hir.assertz v674 #[code = 250];
                            v675 = hir.int_to_ptr v672 : ptr<byte, i32>;
                            hir.store v675, v569;
                            scf.yield ;
                        };
                        v1182 = arith.constant 0 : i32;
                        v1183 = arith.constant 1 : i32;
                        v1155 = cf.select v661, v1183, v1182 : i32;
                        scf.yield v1155;
                    } else {
                    ^block74:
                        v1181 = arith.constant 8 : u32;
                        v624 = hir.bitcast v568 : u32;
                        v626 = arith.add v624, v1181 : u32 #[overflow = checked];
                        v1180 = arith.constant 4 : u32;
                        v628 = arith.mod v626, v1180 : u32;
                        hir.assertz v628 #[code = 250];
                        v629 = hir.int_to_ptr v626 : ptr<byte, i32>;
                        hir.store v629, v571;
                        v1179 = arith.constant 4 : u32;
                        v632 = hir.bitcast v568 : u32;
                        v634 = arith.add v632, v1179 : u32 #[overflow = checked];
                        v1178 = arith.constant 4 : u32;
                        v636 = arith.mod v634, v1178 : u32;
                        hir.assertz v636 #[code = 250];
                        v1177 = arith.constant 0 : i32;
                        v637 = hir.int_to_ptr v634 : ptr<byte, i32>;
                        hir.store v637, v1177;
                        v1176 = arith.constant 0 : i32;
                        scf.yield v1176;
                    };
                    scf.yield v1157;
                } else {
                ^block72:
                    v1175 = ub.poison i32 : i32;
                    scf.yield v1175;
                };
                v1170 = arith.constant 0 : u32;
                v1103 = arith.constant 1 : u32;
                v1163 = cf.select v612, v1103, v1170 : u32;
                v1171 = ub.poison i32 : i32;
                v1162 = cf.select v612, v579, v1171 : i32;
                v1172 = ub.poison i32 : i32;
                v1161 = cf.select v612, v568, v1172 : i32;
                v1173 = ub.poison i32 : i32;
                v1160 = cf.select v612, v1173, v579 : i32;
                v1174 = ub.poison i32 : i32;
                v1159 = cf.select v612, v1174, v568 : i32;
                scf.yield v1159, v1160, v1161, v1158, v1162, v1163;
            };
            v1116, v1117, v1118 = scf.index_switch v1115 : i32, i32, i32 
            case 0 {
            ^block70:
                v1169 = arith.constant 4 : u32;
                v615 = hir.bitcast v1110 : u32;
                v617 = arith.add v615, v1169 : u32 #[overflow = checked];
                v1168 = arith.constant 4 : u32;
                v619 = arith.mod v617, v1168 : u32;
                hir.assertz v619 #[code = 250];
                v1167 = arith.constant 0 : i32;
                v620 = hir.int_to_ptr v617 : ptr<byte, i32>;
                hir.store v620, v1167;
                v1166 = arith.constant 1 : i32;
                scf.yield v1110, v1166, v1111;
            }
            default {
            ^block149:
                scf.yield v1112, v1113, v1114;
            };
            v694 = hir.bitcast v1116 : u32;
            v1165 = arith.constant 4 : u32;
            v696 = arith.mod v694, v1165 : u32;
            hir.assertz v696 #[code = 250];
            v697 = hir.int_to_ptr v694 : ptr<byte, i32>;
            hir.store v697, v1117;
            v1164 = arith.constant 16 : i32;
            v702 = arith.add v1118, v1164 : i32 #[overflow = wrapping];
            v703 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v704 = hir.bitcast v703 : ptr<byte, i32>;
            hir.store v704, v702;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v705: i32, v706: i32, v707: i32) {
        ^block80(v705: i32, v706: i32, v707: i32):
            v709 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v710 = hir.bitcast v709 : ptr<byte, i32>;
            v711 = hir.load v710 : i32;
            v712 = arith.constant 16 : i32;
            v713 = arith.sub v711, v712 : i32 #[overflow = wrapping];
            v714 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v715 = hir.bitcast v714 : ptr<byte, i32>;
            hir.store v715, v713;
            v708 = arith.constant 0 : i32;
            v716 = arith.constant 8 : i32;
            v717 = arith.add v713, v716 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::alloc::Global::alloc_impl(v717, v706, v707, v708)
            v720 = arith.constant 12 : u32;
            v719 = hir.bitcast v713 : u32;
            v721 = arith.add v719, v720 : u32 #[overflow = checked];
            v722 = arith.constant 4 : u32;
            v723 = arith.mod v721, v722 : u32;
            hir.assertz v723 #[code = 250];
            v724 = hir.int_to_ptr v721 : ptr<byte, i32>;
            v725 = hir.load v724 : i32;
            v727 = arith.constant 8 : u32;
            v726 = hir.bitcast v713 : u32;
            v728 = arith.add v726, v727 : u32 #[overflow = checked];
            v1203 = arith.constant 4 : u32;
            v730 = arith.mod v728, v1203 : u32;
            hir.assertz v730 #[code = 250];
            v731 = hir.int_to_ptr v728 : ptr<byte, i32>;
            v732 = hir.load v731 : i32;
            v733 = hir.bitcast v705 : u32;
            v1202 = arith.constant 4 : u32;
            v735 = arith.mod v733, v1202 : u32;
            hir.assertz v735 #[code = 250];
            v736 = hir.int_to_ptr v733 : ptr<byte, i32>;
            hir.store v736, v732;
            v1201 = arith.constant 4 : u32;
            v737 = hir.bitcast v705 : u32;
            v739 = arith.add v737, v1201 : u32 #[overflow = checked];
            v1200 = arith.constant 4 : u32;
            v741 = arith.mod v739, v1200 : u32;
            hir.assertz v741 #[code = 250];
            v742 = hir.int_to_ptr v739 : ptr<byte, i32>;
            hir.store v742, v725;
            v1199 = arith.constant 16 : i32;
            v744 = arith.add v713, v1199 : i32 #[overflow = wrapping];
            v745 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v746 = hir.bitcast v745 : ptr<byte, i32>;
            hir.store v746, v744;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v747: i32, v748: i32, v749: i32, v750: i32) {
        ^block82(v747: i32, v748: i32, v749: i32, v750: i32):
            v1219 = arith.constant 0 : i32;
            v751 = arith.constant 0 : i32;
            v752 = arith.eq v749, v751 : i1;
            v753 = arith.zext v752 : u32;
            v754 = hir.bitcast v753 : i32;
            v756 = arith.neq v754, v1219 : i1;
            v1215 = scf.if v756 : i32 {
            ^block152:
                scf.yield v748;
            } else {
            ^block85:
                hir.exec @miden:base/note-script@1.0.0/p2id/__rustc::__rust_no_alloc_shim_is_unstable_v2()
                v1218 = arith.constant 0 : i32;
                v758 = arith.neq v750, v1218 : i1;
                v1214 = scf.if v758 : i32 {
                ^block86:
                    v760 = hir.exec @miden:base/note-script@1.0.0/p2id/__rustc::__rust_alloc_zeroed(v749, v748) : i32
                    scf.yield v760;
                } else {
                ^block87:
                    v759 = hir.exec @miden:base/note-script@1.0.0/p2id/__rustc::__rust_alloc(v749, v748) : i32
                    scf.yield v759;
                };
                scf.yield v1214;
            };
            v764 = arith.constant 4 : u32;
            v763 = hir.bitcast v747 : u32;
            v765 = arith.add v763, v764 : u32 #[overflow = checked];
            v1217 = arith.constant 4 : u32;
            v767 = arith.mod v765, v1217 : u32;
            hir.assertz v767 #[code = 250];
            v768 = hir.int_to_ptr v765 : ptr<byte, i32>;
            hir.store v768, v749;
            v770 = hir.bitcast v747 : u32;
            v1216 = arith.constant 4 : u32;
            v772 = arith.mod v770, v1216 : u32;
            hir.assertz v772 #[code = 250];
            v773 = hir.int_to_ptr v770 : ptr<byte, i32>;
            hir.store v773, v1215;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v774: i32, v775: i32, v776: i32, v777: i32) {
        ^block88(v774: i32, v775: i32, v776: i32, v777: i32):
            v1245 = arith.constant 0 : i32;
            v778 = arith.constant 0 : i32;
            v782 = arith.eq v777, v778 : i1;
            v783 = arith.zext v782 : u32;
            v784 = hir.bitcast v783 : i32;
            v786 = arith.neq v784, v1245 : i1;
            v1232, v1233 = scf.if v786 : i32, i32 {
            ^block156:
                v1244 = arith.constant 0 : i32;
                v780 = arith.constant 4 : i32;
                scf.yield v780, v1244;
            } else {
            ^block91:
                v787 = hir.bitcast v775 : u32;
                v822 = arith.constant 4 : u32;
                v789 = arith.mod v787, v822 : u32;
                hir.assertz v789 #[code = 250];
                v790 = hir.int_to_ptr v787 : ptr<byte, i32>;
                v791 = hir.load v790 : i32;
                v1242 = arith.constant 0 : i32;
                v1243 = arith.constant 0 : i32;
                v793 = arith.eq v791, v1243 : i1;
                v794 = arith.zext v793 : u32;
                v795 = hir.bitcast v794 : i32;
                v797 = arith.neq v795, v1242 : i1;
                v1230 = scf.if v797 : i32 {
                ^block155:
                    v1241 = arith.constant 0 : i32;
                    scf.yield v1241;
                } else {
                ^block92:
                    v1240 = arith.constant 4 : u32;
                    v798 = hir.bitcast v774 : u32;
                    v800 = arith.add v798, v1240 : u32 #[overflow = checked];
                    v1239 = arith.constant 4 : u32;
                    v802 = arith.mod v800, v1239 : u32;
                    hir.assertz v802 #[code = 250];
                    v803 = hir.int_to_ptr v800 : ptr<byte, i32>;
                    hir.store v803, v776;
                    v1238 = arith.constant 4 : u32;
                    v804 = hir.bitcast v775 : u32;
                    v806 = arith.add v804, v1238 : u32 #[overflow = checked];
                    v1237 = arith.constant 4 : u32;
                    v808 = arith.mod v806, v1237 : u32;
                    hir.assertz v808 #[code = 250];
                    v809 = hir.int_to_ptr v806 : ptr<byte, i32>;
                    v810 = hir.load v809 : i32;
                    v811 = hir.bitcast v774 : u32;
                    v1236 = arith.constant 4 : u32;
                    v813 = arith.mod v811, v1236 : u32;
                    hir.assertz v813 #[code = 250];
                    v814 = hir.int_to_ptr v811 : ptr<byte, i32>;
                    hir.store v814, v810;
                    v815 = arith.mul v791, v777 : i32 #[overflow = wrapping];
                    scf.yield v815;
                };
                v816 = arith.constant 8 : i32;
                v1235 = arith.constant 4 : i32;
                v1231 = cf.select v797, v1235, v816 : i32;
                scf.yield v1231, v1230;
            };
            v819 = arith.add v774, v1232 : i32 #[overflow = wrapping];
            v821 = hir.bitcast v819 : u32;
            v1234 = arith.constant 4 : u32;
            v823 = arith.mod v821, v1234 : u32;
            hir.assertz v823 #[code = 250];
            v824 = hir.int_to_ptr v821 : ptr<byte, i32>;
            hir.store v824, v1233;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v825: i32, v826: i32, v827: i32) {
        ^block93(v825: i32, v826: i32, v827: i32):
            v1247 = arith.constant 0 : i32;
            v828 = arith.constant 0 : i32;
            v829 = arith.eq v827, v828 : i1;
            v830 = arith.zext v829 : u32;
            v831 = hir.bitcast v830 : i32;
            v833 = arith.neq v831, v1247 : i1;
            scf.if v833{
            ^block95:
                scf.yield ;
            } else {
            ^block96:
                hir.exec @miden:base/note-script@1.0.0/p2id/__rustc::__rust_dealloc(v825, v827, v826)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v834: i32, v835: i32, v836: i32) {
        ^block97(v834: i32, v835: i32, v836: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v837: i32, v838: i32) -> i32 {
        ^block99(v837: i32, v838: i32):
            v845 = arith.constant 0 : i32;
            v841 = hir.bitcast v838 : u32;
            v840 = hir.bitcast v837 : u32;
            v842 = arith.gt v840, v841 : i1;
            v843 = arith.zext v842 : u32;
            v844 = hir.bitcast v843 : i32;
            v846 = arith.neq v844, v845 : i1;
            v847 = cf.select v846, v837, v838 : i32;
            builtin.ret v847;
        };

        private builtin.function @miden::account::get_id(v848: i32) {
        ^block101(v848: i32):
            v849, v850 = hir.exec @miden/account/get_id() : felt, felt
            v851 = hir.bitcast v848 : u32;
            v852 = hir.int_to_ptr v851 : ptr<byte, felt>;
            hir.store v852, v849;
            v853 = arith.constant 4 : u32;
            v854 = arith.add v851, v853 : u32 #[overflow = checked];
            v855 = hir.int_to_ptr v854 : ptr<byte, felt>;
            hir.store v855, v850;
            builtin.ret ;
        };

        private builtin.function @miden::note::get_inputs(v856: i32) -> i32 {
        ^block105(v856: i32):
            v857, v858 = hir.exec @miden/note/get_inputs(v856) : i32, i32
            builtin.ret v857;
        };

        private builtin.function @miden::note::get_assets(v860: i32) -> i32 {
        ^block108(v860: i32):
            v861, v862 = hir.exec @miden/note/get_assets(v860) : i32, i32
            builtin.ret v861;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.global_variable private @#GOT.data.internal.__memory_base : i32 {
            builtin.ret_imm 0;
        };

        builtin.segment readonly @1048576 = 0x0073722e65746f6e2f73676e69646e69622f6372732f302e362e302d7379732d657361622d6e6564696d;

        builtin.segment @1048620 = 0x0000002200000037000000290010000000000021000000190000002900100000000000010000000100000001;
    };

    public builtin.function @run(v864: felt, v865: felt, v866: felt, v867: felt) {
    ^block110(v864: felt, v865: felt, v866: felt, v867: felt):
        hir.exec @miden:base/note-script@1.0.0/p2id/miden:base/note-script@1.0.0#run(v864, v865, v866, v867)
        builtin.ret ;
    };
};