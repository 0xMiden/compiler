builtin.component miden:base/note-script@1.0.0 {
    builtin.module public @p2id {
        private builtin.function @p2id::bindings::miden::basic_wallet::basic_wallet::receive_asset::wit_import7(v0: felt, v1: felt, v2: felt, v3: felt) {
        ^block3(v0: felt, v1: felt, v2: felt, v3: felt):
            hir.call v0, v1, v2, v3 #[callee = miden:basic-wallet/basic-wallet@0.1.0/receive-asset] #[signature = (param felt) (param felt) (param felt) (param felt)];
            builtin.ret ;
        };

        private builtin.function @__wasm_call_ctors() {
        ^block8:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc(v4: i32, v5: i32) -> i32 {
        ^block10(v4: i32, v5: i32):
            v7 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
            v8 = hir.bitcast v7 : ptr<byte, i32>;
            v9 = hir.load v8 : i32;
            v10 = arith.constant 1048588 : i32;
            v11 = arith.add v9, v10 : i32 #[overflow = wrapping];
            v12 = hir.exec @miden:base/note-script@1.0.0/p2id/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v11, v5, v4) : i32
            builtin.ret v12;
        };

        private builtin.function @__rustc::__rust_dealloc(v13: i32, v14: i32, v15: i32) {
        ^block12(v13: i32, v14: i32, v15: i32):
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v16: i32, v17: i32) -> i32 {
        ^block14(v16: i32, v17: i32):
            v19 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
            v20 = hir.bitcast v19 : ptr<byte, i32>;
            v21 = hir.load v20 : i32;
            v22 = arith.constant 1048588 : i32;
            v23 = arith.add v21, v22 : i32 #[overflow = wrapping];
            v24 = hir.exec @miden:base/note-script@1.0.0/p2id/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v23, v17, v16) : i32
            v969 = arith.constant 0 : i32;
            v25 = arith.constant 0 : i32;
            v26 = arith.eq v24, v25 : i1;
            v27 = arith.zext v26 : u32;
            v28 = hir.bitcast v27 : i32;
            v30 = arith.neq v28, v969 : i1;
            scf.if v30{
            ^block16:
                scf.yield ;
            } else {
            ^block17:
                v967 = arith.constant 0 : i32;
                v968 = arith.constant 0 : i32;
                v32 = arith.eq v16, v968 : i1;
                v33 = arith.zext v32 : u32;
                v34 = hir.bitcast v33 : i32;
                v36 = arith.neq v34, v967 : i1;
                scf.if v36{
                ^block123:
                    scf.yield ;
                } else {
                ^block18:
                    v961 = arith.constant 0 : u8;
                    v39 = hir.bitcast v16 : u32;
                    v40 = hir.bitcast v24 : u32;
                    v41 = hir.int_to_ptr v40 : ptr<byte, u8>;
                    hir.mem_set v41, v39, v961;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v24;
        };

        private builtin.function @p2id::bindings::__link_custom_section_describing_imports() {
        ^block19:
            builtin.ret ;
        };

        private builtin.function @miden:base/note-script@1.0.0#run(v43: felt, v44: felt, v45: felt, v46: felt) {
        ^block21(v43: felt, v44: felt, v45: felt, v46: felt):
            v50 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v51 = hir.bitcast v50 : ptr<byte, i32>;
            v52 = hir.load v51 : i32;
            v53 = arith.constant 48 : i32;
            v54 = arith.sub v52, v53 : i32 #[overflow = wrapping];
            v55 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v56 = hir.bitcast v55 : ptr<byte, i32>;
            hir.store v56, v54;
            hir.exec @miden:base/note-script@1.0.0/p2id/wit_bindgen::rt::run_ctors_once()
            v57 = arith.constant 32 : i32;
            v58 = arith.add v54, v57 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/miden_base_sys::bindings::active_note::get_inputs(v58)
            v60 = arith.constant 40 : u32;
            v59 = hir.bitcast v54 : u32;
            v61 = arith.add v59, v60 : u32 #[overflow = checked];
            v62 = arith.constant 4 : u32;
            v63 = arith.mod v61, v62 : u32;
            hir.assertz v63 #[code = 250];
            v64 = hir.int_to_ptr v61 : ptr<byte, i32>;
            v65 = hir.load v64 : i32;
            v66 = hir.cast v65 : u32;
            v1015 = scf.index_switch v66 : u32 
            case 0 {
            ^block128:
                v1052 = arith.constant 1 : u32;
                scf.yield v1052;
            }
            case 1 {
            ^block129:
                v1051 = arith.constant 1 : u32;
                scf.yield v1051;
            }
            default {
            ^block24:
                v68 = arith.constant 36 : u32;
                v67 = hir.bitcast v54 : u32;
                v69 = arith.add v67, v68 : u32 #[overflow = checked];
                v1088 = arith.constant 4 : u32;
                v71 = arith.mod v69, v1088 : u32;
                hir.assertz v71 #[code = 250];
                v72 = hir.int_to_ptr v69 : ptr<byte, i32>;
                v73 = hir.load v72 : i32;
                v1087 = arith.constant 4 : u32;
                v74 = hir.bitcast v73 : u32;
                v76 = arith.add v74, v1087 : u32 #[overflow = checked];
                v1086 = arith.constant 4 : u32;
                v78 = arith.mod v76, v1086 : u32;
                hir.assertz v78 #[code = 250];
                v79 = hir.int_to_ptr v76 : ptr<byte, felt>;
                v80 = hir.load v79 : felt;
                v81 = hir.bitcast v73 : u32;
                v1085 = arith.constant 4 : u32;
                v83 = arith.mod v81, v1085 : u32;
                hir.assertz v83 #[code = 250];
                v84 = hir.int_to_ptr v81 : ptr<byte, felt>;
                v85 = hir.load v84 : felt;
                v1084 = arith.constant 32 : i32;
                v87 = arith.add v54, v1084 : i32 #[overflow = wrapping];
                hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::vec::Vec<miden_field::wasm32::Felt> as core::ops::drop::Drop>::drop(v87)
                v1083 = arith.constant 32 : i32;
                v89 = arith.add v54, v1083 : i32 #[overflow = wrapping];
                hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::raw_vec::RawVec<miden_field::wasm32::Felt> as core::ops::drop::Drop>::drop(v89)
                v90 = arith.constant 8 : i32;
                v91 = arith.add v54, v90 : i32 #[overflow = wrapping];
                hir.exec @miden:base/note-script@1.0.0/p2id/miden_base_sys::bindings::active_account::get_id(v91)
                v93 = arith.constant 12 : u32;
                v92 = hir.bitcast v54 : u32;
                v94 = arith.add v92, v93 : u32 #[overflow = checked];
                v1082 = arith.constant 4 : u32;
                v96 = arith.mod v94, v1082 : u32;
                hir.assertz v96 #[code = 250];
                v97 = hir.int_to_ptr v94 : ptr<byte, felt>;
                v98 = hir.load v97 : felt;
                v100 = arith.constant 8 : u32;
                v99 = hir.bitcast v54 : u32;
                v101 = arith.add v99, v100 : u32 #[overflow = checked];
                v1081 = arith.constant 4 : u32;
                v103 = arith.mod v101, v1081 : u32;
                hir.assertz v103 #[code = 250];
                v104 = hir.int_to_ptr v101 : ptr<byte, felt>;
                v105 = hir.load v104 : felt;
                v47 = arith.constant 0 : i32;
                v108 = arith.constant 1 : i32;
                v106 = arith.eq v105, v85 : i1;
                v107 = hir.cast v106 : i32;
                v109 = arith.neq v107, v108 : i1;
                v110 = arith.zext v109 : u32;
                v111 = hir.bitcast v110 : i32;
                v113 = arith.neq v111, v47 : i1;
                v1017 = scf.if v113 : u32 {
                ^block127:
                    v978 = arith.constant 1 : u32;
                    scf.yield v978;
                } else {
                ^block25:
                    v1079 = arith.constant 0 : i32;
                    v1080 = arith.constant 1 : i32;
                    v114 = arith.eq v98, v80 : i1;
                    v115 = hir.cast v114 : i32;
                    v117 = arith.neq v115, v1080 : i1;
                    v118 = arith.zext v117 : u32;
                    v119 = hir.bitcast v118 : i32;
                    v121 = arith.neq v119, v1079 : i1;
                    scf.if v121{
                    ^block126:
                        scf.yield ;
                    } else {
                    ^block26:
                        v122 = arith.constant 20 : i32;
                        v123 = arith.add v54, v122 : i32 #[overflow = wrapping];
                        hir.exec @miden:base/note-script@1.0.0/p2id/miden_base_sys::bindings::active_note::get_assets(v123)
                        v125 = arith.constant 28 : u32;
                        v124 = hir.bitcast v54 : u32;
                        v126 = arith.add v124, v125 : u32 #[overflow = checked];
                        v1078 = arith.constant 4 : u32;
                        v128 = arith.mod v126, v1078 : u32;
                        hir.assertz v128 #[code = 250];
                        v129 = hir.int_to_ptr v126 : ptr<byte, i32>;
                        v130 = hir.load v129 : i32;
                        v132 = arith.constant 24 : u32;
                        v131 = hir.bitcast v54 : u32;
                        v133 = arith.add v131, v132 : u32 #[overflow = checked];
                        v1077 = arith.constant 4 : u32;
                        v135 = arith.mod v133, v1077 : u32;
                        hir.assertz v135 #[code = 250];
                        v136 = hir.int_to_ptr v133 : ptr<byte, i32>;
                        v137 = hir.load v136 : i32;
                        v139 = arith.constant 20 : u32;
                        v138 = hir.bitcast v54 : u32;
                        v140 = arith.add v138, v139 : u32 #[overflow = checked];
                        v1076 = arith.constant 4 : u32;
                        v142 = arith.mod v140, v1076 : u32;
                        hir.assertz v142 #[code = 250];
                        v143 = hir.int_to_ptr v140 : ptr<byte, i32>;
                        v144 = hir.load v143 : i32;
                        v1075 = arith.constant 40 : u32;
                        v145 = hir.bitcast v54 : u32;
                        v147 = arith.add v145, v1075 : u32 #[overflow = checked];
                        v1074 = arith.constant 4 : u32;
                        v149 = arith.mod v147, v1074 : u32;
                        hir.assertz v149 #[code = 250];
                        v150 = hir.int_to_ptr v147 : ptr<byte, i32>;
                        hir.store v150, v144;
                        v152 = arith.constant 32 : u32;
                        v151 = hir.bitcast v54 : u32;
                        v153 = arith.add v151, v152 : u32 #[overflow = checked];
                        v1073 = arith.constant 4 : u32;
                        v155 = arith.mod v153, v1073 : u32;
                        hir.assertz v155 #[code = 250];
                        v156 = hir.int_to_ptr v153 : ptr<byte, i32>;
                        hir.store v156, v137;
                        v1072 = arith.constant 4 : u32;
                        v159 = arith.shl v130, v1072 : i32;
                        v160 = arith.add v137, v159 : i32 #[overflow = wrapping];
                        v162 = arith.constant 44 : u32;
                        v161 = hir.bitcast v54 : u32;
                        v163 = arith.add v161, v162 : u32 #[overflow = checked];
                        v1071 = arith.constant 4 : u32;
                        v165 = arith.mod v163, v1071 : u32;
                        hir.assertz v165 #[code = 250];
                        v166 = hir.int_to_ptr v163 : ptr<byte, i32>;
                        hir.store v166, v160;
                        v1033, v1034, v1035, v1036, v1037, v1038 = scf.while v159, v137, v54, v160 : i32, i32, i32, i32, i32, i32 {
                        ^block141(v1039: i32, v1040: i32, v1041: i32, v1042: i32):
                            v1069 = arith.constant 0 : i32;
                            v1070 = arith.constant 0 : i32;
                            v169 = arith.eq v1039, v1070 : i1;
                            v170 = arith.zext v169 : u32;
                            v171 = hir.bitcast v170 : i32;
                            v173 = arith.neq v171, v1069 : i1;
                            v1027, v1028 = scf.if v173 : i32, i32 {
                            ^block140:
                                v979 = ub.poison i32 : i32;
                                scf.yield v979, v979;
                            } else {
                            ^block30:
                                v175 = hir.bitcast v1040 : u32;
                                v1068 = arith.constant 4 : u32;
                                v177 = arith.mod v175, v1068 : u32;
                                hir.assertz v177 #[code = 250];
                                v178 = hir.int_to_ptr v175 : ptr<byte, felt>;
                                v179 = hir.load v178 : felt;
                                v1067 = arith.constant 4 : u32;
                                v180 = hir.bitcast v1040 : u32;
                                v182 = arith.add v180, v1067 : u32 #[overflow = checked];
                                v1066 = arith.constant 4 : u32;
                                v184 = arith.mod v182, v1066 : u32;
                                hir.assertz v184 #[code = 250];
                                v185 = hir.int_to_ptr v182 : ptr<byte, felt>;
                                v186 = hir.load v185 : felt;
                                v1065 = arith.constant 8 : u32;
                                v187 = hir.bitcast v1040 : u32;
                                v189 = arith.add v187, v1065 : u32 #[overflow = checked];
                                v1064 = arith.constant 4 : u32;
                                v191 = arith.mod v189, v1064 : u32;
                                hir.assertz v191 #[code = 250];
                                v192 = hir.int_to_ptr v189 : ptr<byte, felt>;
                                v193 = hir.load v192 : felt;
                                v1063 = arith.constant 12 : u32;
                                v194 = hir.bitcast v1040 : u32;
                                v196 = arith.add v194, v1063 : u32 #[overflow = checked];
                                v1062 = arith.constant 4 : u32;
                                v198 = arith.mod v196, v1062 : u32;
                                hir.assertz v198 #[code = 250];
                                v199 = hir.int_to_ptr v196 : ptr<byte, felt>;
                                v200 = hir.load v199 : felt;
                                hir.exec @miden:base/note-script@1.0.0/p2id/p2id::bindings::miden::basic_wallet::basic_wallet::receive_asset::wit_import7(v179, v186, v193, v200)
                                v203 = arith.constant 16 : i32;
                                v204 = arith.add v1040, v203 : i32 #[overflow = wrapping];
                                v201 = arith.constant -16 : i32;
                                v202 = arith.add v1039, v201 : i32 #[overflow = wrapping];
                                scf.yield v202, v204;
                            };
                            v1059 = ub.poison i32 : i32;
                            v1030 = cf.select v173, v1059, v1042 : i32;
                            v1060 = ub.poison i32 : i32;
                            v1029 = cf.select v173, v1060, v1041 : i32;
                            v1061 = arith.constant 1 : u32;
                            v971 = arith.constant 0 : u32;
                            v1032 = cf.select v173, v971, v1061 : u32;
                            v1012 = arith.trunc v1032 : i1;
                            scf.condition v1012, v1027, v1028, v1029, v1030, v1041, v1042;
                        } do {
                        ^block142(v1043: i32, v1044: i32, v1045: i32, v1046: i32, v1047: i32, v1048: i32):
                            scf.yield v1043, v1044, v1045, v1046;
                        };
                        v1058 = arith.constant 36 : u32;
                        v207 = hir.bitcast v1037 : u32;
                        v209 = arith.add v207, v1058 : u32 #[overflow = checked];
                        v1057 = arith.constant 4 : u32;
                        v211 = arith.mod v209, v1057 : u32;
                        hir.assertz v211 #[code = 250];
                        v212 = hir.int_to_ptr v209 : ptr<byte, i32>;
                        hir.store v212, v1038;
                        v1056 = arith.constant 32 : i32;
                        v214 = arith.add v1037, v1056 : i32 #[overflow = wrapping];
                        hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::vec::into_iter::IntoIter<miden_base_sys::bindings::types::Asset> as core::ops::drop::Drop>::drop(v214)
                        v1055 = arith.constant 48 : i32;
                        v216 = arith.add v1037, v1055 : i32 #[overflow = wrapping];
                        v217 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
                        v218 = hir.bitcast v217 : ptr<byte, i32>;
                        hir.store v218, v216;
                        scf.yield ;
                    };
                    v1053 = arith.constant 0 : u32;
                    v1054 = arith.constant 1 : u32;
                    v1049 = cf.select v121, v1054, v1053 : u32;
                    scf.yield v1049;
                };
                scf.yield v1017;
            };
            v1050 = arith.constant 0 : u32;
            v1026 = arith.eq v1015, v1050 : i1;
            cf.cond_br v1026 ^block131, ^block23;
        ^block23:
            ub.unreachable ;
        ^block131:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block31:
            builtin.ret ;
        };

        private builtin.function @wit_bindgen::rt::run_ctors_once() {
        ^block33:
            v220 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
            v221 = hir.bitcast v220 : ptr<byte, i32>;
            v222 = hir.load v221 : i32;
            v223 = arith.constant 1048592 : i32;
            v224 = arith.add v222, v223 : i32 #[overflow = wrapping];
            v225 = hir.bitcast v224 : u32;
            v226 = hir.int_to_ptr v225 : ptr<byte, u8>;
            v227 = hir.load v226 : u8;
            v219 = arith.constant 0 : i32;
            v228 = arith.zext v227 : u32;
            v229 = hir.bitcast v228 : i32;
            v231 = arith.neq v229, v219 : i1;
            scf.if v231{
            ^block35:
                scf.yield ;
            } else {
            ^block36:
                v232 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
                v233 = hir.bitcast v232 : ptr<byte, i32>;
                v234 = hir.load v233 : i32;
                hir.exec @miden:base/note-script@1.0.0/p2id/__wasm_call_ctors()
                v1090 = arith.constant 1 : u8;
                v1092 = arith.constant 1048592 : i32;
                v236 = arith.add v234, v1092 : i32 #[overflow = wrapping];
                v240 = hir.bitcast v236 : u32;
                v241 = hir.int_to_ptr v240 : ptr<byte, u8>;
                hir.store v241, v1090;
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v242: i32, v243: i32, v244: i32) -> i32 {
        ^block37(v242: i32, v243: i32, v244: i32):
            v247 = arith.constant 16 : i32;
            v246 = arith.constant 0 : i32;
            v1094 = arith.constant 16 : u32;
            v249 = hir.bitcast v243 : u32;
            v251 = arith.gt v249, v1094 : i1;
            v252 = arith.zext v251 : u32;
            v253 = hir.bitcast v252 : i32;
            v255 = arith.neq v253, v246 : i1;
            v256 = cf.select v255, v243, v247 : i32;
            v1134 = arith.constant 0 : i32;
            v257 = arith.constant -1 : i32;
            v258 = arith.add v256, v257 : i32 #[overflow = wrapping];
            v259 = arith.band v256, v258 : i32;
            v261 = arith.neq v259, v1134 : i1;
            v1103, v1104 = scf.if v261 : i32, u32 {
            ^block146:
                v1095 = arith.constant 0 : u32;
                v1099 = ub.poison i32 : i32;
                scf.yield v1099, v1095;
            } else {
            ^block40:
                v263 = hir.exec @miden:base/note-script@1.0.0/p2id/<core::ptr::alignment::Alignment>::max(v243, v256) : i32
                v1133 = arith.constant 0 : i32;
                v262 = arith.constant -2147483648 : i32;
                v264 = arith.sub v262, v263 : i32 #[overflow = wrapping];
                v266 = hir.bitcast v264 : u32;
                v265 = hir.bitcast v244 : u32;
                v267 = arith.gt v265, v266 : i1;
                v268 = arith.zext v267 : u32;
                v269 = hir.bitcast v268 : i32;
                v271 = arith.neq v269, v1133 : i1;
                v1118 = scf.if v271 : i32 {
                ^block145:
                    v1132 = ub.poison i32 : i32;
                    scf.yield v1132;
                } else {
                ^block41:
                    v1130 = arith.constant 0 : i32;
                    v277 = arith.sub v1130, v263 : i32 #[overflow = wrapping];
                    v1131 = arith.constant -1 : i32;
                    v273 = arith.add v244, v263 : i32 #[overflow = wrapping];
                    v275 = arith.add v273, v1131 : i32 #[overflow = wrapping];
                    v278 = arith.band v275, v277 : i32;
                    v279 = hir.bitcast v242 : u32;
                    v280 = arith.constant 4 : u32;
                    v281 = arith.mod v279, v280 : u32;
                    hir.assertz v281 #[code = 250];
                    v282 = hir.int_to_ptr v279 : ptr<byte, i32>;
                    v283 = hir.load v282 : i32;
                    v1129 = arith.constant 0 : i32;
                    v285 = arith.neq v283, v1129 : i1;
                    scf.if v285{
                    ^block144:
                        scf.yield ;
                    } else {
                    ^block43:
                        v286 = hir.exec @miden:base/note-script@1.0.0/p2id/intrinsics::mem::heap_base() : i32
                        v287 = hir.mem_size  : u32;
                        v293 = hir.bitcast v242 : u32;
                        v1128 = arith.constant 4 : u32;
                        v295 = arith.mod v293, v1128 : u32;
                        hir.assertz v295 #[code = 250];
                        v1127 = arith.constant 16 : u32;
                        v288 = hir.bitcast v287 : i32;
                        v291 = arith.shl v288, v1127 : i32;
                        v292 = arith.add v286, v291 : i32 #[overflow = wrapping];
                        v296 = hir.int_to_ptr v293 : ptr<byte, i32>;
                        hir.store v296, v292;
                        scf.yield ;
                    };
                    v299 = hir.bitcast v242 : u32;
                    v1126 = arith.constant 4 : u32;
                    v301 = arith.mod v299, v1126 : u32;
                    hir.assertz v301 #[code = 250];
                    v302 = hir.int_to_ptr v299 : ptr<byte, i32>;
                    v303 = hir.load v302 : i32;
                    v1124 = arith.constant 0 : i32;
                    v1125 = arith.constant -1 : i32;
                    v305 = arith.bxor v303, v1125 : i32;
                    v307 = hir.bitcast v305 : u32;
                    v306 = hir.bitcast v278 : u32;
                    v308 = arith.gt v306, v307 : i1;
                    v309 = arith.zext v308 : u32;
                    v310 = hir.bitcast v309 : i32;
                    v312 = arith.neq v310, v1124 : i1;
                    v1117 = scf.if v312 : i32 {
                    ^block44:
                        v1123 = arith.constant 0 : i32;
                        scf.yield v1123;
                    } else {
                    ^block45:
                        v314 = hir.bitcast v242 : u32;
                        v1122 = arith.constant 4 : u32;
                        v316 = arith.mod v314, v1122 : u32;
                        hir.assertz v316 #[code = 250];
                        v313 = arith.add v303, v278 : i32 #[overflow = wrapping];
                        v317 = hir.int_to_ptr v314 : ptr<byte, i32>;
                        hir.store v317, v313;
                        v319 = arith.add v303, v263 : i32 #[overflow = wrapping];
                        scf.yield v319;
                    };
                    scf.yield v1117;
                };
                v1100 = arith.constant 1 : u32;
                v1121 = arith.constant 0 : u32;
                v1119 = cf.select v271, v1121, v1100 : u32;
                scf.yield v1118, v1119;
            };
            v1120 = arith.constant 0 : u32;
            v1116 = arith.eq v1104, v1120 : i1;
            cf.cond_br v1116 ^block39, ^block148(v1103);
        ^block39:
            ub.unreachable ;
        ^block148(v1096: i32):
            builtin.ret v1096;
        };

        private builtin.function @intrinsics::mem::heap_base() -> i32 {
        ^block46:
            v322 = hir.exec @intrinsics/mem/heap_base() : i32
            builtin.ret v322;
        };

        private builtin.function @<alloc::vec::Vec<miden_base_sys::bindings::types::Asset>>::with_capacity(v324: i32) {
        ^block50(v324: i32):
            v327 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v328 = hir.bitcast v327 : ptr<byte, i32>;
            v329 = hir.load v328 : i32;
            v330 = arith.constant 16 : i32;
            v331 = arith.sub v329, v330 : i32 #[overflow = wrapping];
            v332 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v333 = hir.bitcast v332 : ptr<byte, i32>;
            hir.store v333, v331;
            v1139 = arith.constant 16 : i32;
            v336 = arith.constant 256 : i32;
            v334 = arith.constant 8 : i32;
            v335 = arith.add v331, v334 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::raw_vec::RawVecInner>::with_capacity_in(v335, v336, v1139, v1139)
            v340 = arith.constant 8 : u32;
            v339 = hir.bitcast v331 : u32;
            v341 = arith.add v339, v340 : u32 #[overflow = checked];
            v1138 = arith.constant 8 : u32;
            v343 = arith.mod v341, v1138 : u32;
            hir.assertz v343 #[code = 250];
            v344 = hir.int_to_ptr v341 : ptr<byte, i64>;
            v345 = hir.load v344 : i64;
            v1137 = arith.constant 8 : u32;
            v347 = hir.bitcast v324 : u32;
            v349 = arith.add v347, v1137 : u32 #[overflow = checked];
            v350 = arith.constant 4 : u32;
            v351 = arith.mod v349, v350 : u32;
            hir.assertz v351 #[code = 250];
            v325 = arith.constant 0 : i32;
            v352 = hir.int_to_ptr v349 : ptr<byte, i32>;
            hir.store v352, v325;
            v353 = hir.bitcast v324 : u32;
            v1136 = arith.constant 4 : u32;
            v355 = arith.mod v353, v1136 : u32;
            hir.assertz v355 #[code = 250];
            v356 = hir.int_to_ptr v353 : ptr<byte, i64>;
            hir.store v356, v345;
            v1135 = arith.constant 16 : i32;
            v358 = arith.add v331, v1135 : i32 #[overflow = wrapping];
            v359 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v360 = hir.bitcast v359 : ptr<byte, i32>;
            hir.store v360, v358;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::with_capacity_in(v361: i32, v362: i32, v363: i32, v364: i32) {
        ^block52(v361: i32, v362: i32, v363: i32, v364: i32):
            v366 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v367 = hir.bitcast v366 : ptr<byte, i32>;
            v368 = hir.load v367 : i32;
            v369 = arith.constant 16 : i32;
            v370 = arith.sub v368, v369 : i32 #[overflow = wrapping];
            v371 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v372 = hir.bitcast v371 : ptr<byte, i32>;
            hir.store v372, v370;
            v365 = arith.constant 0 : i32;
            v373 = arith.constant 4 : i32;
            v374 = arith.add v370, v373 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::raw_vec::RawVecInner>::try_allocate_in(v374, v362, v365, v363, v364)
            v377 = arith.constant 8 : u32;
            v376 = hir.bitcast v370 : u32;
            v378 = arith.add v376, v377 : u32 #[overflow = checked];
            v379 = arith.constant 4 : u32;
            v380 = arith.mod v378, v379 : u32;
            hir.assertz v380 #[code = 250];
            v381 = hir.int_to_ptr v378 : ptr<byte, i32>;
            v382 = hir.load v381 : i32;
            v1150 = arith.constant 4 : u32;
            v383 = hir.bitcast v370 : u32;
            v385 = arith.add v383, v1150 : u32 #[overflow = checked];
            v1149 = arith.constant 4 : u32;
            v387 = arith.mod v385, v1149 : u32;
            hir.assertz v387 #[code = 250];
            v388 = hir.int_to_ptr v385 : ptr<byte, i32>;
            v389 = hir.load v388 : i32;
            v1148 = arith.constant 0 : i32;
            v390 = arith.constant 1 : i32;
            v391 = arith.neq v389, v390 : i1;
            v392 = arith.zext v391 : u32;
            v393 = hir.bitcast v392 : i32;
            v395 = arith.neq v393, v1148 : i1;
            cf.cond_br v395 ^block54, ^block55;
        ^block54:
            v404 = arith.constant 12 : u32;
            v403 = hir.bitcast v370 : u32;
            v405 = arith.add v403, v404 : u32 #[overflow = checked];
            v1147 = arith.constant 4 : u32;
            v407 = arith.mod v405, v1147 : u32;
            hir.assertz v407 #[code = 250];
            v408 = hir.int_to_ptr v405 : ptr<byte, i32>;
            v409 = hir.load v408 : i32;
            v1146 = arith.constant 4 : u32;
            v410 = hir.bitcast v361 : u32;
            v412 = arith.add v410, v1146 : u32 #[overflow = checked];
            v1145 = arith.constant 4 : u32;
            v414 = arith.mod v412, v1145 : u32;
            hir.assertz v414 #[code = 250];
            v415 = hir.int_to_ptr v412 : ptr<byte, i32>;
            hir.store v415, v409;
            v416 = hir.bitcast v361 : u32;
            v1144 = arith.constant 4 : u32;
            v418 = arith.mod v416, v1144 : u32;
            hir.assertz v418 #[code = 250];
            v419 = hir.int_to_ptr v416 : ptr<byte, i32>;
            hir.store v419, v382;
            v1143 = arith.constant 16 : i32;
            v421 = arith.add v370, v1143 : i32 #[overflow = wrapping];
            v422 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v423 = hir.bitcast v422 : ptr<byte, i32>;
            hir.store v423, v421;
            builtin.ret ;
        ^block55:
            v1142 = arith.constant 12 : u32;
            v396 = hir.bitcast v370 : u32;
            v398 = arith.add v396, v1142 : u32 #[overflow = checked];
            v1141 = arith.constant 4 : u32;
            v400 = arith.mod v398, v1141 : u32;
            hir.assertz v400 #[code = 250];
            v401 = hir.int_to_ptr v398 : ptr<byte, i32>;
            v402 = hir.load v401 : i32;
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::handle_error(v382, v402)
            ub.unreachable ;
        };

        private builtin.function @<alloc::raw_vec::RawVec<miden_field::wasm32::Felt> as core::ops::drop::Drop>::drop(v424: i32) {
        ^block56(v424: i32):
            v425 = arith.constant 4 : i32;
            hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::raw_vec::RawVecInner>::deallocate(v424, v425, v425)
            builtin.ret ;
        };

        private builtin.function @miden_base_sys::bindings::active_note::get_assets(v427: i32) {
        ^block58(v427: i32):
            v429 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v430 = hir.bitcast v429 : ptr<byte, i32>;
            v431 = hir.load v430 : i32;
            v432 = arith.constant 16 : i32;
            v433 = arith.sub v431, v432 : i32 #[overflow = wrapping];
            v434 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v435 = hir.bitcast v434 : ptr<byte, i32>;
            hir.store v435, v433;
            v436 = arith.constant 4 : i32;
            v437 = arith.add v433, v436 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::vec::Vec<miden_base_sys::bindings::types::Asset>>::with_capacity(v437)
            v441 = arith.constant 8 : u32;
            v440 = hir.bitcast v433 : u32;
            v442 = arith.add v440, v441 : u32 #[overflow = checked];
            v443 = arith.constant 4 : u32;
            v444 = arith.mod v442, v443 : u32;
            hir.assertz v444 #[code = 250];
            v445 = hir.int_to_ptr v442 : ptr<byte, i32>;
            v446 = hir.load v445 : i32;
            v1151 = arith.constant 2 : u32;
            v448 = hir.bitcast v446 : u32;
            v450 = arith.shr v448, v1151 : u32;
            v451 = hir.bitcast v450 : i32;
            v452 = hir.exec @miden:base/note-script@1.0.0/p2id/miden::protocol::active_note::get_assets(v451) : i32
            v438 = arith.constant 8 : i32;
            v439 = arith.add v427, v438 : i32 #[overflow = wrapping];
            v453 = hir.bitcast v439 : u32;
            v1156 = arith.constant 4 : u32;
            v455 = arith.mod v453, v1156 : u32;
            hir.assertz v455 #[code = 250];
            v456 = hir.int_to_ptr v453 : ptr<byte, i32>;
            hir.store v456, v452;
            v1155 = arith.constant 4 : u32;
            v457 = hir.bitcast v433 : u32;
            v459 = arith.add v457, v1155 : u32 #[overflow = checked];
            v1154 = arith.constant 4 : u32;
            v461 = arith.mod v459, v1154 : u32;
            hir.assertz v461 #[code = 250];
            v462 = hir.int_to_ptr v459 : ptr<byte, i64>;
            v463 = hir.load v462 : i64;
            v464 = hir.bitcast v427 : u32;
            v1153 = arith.constant 4 : u32;
            v466 = arith.mod v464, v1153 : u32;
            hir.assertz v466 #[code = 250];
            v467 = hir.int_to_ptr v464 : ptr<byte, i64>;
            hir.store v467, v463;
            v1152 = arith.constant 16 : i32;
            v469 = arith.add v433, v1152 : i32 #[overflow = wrapping];
            v470 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v471 = hir.bitcast v470 : ptr<byte, i32>;
            hir.store v471, v469;
            builtin.ret ;
        };

        private builtin.function @miden_base_sys::bindings::active_note::get_inputs(v472: i32) {
        ^block60(v472: i32):
            v474 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v475 = hir.bitcast v474 : ptr<byte, i32>;
            v476 = hir.load v475 : i32;
            v477 = arith.constant 16 : i32;
            v478 = arith.sub v476, v477 : i32 #[overflow = wrapping];
            v479 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v480 = hir.bitcast v479 : ptr<byte, i32>;
            hir.store v480, v478;
            v484 = arith.constant 4 : i32;
            v483 = arith.constant 1024 : i32;
            v481 = arith.constant 8 : i32;
            v482 = arith.add v478, v481 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::raw_vec::RawVecInner>::with_capacity_in(v482, v483, v484, v484)
            v487 = arith.constant 8 : u32;
            v486 = hir.bitcast v478 : u32;
            v488 = arith.add v486, v487 : u32 #[overflow = checked];
            v489 = arith.constant 4 : u32;
            v490 = arith.mod v488, v489 : u32;
            hir.assertz v490 #[code = 250];
            v491 = hir.int_to_ptr v488 : ptr<byte, i32>;
            v492 = hir.load v491 : i32;
            v494 = arith.constant 12 : u32;
            v493 = hir.bitcast v478 : u32;
            v495 = arith.add v493, v494 : u32 #[overflow = checked];
            v1164 = arith.constant 4 : u32;
            v497 = arith.mod v495, v1164 : u32;
            hir.assertz v497 #[code = 250];
            v498 = hir.int_to_ptr v495 : ptr<byte, i32>;
            v499 = hir.load v498 : i32;
            v1157 = arith.constant 2 : u32;
            v501 = hir.bitcast v499 : u32;
            v503 = arith.shr v501, v1157 : u32;
            v504 = hir.bitcast v503 : i32;
            v505 = hir.exec @miden:base/note-script@1.0.0/p2id/miden::protocol::active_note::get_inputs(v504) : i32
            v1163 = arith.constant 8 : u32;
            v506 = hir.bitcast v472 : u32;
            v508 = arith.add v506, v1163 : u32 #[overflow = checked];
            v1162 = arith.constant 4 : u32;
            v510 = arith.mod v508, v1162 : u32;
            hir.assertz v510 #[code = 250];
            v511 = hir.int_to_ptr v508 : ptr<byte, i32>;
            hir.store v511, v505;
            v1161 = arith.constant 4 : u32;
            v512 = hir.bitcast v472 : u32;
            v514 = arith.add v512, v1161 : u32 #[overflow = checked];
            v1160 = arith.constant 4 : u32;
            v516 = arith.mod v514, v1160 : u32;
            hir.assertz v516 #[code = 250];
            v517 = hir.int_to_ptr v514 : ptr<byte, i32>;
            hir.store v517, v499;
            v518 = hir.bitcast v472 : u32;
            v1159 = arith.constant 4 : u32;
            v520 = arith.mod v518, v1159 : u32;
            hir.assertz v520 #[code = 250];
            v521 = hir.int_to_ptr v518 : ptr<byte, i32>;
            hir.store v521, v492;
            v1158 = arith.constant 16 : i32;
            v523 = arith.add v478, v1158 : i32 #[overflow = wrapping];
            v524 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v525 = hir.bitcast v524 : ptr<byte, i32>;
            hir.store v525, v523;
            builtin.ret ;
        };

        private builtin.function @<alloc::vec::into_iter::IntoIter<miden_base_sys::bindings::types::Asset> as core::ops::drop::Drop>::drop(v526: i32) {
        ^block62(v526: i32):
            v528 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v529 = hir.bitcast v528 : ptr<byte, i32>;
            v530 = hir.load v529 : i32;
            v531 = arith.constant 16 : i32;
            v532 = arith.sub v530, v531 : i32 #[overflow = wrapping];
            v533 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v534 = hir.bitcast v533 : ptr<byte, i32>;
            hir.store v534, v532;
            v536 = arith.constant 12 : u32;
            v535 = hir.bitcast v532 : u32;
            v537 = arith.add v535, v536 : u32 #[overflow = checked];
            v538 = arith.constant 4 : u32;
            v539 = arith.mod v537, v538 : u32;
            hir.assertz v539 #[code = 250];
            v540 = hir.int_to_ptr v537 : ptr<byte, i32>;
            hir.store v540, v526;
            v541 = arith.constant 12 : i32;
            v542 = arith.add v532, v541 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/<<alloc::vec::into_iter::IntoIter<_, _> as core::ops::drop::Drop>::drop::DropGuard<miden_base_sys::bindings::types::Asset, alloc::alloc::Global> as core::ops::drop::Drop>::drop(v542)
            v1165 = arith.constant 16 : i32;
            v544 = arith.add v532, v1165 : i32 #[overflow = wrapping];
            v545 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v546 = hir.bitcast v545 : ptr<byte, i32>;
            hir.store v546, v544;
            builtin.ret ;
        };

        private builtin.function @miden_base_sys::bindings::active_account::get_id(v547: i32) {
        ^block64(v547: i32):
            v549 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v550 = hir.bitcast v549 : ptr<byte, i32>;
            v551 = hir.load v550 : i32;
            v552 = arith.constant 16 : i32;
            v553 = arith.sub v551, v552 : i32 #[overflow = wrapping];
            v554 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v555 = hir.bitcast v554 : ptr<byte, i32>;
            hir.store v555, v553;
            v556 = arith.constant 8 : i32;
            v557 = arith.add v553, v556 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/miden::protocol::active_account::get_id(v557)
            v559 = arith.constant 8 : u32;
            v558 = hir.bitcast v553 : u32;
            v560 = arith.add v558, v559 : u32 #[overflow = checked];
            v561 = arith.constant 4 : u32;
            v562 = arith.mod v560, v561 : u32;
            hir.assertz v562 #[code = 250];
            v563 = hir.int_to_ptr v560 : ptr<byte, i64>;
            v564 = hir.load v563 : i64;
            v565 = hir.bitcast v547 : u32;
            v1167 = arith.constant 8 : u32;
            v567 = arith.mod v565, v1167 : u32;
            hir.assertz v567 #[code = 250];
            v568 = hir.int_to_ptr v565 : ptr<byte, i64>;
            hir.store v568, v564;
            v1166 = arith.constant 16 : i32;
            v570 = arith.add v553, v1166 : i32 #[overflow = wrapping];
            v571 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v572 = hir.bitcast v571 : ptr<byte, i32>;
            hir.store v572, v570;
            builtin.ret ;
        };

        private builtin.function @<<alloc::vec::into_iter::IntoIter<_, _> as core::ops::drop::Drop>::drop::DropGuard<miden_base_sys::bindings::types::Asset, alloc::alloc::Global> as core::ops::drop::Drop>::drop(v573: i32) {
        ^block66(v573: i32):
            v575 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v576 = hir.bitcast v575 : ptr<byte, i32>;
            v577 = hir.load v576 : i32;
            v578 = arith.constant 16 : i32;
            v579 = arith.sub v577, v578 : i32 #[overflow = wrapping];
            v580 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v581 = hir.bitcast v580 : ptr<byte, i32>;
            hir.store v581, v579;
            v582 = hir.bitcast v573 : u32;
            v583 = arith.constant 4 : u32;
            v584 = arith.mod v582, v583 : u32;
            hir.assertz v584 #[code = 250];
            v585 = hir.int_to_ptr v582 : ptr<byte, i32>;
            v586 = hir.load v585 : i32;
            v587 = hir.bitcast v586 : u32;
            v1173 = arith.constant 4 : u32;
            v589 = arith.mod v587, v1173 : u32;
            hir.assertz v589 #[code = 250];
            v590 = hir.int_to_ptr v587 : ptr<byte, i32>;
            v591 = hir.load v590 : i32;
            v593 = arith.constant 12 : u32;
            v592 = hir.bitcast v579 : u32;
            v594 = arith.add v592, v593 : u32 #[overflow = checked];
            v1172 = arith.constant 4 : u32;
            v596 = arith.mod v594, v1172 : u32;
            hir.assertz v596 #[code = 250];
            v597 = hir.int_to_ptr v594 : ptr<byte, i32>;
            hir.store v597, v591;
            v599 = arith.constant 8 : u32;
            v598 = hir.bitcast v586 : u32;
            v600 = arith.add v598, v599 : u32 #[overflow = checked];
            v1171 = arith.constant 4 : u32;
            v602 = arith.mod v600, v1171 : u32;
            hir.assertz v602 #[code = 250];
            v603 = hir.int_to_ptr v600 : ptr<byte, i32>;
            v604 = hir.load v603 : i32;
            v1170 = arith.constant 8 : u32;
            v605 = hir.bitcast v579 : u32;
            v607 = arith.add v605, v1170 : u32 #[overflow = checked];
            v1169 = arith.constant 4 : u32;
            v609 = arith.mod v607, v1169 : u32;
            hir.assertz v609 #[code = 250];
            v610 = hir.int_to_ptr v607 : ptr<byte, i32>;
            hir.store v610, v604;
            v611 = arith.constant 8 : i32;
            v612 = arith.add v579, v611 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::raw_vec::RawVec<miden_base_sys::bindings::types::Asset> as core::ops::drop::Drop>::drop(v612)
            v1168 = arith.constant 16 : i32;
            v614 = arith.add v579, v1168 : i32 #[overflow = wrapping];
            v615 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v616 = hir.bitcast v615 : ptr<byte, i32>;
            hir.store v616, v614;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVec<miden_base_sys::bindings::types::Asset> as core::ops::drop::Drop>::drop(v617: i32) {
        ^block68(v617: i32):
            v618 = arith.constant 16 : i32;
            hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::raw_vec::RawVecInner>::deallocate(v617, v618, v618)
            builtin.ret ;
        };

        private builtin.function @<alloc::vec::Vec<miden_field::wasm32::Felt> as core::ops::drop::Drop>::drop(v620: i32) {
        ^block70(v620: i32):
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global>::alloc_impl(v621: i32, v622: i32, v623: i32, v624: i32) {
        ^block72(v621: i32, v622: i32, v623: i32, v624: i32):
            v1189 = arith.constant 0 : i32;
            v625 = arith.constant 0 : i32;
            v626 = arith.eq v623, v625 : i1;
            v627 = arith.zext v626 : u32;
            v628 = hir.bitcast v627 : i32;
            v630 = arith.neq v628, v1189 : i1;
            v1185 = scf.if v630 : i32 {
            ^block154:
                scf.yield v622;
            } else {
            ^block75:
                hir.exec @miden:base/note-script@1.0.0/p2id/__rustc::__rust_no_alloc_shim_is_unstable_v2()
                v1188 = arith.constant 0 : i32;
                v632 = arith.neq v624, v1188 : i1;
                v1184 = scf.if v632 : i32 {
                ^block76:
                    v634 = hir.exec @miden:base/note-script@1.0.0/p2id/__rustc::__rust_alloc_zeroed(v623, v622) : i32
                    scf.yield v634;
                } else {
                ^block77:
                    v633 = hir.exec @miden:base/note-script@1.0.0/p2id/__rustc::__rust_alloc(v623, v622) : i32
                    scf.yield v633;
                };
                scf.yield v1184;
            };
            v638 = arith.constant 4 : u32;
            v637 = hir.bitcast v621 : u32;
            v639 = arith.add v637, v638 : u32 #[overflow = checked];
            v1187 = arith.constant 4 : u32;
            v641 = arith.mod v639, v1187 : u32;
            hir.assertz v641 #[code = 250];
            v642 = hir.int_to_ptr v639 : ptr<byte, i32>;
            hir.store v642, v623;
            v644 = hir.bitcast v621 : u32;
            v1186 = arith.constant 4 : u32;
            v646 = arith.mod v644, v1186 : u32;
            hir.assertz v646 #[code = 250];
            v647 = hir.int_to_ptr v644 : ptr<byte, i32>;
            hir.store v647, v1185;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::deallocate(v648: i32, v649: i32, v650: i32) {
        ^block78(v648: i32, v649: i32, v650: i32):
            v652 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v653 = hir.bitcast v652 : ptr<byte, i32>;
            v654 = hir.load v653 : i32;
            v655 = arith.constant 16 : i32;
            v656 = arith.sub v654, v655 : i32 #[overflow = wrapping];
            v657 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v658 = hir.bitcast v657 : ptr<byte, i32>;
            hir.store v658, v656;
            v659 = arith.constant 4 : i32;
            v660 = arith.add v656, v659 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::raw_vec::RawVecInner>::current_memory(v660, v648, v649, v650)
            v662 = arith.constant 8 : u32;
            v661 = hir.bitcast v656 : u32;
            v663 = arith.add v661, v662 : u32 #[overflow = checked];
            v664 = arith.constant 4 : u32;
            v665 = arith.mod v663, v664 : u32;
            hir.assertz v665 #[code = 250];
            v666 = hir.int_to_ptr v663 : ptr<byte, i32>;
            v667 = hir.load v666 : i32;
            v1196 = arith.constant 0 : i32;
            v651 = arith.constant 0 : i32;
            v669 = arith.eq v667, v651 : i1;
            v670 = arith.zext v669 : u32;
            v671 = hir.bitcast v670 : i32;
            v673 = arith.neq v671, v1196 : i1;
            scf.if v673{
            ^block157:
                scf.yield ;
            } else {
            ^block81:
                v1195 = arith.constant 4 : u32;
                v674 = hir.bitcast v656 : u32;
                v676 = arith.add v674, v1195 : u32 #[overflow = checked];
                v1194 = arith.constant 4 : u32;
                v678 = arith.mod v676, v1194 : u32;
                hir.assertz v678 #[code = 250];
                v679 = hir.int_to_ptr v676 : ptr<byte, i32>;
                v680 = hir.load v679 : i32;
                v682 = arith.constant 12 : u32;
                v681 = hir.bitcast v656 : u32;
                v683 = arith.add v681, v682 : u32 #[overflow = checked];
                v1193 = arith.constant 4 : u32;
                v685 = arith.mod v683, v1193 : u32;
                hir.assertz v685 #[code = 250];
                v686 = hir.int_to_ptr v683 : ptr<byte, i32>;
                v687 = hir.load v686 : i32;
                hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v680, v667, v687)
                scf.yield ;
            };
            v1192 = arith.constant 16 : i32;
            v690 = arith.add v656, v1192 : i32 #[overflow = wrapping];
            v691 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v692 = hir.bitcast v691 : ptr<byte, i32>;
            hir.store v692, v690;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::current_memory(v693: i32, v694: i32, v695: i32, v696: i32) {
        ^block82(v693: i32, v694: i32, v695: i32, v696: i32):
            v1222 = arith.constant 0 : i32;
            v697 = arith.constant 0 : i32;
            v701 = arith.eq v696, v697 : i1;
            v702 = arith.zext v701 : u32;
            v703 = hir.bitcast v702 : i32;
            v705 = arith.neq v703, v1222 : i1;
            v1209, v1210 = scf.if v705 : i32, i32 {
            ^block160:
                v1221 = arith.constant 0 : i32;
                v699 = arith.constant 4 : i32;
                scf.yield v699, v1221;
            } else {
            ^block85:
                v706 = hir.bitcast v694 : u32;
                v741 = arith.constant 4 : u32;
                v708 = arith.mod v706, v741 : u32;
                hir.assertz v708 #[code = 250];
                v709 = hir.int_to_ptr v706 : ptr<byte, i32>;
                v710 = hir.load v709 : i32;
                v1219 = arith.constant 0 : i32;
                v1220 = arith.constant 0 : i32;
                v712 = arith.eq v710, v1220 : i1;
                v713 = arith.zext v712 : u32;
                v714 = hir.bitcast v713 : i32;
                v716 = arith.neq v714, v1219 : i1;
                v1207 = scf.if v716 : i32 {
                ^block159:
                    v1218 = arith.constant 0 : i32;
                    scf.yield v1218;
                } else {
                ^block86:
                    v1217 = arith.constant 4 : u32;
                    v717 = hir.bitcast v693 : u32;
                    v719 = arith.add v717, v1217 : u32 #[overflow = checked];
                    v1216 = arith.constant 4 : u32;
                    v721 = arith.mod v719, v1216 : u32;
                    hir.assertz v721 #[code = 250];
                    v722 = hir.int_to_ptr v719 : ptr<byte, i32>;
                    hir.store v722, v695;
                    v1215 = arith.constant 4 : u32;
                    v723 = hir.bitcast v694 : u32;
                    v725 = arith.add v723, v1215 : u32 #[overflow = checked];
                    v1214 = arith.constant 4 : u32;
                    v727 = arith.mod v725, v1214 : u32;
                    hir.assertz v727 #[code = 250];
                    v728 = hir.int_to_ptr v725 : ptr<byte, i32>;
                    v729 = hir.load v728 : i32;
                    v730 = hir.bitcast v693 : u32;
                    v1213 = arith.constant 4 : u32;
                    v732 = arith.mod v730, v1213 : u32;
                    hir.assertz v732 #[code = 250];
                    v733 = hir.int_to_ptr v730 : ptr<byte, i32>;
                    hir.store v733, v729;
                    v734 = arith.mul v710, v696 : i32 #[overflow = wrapping];
                    scf.yield v734;
                };
                v735 = arith.constant 8 : i32;
                v1212 = arith.constant 4 : i32;
                v1208 = cf.select v716, v1212, v735 : i32;
                scf.yield v1208, v1207;
            };
            v738 = arith.add v693, v1209 : i32 #[overflow = wrapping];
            v740 = hir.bitcast v738 : u32;
            v1211 = arith.constant 4 : u32;
            v742 = arith.mod v740, v1211 : u32;
            hir.assertz v742 #[code = 250];
            v743 = hir.int_to_ptr v740 : ptr<byte, i32>;
            hir.store v743, v1210;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v744: i32, v745: i32, v746: i32) {
        ^block87(v744: i32, v745: i32, v746: i32):
            v1224 = arith.constant 0 : i32;
            v747 = arith.constant 0 : i32;
            v748 = arith.eq v746, v747 : i1;
            v749 = arith.zext v748 : u32;
            v750 = hir.bitcast v749 : i32;
            v752 = arith.neq v750, v1224 : i1;
            scf.if v752{
            ^block89:
                scf.yield ;
            } else {
            ^block90:
                hir.exec @miden:base/note-script@1.0.0/p2id/__rustc::__rust_dealloc(v744, v746, v745)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v753: i32, v754: i32, v755: i32) {
        ^block91(v753: i32, v754: i32, v755: i32):
            v757 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v758 = hir.bitcast v757 : ptr<byte, i32>;
            v759 = hir.load v758 : i32;
            v760 = arith.constant 16 : i32;
            v761 = arith.sub v759, v760 : i32 #[overflow = wrapping];
            v762 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v763 = hir.bitcast v762 : ptr<byte, i32>;
            hir.store v763, v761;
            v756 = arith.constant 0 : i32;
            v764 = arith.constant 8 : i32;
            v765 = arith.add v761, v764 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::alloc::Global>::alloc_impl(v765, v754, v755, v756)
            v768 = arith.constant 12 : u32;
            v767 = hir.bitcast v761 : u32;
            v769 = arith.add v767, v768 : u32 #[overflow = checked];
            v770 = arith.constant 4 : u32;
            v771 = arith.mod v769, v770 : u32;
            hir.assertz v771 #[code = 250];
            v772 = hir.int_to_ptr v769 : ptr<byte, i32>;
            v773 = hir.load v772 : i32;
            v775 = arith.constant 8 : u32;
            v774 = hir.bitcast v761 : u32;
            v776 = arith.add v774, v775 : u32 #[overflow = checked];
            v1229 = arith.constant 4 : u32;
            v778 = arith.mod v776, v1229 : u32;
            hir.assertz v778 #[code = 250];
            v779 = hir.int_to_ptr v776 : ptr<byte, i32>;
            v780 = hir.load v779 : i32;
            v781 = hir.bitcast v753 : u32;
            v1228 = arith.constant 4 : u32;
            v783 = arith.mod v781, v1228 : u32;
            hir.assertz v783 #[code = 250];
            v784 = hir.int_to_ptr v781 : ptr<byte, i32>;
            hir.store v784, v780;
            v1227 = arith.constant 4 : u32;
            v785 = hir.bitcast v753 : u32;
            v787 = arith.add v785, v1227 : u32 #[overflow = checked];
            v1226 = arith.constant 4 : u32;
            v789 = arith.mod v787, v1226 : u32;
            hir.assertz v789 #[code = 250];
            v790 = hir.int_to_ptr v787 : ptr<byte, i32>;
            hir.store v790, v773;
            v1225 = arith.constant 16 : i32;
            v792 = arith.add v761, v1225 : i32 #[overflow = wrapping];
            v793 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v794 = hir.bitcast v793 : ptr<byte, i32>;
            hir.store v794, v792;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::try_allocate_in(v795: i32, v796: i32, v797: i32, v798: i32, v799: i32) {
        ^block93(v795: i32, v796: i32, v797: i32, v798: i32, v799: i32):
            v802 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v803 = hir.bitcast v802 : ptr<byte, i32>;
            v804 = hir.load v803 : i32;
            v805 = arith.constant 16 : i32;
            v806 = arith.sub v804, v805 : i32 #[overflow = wrapping];
            v807 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v808 = hir.bitcast v807 : ptr<byte, i32>;
            hir.store v808, v806;
            v818 = hir.bitcast v796 : u32;
            v819 = arith.zext v818 : u64;
            v820 = hir.bitcast v819 : i64;
            v800 = arith.constant 0 : i32;
            v813 = arith.sub v800, v798 : i32 #[overflow = wrapping];
            v810 = arith.constant -1 : i32;
            v809 = arith.add v798, v799 : i32 #[overflow = wrapping];
            v811 = arith.add v809, v810 : i32 #[overflow = wrapping];
            v814 = arith.band v811, v813 : i32;
            v815 = hir.bitcast v814 : u32;
            v816 = arith.zext v815 : u64;
            v817 = hir.bitcast v816 : i64;
            v821 = arith.mul v817, v820 : i64 #[overflow = wrapping];
            v1332 = arith.constant 0 : i32;
            v822 = arith.constant 32 : i64;
            v824 = hir.cast v822 : u32;
            v823 = hir.bitcast v821 : u64;
            v825 = arith.shr v823, v824 : u64;
            v826 = hir.bitcast v825 : i64;
            v827 = arith.trunc v826 : i32;
            v829 = arith.neq v827, v1332 : i1;
            v1245, v1246, v1247, v1248, v1249, v1250 = scf.if v829 : i32, i32, i32, i32, i32, u32 {
            ^block164:
                v1230 = arith.constant 0 : u32;
                v1237 = ub.poison i32 : i32;
                scf.yield v795, v806, v1237, v1237, v1237, v1230;
            } else {
            ^block98:
                v830 = arith.trunc v821 : i32;
                v1331 = arith.constant 0 : i32;
                v831 = arith.constant -2147483648 : i32;
                v832 = arith.sub v831, v798 : i32 #[overflow = wrapping];
                v834 = hir.bitcast v832 : u32;
                v833 = hir.bitcast v830 : u32;
                v835 = arith.lte v833, v834 : i1;
                v836 = arith.zext v835 : u32;
                v837 = hir.bitcast v836 : i32;
                v839 = arith.neq v837, v1331 : i1;
                v1293 = scf.if v839 : i32 {
                ^block96:
                    v1330 = arith.constant 0 : i32;
                    v850 = arith.neq v830, v1330 : i1;
                    v1292 = scf.if v850 : i32 {
                    ^block100:
                        v1329 = arith.constant 0 : i32;
                        v866 = arith.neq v797, v1329 : i1;
                        v1291 = scf.if v866 : i32 {
                        ^block103:
                            v848 = arith.constant 1 : i32;
                            hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::alloc::Global>::alloc_impl(v806, v798, v830, v848)
                            v877 = hir.bitcast v806 : u32;
                            v918 = arith.constant 4 : u32;
                            v879 = arith.mod v877, v918 : u32;
                            hir.assertz v879 #[code = 250];
                            v880 = hir.int_to_ptr v877 : ptr<byte, i32>;
                            v881 = hir.load v880 : i32;
                            scf.yield v881;
                        } else {
                        ^block104:
                            v867 = arith.constant 8 : i32;
                            v868 = arith.add v806, v867 : i32 #[overflow = wrapping];
                            hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v868, v798, v830)
                            v852 = arith.constant 8 : u32;
                            v869 = hir.bitcast v806 : u32;
                            v871 = arith.add v869, v852 : u32 #[overflow = checked];
                            v1328 = arith.constant 4 : u32;
                            v873 = arith.mod v871, v1328 : u32;
                            hir.assertz v873 #[code = 250];
                            v874 = hir.int_to_ptr v871 : ptr<byte, i32>;
                            v875 = hir.load v874 : i32;
                            scf.yield v875;
                        };
                        v1327 = arith.constant 0 : i32;
                        v884 = arith.neq v1291, v1327 : i1;
                        scf.if v884{
                        ^block105:
                            v1326 = arith.constant 8 : u32;
                            v901 = hir.bitcast v795 : u32;
                            v903 = arith.add v901, v1326 : u32 #[overflow = checked];
                            v1325 = arith.constant 4 : u32;
                            v905 = arith.mod v903, v1325 : u32;
                            hir.assertz v905 #[code = 250];
                            v906 = hir.int_to_ptr v903 : ptr<byte, i32>;
                            hir.store v906, v1291;
                            v1324 = arith.constant 4 : u32;
                            v908 = hir.bitcast v795 : u32;
                            v910 = arith.add v908, v1324 : u32 #[overflow = checked];
                            v1323 = arith.constant 4 : u32;
                            v912 = arith.mod v910, v1323 : u32;
                            hir.assertz v912 #[code = 250];
                            v913 = hir.int_to_ptr v910 : ptr<byte, i32>;
                            hir.store v913, v796;
                            scf.yield ;
                        } else {
                        ^block106:
                            v1322 = arith.constant 8 : u32;
                            v887 = hir.bitcast v795 : u32;
                            v889 = arith.add v887, v1322 : u32 #[overflow = checked];
                            v1321 = arith.constant 4 : u32;
                            v891 = arith.mod v889, v1321 : u32;
                            hir.assertz v891 #[code = 250];
                            v892 = hir.int_to_ptr v889 : ptr<byte, i32>;
                            hir.store v892, v830;
                            v1320 = arith.constant 4 : u32;
                            v894 = hir.bitcast v795 : u32;
                            v896 = arith.add v894, v1320 : u32 #[overflow = checked];
                            v1319 = arith.constant 4 : u32;
                            v898 = arith.mod v896, v1319 : u32;
                            hir.assertz v898 #[code = 250];
                            v899 = hir.int_to_ptr v896 : ptr<byte, i32>;
                            hir.store v899, v798;
                            scf.yield ;
                        };
                        v1317 = arith.constant 1 : i32;
                        v1318 = arith.constant 0 : i32;
                        v1290 = cf.select v884, v1318, v1317 : i32;
                        scf.yield v1290;
                    } else {
                    ^block101:
                        v1316 = arith.constant 8 : u32;
                        v851 = hir.bitcast v795 : u32;
                        v853 = arith.add v851, v1316 : u32 #[overflow = checked];
                        v1315 = arith.constant 4 : u32;
                        v855 = arith.mod v853, v1315 : u32;
                        hir.assertz v855 #[code = 250];
                        v856 = hir.int_to_ptr v853 : ptr<byte, i32>;
                        hir.store v856, v798;
                        v1314 = arith.constant 4 : u32;
                        v859 = hir.bitcast v795 : u32;
                        v861 = arith.add v859, v1314 : u32 #[overflow = checked];
                        v1313 = arith.constant 4 : u32;
                        v863 = arith.mod v861, v1313 : u32;
                        hir.assertz v863 #[code = 250];
                        v1312 = arith.constant 0 : i32;
                        v864 = hir.int_to_ptr v861 : ptr<byte, i32>;
                        hir.store v864, v1312;
                        v1311 = arith.constant 0 : i32;
                        scf.yield v1311;
                    };
                    scf.yield v1292;
                } else {
                ^block99:
                    v1310 = ub.poison i32 : i32;
                    scf.yield v1310;
                };
                v1305 = arith.constant 0 : u32;
                v1238 = arith.constant 1 : u32;
                v1298 = cf.select v839, v1238, v1305 : u32;
                v1306 = ub.poison i32 : i32;
                v1297 = cf.select v839, v806, v1306 : i32;
                v1307 = ub.poison i32 : i32;
                v1296 = cf.select v839, v795, v1307 : i32;
                v1308 = ub.poison i32 : i32;
                v1295 = cf.select v839, v1308, v806 : i32;
                v1309 = ub.poison i32 : i32;
                v1294 = cf.select v839, v1309, v795 : i32;
                scf.yield v1294, v1295, v1296, v1293, v1297, v1298;
            };
            v1251, v1252, v1253 = scf.index_switch v1250 : i32, i32, i32 
            case 0 {
            ^block97:
                v1304 = arith.constant 4 : u32;
                v842 = hir.bitcast v1245 : u32;
                v844 = arith.add v842, v1304 : u32 #[overflow = checked];
                v1303 = arith.constant 4 : u32;
                v846 = arith.mod v844, v1303 : u32;
                hir.assertz v846 #[code = 250];
                v1302 = arith.constant 0 : i32;
                v847 = hir.int_to_ptr v844 : ptr<byte, i32>;
                hir.store v847, v1302;
                v1301 = arith.constant 1 : i32;
                scf.yield v1245, v1301, v1246;
            }
            default {
            ^block168:
                scf.yield v1247, v1248, v1249;
            };
            v917 = hir.bitcast v1251 : u32;
            v1300 = arith.constant 4 : u32;
            v919 = arith.mod v917, v1300 : u32;
            hir.assertz v919 #[code = 250];
            v920 = hir.int_to_ptr v917 : ptr<byte, i32>;
            hir.store v920, v1252;
            v1299 = arith.constant 16 : i32;
            v925 = arith.add v1253, v1299 : i32 #[overflow = wrapping];
            v926 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v927 = hir.bitcast v926 : ptr<byte, i32>;
            hir.store v927, v925;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v928: i32, v929: i32) {
        ^block107(v928: i32, v929: i32):
            ub.unreachable ;
        };

        private builtin.function @<core::ptr::alignment::Alignment>::max(v930: i32, v931: i32) -> i32 {
        ^block109(v930: i32, v931: i32):
            v938 = arith.constant 0 : i32;
            v934 = hir.bitcast v931 : u32;
            v933 = hir.bitcast v930 : u32;
            v935 = arith.gt v933, v934 : i1;
            v936 = arith.zext v935 : u32;
            v937 = hir.bitcast v936 : i32;
            v939 = arith.neq v937, v938 : i1;
            v940 = cf.select v939, v930, v931 : i32;
            builtin.ret v940;
        };

        private builtin.function @miden::protocol::active_account::get_id(v941: i32) {
        ^block111(v941: i32):
            v942, v943 = hir.exec @miden/protocol/active_account/get_id() : felt, felt
            v944 = hir.bitcast v941 : u32;
            v945 = hir.int_to_ptr v944 : ptr<byte, felt>;
            hir.store v945, v942;
            v946 = arith.constant 4 : u32;
            v947 = arith.add v944, v946 : u32 #[overflow = checked];
            v948 = hir.int_to_ptr v947 : ptr<byte, felt>;
            hir.store v948, v943;
            builtin.ret ;
        };

        private builtin.function @miden::protocol::active_note::get_assets(v949: i32) -> i32 {
        ^block116(v949: i32):
            v950, v951 = hir.exec @miden/protocol/active_note/get_assets(v949) : i32, i32
            builtin.ret v950;
        };

        private builtin.function @miden::protocol::active_note::get_inputs(v953: i32) -> i32 {
        ^block119(v953: i32):
            v954, v955 = hir.exec @miden/protocol/active_note/get_inputs(v953) : i32, i32
            builtin.ret v954;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.global_variable private @#GOT.data.internal.__memory_base : i32 {
            builtin.ret_imm 0;
        };

        builtin.segment @1048576 = 0x000000010000000100000001;
    };

    public builtin.function @run(v957: felt, v958: felt, v959: felt, v960: felt) {
    ^block121(v957: felt, v958: felt, v959: felt, v960: felt):
        hir.exec @miden:base/note-script@1.0.0/p2id/miden:base/note-script@1.0.0#run(v957, v958, v959, v960)
        builtin.ret ;
    };
};