builtin.component miden:base/note-script@1.0.0 {
    builtin.module public @p2id {
        private builtin.function @p2id::bindings::miden::basic_wallet::basic_wallet::receive_asset::wit_import7(v0: felt, v1: felt, v2: felt, v3: felt) {
        ^block3(v0: felt, v1: felt, v2: felt, v3: felt):
            hir.call v0, v1, v2, v3 #[callee = miden:basic-wallet/basic-wallet@0.1.0/receive-asset] #[signature = (param felt) (param felt) (param felt) (param felt)];
            builtin.ret ;
        };

        private builtin.function @__wasm_call_ctors() {
        ^block8:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc(v4: i32, v5: i32) -> i32 {
        ^block10(v4: i32, v5: i32):
            v7 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
            v8 = hir.bitcast v7 : ptr<byte, i32>;
            v9 = hir.load v8 : i32;
            v10 = arith.constant 1048672 : i32;
            v11 = arith.add v9, v10 : i32 #[overflow = wrapping];
            v12 = hir.exec @miden:base/note-script@1.0.0/p2id/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v11, v5, v4) : i32
            builtin.ret v12;
        };

        private builtin.function @__rustc::__rust_dealloc(v13: i32, v14: i32, v15: i32) {
        ^block12(v13: i32, v14: i32, v15: i32):
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v16: i32, v17: i32) -> i32 {
        ^block14(v16: i32, v17: i32):
            v19 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
            v20 = hir.bitcast v19 : ptr<byte, i32>;
            v21 = hir.load v20 : i32;
            v22 = arith.constant 1048672 : i32;
            v23 = arith.add v21, v22 : i32 #[overflow = wrapping];
            v24 = hir.exec @miden:base/note-script@1.0.0/p2id/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v23, v17, v16) : i32
            v905 = arith.constant 0 : i32;
            v25 = arith.constant 0 : i32;
            v26 = arith.eq v24, v25 : i1;
            v27 = arith.zext v26 : u32;
            v28 = hir.bitcast v27 : i32;
            v30 = arith.neq v28, v905 : i1;
            scf.if v30{
            ^block16:
                scf.yield ;
            } else {
            ^block17:
                v903 = arith.constant 0 : i32;
                v904 = arith.constant 0 : i32;
                v32 = arith.eq v16, v904 : i1;
                v33 = arith.zext v32 : u32;
                v34 = hir.bitcast v33 : i32;
                v36 = arith.neq v34, v903 : i1;
                scf.if v36{
                ^block114:
                    scf.yield ;
                } else {
                ^block18:
                    v897 = arith.constant 0 : u8;
                    v39 = hir.bitcast v16 : u32;
                    v40 = hir.bitcast v24 : u32;
                    v41 = hir.int_to_ptr v40 : ptr<byte, u8>;
                    hir.mem_set v41, v39, v897;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v24;
        };

        private builtin.function @p2id::bindings::__link_custom_section_describing_imports() {
        ^block19:
            builtin.ret ;
        };

        private builtin.function @miden:base/note-script@1.0.0#run(v43: felt, v44: felt, v45: felt, v46: felt) {
        ^block21(v43: felt, v44: felt, v45: felt, v46: felt):
            v50 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v51 = hir.bitcast v50 : ptr<byte, i32>;
            v52 = hir.load v51 : i32;
            v53 = arith.constant 48 : i32;
            v54 = arith.sub v52, v53 : i32 #[overflow = wrapping];
            v55 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v56 = hir.bitcast v55 : ptr<byte, i32>;
            hir.store v56, v54;
            hir.exec @miden:base/note-script@1.0.0/p2id/wit_bindgen::rt::run_ctors_once()
            v57 = arith.constant 16 : i32;
            v58 = arith.add v54, v57 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/miden_base_sys::bindings::active_note::get_inputs(v58)
            v60 = arith.constant 24 : u32;
            v59 = hir.bitcast v54 : u32;
            v61 = arith.add v59, v60 : u32 #[overflow = checked];
            v62 = arith.constant 4 : u32;
            v63 = arith.mod v61, v62 : u32;
            hir.assertz v63 #[code = 250];
            v64 = hir.int_to_ptr v61 : ptr<byte, i32>;
            v65 = hir.load v64 : i32;
            v66 = hir.cast v65 : u32;
            v963 = scf.index_switch v66 : u32 
            case 0 {
            ^block119:
                v1007 = arith.constant 1 : u32;
                scf.yield v1007;
            }
            case 1 {
            ^block120:
                v1006 = arith.constant 1 : u32;
                scf.yield v1006;
            }
            default {
            ^block24:
                v68 = arith.constant 20 : u32;
                v67 = hir.bitcast v54 : u32;
                v69 = arith.add v67, v68 : u32 #[overflow = checked];
                v1040 = arith.constant 4 : u32;
                v71 = arith.mod v69, v1040 : u32;
                hir.assertz v71 #[code = 250];
                v72 = hir.int_to_ptr v69 : ptr<byte, i32>;
                v73 = hir.load v72 : i32;
                v1039 = arith.constant 4 : u32;
                v74 = hir.bitcast v73 : u32;
                v76 = arith.add v74, v1039 : u32 #[overflow = checked];
                v1038 = arith.constant 4 : u32;
                v78 = arith.mod v76, v1038 : u32;
                hir.assertz v78 #[code = 250];
                v79 = hir.int_to_ptr v76 : ptr<byte, felt>;
                v80 = hir.load v79 : felt;
                v81 = hir.bitcast v73 : u32;
                v1037 = arith.constant 4 : u32;
                v83 = arith.mod v81, v1037 : u32;
                hir.assertz v83 #[code = 250];
                v84 = hir.int_to_ptr v81 : ptr<byte, felt>;
                v85 = hir.load v84 : felt;
                v86 = arith.constant 8 : i32;
                v87 = arith.add v54, v86 : i32 #[overflow = wrapping];
                hir.exec @miden:base/note-script@1.0.0/p2id/miden_base_sys::bindings::active_account::get_id(v87)
                v89 = arith.constant 12 : u32;
                v88 = hir.bitcast v54 : u32;
                v90 = arith.add v88, v89 : u32 #[overflow = checked];
                v1036 = arith.constant 4 : u32;
                v92 = arith.mod v90, v1036 : u32;
                hir.assertz v92 #[code = 250];
                v93 = hir.int_to_ptr v90 : ptr<byte, felt>;
                v94 = hir.load v93 : felt;
                v96 = arith.constant 8 : u32;
                v95 = hir.bitcast v54 : u32;
                v97 = arith.add v95, v96 : u32 #[overflow = checked];
                v1035 = arith.constant 4 : u32;
                v99 = arith.mod v97, v1035 : u32;
                hir.assertz v99 #[code = 250];
                v100 = hir.int_to_ptr v97 : ptr<byte, felt>;
                v101 = hir.load v100 : felt;
                v102 = hir.exec @miden:base/note-script@1.0.0/p2id/intrinsics::felt::eq(v101, v85) : i32
                v47 = arith.constant 0 : i32;
                v103 = arith.constant 1 : i32;
                v104 = arith.neq v102, v103 : i1;
                v105 = arith.zext v104 : u32;
                v106 = hir.bitcast v105 : i32;
                v108 = arith.neq v106, v47 : i1;
                v965 = scf.if v108 : u32 {
                ^block118:
                    v915 = arith.constant 1 : u32;
                    scf.yield v915;
                } else {
                ^block25:
                    v109 = hir.exec @miden:base/note-script@1.0.0/p2id/intrinsics::felt::eq(v94, v80) : i32
                    v1033 = arith.constant 0 : i32;
                    v1034 = arith.constant 1 : i32;
                    v111 = arith.neq v109, v1034 : i1;
                    v112 = arith.zext v111 : u32;
                    v113 = hir.bitcast v112 : i32;
                    v115 = arith.neq v113, v1033 : i1;
                    scf.if v115{
                    ^block117:
                        scf.yield ;
                    } else {
                    ^block26:
                        v116 = arith.constant 28 : i32;
                        v117 = arith.add v54, v116 : i32 #[overflow = wrapping];
                        hir.exec @miden:base/note-script@1.0.0/p2id/miden_base_sys::bindings::active_note::get_assets(v117)
                        v119 = arith.constant 36 : u32;
                        v118 = hir.bitcast v54 : u32;
                        v120 = arith.add v118, v119 : u32 #[overflow = checked];
                        v1032 = arith.constant 4 : u32;
                        v122 = arith.mod v120, v1032 : u32;
                        hir.assertz v122 #[code = 250];
                        v123 = hir.int_to_ptr v120 : ptr<byte, i32>;
                        v124 = hir.load v123 : i32;
                        v129 = arith.constant 28 : u32;
                        v128 = hir.bitcast v54 : u32;
                        v130 = arith.add v128, v129 : u32 #[overflow = checked];
                        v1031 = arith.constant 4 : u32;
                        v132 = arith.mod v130, v1031 : u32;
                        hir.assertz v132 #[code = 250];
                        v133 = hir.int_to_ptr v130 : ptr<byte, i32>;
                        v134 = hir.load v133 : i32;
                        v136 = arith.constant 32 : u32;
                        v135 = hir.bitcast v54 : u32;
                        v137 = arith.add v135, v136 : u32 #[overflow = checked];
                        v1030 = arith.constant 4 : u32;
                        v139 = arith.mod v137, v1030 : u32;
                        hir.assertz v139 #[code = 250];
                        v140 = hir.int_to_ptr v137 : ptr<byte, i32>;
                        v141 = hir.load v140 : i32;
                        v1029 = arith.constant 4 : u32;
                        v127 = arith.shl v124, v1029 : i32;
                        v983, v984, v985, v986, v987, v988, v989, v990 = scf.while v127, v141, v54, v141, v134 : i32, i32, i32, i32, i32, i32, i32, i32 {
                        ^block132(v991: i32, v992: i32, v993: i32, v994: i32, v995: i32):
                            v1027 = arith.constant 0 : i32;
                            v1028 = arith.constant 0 : i32;
                            v144 = arith.eq v991, v1028 : i1;
                            v145 = arith.zext v144 : u32;
                            v146 = hir.bitcast v145 : i32;
                            v148 = arith.neq v146, v1027 : i1;
                            v976, v977 = scf.if v148 : i32, i32 {
                            ^block131:
                                v916 = ub.poison i32 : i32;
                                scf.yield v916, v916;
                            } else {
                            ^block30:
                                v150 = hir.bitcast v992 : u32;
                                v1026 = arith.constant 4 : u32;
                                v152 = arith.mod v150, v1026 : u32;
                                hir.assertz v152 #[code = 250];
                                v153 = hir.int_to_ptr v150 : ptr<byte, felt>;
                                v154 = hir.load v153 : felt;
                                v1025 = arith.constant 4 : u32;
                                v155 = hir.bitcast v992 : u32;
                                v157 = arith.add v155, v1025 : u32 #[overflow = checked];
                                v1024 = arith.constant 4 : u32;
                                v159 = arith.mod v157, v1024 : u32;
                                hir.assertz v159 #[code = 250];
                                v160 = hir.int_to_ptr v157 : ptr<byte, felt>;
                                v161 = hir.load v160 : felt;
                                v1023 = arith.constant 8 : u32;
                                v162 = hir.bitcast v992 : u32;
                                v164 = arith.add v162, v1023 : u32 #[overflow = checked];
                                v1022 = arith.constant 4 : u32;
                                v166 = arith.mod v164, v1022 : u32;
                                hir.assertz v166 #[code = 250];
                                v167 = hir.int_to_ptr v164 : ptr<byte, felt>;
                                v168 = hir.load v167 : felt;
                                v1021 = arith.constant 12 : u32;
                                v169 = hir.bitcast v992 : u32;
                                v171 = arith.add v169, v1021 : u32 #[overflow = checked];
                                v1020 = arith.constant 4 : u32;
                                v173 = arith.mod v171, v1020 : u32;
                                hir.assertz v173 #[code = 250];
                                v174 = hir.int_to_ptr v171 : ptr<byte, felt>;
                                v175 = hir.load v174 : felt;
                                hir.exec @miden:base/note-script@1.0.0/p2id/p2id::bindings::miden::basic_wallet::basic_wallet::receive_asset::wit_import7(v154, v161, v168, v175)
                                v1019 = arith.constant 16 : i32;
                                v179 = arith.add v992, v1019 : i32 #[overflow = wrapping];
                                v176 = arith.constant -16 : i32;
                                v177 = arith.add v991, v176 : i32 #[overflow = wrapping];
                                scf.yield v177, v179;
                            };
                            v1015 = ub.poison i32 : i32;
                            v980 = cf.select v148, v1015, v995 : i32;
                            v1016 = ub.poison i32 : i32;
                            v979 = cf.select v148, v1016, v994 : i32;
                            v1017 = ub.poison i32 : i32;
                            v978 = cf.select v148, v1017, v993 : i32;
                            v1018 = arith.constant 1 : u32;
                            v907 = arith.constant 0 : u32;
                            v982 = cf.select v148, v907, v1018 : u32;
                            v960 = arith.trunc v982 : i1;
                            scf.condition v960, v976, v977, v978, v979, v980, v993, v994, v995;
                        } do {
                        ^block133(v996: i32, v997: i32, v998: i32, v999: i32, v1000: i32, v1001: i32, v1002: i32, v1003: i32):
                            scf.yield v996, v997, v998, v999, v1000;
                        };
                        v183 = arith.constant 44 : u32;
                        v182 = hir.bitcast v988 : u32;
                        v184 = arith.add v182, v183 : u32 #[overflow = checked];
                        v1014 = arith.constant 4 : u32;
                        v186 = arith.mod v184, v1014 : u32;
                        hir.assertz v186 #[code = 250];
                        v187 = hir.int_to_ptr v184 : ptr<byte, i32>;
                        hir.store v187, v989;
                        v190 = arith.constant 40 : u32;
                        v189 = hir.bitcast v988 : u32;
                        v191 = arith.add v189, v190 : u32 #[overflow = checked];
                        v1013 = arith.constant 4 : u32;
                        v193 = arith.mod v191, v1013 : u32;
                        hir.assertz v193 #[code = 250];
                        v194 = hir.int_to_ptr v191 : ptr<byte, i32>;
                        hir.store v194, v990;
                        v1012 = arith.constant 16 : i32;
                        v195 = arith.constant 40 : i32;
                        v196 = arith.add v988, v195 : i32 #[overflow = wrapping];
                        hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::RawVecInner<A>::deallocate(v196, v1012, v1012)
                        v125 = arith.constant 4 : i32;
                        v1011 = arith.constant 16 : i32;
                        v200 = arith.add v988, v1011 : i32 #[overflow = wrapping];
                        hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::RawVecInner<A>::deallocate(v200, v125, v125)
                        v1010 = arith.constant 48 : i32;
                        v204 = arith.add v988, v1010 : i32 #[overflow = wrapping];
                        v205 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
                        v206 = hir.bitcast v205 : ptr<byte, i32>;
                        hir.store v206, v204;
                        scf.yield ;
                    };
                    v1008 = arith.constant 0 : u32;
                    v1009 = arith.constant 1 : u32;
                    v1004 = cf.select v115, v1009, v1008 : u32;
                    scf.yield v1004;
                };
                scf.yield v965;
            };
            v1005 = arith.constant 0 : u32;
            v975 = arith.eq v963, v1005 : i1;
            cf.cond_br v975 ^block122, ^block23;
        ^block23:
            ub.unreachable ;
        ^block122:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block31:
            builtin.ret ;
        };

        private builtin.function @wit_bindgen::rt::run_ctors_once() {
        ^block33:
            v208 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
            v209 = hir.bitcast v208 : ptr<byte, i32>;
            v210 = hir.load v209 : i32;
            v211 = arith.constant 1048676 : i32;
            v212 = arith.add v210, v211 : i32 #[overflow = wrapping];
            v213 = hir.bitcast v212 : u32;
            v214 = hir.int_to_ptr v213 : ptr<byte, u8>;
            v215 = hir.load v214 : u8;
            v207 = arith.constant 0 : i32;
            v216 = arith.zext v215 : u32;
            v217 = hir.bitcast v216 : i32;
            v219 = arith.neq v217, v207 : i1;
            scf.if v219{
            ^block35:
                scf.yield ;
            } else {
            ^block36:
                v220 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
                v221 = hir.bitcast v220 : ptr<byte, i32>;
                v222 = hir.load v221 : i32;
                hir.exec @miden:base/note-script@1.0.0/p2id/__wasm_call_ctors()
                v1042 = arith.constant 1 : u8;
                v1044 = arith.constant 1048676 : i32;
                v224 = arith.add v222, v1044 : i32 #[overflow = wrapping];
                v228 = hir.bitcast v224 : u32;
                v229 = hir.int_to_ptr v228 : ptr<byte, u8>;
                hir.store v229, v1042;
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v230: i32, v231: i32, v232: i32) -> i32 {
        ^block37(v230: i32, v231: i32, v232: i32):
            v235 = arith.constant 16 : i32;
            v234 = arith.constant 0 : i32;
            v1046 = arith.constant 16 : u32;
            v237 = hir.bitcast v231 : u32;
            v239 = arith.gt v237, v1046 : i1;
            v240 = arith.zext v239 : u32;
            v241 = hir.bitcast v240 : i32;
            v243 = arith.neq v241, v234 : i1;
            v244 = cf.select v243, v231, v235 : i32;
            v1086 = arith.constant 0 : i32;
            v245 = arith.constant -1 : i32;
            v246 = arith.add v244, v245 : i32 #[overflow = wrapping];
            v247 = arith.band v244, v246 : i32;
            v249 = arith.neq v247, v1086 : i1;
            v1055, v1056 = scf.if v249 : i32, u32 {
            ^block137:
                v1047 = arith.constant 0 : u32;
                v1051 = ub.poison i32 : i32;
                scf.yield v1051, v1047;
            } else {
            ^block40:
                v251 = hir.exec @miden:base/note-script@1.0.0/p2id/core::ptr::alignment::Alignment::max(v231, v244) : i32
                v1085 = arith.constant 0 : i32;
                v250 = arith.constant -2147483648 : i32;
                v252 = arith.sub v250, v251 : i32 #[overflow = wrapping];
                v254 = hir.bitcast v252 : u32;
                v253 = hir.bitcast v232 : u32;
                v255 = arith.gt v253, v254 : i1;
                v256 = arith.zext v255 : u32;
                v257 = hir.bitcast v256 : i32;
                v259 = arith.neq v257, v1085 : i1;
                v1070 = scf.if v259 : i32 {
                ^block136:
                    v1084 = ub.poison i32 : i32;
                    scf.yield v1084;
                } else {
                ^block41:
                    v1082 = arith.constant 0 : i32;
                    v265 = arith.sub v1082, v251 : i32 #[overflow = wrapping];
                    v1083 = arith.constant -1 : i32;
                    v261 = arith.add v232, v251 : i32 #[overflow = wrapping];
                    v263 = arith.add v261, v1083 : i32 #[overflow = wrapping];
                    v266 = arith.band v263, v265 : i32;
                    v267 = hir.bitcast v230 : u32;
                    v268 = arith.constant 4 : u32;
                    v269 = arith.mod v267, v268 : u32;
                    hir.assertz v269 #[code = 250];
                    v270 = hir.int_to_ptr v267 : ptr<byte, i32>;
                    v271 = hir.load v270 : i32;
                    v1081 = arith.constant 0 : i32;
                    v273 = arith.neq v271, v1081 : i1;
                    scf.if v273{
                    ^block135:
                        scf.yield ;
                    } else {
                    ^block43:
                        v274 = hir.exec @miden:base/note-script@1.0.0/p2id/intrinsics::mem::heap_base() : i32
                        v275 = hir.mem_size  : u32;
                        v281 = hir.bitcast v230 : u32;
                        v1080 = arith.constant 4 : u32;
                        v283 = arith.mod v281, v1080 : u32;
                        hir.assertz v283 #[code = 250];
                        v1079 = arith.constant 16 : u32;
                        v276 = hir.bitcast v275 : i32;
                        v279 = arith.shl v276, v1079 : i32;
                        v280 = arith.add v274, v279 : i32 #[overflow = wrapping];
                        v284 = hir.int_to_ptr v281 : ptr<byte, i32>;
                        hir.store v284, v280;
                        scf.yield ;
                    };
                    v287 = hir.bitcast v230 : u32;
                    v1078 = arith.constant 4 : u32;
                    v289 = arith.mod v287, v1078 : u32;
                    hir.assertz v289 #[code = 250];
                    v290 = hir.int_to_ptr v287 : ptr<byte, i32>;
                    v291 = hir.load v290 : i32;
                    v1076 = arith.constant 0 : i32;
                    v1077 = arith.constant -1 : i32;
                    v293 = arith.bxor v291, v1077 : i32;
                    v295 = hir.bitcast v293 : u32;
                    v294 = hir.bitcast v266 : u32;
                    v296 = arith.gt v294, v295 : i1;
                    v297 = arith.zext v296 : u32;
                    v298 = hir.bitcast v297 : i32;
                    v300 = arith.neq v298, v1076 : i1;
                    v1069 = scf.if v300 : i32 {
                    ^block44:
                        v1075 = arith.constant 0 : i32;
                        scf.yield v1075;
                    } else {
                    ^block45:
                        v302 = hir.bitcast v230 : u32;
                        v1074 = arith.constant 4 : u32;
                        v304 = arith.mod v302, v1074 : u32;
                        hir.assertz v304 #[code = 250];
                        v301 = arith.add v291, v266 : i32 #[overflow = wrapping];
                        v305 = hir.int_to_ptr v302 : ptr<byte, i32>;
                        hir.store v305, v301;
                        v307 = arith.add v291, v251 : i32 #[overflow = wrapping];
                        scf.yield v307;
                    };
                    scf.yield v1069;
                };
                v1052 = arith.constant 1 : u32;
                v1073 = arith.constant 0 : u32;
                v1071 = cf.select v259, v1073, v1052 : u32;
                scf.yield v1070, v1071;
            };
            v1072 = arith.constant 0 : u32;
            v1068 = arith.eq v1056, v1072 : i1;
            cf.cond_br v1068 ^block39, ^block139(v1055);
        ^block39:
            ub.unreachable ;
        ^block139(v1048: i32):
            builtin.ret v1048;
        };

        private builtin.function @intrinsics::mem::heap_base() -> i32 {
        ^block46:
            v310 = hir.exec @intrinsics/mem/heap_base() : i32
            builtin.ret v310;
        };

        private builtin.function @alloc::vec::Vec<T>::with_capacity(v312: i32, v313: i32) {
        ^block50(v312: i32, v313: i32):
            v316 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v317 = hir.bitcast v316 : ptr<byte, i32>;
            v318 = hir.load v317 : i32;
            v319 = arith.constant 16 : i32;
            v320 = arith.sub v318, v319 : i32 #[overflow = wrapping];
            v321 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v322 = hir.bitcast v321 : ptr<byte, i32>;
            hir.store v322, v320;
            v1091 = arith.constant 16 : i32;
            v323 = arith.constant 8 : i32;
            v324 = arith.add v320, v323 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::RawVecInner<A>::with_capacity_in(v324, v1091, v1091, v313)
            v328 = arith.constant 8 : u32;
            v327 = hir.bitcast v320 : u32;
            v329 = arith.add v327, v328 : u32 #[overflow = checked];
            v1090 = arith.constant 8 : u32;
            v331 = arith.mod v329, v1090 : u32;
            hir.assertz v331 #[code = 250];
            v332 = hir.int_to_ptr v329 : ptr<byte, i64>;
            v333 = hir.load v332 : i64;
            v1089 = arith.constant 8 : u32;
            v335 = hir.bitcast v312 : u32;
            v337 = arith.add v335, v1089 : u32 #[overflow = checked];
            v338 = arith.constant 4 : u32;
            v339 = arith.mod v337, v338 : u32;
            hir.assertz v339 #[code = 250];
            v314 = arith.constant 0 : i32;
            v340 = hir.int_to_ptr v337 : ptr<byte, i32>;
            hir.store v340, v314;
            v341 = hir.bitcast v312 : u32;
            v1088 = arith.constant 4 : u32;
            v343 = arith.mod v341, v1088 : u32;
            hir.assertz v343 #[code = 250];
            v344 = hir.int_to_ptr v341 : ptr<byte, i64>;
            hir.store v344, v333;
            v1087 = arith.constant 16 : i32;
            v346 = arith.add v320, v1087 : i32 #[overflow = wrapping];
            v347 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v348 = hir.bitcast v347 : ptr<byte, i32>;
            hir.store v348, v346;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::with_capacity_in(v349: i32, v350: i32, v351: i32, v352: i32) {
        ^block52(v349: i32, v350: i32, v351: i32, v352: i32):
            v354 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v355 = hir.bitcast v354 : ptr<byte, i32>;
            v356 = hir.load v355 : i32;
            v357 = arith.constant 16 : i32;
            v358 = arith.sub v356, v357 : i32 #[overflow = wrapping];
            v359 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v360 = hir.bitcast v359 : ptr<byte, i32>;
            hir.store v360, v358;
            v353 = arith.constant 0 : i32;
            v363 = arith.constant 256 : i32;
            v361 = arith.constant 4 : i32;
            v362 = arith.add v358, v361 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::RawVecInner<A>::try_allocate_in(v362, v363, v353, v350, v351)
            v366 = arith.constant 8 : u32;
            v365 = hir.bitcast v358 : u32;
            v367 = arith.add v365, v366 : u32 #[overflow = checked];
            v368 = arith.constant 4 : u32;
            v369 = arith.mod v367, v368 : u32;
            hir.assertz v369 #[code = 250];
            v370 = hir.int_to_ptr v367 : ptr<byte, i32>;
            v371 = hir.load v370 : i32;
            v1102 = arith.constant 4 : u32;
            v372 = hir.bitcast v358 : u32;
            v374 = arith.add v372, v1102 : u32 #[overflow = checked];
            v1101 = arith.constant 4 : u32;
            v376 = arith.mod v374, v1101 : u32;
            hir.assertz v376 #[code = 250];
            v377 = hir.int_to_ptr v374 : ptr<byte, i32>;
            v378 = hir.load v377 : i32;
            v1100 = arith.constant 0 : i32;
            v379 = arith.constant 1 : i32;
            v380 = arith.neq v378, v379 : i1;
            v381 = arith.zext v380 : u32;
            v382 = hir.bitcast v381 : i32;
            v384 = arith.neq v382, v1100 : i1;
            cf.cond_br v384 ^block54, ^block55;
        ^block54:
            v393 = arith.constant 12 : u32;
            v392 = hir.bitcast v358 : u32;
            v394 = arith.add v392, v393 : u32 #[overflow = checked];
            v1099 = arith.constant 4 : u32;
            v396 = arith.mod v394, v1099 : u32;
            hir.assertz v396 #[code = 250];
            v397 = hir.int_to_ptr v394 : ptr<byte, i32>;
            v398 = hir.load v397 : i32;
            v1098 = arith.constant 4 : u32;
            v399 = hir.bitcast v349 : u32;
            v401 = arith.add v399, v1098 : u32 #[overflow = checked];
            v1097 = arith.constant 4 : u32;
            v403 = arith.mod v401, v1097 : u32;
            hir.assertz v403 #[code = 250];
            v404 = hir.int_to_ptr v401 : ptr<byte, i32>;
            hir.store v404, v398;
            v405 = hir.bitcast v349 : u32;
            v1096 = arith.constant 4 : u32;
            v407 = arith.mod v405, v1096 : u32;
            hir.assertz v407 #[code = 250];
            v408 = hir.int_to_ptr v405 : ptr<byte, i32>;
            hir.store v408, v371;
            v1095 = arith.constant 16 : i32;
            v410 = arith.add v358, v1095 : i32 #[overflow = wrapping];
            v411 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v412 = hir.bitcast v411 : ptr<byte, i32>;
            hir.store v412, v410;
            builtin.ret ;
        ^block55:
            v1094 = arith.constant 12 : u32;
            v385 = hir.bitcast v358 : u32;
            v387 = arith.add v385, v1094 : u32 #[overflow = checked];
            v1093 = arith.constant 4 : u32;
            v389 = arith.mod v387, v1093 : u32;
            hir.assertz v389 #[code = 250];
            v390 = hir.int_to_ptr v387 : ptr<byte, i32>;
            v391 = hir.load v390 : i32;
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::handle_error(v371, v391, v352)
            ub.unreachable ;
        };

        private builtin.function @miden_base_sys::bindings::active_account::get_id(v413: i32) {
        ^block56(v413: i32):
            v415 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v416 = hir.bitcast v415 : ptr<byte, i32>;
            v417 = hir.load v416 : i32;
            v418 = arith.constant 16 : i32;
            v419 = arith.sub v417, v418 : i32 #[overflow = wrapping];
            v420 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v421 = hir.bitcast v420 : ptr<byte, i32>;
            hir.store v421, v419;
            v422 = arith.constant 8 : i32;
            v423 = arith.add v419, v422 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/miden::active_account::get_id(v423)
            v425 = arith.constant 8 : u32;
            v424 = hir.bitcast v419 : u32;
            v426 = arith.add v424, v425 : u32 #[overflow = checked];
            v427 = arith.constant 4 : u32;
            v428 = arith.mod v426, v427 : u32;
            hir.assertz v428 #[code = 250];
            v429 = hir.int_to_ptr v426 : ptr<byte, i64>;
            v430 = hir.load v429 : i64;
            v431 = hir.bitcast v413 : u32;
            v1104 = arith.constant 8 : u32;
            v433 = arith.mod v431, v1104 : u32;
            hir.assertz v433 #[code = 250];
            v434 = hir.int_to_ptr v431 : ptr<byte, i64>;
            hir.store v434, v430;
            v1103 = arith.constant 16 : i32;
            v436 = arith.add v419, v1103 : i32 #[overflow = wrapping];
            v437 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v438 = hir.bitcast v437 : ptr<byte, i32>;
            hir.store v438, v436;
            builtin.ret ;
        };

        private builtin.function @miden_base_sys::bindings::active_note::get_inputs(v439: i32) {
        ^block58(v439: i32):
            v441 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v442 = hir.bitcast v441 : ptr<byte, i32>;
            v443 = hir.load v442 : i32;
            v444 = arith.constant 16 : i32;
            v445 = arith.sub v443, v444 : i32 #[overflow = wrapping];
            v446 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v447 = hir.bitcast v446 : ptr<byte, i32>;
            hir.store v447, v445;
            v452 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
            v453 = hir.bitcast v452 : ptr<byte, i32>;
            v454 = hir.load v453 : i32;
            v455 = arith.constant 1048640 : i32;
            v456 = arith.add v454, v455 : i32 #[overflow = wrapping];
            v450 = arith.constant 4 : i32;
            v448 = arith.constant 8 : i32;
            v449 = arith.add v445, v448 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::RawVecInner<A>::with_capacity_in(v449, v450, v450, v456)
            v458 = arith.constant 8 : u32;
            v457 = hir.bitcast v445 : u32;
            v459 = arith.add v457, v458 : u32 #[overflow = checked];
            v460 = arith.constant 4 : u32;
            v461 = arith.mod v459, v460 : u32;
            hir.assertz v461 #[code = 250];
            v462 = hir.int_to_ptr v459 : ptr<byte, i32>;
            v463 = hir.load v462 : i32;
            v465 = arith.constant 12 : u32;
            v464 = hir.bitcast v445 : u32;
            v466 = arith.add v464, v465 : u32 #[overflow = checked];
            v1112 = arith.constant 4 : u32;
            v468 = arith.mod v466, v1112 : u32;
            hir.assertz v468 #[code = 250];
            v469 = hir.int_to_ptr v466 : ptr<byte, i32>;
            v470 = hir.load v469 : i32;
            v1105 = arith.constant 2 : u32;
            v472 = hir.bitcast v470 : u32;
            v474 = arith.shr v472, v1105 : u32;
            v475 = hir.bitcast v474 : i32;
            v476 = hir.exec @miden:base/note-script@1.0.0/p2id/miden::active_note::get_inputs(v475) : i32
            v1111 = arith.constant 8 : u32;
            v477 = hir.bitcast v439 : u32;
            v479 = arith.add v477, v1111 : u32 #[overflow = checked];
            v1110 = arith.constant 4 : u32;
            v481 = arith.mod v479, v1110 : u32;
            hir.assertz v481 #[code = 250];
            v482 = hir.int_to_ptr v479 : ptr<byte, i32>;
            hir.store v482, v476;
            v1109 = arith.constant 4 : u32;
            v483 = hir.bitcast v439 : u32;
            v485 = arith.add v483, v1109 : u32 #[overflow = checked];
            v1108 = arith.constant 4 : u32;
            v487 = arith.mod v485, v1108 : u32;
            hir.assertz v487 #[code = 250];
            v488 = hir.int_to_ptr v485 : ptr<byte, i32>;
            hir.store v488, v470;
            v489 = hir.bitcast v439 : u32;
            v1107 = arith.constant 4 : u32;
            v491 = arith.mod v489, v1107 : u32;
            hir.assertz v491 #[code = 250];
            v492 = hir.int_to_ptr v489 : ptr<byte, i32>;
            hir.store v492, v463;
            v1106 = arith.constant 16 : i32;
            v494 = arith.add v445, v1106 : i32 #[overflow = wrapping];
            v495 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v496 = hir.bitcast v495 : ptr<byte, i32>;
            hir.store v496, v494;
            builtin.ret ;
        };

        private builtin.function @miden_base_sys::bindings::active_note::get_assets(v497: i32) {
        ^block60(v497: i32):
            v499 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v500 = hir.bitcast v499 : ptr<byte, i32>;
            v501 = hir.load v500 : i32;
            v502 = arith.constant 16 : i32;
            v503 = arith.sub v501, v502 : i32 #[overflow = wrapping];
            v504 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v505 = hir.bitcast v504 : ptr<byte, i32>;
            hir.store v505, v503;
            v508 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
            v509 = hir.bitcast v508 : ptr<byte, i32>;
            v510 = hir.load v509 : i32;
            v511 = arith.constant 1048656 : i32;
            v512 = arith.add v510, v511 : i32 #[overflow = wrapping];
            v506 = arith.constant 4 : i32;
            v507 = arith.add v503, v506 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::vec::Vec<T>::with_capacity(v507, v512)
            v516 = arith.constant 8 : u32;
            v515 = hir.bitcast v503 : u32;
            v517 = arith.add v515, v516 : u32 #[overflow = checked];
            v518 = arith.constant 4 : u32;
            v519 = arith.mod v517, v518 : u32;
            hir.assertz v519 #[code = 250];
            v520 = hir.int_to_ptr v517 : ptr<byte, i32>;
            v521 = hir.load v520 : i32;
            v1113 = arith.constant 2 : u32;
            v523 = hir.bitcast v521 : u32;
            v525 = arith.shr v523, v1113 : u32;
            v526 = hir.bitcast v525 : i32;
            v527 = hir.exec @miden:base/note-script@1.0.0/p2id/miden::active_note::get_assets(v526) : i32
            v513 = arith.constant 8 : i32;
            v514 = arith.add v497, v513 : i32 #[overflow = wrapping];
            v528 = hir.bitcast v514 : u32;
            v1118 = arith.constant 4 : u32;
            v530 = arith.mod v528, v1118 : u32;
            hir.assertz v530 #[code = 250];
            v531 = hir.int_to_ptr v528 : ptr<byte, i32>;
            hir.store v531, v527;
            v1117 = arith.constant 4 : u32;
            v532 = hir.bitcast v503 : u32;
            v534 = arith.add v532, v1117 : u32 #[overflow = checked];
            v1116 = arith.constant 4 : u32;
            v536 = arith.mod v534, v1116 : u32;
            hir.assertz v536 #[code = 250];
            v537 = hir.int_to_ptr v534 : ptr<byte, i64>;
            v538 = hir.load v537 : i64;
            v539 = hir.bitcast v497 : u32;
            v1115 = arith.constant 4 : u32;
            v541 = arith.mod v539, v1115 : u32;
            hir.assertz v541 #[code = 250];
            v542 = hir.int_to_ptr v539 : ptr<byte, i64>;
            hir.store v542, v538;
            v1114 = arith.constant 16 : i32;
            v544 = arith.add v503, v1114 : i32 #[overflow = wrapping];
            v545 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v546 = hir.bitcast v545 : ptr<byte, i32>;
            hir.store v546, v544;
            builtin.ret ;
        };

        private builtin.function @intrinsics::felt::eq(v547: felt, v548: felt) -> i32 {
        ^block62(v547: felt, v548: felt):
            v549 = arith.eq v547, v548 : i1;
            v550 = hir.cast v549 : i32;
            builtin.ret v550;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v552: i32, v553: i32, v554: i32) {
        ^block64(v552: i32, v553: i32, v554: i32):
            v556 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v557 = hir.bitcast v556 : ptr<byte, i32>;
            v558 = hir.load v557 : i32;
            v559 = arith.constant 16 : i32;
            v560 = arith.sub v558, v559 : i32 #[overflow = wrapping];
            v561 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v562 = hir.bitcast v561 : ptr<byte, i32>;
            hir.store v562, v560;
            v563 = arith.constant 4 : i32;
            v564 = arith.add v560, v563 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::RawVecInner<A>::current_memory(v564, v552, v553, v554)
            v566 = arith.constant 8 : u32;
            v565 = hir.bitcast v560 : u32;
            v567 = arith.add v565, v566 : u32 #[overflow = checked];
            v568 = arith.constant 4 : u32;
            v569 = arith.mod v567, v568 : u32;
            hir.assertz v569 #[code = 250];
            v570 = hir.int_to_ptr v567 : ptr<byte, i32>;
            v571 = hir.load v570 : i32;
            v1125 = arith.constant 0 : i32;
            v555 = arith.constant 0 : i32;
            v573 = arith.eq v571, v555 : i1;
            v574 = arith.zext v573 : u32;
            v575 = hir.bitcast v574 : i32;
            v577 = arith.neq v575, v1125 : i1;
            scf.if v577{
            ^block145:
                scf.yield ;
            } else {
            ^block67:
                v1124 = arith.constant 4 : u32;
                v578 = hir.bitcast v560 : u32;
                v580 = arith.add v578, v1124 : u32 #[overflow = checked];
                v1123 = arith.constant 4 : u32;
                v582 = arith.mod v580, v1123 : u32;
                hir.assertz v582 #[code = 250];
                v583 = hir.int_to_ptr v580 : ptr<byte, i32>;
                v584 = hir.load v583 : i32;
                v586 = arith.constant 12 : u32;
                v585 = hir.bitcast v560 : u32;
                v587 = arith.add v585, v586 : u32 #[overflow = checked];
                v1122 = arith.constant 4 : u32;
                v589 = arith.mod v587, v1122 : u32;
                hir.assertz v589 #[code = 250];
                v590 = hir.int_to_ptr v587 : ptr<byte, i32>;
                v591 = hir.load v590 : i32;
                hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v584, v571, v591)
                scf.yield ;
            };
            v1121 = arith.constant 16 : i32;
            v594 = arith.add v560, v1121 : i32 #[overflow = wrapping];
            v595 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v596 = hir.bitcast v595 : ptr<byte, i32>;
            hir.store v596, v594;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::try_allocate_in(v597: i32, v598: i32, v599: i32, v600: i32, v601: i32) {
        ^block68(v597: i32, v598: i32, v599: i32, v600: i32, v601: i32):
            v604 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v605 = hir.bitcast v604 : ptr<byte, i32>;
            v606 = hir.load v605 : i32;
            v607 = arith.constant 16 : i32;
            v608 = arith.sub v606, v607 : i32 #[overflow = wrapping];
            v609 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v610 = hir.bitcast v609 : ptr<byte, i32>;
            hir.store v610, v608;
            v620 = hir.bitcast v598 : u32;
            v621 = arith.zext v620 : u64;
            v622 = hir.bitcast v621 : i64;
            v602 = arith.constant 0 : i32;
            v615 = arith.sub v602, v600 : i32 #[overflow = wrapping];
            v612 = arith.constant -1 : i32;
            v611 = arith.add v600, v601 : i32 #[overflow = wrapping];
            v613 = arith.add v611, v612 : i32 #[overflow = wrapping];
            v616 = arith.band v613, v615 : i32;
            v617 = hir.bitcast v616 : u32;
            v618 = arith.zext v617 : u64;
            v619 = hir.bitcast v618 : i64;
            v623 = arith.mul v619, v622 : i64 #[overflow = wrapping];
            v1229 = arith.constant 0 : i32;
            v624 = arith.constant 32 : i64;
            v626 = hir.cast v624 : u32;
            v625 = hir.bitcast v623 : u64;
            v627 = arith.shr v625, v626 : u64;
            v628 = hir.bitcast v627 : i64;
            v629 = arith.trunc v628 : i32;
            v631 = arith.neq v629, v1229 : i1;
            v1141, v1142, v1143, v1144, v1145, v1146 = scf.if v631 : i32, i32, i32, i32, i32, u32 {
            ^block147:
                v1126 = arith.constant 0 : u32;
                v1133 = ub.poison i32 : i32;
                scf.yield v597, v608, v1133, v1133, v1133, v1126;
            } else {
            ^block73:
                v632 = arith.trunc v623 : i32;
                v1228 = arith.constant 0 : i32;
                v633 = arith.constant -2147483648 : i32;
                v634 = arith.sub v633, v600 : i32 #[overflow = wrapping];
                v636 = hir.bitcast v634 : u32;
                v635 = hir.bitcast v632 : u32;
                v637 = arith.lte v635, v636 : i1;
                v638 = arith.zext v637 : u32;
                v639 = hir.bitcast v638 : i32;
                v641 = arith.neq v639, v1228 : i1;
                v1189 = scf.if v641 : i32 {
                ^block71:
                    v1227 = arith.constant 0 : i32;
                    v652 = arith.neq v632, v1227 : i1;
                    v1188 = scf.if v652 : i32 {
                    ^block75:
                        v1226 = arith.constant 0 : i32;
                        v668 = arith.neq v599, v1226 : i1;
                        v1187 = scf.if v668 : i32 {
                        ^block78:
                            v650 = arith.constant 1 : i32;
                            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::alloc::Global::alloc_impl(v608, v600, v632, v650)
                            v679 = hir.bitcast v608 : u32;
                            v724 = arith.constant 4 : u32;
                            v681 = arith.mod v679, v724 : u32;
                            hir.assertz v681 #[code = 250];
                            v682 = hir.int_to_ptr v679 : ptr<byte, i32>;
                            v683 = hir.load v682 : i32;
                            scf.yield v683;
                        } else {
                        ^block79:
                            v669 = arith.constant 8 : i32;
                            v670 = arith.add v608, v669 : i32 #[overflow = wrapping];
                            hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v670, v600, v632)
                            v654 = arith.constant 8 : u32;
                            v671 = hir.bitcast v608 : u32;
                            v673 = arith.add v671, v654 : u32 #[overflow = checked];
                            v1225 = arith.constant 4 : u32;
                            v675 = arith.mod v673, v1225 : u32;
                            hir.assertz v675 #[code = 250];
                            v676 = hir.int_to_ptr v673 : ptr<byte, i32>;
                            v677 = hir.load v676 : i32;
                            scf.yield v677;
                        };
                        v1223 = arith.constant 0 : i32;
                        v1224 = arith.constant 0 : i32;
                        v686 = arith.eq v1187, v1224 : i1;
                        v687 = arith.zext v686 : u32;
                        v688 = hir.bitcast v687 : i32;
                        v690 = arith.neq v688, v1223 : i1;
                        scf.if v690{
                        ^block80:
                            v1222 = arith.constant 8 : u32;
                            v707 = hir.bitcast v597 : u32;
                            v709 = arith.add v707, v1222 : u32 #[overflow = checked];
                            v1221 = arith.constant 4 : u32;
                            v711 = arith.mod v709, v1221 : u32;
                            hir.assertz v711 #[code = 250];
                            v712 = hir.int_to_ptr v709 : ptr<byte, i32>;
                            hir.store v712, v632;
                            v1220 = arith.constant 4 : u32;
                            v714 = hir.bitcast v597 : u32;
                            v716 = arith.add v714, v1220 : u32 #[overflow = checked];
                            v1219 = arith.constant 4 : u32;
                            v718 = arith.mod v716, v1219 : u32;
                            hir.assertz v718 #[code = 250];
                            v719 = hir.int_to_ptr v716 : ptr<byte, i32>;
                            hir.store v719, v600;
                            scf.yield ;
                        } else {
                        ^block81:
                            v1218 = arith.constant 8 : u32;
                            v692 = hir.bitcast v597 : u32;
                            v694 = arith.add v692, v1218 : u32 #[overflow = checked];
                            v1217 = arith.constant 4 : u32;
                            v696 = arith.mod v694, v1217 : u32;
                            hir.assertz v696 #[code = 250];
                            v697 = hir.int_to_ptr v694 : ptr<byte, i32>;
                            hir.store v697, v1187;
                            v1216 = arith.constant 4 : u32;
                            v699 = hir.bitcast v597 : u32;
                            v701 = arith.add v699, v1216 : u32 #[overflow = checked];
                            v1215 = arith.constant 4 : u32;
                            v703 = arith.mod v701, v1215 : u32;
                            hir.assertz v703 #[code = 250];
                            v704 = hir.int_to_ptr v701 : ptr<byte, i32>;
                            hir.store v704, v598;
                            scf.yield ;
                        };
                        v1213 = arith.constant 0 : i32;
                        v1214 = arith.constant 1 : i32;
                        v1186 = cf.select v690, v1214, v1213 : i32;
                        scf.yield v1186;
                    } else {
                    ^block76:
                        v1212 = arith.constant 8 : u32;
                        v653 = hir.bitcast v597 : u32;
                        v655 = arith.add v653, v1212 : u32 #[overflow = checked];
                        v1211 = arith.constant 4 : u32;
                        v657 = arith.mod v655, v1211 : u32;
                        hir.assertz v657 #[code = 250];
                        v658 = hir.int_to_ptr v655 : ptr<byte, i32>;
                        hir.store v658, v600;
                        v1210 = arith.constant 4 : u32;
                        v661 = hir.bitcast v597 : u32;
                        v663 = arith.add v661, v1210 : u32 #[overflow = checked];
                        v1209 = arith.constant 4 : u32;
                        v665 = arith.mod v663, v1209 : u32;
                        hir.assertz v665 #[code = 250];
                        v1208 = arith.constant 0 : i32;
                        v666 = hir.int_to_ptr v663 : ptr<byte, i32>;
                        hir.store v666, v1208;
                        v1207 = arith.constant 0 : i32;
                        scf.yield v1207;
                    };
                    scf.yield v1188;
                } else {
                ^block74:
                    v1206 = ub.poison i32 : i32;
                    scf.yield v1206;
                };
                v1201 = arith.constant 0 : u32;
                v1134 = arith.constant 1 : u32;
                v1194 = cf.select v641, v1134, v1201 : u32;
                v1202 = ub.poison i32 : i32;
                v1193 = cf.select v641, v608, v1202 : i32;
                v1203 = ub.poison i32 : i32;
                v1192 = cf.select v641, v597, v1203 : i32;
                v1204 = ub.poison i32 : i32;
                v1191 = cf.select v641, v1204, v608 : i32;
                v1205 = ub.poison i32 : i32;
                v1190 = cf.select v641, v1205, v597 : i32;
                scf.yield v1190, v1191, v1192, v1189, v1193, v1194;
            };
            v1147, v1148, v1149 = scf.index_switch v1146 : i32, i32, i32 
            case 0 {
            ^block72:
                v1200 = arith.constant 4 : u32;
                v644 = hir.bitcast v1141 : u32;
                v646 = arith.add v644, v1200 : u32 #[overflow = checked];
                v1199 = arith.constant 4 : u32;
                v648 = arith.mod v646, v1199 : u32;
                hir.assertz v648 #[code = 250];
                v1198 = arith.constant 0 : i32;
                v649 = hir.int_to_ptr v646 : ptr<byte, i32>;
                hir.store v649, v1198;
                v1197 = arith.constant 1 : i32;
                scf.yield v1141, v1197, v1142;
            }
            default {
            ^block151:
                scf.yield v1143, v1144, v1145;
            };
            v723 = hir.bitcast v1147 : u32;
            v1196 = arith.constant 4 : u32;
            v725 = arith.mod v723, v1196 : u32;
            hir.assertz v725 #[code = 250];
            v726 = hir.int_to_ptr v723 : ptr<byte, i32>;
            hir.store v726, v1148;
            v1195 = arith.constant 16 : i32;
            v731 = arith.add v1149, v1195 : i32 #[overflow = wrapping];
            v732 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v733 = hir.bitcast v732 : ptr<byte, i32>;
            hir.store v733, v731;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v734: i32, v735: i32, v736: i32) {
        ^block82(v734: i32, v735: i32, v736: i32):
            v738 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v739 = hir.bitcast v738 : ptr<byte, i32>;
            v740 = hir.load v739 : i32;
            v741 = arith.constant 16 : i32;
            v742 = arith.sub v740, v741 : i32 #[overflow = wrapping];
            v743 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v744 = hir.bitcast v743 : ptr<byte, i32>;
            hir.store v744, v742;
            v737 = arith.constant 0 : i32;
            v745 = arith.constant 8 : i32;
            v746 = arith.add v742, v745 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::alloc::Global::alloc_impl(v746, v735, v736, v737)
            v749 = arith.constant 12 : u32;
            v748 = hir.bitcast v742 : u32;
            v750 = arith.add v748, v749 : u32 #[overflow = checked];
            v751 = arith.constant 4 : u32;
            v752 = arith.mod v750, v751 : u32;
            hir.assertz v752 #[code = 250];
            v753 = hir.int_to_ptr v750 : ptr<byte, i32>;
            v754 = hir.load v753 : i32;
            v756 = arith.constant 8 : u32;
            v755 = hir.bitcast v742 : u32;
            v757 = arith.add v755, v756 : u32 #[overflow = checked];
            v1234 = arith.constant 4 : u32;
            v759 = arith.mod v757, v1234 : u32;
            hir.assertz v759 #[code = 250];
            v760 = hir.int_to_ptr v757 : ptr<byte, i32>;
            v761 = hir.load v760 : i32;
            v762 = hir.bitcast v734 : u32;
            v1233 = arith.constant 4 : u32;
            v764 = arith.mod v762, v1233 : u32;
            hir.assertz v764 #[code = 250];
            v765 = hir.int_to_ptr v762 : ptr<byte, i32>;
            hir.store v765, v761;
            v1232 = arith.constant 4 : u32;
            v766 = hir.bitcast v734 : u32;
            v768 = arith.add v766, v1232 : u32 #[overflow = checked];
            v1231 = arith.constant 4 : u32;
            v770 = arith.mod v768, v1231 : u32;
            hir.assertz v770 #[code = 250];
            v771 = hir.int_to_ptr v768 : ptr<byte, i32>;
            hir.store v771, v754;
            v1230 = arith.constant 16 : i32;
            v773 = arith.add v742, v1230 : i32 #[overflow = wrapping];
            v774 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v775 = hir.bitcast v774 : ptr<byte, i32>;
            hir.store v775, v773;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v776: i32, v777: i32, v778: i32, v779: i32) {
        ^block84(v776: i32, v777: i32, v778: i32, v779: i32):
            v1250 = arith.constant 0 : i32;
            v780 = arith.constant 0 : i32;
            v781 = arith.eq v778, v780 : i1;
            v782 = arith.zext v781 : u32;
            v783 = hir.bitcast v782 : i32;
            v785 = arith.neq v783, v1250 : i1;
            v1246 = scf.if v785 : i32 {
            ^block154:
                scf.yield v777;
            } else {
            ^block87:
                hir.exec @miden:base/note-script@1.0.0/p2id/__rustc::__rust_no_alloc_shim_is_unstable_v2()
                v1249 = arith.constant 0 : i32;
                v787 = arith.neq v779, v1249 : i1;
                v1245 = scf.if v787 : i32 {
                ^block88:
                    v789 = hir.exec @miden:base/note-script@1.0.0/p2id/__rustc::__rust_alloc_zeroed(v778, v777) : i32
                    scf.yield v789;
                } else {
                ^block89:
                    v788 = hir.exec @miden:base/note-script@1.0.0/p2id/__rustc::__rust_alloc(v778, v777) : i32
                    scf.yield v788;
                };
                scf.yield v1245;
            };
            v793 = arith.constant 4 : u32;
            v792 = hir.bitcast v776 : u32;
            v794 = arith.add v792, v793 : u32 #[overflow = checked];
            v1248 = arith.constant 4 : u32;
            v796 = arith.mod v794, v1248 : u32;
            hir.assertz v796 #[code = 250];
            v797 = hir.int_to_ptr v794 : ptr<byte, i32>;
            hir.store v797, v778;
            v799 = hir.bitcast v776 : u32;
            v1247 = arith.constant 4 : u32;
            v801 = arith.mod v799, v1247 : u32;
            hir.assertz v801 #[code = 250];
            v802 = hir.int_to_ptr v799 : ptr<byte, i32>;
            hir.store v802, v1246;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v803: i32, v804: i32, v805: i32, v806: i32) {
        ^block90(v803: i32, v804: i32, v805: i32, v806: i32):
            v1276 = arith.constant 0 : i32;
            v807 = arith.constant 0 : i32;
            v811 = arith.eq v806, v807 : i1;
            v812 = arith.zext v811 : u32;
            v813 = hir.bitcast v812 : i32;
            v815 = arith.neq v813, v1276 : i1;
            v1263, v1264 = scf.if v815 : i32, i32 {
            ^block158:
                v1275 = arith.constant 0 : i32;
                v809 = arith.constant 4 : i32;
                scf.yield v809, v1275;
            } else {
            ^block93:
                v816 = hir.bitcast v804 : u32;
                v851 = arith.constant 4 : u32;
                v818 = arith.mod v816, v851 : u32;
                hir.assertz v818 #[code = 250];
                v819 = hir.int_to_ptr v816 : ptr<byte, i32>;
                v820 = hir.load v819 : i32;
                v1273 = arith.constant 0 : i32;
                v1274 = arith.constant 0 : i32;
                v822 = arith.eq v820, v1274 : i1;
                v823 = arith.zext v822 : u32;
                v824 = hir.bitcast v823 : i32;
                v826 = arith.neq v824, v1273 : i1;
                v1261 = scf.if v826 : i32 {
                ^block157:
                    v1272 = arith.constant 0 : i32;
                    scf.yield v1272;
                } else {
                ^block94:
                    v1271 = arith.constant 4 : u32;
                    v827 = hir.bitcast v803 : u32;
                    v829 = arith.add v827, v1271 : u32 #[overflow = checked];
                    v1270 = arith.constant 4 : u32;
                    v831 = arith.mod v829, v1270 : u32;
                    hir.assertz v831 #[code = 250];
                    v832 = hir.int_to_ptr v829 : ptr<byte, i32>;
                    hir.store v832, v805;
                    v1269 = arith.constant 4 : u32;
                    v833 = hir.bitcast v804 : u32;
                    v835 = arith.add v833, v1269 : u32 #[overflow = checked];
                    v1268 = arith.constant 4 : u32;
                    v837 = arith.mod v835, v1268 : u32;
                    hir.assertz v837 #[code = 250];
                    v838 = hir.int_to_ptr v835 : ptr<byte, i32>;
                    v839 = hir.load v838 : i32;
                    v840 = hir.bitcast v803 : u32;
                    v1267 = arith.constant 4 : u32;
                    v842 = arith.mod v840, v1267 : u32;
                    hir.assertz v842 #[code = 250];
                    v843 = hir.int_to_ptr v840 : ptr<byte, i32>;
                    hir.store v843, v839;
                    v844 = arith.mul v820, v806 : i32 #[overflow = wrapping];
                    scf.yield v844;
                };
                v845 = arith.constant 8 : i32;
                v1266 = arith.constant 4 : i32;
                v1262 = cf.select v826, v1266, v845 : i32;
                scf.yield v1262, v1261;
            };
            v848 = arith.add v803, v1263 : i32 #[overflow = wrapping];
            v850 = hir.bitcast v848 : u32;
            v1265 = arith.constant 4 : u32;
            v852 = arith.mod v850, v1265 : u32;
            hir.assertz v852 #[code = 250];
            v853 = hir.int_to_ptr v850 : ptr<byte, i32>;
            hir.store v853, v1264;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v854: i32, v855: i32, v856: i32) {
        ^block95(v854: i32, v855: i32, v856: i32):
            v1278 = arith.constant 0 : i32;
            v857 = arith.constant 0 : i32;
            v858 = arith.eq v856, v857 : i1;
            v859 = arith.zext v858 : u32;
            v860 = hir.bitcast v859 : i32;
            v862 = arith.neq v860, v1278 : i1;
            scf.if v862{
            ^block97:
                scf.yield ;
            } else {
            ^block98:
                hir.exec @miden:base/note-script@1.0.0/p2id/__rustc::__rust_dealloc(v854, v856, v855)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v863: i32, v864: i32, v865: i32) {
        ^block99(v863: i32, v864: i32, v865: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v866: i32, v867: i32) -> i32 {
        ^block101(v866: i32, v867: i32):
            v874 = arith.constant 0 : i32;
            v870 = hir.bitcast v867 : u32;
            v869 = hir.bitcast v866 : u32;
            v871 = arith.gt v869, v870 : i1;
            v872 = arith.zext v871 : u32;
            v873 = hir.bitcast v872 : i32;
            v875 = arith.neq v873, v874 : i1;
            v876 = cf.select v875, v866, v867 : i32;
            builtin.ret v876;
        };

        private builtin.function @miden::active_account::get_id(v877: i32) {
        ^block103(v877: i32):
            v878, v879 = hir.exec @miden/active_account/get_id() : felt, felt
            v880 = hir.bitcast v877 : u32;
            v881 = hir.int_to_ptr v880 : ptr<byte, felt>;
            hir.store v881, v878;
            v882 = arith.constant 4 : u32;
            v883 = arith.add v880, v882 : u32 #[overflow = checked];
            v884 = hir.int_to_ptr v883 : ptr<byte, felt>;
            hir.store v884, v879;
            builtin.ret ;
        };

        private builtin.function @miden::active_note::get_inputs(v885: i32) -> i32 {
        ^block107(v885: i32):
            v886, v887 = hir.exec @miden/active_note/get_inputs(v885) : i32, i32
            builtin.ret v886;
        };

        private builtin.function @miden::active_note::get_assets(v889: i32) -> i32 {
        ^block110(v889: i32):
            v890, v891 = hir.exec @miden/active_note/get_assets(v889) : i32, i32
            builtin.ret v890;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.global_variable private @#GOT.data.internal.__memory_base : i32 {
            builtin.ret_imm 0;
        };

        builtin.segment readonly @1048576 = 0x0073722e65746f6e5f6576697463612f73676e69646e69622f6372732f302e372e302d7379732d657361622d6e6564696d;

        builtin.segment @1048628 = 0x000000220000003d0000003000100000000000210000001f0000003000100000000000010000000100000001;
    };

    public builtin.function @run(v893: felt, v894: felt, v895: felt, v896: felt) {
    ^block112(v893: felt, v894: felt, v895: felt, v896: felt):
        hir.exec @miden:base/note-script@1.0.0/p2id/miden:base/note-script@1.0.0#run(v893, v894, v895, v896)
        builtin.ret ;
    };
};