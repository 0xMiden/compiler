builtin.component miden:base/note-script@1.0.0 {
    builtin.module public @p2id {
        private builtin.function @p2id::bindings::miden::basic_wallet::basic_wallet::receive_asset::wit_import7(v0: felt, v1: felt, v2: felt, v3: felt) {
        ^block3(v0: felt, v1: felt, v2: felt, v3: felt):
            hir.call v0, v1, v2, v3 #[callee = miden:basic-wallet/basic-wallet@0.1.0/receive-asset] #[signature = (param felt) (param felt) (param felt) (param felt)];
            builtin.ret ;
        };

        private builtin.function @__wasm_call_ctors() {
        ^block8:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc(v4: i32, v5: i32) -> i32 {
        ^block10(v4: i32, v5: i32):
            v7 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
            v8 = hir.bitcast v7 : ptr<byte, i32>;
            v9 = hir.load v8 : i32;
            v10 = arith.constant 1048616 : i32;
            v11 = arith.add v9, v10 : i32 #[overflow = wrapping];
            v12 = hir.exec @miden:base/note-script@1.0.0/p2id/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v11, v5, v4) : i32
            builtin.ret v12;
        };

        private builtin.function @__rustc::__rust_dealloc(v13: i32, v14: i32, v15: i32) {
        ^block12(v13: i32, v14: i32, v15: i32):
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v16: i32, v17: i32) -> i32 {
        ^block14(v16: i32, v17: i32):
            v19 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
            v20 = hir.bitcast v19 : ptr<byte, i32>;
            v21 = hir.load v20 : i32;
            v22 = arith.constant 1048616 : i32;
            v23 = arith.add v21, v22 : i32 #[overflow = wrapping];
            v24 = hir.exec @miden:base/note-script@1.0.0/p2id/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v23, v17, v16) : i32
            v898 = arith.constant 0 : i32;
            v25 = arith.constant 0 : i32;
            v26 = arith.eq v24, v25 : i1;
            v27 = arith.zext v26 : u32;
            v28 = hir.bitcast v27 : i32;
            v30 = arith.neq v28, v898 : i1;
            scf.if v30{
            ^block16:
                scf.yield ;
            } else {
            ^block17:
                v896 = arith.constant 0 : i32;
                v897 = arith.constant 0 : i32;
                v32 = arith.eq v16, v897 : i1;
                v33 = arith.zext v32 : u32;
                v34 = hir.bitcast v33 : i32;
                v36 = arith.neq v34, v896 : i1;
                scf.if v36{
                ^block114:
                    scf.yield ;
                } else {
                ^block18:
                    v890 = arith.constant 0 : u8;
                    v39 = hir.bitcast v16 : u32;
                    v40 = hir.bitcast v24 : u32;
                    v41 = hir.int_to_ptr v40 : ptr<byte, u8>;
                    hir.mem_set v41, v39, v890;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v24;
        };

        private builtin.function @p2id::bindings::__link_custom_section_describing_imports() {
        ^block19:
            builtin.ret ;
        };

        private builtin.function @miden:base/note-script@1.0.0#run(v43: felt, v44: felt, v45: felt, v46: felt) {
        ^block21(v43: felt, v44: felt, v45: felt, v46: felt):
            v50 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v51 = hir.bitcast v50 : ptr<byte, i32>;
            v52 = hir.load v51 : i32;
            v53 = arith.constant 48 : i32;
            v54 = arith.sub v52, v53 : i32 #[overflow = wrapping];
            v55 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v56 = hir.bitcast v55 : ptr<byte, i32>;
            hir.store v56, v54;
            hir.exec @miden:base/note-script@1.0.0/p2id/wit_bindgen::rt::run_ctors_once()
            v57 = arith.constant 16 : i32;
            v58 = arith.add v54, v57 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/miden_base_sys::bindings::active_note::get_inputs(v58)
            v60 = arith.constant 24 : u32;
            v59 = hir.bitcast v54 : u32;
            v61 = arith.add v59, v60 : u32 #[overflow = checked];
            v62 = arith.constant 4 : u32;
            v63 = arith.mod v61, v62 : u32;
            hir.assertz v63 #[code = 250];
            v64 = hir.int_to_ptr v61 : ptr<byte, i32>;
            v65 = hir.load v64 : i32;
            v66 = hir.cast v65 : u32;
            v956 = scf.index_switch v66 : u32 
            case 0 {
            ^block119:
                v1000 = arith.constant 1 : u32;
                scf.yield v1000;
            }
            case 1 {
            ^block120:
                v999 = arith.constant 1 : u32;
                scf.yield v999;
            }
            default {
            ^block24:
                v68 = arith.constant 20 : u32;
                v67 = hir.bitcast v54 : u32;
                v69 = arith.add v67, v68 : u32 #[overflow = checked];
                v1033 = arith.constant 4 : u32;
                v71 = arith.mod v69, v1033 : u32;
                hir.assertz v71 #[code = 250];
                v72 = hir.int_to_ptr v69 : ptr<byte, i32>;
                v73 = hir.load v72 : i32;
                v1032 = arith.constant 4 : u32;
                v74 = hir.bitcast v73 : u32;
                v76 = arith.add v74, v1032 : u32 #[overflow = checked];
                v1031 = arith.constant 4 : u32;
                v78 = arith.mod v76, v1031 : u32;
                hir.assertz v78 #[code = 250];
                v79 = hir.int_to_ptr v76 : ptr<byte, felt>;
                v80 = hir.load v79 : felt;
                v81 = hir.bitcast v73 : u32;
                v1030 = arith.constant 4 : u32;
                v83 = arith.mod v81, v1030 : u32;
                hir.assertz v83 #[code = 250];
                v84 = hir.int_to_ptr v81 : ptr<byte, felt>;
                v85 = hir.load v84 : felt;
                v86 = arith.constant 8 : i32;
                v87 = arith.add v54, v86 : i32 #[overflow = wrapping];
                hir.exec @miden:base/note-script@1.0.0/p2id/miden_base_sys::bindings::active_account::get_id(v87)
                v89 = arith.constant 12 : u32;
                v88 = hir.bitcast v54 : u32;
                v90 = arith.add v88, v89 : u32 #[overflow = checked];
                v1029 = arith.constant 4 : u32;
                v92 = arith.mod v90, v1029 : u32;
                hir.assertz v92 #[code = 250];
                v93 = hir.int_to_ptr v90 : ptr<byte, felt>;
                v94 = hir.load v93 : felt;
                v96 = arith.constant 8 : u32;
                v95 = hir.bitcast v54 : u32;
                v97 = arith.add v95, v96 : u32 #[overflow = checked];
                v1028 = arith.constant 4 : u32;
                v99 = arith.mod v97, v1028 : u32;
                hir.assertz v99 #[code = 250];
                v100 = hir.int_to_ptr v97 : ptr<byte, felt>;
                v101 = hir.load v100 : felt;
                v102 = hir.exec @miden:base/note-script@1.0.0/p2id/intrinsics::felt::eq(v101, v85) : i32
                v47 = arith.constant 0 : i32;
                v103 = arith.constant 1 : i32;
                v104 = arith.neq v102, v103 : i1;
                v105 = arith.zext v104 : u32;
                v106 = hir.bitcast v105 : i32;
                v108 = arith.neq v106, v47 : i1;
                v958 = scf.if v108 : u32 {
                ^block118:
                    v908 = arith.constant 1 : u32;
                    scf.yield v908;
                } else {
                ^block25:
                    v109 = hir.exec @miden:base/note-script@1.0.0/p2id/intrinsics::felt::eq(v94, v80) : i32
                    v1026 = arith.constant 0 : i32;
                    v1027 = arith.constant 1 : i32;
                    v111 = arith.neq v109, v1027 : i1;
                    v112 = arith.zext v111 : u32;
                    v113 = hir.bitcast v112 : i32;
                    v115 = arith.neq v113, v1026 : i1;
                    scf.if v115{
                    ^block117:
                        scf.yield ;
                    } else {
                    ^block26:
                        v116 = arith.constant 28 : i32;
                        v117 = arith.add v54, v116 : i32 #[overflow = wrapping];
                        hir.exec @miden:base/note-script@1.0.0/p2id/miden_base_sys::bindings::active_note::get_assets(v117)
                        v119 = arith.constant 36 : u32;
                        v118 = hir.bitcast v54 : u32;
                        v120 = arith.add v118, v119 : u32 #[overflow = checked];
                        v1025 = arith.constant 4 : u32;
                        v122 = arith.mod v120, v1025 : u32;
                        hir.assertz v122 #[code = 250];
                        v123 = hir.int_to_ptr v120 : ptr<byte, i32>;
                        v124 = hir.load v123 : i32;
                        v129 = arith.constant 28 : u32;
                        v128 = hir.bitcast v54 : u32;
                        v130 = arith.add v128, v129 : u32 #[overflow = checked];
                        v1024 = arith.constant 4 : u32;
                        v132 = arith.mod v130, v1024 : u32;
                        hir.assertz v132 #[code = 250];
                        v133 = hir.int_to_ptr v130 : ptr<byte, i32>;
                        v134 = hir.load v133 : i32;
                        v136 = arith.constant 32 : u32;
                        v135 = hir.bitcast v54 : u32;
                        v137 = arith.add v135, v136 : u32 #[overflow = checked];
                        v1023 = arith.constant 4 : u32;
                        v139 = arith.mod v137, v1023 : u32;
                        hir.assertz v139 #[code = 250];
                        v140 = hir.int_to_ptr v137 : ptr<byte, i32>;
                        v141 = hir.load v140 : i32;
                        v1022 = arith.constant 4 : u32;
                        v127 = arith.shl v124, v1022 : i32;
                        v976, v977, v978, v979, v980, v981, v982, v983 = scf.while v127, v141, v54, v141, v134 : i32, i32, i32, i32, i32, i32, i32, i32 {
                        ^block132(v984: i32, v985: i32, v986: i32, v987: i32, v988: i32):
                            v1020 = arith.constant 0 : i32;
                            v1021 = arith.constant 0 : i32;
                            v144 = arith.eq v984, v1021 : i1;
                            v145 = arith.zext v144 : u32;
                            v146 = hir.bitcast v145 : i32;
                            v148 = arith.neq v146, v1020 : i1;
                            v969, v970 = scf.if v148 : i32, i32 {
                            ^block131:
                                v909 = ub.poison i32 : i32;
                                scf.yield v909, v909;
                            } else {
                            ^block30:
                                v150 = hir.bitcast v985 : u32;
                                v1019 = arith.constant 4 : u32;
                                v152 = arith.mod v150, v1019 : u32;
                                hir.assertz v152 #[code = 250];
                                v153 = hir.int_to_ptr v150 : ptr<byte, felt>;
                                v154 = hir.load v153 : felt;
                                v1018 = arith.constant 4 : u32;
                                v155 = hir.bitcast v985 : u32;
                                v157 = arith.add v155, v1018 : u32 #[overflow = checked];
                                v1017 = arith.constant 4 : u32;
                                v159 = arith.mod v157, v1017 : u32;
                                hir.assertz v159 #[code = 250];
                                v160 = hir.int_to_ptr v157 : ptr<byte, felt>;
                                v161 = hir.load v160 : felt;
                                v1016 = arith.constant 8 : u32;
                                v162 = hir.bitcast v985 : u32;
                                v164 = arith.add v162, v1016 : u32 #[overflow = checked];
                                v1015 = arith.constant 4 : u32;
                                v166 = arith.mod v164, v1015 : u32;
                                hir.assertz v166 #[code = 250];
                                v167 = hir.int_to_ptr v164 : ptr<byte, felt>;
                                v168 = hir.load v167 : felt;
                                v1014 = arith.constant 12 : u32;
                                v169 = hir.bitcast v985 : u32;
                                v171 = arith.add v169, v1014 : u32 #[overflow = checked];
                                v1013 = arith.constant 4 : u32;
                                v173 = arith.mod v171, v1013 : u32;
                                hir.assertz v173 #[code = 250];
                                v174 = hir.int_to_ptr v171 : ptr<byte, felt>;
                                v175 = hir.load v174 : felt;
                                hir.exec @miden:base/note-script@1.0.0/p2id/p2id::bindings::miden::basic_wallet::basic_wallet::receive_asset::wit_import7(v154, v161, v168, v175)
                                v1012 = arith.constant 16 : i32;
                                v179 = arith.add v985, v1012 : i32 #[overflow = wrapping];
                                v176 = arith.constant -16 : i32;
                                v177 = arith.add v984, v176 : i32 #[overflow = wrapping];
                                scf.yield v177, v179;
                            };
                            v1008 = ub.poison i32 : i32;
                            v973 = cf.select v148, v1008, v988 : i32;
                            v1009 = ub.poison i32 : i32;
                            v972 = cf.select v148, v1009, v987 : i32;
                            v1010 = ub.poison i32 : i32;
                            v971 = cf.select v148, v1010, v986 : i32;
                            v1011 = arith.constant 1 : u32;
                            v900 = arith.constant 0 : u32;
                            v975 = cf.select v148, v900, v1011 : u32;
                            v953 = arith.trunc v975 : i1;
                            scf.condition v953, v969, v970, v971, v972, v973, v986, v987, v988;
                        } do {
                        ^block133(v989: i32, v990: i32, v991: i32, v992: i32, v993: i32, v994: i32, v995: i32, v996: i32):
                            scf.yield v989, v990, v991, v992, v993;
                        };
                        v183 = arith.constant 44 : u32;
                        v182 = hir.bitcast v981 : u32;
                        v184 = arith.add v182, v183 : u32 #[overflow = checked];
                        v1007 = arith.constant 4 : u32;
                        v186 = arith.mod v184, v1007 : u32;
                        hir.assertz v186 #[code = 250];
                        v187 = hir.int_to_ptr v184 : ptr<byte, i32>;
                        hir.store v187, v982;
                        v190 = arith.constant 40 : u32;
                        v189 = hir.bitcast v981 : u32;
                        v191 = arith.add v189, v190 : u32 #[overflow = checked];
                        v1006 = arith.constant 4 : u32;
                        v193 = arith.mod v191, v1006 : u32;
                        hir.assertz v193 #[code = 250];
                        v194 = hir.int_to_ptr v191 : ptr<byte, i32>;
                        hir.store v194, v983;
                        v1005 = arith.constant 16 : i32;
                        v195 = arith.constant 40 : i32;
                        v196 = arith.add v981, v195 : i32 #[overflow = wrapping];
                        hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::RawVecInner<A>::deallocate(v196, v1005, v1005)
                        v125 = arith.constant 4 : i32;
                        v1004 = arith.constant 16 : i32;
                        v200 = arith.add v981, v1004 : i32 #[overflow = wrapping];
                        hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::RawVecInner<A>::deallocate(v200, v125, v125)
                        v1003 = arith.constant 48 : i32;
                        v204 = arith.add v981, v1003 : i32 #[overflow = wrapping];
                        v205 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
                        v206 = hir.bitcast v205 : ptr<byte, i32>;
                        hir.store v206, v204;
                        scf.yield ;
                    };
                    v1001 = arith.constant 0 : u32;
                    v1002 = arith.constant 1 : u32;
                    v997 = cf.select v115, v1002, v1001 : u32;
                    scf.yield v997;
                };
                scf.yield v958;
            };
            v998 = arith.constant 0 : u32;
            v968 = arith.eq v956, v998 : i1;
            cf.cond_br v968 ^block122, ^block23;
        ^block23:
            ub.unreachable ;
        ^block122:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block31:
            builtin.ret ;
        };

        private builtin.function @wit_bindgen::rt::run_ctors_once() {
        ^block33:
            v208 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
            v209 = hir.bitcast v208 : ptr<byte, i32>;
            v210 = hir.load v209 : i32;
            v211 = arith.constant 1048620 : i32;
            v212 = arith.add v210, v211 : i32 #[overflow = wrapping];
            v213 = hir.bitcast v212 : u32;
            v214 = hir.int_to_ptr v213 : ptr<byte, u8>;
            v215 = hir.load v214 : u8;
            v207 = arith.constant 0 : i32;
            v216 = arith.zext v215 : u32;
            v217 = hir.bitcast v216 : i32;
            v219 = arith.neq v217, v207 : i1;
            scf.if v219{
            ^block35:
                scf.yield ;
            } else {
            ^block36:
                v220 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
                v221 = hir.bitcast v220 : ptr<byte, i32>;
                v222 = hir.load v221 : i32;
                hir.exec @miden:base/note-script@1.0.0/p2id/__wasm_call_ctors()
                v1035 = arith.constant 1 : u8;
                v1037 = arith.constant 1048620 : i32;
                v224 = arith.add v222, v1037 : i32 #[overflow = wrapping];
                v228 = hir.bitcast v224 : u32;
                v229 = hir.int_to_ptr v228 : ptr<byte, u8>;
                hir.store v229, v1035;
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v230: i32, v231: i32, v232: i32) -> i32 {
        ^block37(v230: i32, v231: i32, v232: i32):
            v235 = arith.constant 16 : i32;
            v234 = arith.constant 0 : i32;
            v1039 = arith.constant 16 : u32;
            v237 = hir.bitcast v231 : u32;
            v239 = arith.gt v237, v1039 : i1;
            v240 = arith.zext v239 : u32;
            v241 = hir.bitcast v240 : i32;
            v243 = arith.neq v241, v234 : i1;
            v244 = cf.select v243, v231, v235 : i32;
            v1079 = arith.constant 0 : i32;
            v245 = arith.constant -1 : i32;
            v246 = arith.add v244, v245 : i32 #[overflow = wrapping];
            v247 = arith.band v244, v246 : i32;
            v249 = arith.neq v247, v1079 : i1;
            v1048, v1049 = scf.if v249 : i32, u32 {
            ^block137:
                v1040 = arith.constant 0 : u32;
                v1044 = ub.poison i32 : i32;
                scf.yield v1044, v1040;
            } else {
            ^block40:
                v251 = hir.exec @miden:base/note-script@1.0.0/p2id/core::ptr::alignment::Alignment::max(v231, v244) : i32
                v1078 = arith.constant 0 : i32;
                v250 = arith.constant -2147483648 : i32;
                v252 = arith.sub v250, v251 : i32 #[overflow = wrapping];
                v254 = hir.bitcast v252 : u32;
                v253 = hir.bitcast v232 : u32;
                v255 = arith.gt v253, v254 : i1;
                v256 = arith.zext v255 : u32;
                v257 = hir.bitcast v256 : i32;
                v259 = arith.neq v257, v1078 : i1;
                v1063 = scf.if v259 : i32 {
                ^block136:
                    v1077 = ub.poison i32 : i32;
                    scf.yield v1077;
                } else {
                ^block41:
                    v1075 = arith.constant 0 : i32;
                    v265 = arith.sub v1075, v251 : i32 #[overflow = wrapping];
                    v1076 = arith.constant -1 : i32;
                    v261 = arith.add v232, v251 : i32 #[overflow = wrapping];
                    v263 = arith.add v261, v1076 : i32 #[overflow = wrapping];
                    v266 = arith.band v263, v265 : i32;
                    v267 = hir.bitcast v230 : u32;
                    v268 = arith.constant 4 : u32;
                    v269 = arith.mod v267, v268 : u32;
                    hir.assertz v269 #[code = 250];
                    v270 = hir.int_to_ptr v267 : ptr<byte, i32>;
                    v271 = hir.load v270 : i32;
                    v1074 = arith.constant 0 : i32;
                    v273 = arith.neq v271, v1074 : i1;
                    scf.if v273{
                    ^block135:
                        scf.yield ;
                    } else {
                    ^block43:
                        v274 = hir.exec @miden:base/note-script@1.0.0/p2id/intrinsics::mem::heap_base() : i32
                        v275 = hir.mem_size  : u32;
                        v281 = hir.bitcast v230 : u32;
                        v1073 = arith.constant 4 : u32;
                        v283 = arith.mod v281, v1073 : u32;
                        hir.assertz v283 #[code = 250];
                        v1072 = arith.constant 16 : u32;
                        v276 = hir.bitcast v275 : i32;
                        v279 = arith.shl v276, v1072 : i32;
                        v280 = arith.add v274, v279 : i32 #[overflow = wrapping];
                        v284 = hir.int_to_ptr v281 : ptr<byte, i32>;
                        hir.store v284, v280;
                        scf.yield ;
                    };
                    v287 = hir.bitcast v230 : u32;
                    v1071 = arith.constant 4 : u32;
                    v289 = arith.mod v287, v1071 : u32;
                    hir.assertz v289 #[code = 250];
                    v290 = hir.int_to_ptr v287 : ptr<byte, i32>;
                    v291 = hir.load v290 : i32;
                    v1069 = arith.constant 0 : i32;
                    v1070 = arith.constant -1 : i32;
                    v293 = arith.bxor v291, v1070 : i32;
                    v295 = hir.bitcast v293 : u32;
                    v294 = hir.bitcast v266 : u32;
                    v296 = arith.gt v294, v295 : i1;
                    v297 = arith.zext v296 : u32;
                    v298 = hir.bitcast v297 : i32;
                    v300 = arith.neq v298, v1069 : i1;
                    v1062 = scf.if v300 : i32 {
                    ^block44:
                        v1068 = arith.constant 0 : i32;
                        scf.yield v1068;
                    } else {
                    ^block45:
                        v302 = hir.bitcast v230 : u32;
                        v1067 = arith.constant 4 : u32;
                        v304 = arith.mod v302, v1067 : u32;
                        hir.assertz v304 #[code = 250];
                        v301 = arith.add v291, v266 : i32 #[overflow = wrapping];
                        v305 = hir.int_to_ptr v302 : ptr<byte, i32>;
                        hir.store v305, v301;
                        v307 = arith.add v291, v251 : i32 #[overflow = wrapping];
                        scf.yield v307;
                    };
                    scf.yield v1062;
                };
                v1045 = arith.constant 1 : u32;
                v1066 = arith.constant 0 : u32;
                v1064 = cf.select v259, v1066, v1045 : u32;
                scf.yield v1063, v1064;
            };
            v1065 = arith.constant 0 : u32;
            v1061 = arith.eq v1049, v1065 : i1;
            cf.cond_br v1061 ^block39, ^block139(v1048);
        ^block39:
            ub.unreachable ;
        ^block139(v1041: i32):
            builtin.ret v1041;
        };

        private builtin.function @intrinsics::mem::heap_base() -> i32 {
        ^block46:
            v310 = hir.exec @intrinsics/mem/heap_base() : i32
            builtin.ret v310;
        };

        private builtin.function @alloc::vec::Vec<T>::with_capacity(v312: i32) {
        ^block50(v312: i32):
            v315 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v316 = hir.bitcast v315 : ptr<byte, i32>;
            v317 = hir.load v316 : i32;
            v318 = arith.constant 16 : i32;
            v319 = arith.sub v317, v318 : i32 #[overflow = wrapping];
            v320 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v321 = hir.bitcast v320 : ptr<byte, i32>;
            hir.store v321, v319;
            v1084 = arith.constant 16 : i32;
            v322 = arith.constant 8 : i32;
            v323 = arith.add v319, v322 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::RawVecInner<A>::with_capacity_in(v323, v1084, v1084)
            v327 = arith.constant 8 : u32;
            v326 = hir.bitcast v319 : u32;
            v328 = arith.add v326, v327 : u32 #[overflow = checked];
            v1083 = arith.constant 8 : u32;
            v330 = arith.mod v328, v1083 : u32;
            hir.assertz v330 #[code = 250];
            v331 = hir.int_to_ptr v328 : ptr<byte, i64>;
            v332 = hir.load v331 : i64;
            v1082 = arith.constant 8 : u32;
            v334 = hir.bitcast v312 : u32;
            v336 = arith.add v334, v1082 : u32 #[overflow = checked];
            v337 = arith.constant 4 : u32;
            v338 = arith.mod v336, v337 : u32;
            hir.assertz v338 #[code = 250];
            v313 = arith.constant 0 : i32;
            v339 = hir.int_to_ptr v336 : ptr<byte, i32>;
            hir.store v339, v313;
            v340 = hir.bitcast v312 : u32;
            v1081 = arith.constant 4 : u32;
            v342 = arith.mod v340, v1081 : u32;
            hir.assertz v342 #[code = 250];
            v343 = hir.int_to_ptr v340 : ptr<byte, i64>;
            hir.store v343, v332;
            v1080 = arith.constant 16 : i32;
            v345 = arith.add v319, v1080 : i32 #[overflow = wrapping];
            v346 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v347 = hir.bitcast v346 : ptr<byte, i32>;
            hir.store v347, v345;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::with_capacity_in(v348: i32, v349: i32, v350: i32) {
        ^block52(v348: i32, v349: i32, v350: i32):
            v352 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v353 = hir.bitcast v352 : ptr<byte, i32>;
            v354 = hir.load v353 : i32;
            v355 = arith.constant 16 : i32;
            v356 = arith.sub v354, v355 : i32 #[overflow = wrapping];
            v357 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v358 = hir.bitcast v357 : ptr<byte, i32>;
            hir.store v358, v356;
            v351 = arith.constant 0 : i32;
            v361 = arith.constant 256 : i32;
            v359 = arith.constant 4 : i32;
            v360 = arith.add v356, v359 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::RawVecInner<A>::try_allocate_in(v360, v361, v351, v349, v350)
            v364 = arith.constant 8 : u32;
            v363 = hir.bitcast v356 : u32;
            v365 = arith.add v363, v364 : u32 #[overflow = checked];
            v366 = arith.constant 4 : u32;
            v367 = arith.mod v365, v366 : u32;
            hir.assertz v367 #[code = 250];
            v368 = hir.int_to_ptr v365 : ptr<byte, i32>;
            v369 = hir.load v368 : i32;
            v1095 = arith.constant 4 : u32;
            v370 = hir.bitcast v356 : u32;
            v372 = arith.add v370, v1095 : u32 #[overflow = checked];
            v1094 = arith.constant 4 : u32;
            v374 = arith.mod v372, v1094 : u32;
            hir.assertz v374 #[code = 250];
            v375 = hir.int_to_ptr v372 : ptr<byte, i32>;
            v376 = hir.load v375 : i32;
            v1093 = arith.constant 0 : i32;
            v377 = arith.constant 1 : i32;
            v378 = arith.neq v376, v377 : i1;
            v379 = arith.zext v378 : u32;
            v380 = hir.bitcast v379 : i32;
            v382 = arith.neq v380, v1093 : i1;
            cf.cond_br v382 ^block54, ^block55;
        ^block54:
            v396 = arith.constant 12 : u32;
            v395 = hir.bitcast v356 : u32;
            v397 = arith.add v395, v396 : u32 #[overflow = checked];
            v1092 = arith.constant 4 : u32;
            v399 = arith.mod v397, v1092 : u32;
            hir.assertz v399 #[code = 250];
            v400 = hir.int_to_ptr v397 : ptr<byte, i32>;
            v401 = hir.load v400 : i32;
            v1091 = arith.constant 4 : u32;
            v402 = hir.bitcast v348 : u32;
            v404 = arith.add v402, v1091 : u32 #[overflow = checked];
            v1090 = arith.constant 4 : u32;
            v406 = arith.mod v404, v1090 : u32;
            hir.assertz v406 #[code = 250];
            v407 = hir.int_to_ptr v404 : ptr<byte, i32>;
            hir.store v407, v401;
            v408 = hir.bitcast v348 : u32;
            v1089 = arith.constant 4 : u32;
            v410 = arith.mod v408, v1089 : u32;
            hir.assertz v410 #[code = 250];
            v411 = hir.int_to_ptr v408 : ptr<byte, i32>;
            hir.store v411, v369;
            v1088 = arith.constant 16 : i32;
            v413 = arith.add v356, v1088 : i32 #[overflow = wrapping];
            v414 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v415 = hir.bitcast v414 : ptr<byte, i32>;
            hir.store v415, v413;
            builtin.ret ;
        ^block55:
            v383 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/GOT.data.internal.__memory_base : ptr<byte, u8>
            v384 = hir.bitcast v383 : ptr<byte, i32>;
            v385 = hir.load v384 : i32;
            v1087 = arith.constant 12 : u32;
            v386 = hir.bitcast v356 : u32;
            v388 = arith.add v386, v1087 : u32 #[overflow = checked];
            v1086 = arith.constant 4 : u32;
            v390 = arith.mod v388, v1086 : u32;
            hir.assertz v390 #[code = 250];
            v391 = hir.int_to_ptr v388 : ptr<byte, i32>;
            v392 = hir.load v391 : i32;
            v393 = arith.constant 1048600 : i32;
            v394 = arith.add v385, v393 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::handle_error(v369, v392, v394)
            ub.unreachable ;
        };

        private builtin.function @miden_base_sys::bindings::active_account::get_id(v416: i32) {
        ^block56(v416: i32):
            v418 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v419 = hir.bitcast v418 : ptr<byte, i32>;
            v420 = hir.load v419 : i32;
            v421 = arith.constant 16 : i32;
            v422 = arith.sub v420, v421 : i32 #[overflow = wrapping];
            v423 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v424 = hir.bitcast v423 : ptr<byte, i32>;
            hir.store v424, v422;
            v425 = arith.constant 8 : i32;
            v426 = arith.add v422, v425 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/miden::active_account::get_id(v426)
            v428 = arith.constant 8 : u32;
            v427 = hir.bitcast v422 : u32;
            v429 = arith.add v427, v428 : u32 #[overflow = checked];
            v430 = arith.constant 4 : u32;
            v431 = arith.mod v429, v430 : u32;
            hir.assertz v431 #[code = 250];
            v432 = hir.int_to_ptr v429 : ptr<byte, i64>;
            v433 = hir.load v432 : i64;
            v434 = hir.bitcast v416 : u32;
            v1097 = arith.constant 8 : u32;
            v436 = arith.mod v434, v1097 : u32;
            hir.assertz v436 #[code = 250];
            v437 = hir.int_to_ptr v434 : ptr<byte, i64>;
            hir.store v437, v433;
            v1096 = arith.constant 16 : i32;
            v439 = arith.add v422, v1096 : i32 #[overflow = wrapping];
            v440 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v441 = hir.bitcast v440 : ptr<byte, i32>;
            hir.store v441, v439;
            builtin.ret ;
        };

        private builtin.function @miden_base_sys::bindings::active_note::get_inputs(v442: i32) {
        ^block58(v442: i32):
            v444 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v445 = hir.bitcast v444 : ptr<byte, i32>;
            v446 = hir.load v445 : i32;
            v447 = arith.constant 16 : i32;
            v448 = arith.sub v446, v447 : i32 #[overflow = wrapping];
            v449 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v450 = hir.bitcast v449 : ptr<byte, i32>;
            hir.store v450, v448;
            v453 = arith.constant 4 : i32;
            v451 = arith.constant 8 : i32;
            v452 = arith.add v448, v451 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::RawVecInner<A>::with_capacity_in(v452, v453, v453)
            v456 = arith.constant 8 : u32;
            v455 = hir.bitcast v448 : u32;
            v457 = arith.add v455, v456 : u32 #[overflow = checked];
            v458 = arith.constant 4 : u32;
            v459 = arith.mod v457, v458 : u32;
            hir.assertz v459 #[code = 250];
            v460 = hir.int_to_ptr v457 : ptr<byte, i32>;
            v461 = hir.load v460 : i32;
            v463 = arith.constant 12 : u32;
            v462 = hir.bitcast v448 : u32;
            v464 = arith.add v462, v463 : u32 #[overflow = checked];
            v1105 = arith.constant 4 : u32;
            v466 = arith.mod v464, v1105 : u32;
            hir.assertz v466 #[code = 250];
            v467 = hir.int_to_ptr v464 : ptr<byte, i32>;
            v468 = hir.load v467 : i32;
            v1098 = arith.constant 2 : u32;
            v470 = hir.bitcast v468 : u32;
            v472 = arith.shr v470, v1098 : u32;
            v473 = hir.bitcast v472 : i32;
            v474 = hir.exec @miden:base/note-script@1.0.0/p2id/miden::active_note::get_inputs(v473) : i32
            v1104 = arith.constant 8 : u32;
            v475 = hir.bitcast v442 : u32;
            v477 = arith.add v475, v1104 : u32 #[overflow = checked];
            v1103 = arith.constant 4 : u32;
            v479 = arith.mod v477, v1103 : u32;
            hir.assertz v479 #[code = 250];
            v480 = hir.int_to_ptr v477 : ptr<byte, i32>;
            hir.store v480, v474;
            v1102 = arith.constant 4 : u32;
            v481 = hir.bitcast v442 : u32;
            v483 = arith.add v481, v1102 : u32 #[overflow = checked];
            v1101 = arith.constant 4 : u32;
            v485 = arith.mod v483, v1101 : u32;
            hir.assertz v485 #[code = 250];
            v486 = hir.int_to_ptr v483 : ptr<byte, i32>;
            hir.store v486, v468;
            v487 = hir.bitcast v442 : u32;
            v1100 = arith.constant 4 : u32;
            v489 = arith.mod v487, v1100 : u32;
            hir.assertz v489 #[code = 250];
            v490 = hir.int_to_ptr v487 : ptr<byte, i32>;
            hir.store v490, v461;
            v1099 = arith.constant 16 : i32;
            v492 = arith.add v448, v1099 : i32 #[overflow = wrapping];
            v493 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v494 = hir.bitcast v493 : ptr<byte, i32>;
            hir.store v494, v492;
            builtin.ret ;
        };

        private builtin.function @miden_base_sys::bindings::active_note::get_assets(v495: i32) {
        ^block60(v495: i32):
            v497 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v498 = hir.bitcast v497 : ptr<byte, i32>;
            v499 = hir.load v498 : i32;
            v500 = arith.constant 16 : i32;
            v501 = arith.sub v499, v500 : i32 #[overflow = wrapping];
            v502 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v503 = hir.bitcast v502 : ptr<byte, i32>;
            hir.store v503, v501;
            v504 = arith.constant 4 : i32;
            v505 = arith.add v501, v504 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::vec::Vec<T>::with_capacity(v505)
            v509 = arith.constant 8 : u32;
            v508 = hir.bitcast v501 : u32;
            v510 = arith.add v508, v509 : u32 #[overflow = checked];
            v511 = arith.constant 4 : u32;
            v512 = arith.mod v510, v511 : u32;
            hir.assertz v512 #[code = 250];
            v513 = hir.int_to_ptr v510 : ptr<byte, i32>;
            v514 = hir.load v513 : i32;
            v1106 = arith.constant 2 : u32;
            v516 = hir.bitcast v514 : u32;
            v518 = arith.shr v516, v1106 : u32;
            v519 = hir.bitcast v518 : i32;
            v520 = hir.exec @miden:base/note-script@1.0.0/p2id/miden::active_note::get_assets(v519) : i32
            v506 = arith.constant 8 : i32;
            v507 = arith.add v495, v506 : i32 #[overflow = wrapping];
            v521 = hir.bitcast v507 : u32;
            v1111 = arith.constant 4 : u32;
            v523 = arith.mod v521, v1111 : u32;
            hir.assertz v523 #[code = 250];
            v524 = hir.int_to_ptr v521 : ptr<byte, i32>;
            hir.store v524, v520;
            v1110 = arith.constant 4 : u32;
            v525 = hir.bitcast v501 : u32;
            v527 = arith.add v525, v1110 : u32 #[overflow = checked];
            v1109 = arith.constant 4 : u32;
            v529 = arith.mod v527, v1109 : u32;
            hir.assertz v529 #[code = 250];
            v530 = hir.int_to_ptr v527 : ptr<byte, i64>;
            v531 = hir.load v530 : i64;
            v532 = hir.bitcast v495 : u32;
            v1108 = arith.constant 4 : u32;
            v534 = arith.mod v532, v1108 : u32;
            hir.assertz v534 #[code = 250];
            v535 = hir.int_to_ptr v532 : ptr<byte, i64>;
            hir.store v535, v531;
            v1107 = arith.constant 16 : i32;
            v537 = arith.add v501, v1107 : i32 #[overflow = wrapping];
            v538 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v539 = hir.bitcast v538 : ptr<byte, i32>;
            hir.store v539, v537;
            builtin.ret ;
        };

        private builtin.function @intrinsics::felt::eq(v540: felt, v541: felt) -> i32 {
        ^block62(v540: felt, v541: felt):
            v542 = arith.eq v540, v541 : i1;
            v543 = hir.cast v542 : i32;
            builtin.ret v543;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v545: i32, v546: i32, v547: i32) {
        ^block64(v545: i32, v546: i32, v547: i32):
            v549 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v550 = hir.bitcast v549 : ptr<byte, i32>;
            v551 = hir.load v550 : i32;
            v552 = arith.constant 16 : i32;
            v553 = arith.sub v551, v552 : i32 #[overflow = wrapping];
            v554 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v555 = hir.bitcast v554 : ptr<byte, i32>;
            hir.store v555, v553;
            v556 = arith.constant 4 : i32;
            v557 = arith.add v553, v556 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::raw_vec::RawVecInner<A>::current_memory(v557, v545, v546, v547)
            v559 = arith.constant 8 : u32;
            v558 = hir.bitcast v553 : u32;
            v560 = arith.add v558, v559 : u32 #[overflow = checked];
            v561 = arith.constant 4 : u32;
            v562 = arith.mod v560, v561 : u32;
            hir.assertz v562 #[code = 250];
            v563 = hir.int_to_ptr v560 : ptr<byte, i32>;
            v564 = hir.load v563 : i32;
            v1118 = arith.constant 0 : i32;
            v548 = arith.constant 0 : i32;
            v566 = arith.eq v564, v548 : i1;
            v567 = arith.zext v566 : u32;
            v568 = hir.bitcast v567 : i32;
            v570 = arith.neq v568, v1118 : i1;
            scf.if v570{
            ^block145:
                scf.yield ;
            } else {
            ^block67:
                v1117 = arith.constant 4 : u32;
                v571 = hir.bitcast v553 : u32;
                v573 = arith.add v571, v1117 : u32 #[overflow = checked];
                v1116 = arith.constant 4 : u32;
                v575 = arith.mod v573, v1116 : u32;
                hir.assertz v575 #[code = 250];
                v576 = hir.int_to_ptr v573 : ptr<byte, i32>;
                v577 = hir.load v576 : i32;
                v579 = arith.constant 12 : u32;
                v578 = hir.bitcast v553 : u32;
                v580 = arith.add v578, v579 : u32 #[overflow = checked];
                v1115 = arith.constant 4 : u32;
                v582 = arith.mod v580, v1115 : u32;
                hir.assertz v582 #[code = 250];
                v583 = hir.int_to_ptr v580 : ptr<byte, i32>;
                v584 = hir.load v583 : i32;
                hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v577, v564, v584)
                scf.yield ;
            };
            v1114 = arith.constant 16 : i32;
            v587 = arith.add v553, v1114 : i32 #[overflow = wrapping];
            v588 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v589 = hir.bitcast v588 : ptr<byte, i32>;
            hir.store v589, v587;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::try_allocate_in(v590: i32, v591: i32, v592: i32, v593: i32, v594: i32) {
        ^block68(v590: i32, v591: i32, v592: i32, v593: i32, v594: i32):
            v597 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v598 = hir.bitcast v597 : ptr<byte, i32>;
            v599 = hir.load v598 : i32;
            v600 = arith.constant 16 : i32;
            v601 = arith.sub v599, v600 : i32 #[overflow = wrapping];
            v602 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v603 = hir.bitcast v602 : ptr<byte, i32>;
            hir.store v603, v601;
            v613 = hir.bitcast v591 : u32;
            v614 = arith.zext v613 : u64;
            v615 = hir.bitcast v614 : i64;
            v595 = arith.constant 0 : i32;
            v608 = arith.sub v595, v593 : i32 #[overflow = wrapping];
            v605 = arith.constant -1 : i32;
            v604 = arith.add v593, v594 : i32 #[overflow = wrapping];
            v606 = arith.add v604, v605 : i32 #[overflow = wrapping];
            v609 = arith.band v606, v608 : i32;
            v610 = hir.bitcast v609 : u32;
            v611 = arith.zext v610 : u64;
            v612 = hir.bitcast v611 : i64;
            v616 = arith.mul v612, v615 : i64 #[overflow = wrapping];
            v1222 = arith.constant 0 : i32;
            v617 = arith.constant 32 : i64;
            v619 = hir.cast v617 : u32;
            v618 = hir.bitcast v616 : u64;
            v620 = arith.shr v618, v619 : u64;
            v621 = hir.bitcast v620 : i64;
            v622 = arith.trunc v621 : i32;
            v624 = arith.neq v622, v1222 : i1;
            v1134, v1135, v1136, v1137, v1138, v1139 = scf.if v624 : i32, i32, i32, i32, i32, u32 {
            ^block147:
                v1119 = arith.constant 0 : u32;
                v1126 = ub.poison i32 : i32;
                scf.yield v590, v601, v1126, v1126, v1126, v1119;
            } else {
            ^block73:
                v625 = arith.trunc v616 : i32;
                v1221 = arith.constant 0 : i32;
                v626 = arith.constant -2147483648 : i32;
                v627 = arith.sub v626, v593 : i32 #[overflow = wrapping];
                v629 = hir.bitcast v627 : u32;
                v628 = hir.bitcast v625 : u32;
                v630 = arith.lte v628, v629 : i1;
                v631 = arith.zext v630 : u32;
                v632 = hir.bitcast v631 : i32;
                v634 = arith.neq v632, v1221 : i1;
                v1182 = scf.if v634 : i32 {
                ^block71:
                    v1220 = arith.constant 0 : i32;
                    v645 = arith.neq v625, v1220 : i1;
                    v1181 = scf.if v645 : i32 {
                    ^block75:
                        v1219 = arith.constant 0 : i32;
                        v661 = arith.neq v592, v1219 : i1;
                        v1180 = scf.if v661 : i32 {
                        ^block78:
                            v643 = arith.constant 1 : i32;
                            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::alloc::Global::alloc_impl(v601, v593, v625, v643)
                            v672 = hir.bitcast v601 : u32;
                            v717 = arith.constant 4 : u32;
                            v674 = arith.mod v672, v717 : u32;
                            hir.assertz v674 #[code = 250];
                            v675 = hir.int_to_ptr v672 : ptr<byte, i32>;
                            v676 = hir.load v675 : i32;
                            scf.yield v676;
                        } else {
                        ^block79:
                            v662 = arith.constant 8 : i32;
                            v663 = arith.add v601, v662 : i32 #[overflow = wrapping];
                            hir.exec @miden:base/note-script@1.0.0/p2id/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v663, v593, v625)
                            v647 = arith.constant 8 : u32;
                            v664 = hir.bitcast v601 : u32;
                            v666 = arith.add v664, v647 : u32 #[overflow = checked];
                            v1218 = arith.constant 4 : u32;
                            v668 = arith.mod v666, v1218 : u32;
                            hir.assertz v668 #[code = 250];
                            v669 = hir.int_to_ptr v666 : ptr<byte, i32>;
                            v670 = hir.load v669 : i32;
                            scf.yield v670;
                        };
                        v1216 = arith.constant 0 : i32;
                        v1217 = arith.constant 0 : i32;
                        v679 = arith.eq v1180, v1217 : i1;
                        v680 = arith.zext v679 : u32;
                        v681 = hir.bitcast v680 : i32;
                        v683 = arith.neq v681, v1216 : i1;
                        scf.if v683{
                        ^block80:
                            v1215 = arith.constant 8 : u32;
                            v700 = hir.bitcast v590 : u32;
                            v702 = arith.add v700, v1215 : u32 #[overflow = checked];
                            v1214 = arith.constant 4 : u32;
                            v704 = arith.mod v702, v1214 : u32;
                            hir.assertz v704 #[code = 250];
                            v705 = hir.int_to_ptr v702 : ptr<byte, i32>;
                            hir.store v705, v625;
                            v1213 = arith.constant 4 : u32;
                            v707 = hir.bitcast v590 : u32;
                            v709 = arith.add v707, v1213 : u32 #[overflow = checked];
                            v1212 = arith.constant 4 : u32;
                            v711 = arith.mod v709, v1212 : u32;
                            hir.assertz v711 #[code = 250];
                            v712 = hir.int_to_ptr v709 : ptr<byte, i32>;
                            hir.store v712, v593;
                            scf.yield ;
                        } else {
                        ^block81:
                            v1211 = arith.constant 8 : u32;
                            v685 = hir.bitcast v590 : u32;
                            v687 = arith.add v685, v1211 : u32 #[overflow = checked];
                            v1210 = arith.constant 4 : u32;
                            v689 = arith.mod v687, v1210 : u32;
                            hir.assertz v689 #[code = 250];
                            v690 = hir.int_to_ptr v687 : ptr<byte, i32>;
                            hir.store v690, v1180;
                            v1209 = arith.constant 4 : u32;
                            v692 = hir.bitcast v590 : u32;
                            v694 = arith.add v692, v1209 : u32 #[overflow = checked];
                            v1208 = arith.constant 4 : u32;
                            v696 = arith.mod v694, v1208 : u32;
                            hir.assertz v696 #[code = 250];
                            v697 = hir.int_to_ptr v694 : ptr<byte, i32>;
                            hir.store v697, v591;
                            scf.yield ;
                        };
                        v1206 = arith.constant 0 : i32;
                        v1207 = arith.constant 1 : i32;
                        v1179 = cf.select v683, v1207, v1206 : i32;
                        scf.yield v1179;
                    } else {
                    ^block76:
                        v1205 = arith.constant 8 : u32;
                        v646 = hir.bitcast v590 : u32;
                        v648 = arith.add v646, v1205 : u32 #[overflow = checked];
                        v1204 = arith.constant 4 : u32;
                        v650 = arith.mod v648, v1204 : u32;
                        hir.assertz v650 #[code = 250];
                        v651 = hir.int_to_ptr v648 : ptr<byte, i32>;
                        hir.store v651, v593;
                        v1203 = arith.constant 4 : u32;
                        v654 = hir.bitcast v590 : u32;
                        v656 = arith.add v654, v1203 : u32 #[overflow = checked];
                        v1202 = arith.constant 4 : u32;
                        v658 = arith.mod v656, v1202 : u32;
                        hir.assertz v658 #[code = 250];
                        v1201 = arith.constant 0 : i32;
                        v659 = hir.int_to_ptr v656 : ptr<byte, i32>;
                        hir.store v659, v1201;
                        v1200 = arith.constant 0 : i32;
                        scf.yield v1200;
                    };
                    scf.yield v1181;
                } else {
                ^block74:
                    v1199 = ub.poison i32 : i32;
                    scf.yield v1199;
                };
                v1194 = arith.constant 0 : u32;
                v1127 = arith.constant 1 : u32;
                v1187 = cf.select v634, v1127, v1194 : u32;
                v1195 = ub.poison i32 : i32;
                v1186 = cf.select v634, v601, v1195 : i32;
                v1196 = ub.poison i32 : i32;
                v1185 = cf.select v634, v590, v1196 : i32;
                v1197 = ub.poison i32 : i32;
                v1184 = cf.select v634, v1197, v601 : i32;
                v1198 = ub.poison i32 : i32;
                v1183 = cf.select v634, v1198, v590 : i32;
                scf.yield v1183, v1184, v1185, v1182, v1186, v1187;
            };
            v1140, v1141, v1142 = scf.index_switch v1139 : i32, i32, i32 
            case 0 {
            ^block72:
                v1193 = arith.constant 4 : u32;
                v637 = hir.bitcast v1134 : u32;
                v639 = arith.add v637, v1193 : u32 #[overflow = checked];
                v1192 = arith.constant 4 : u32;
                v641 = arith.mod v639, v1192 : u32;
                hir.assertz v641 #[code = 250];
                v1191 = arith.constant 0 : i32;
                v642 = hir.int_to_ptr v639 : ptr<byte, i32>;
                hir.store v642, v1191;
                v1190 = arith.constant 1 : i32;
                scf.yield v1134, v1190, v1135;
            }
            default {
            ^block151:
                scf.yield v1136, v1137, v1138;
            };
            v716 = hir.bitcast v1140 : u32;
            v1189 = arith.constant 4 : u32;
            v718 = arith.mod v716, v1189 : u32;
            hir.assertz v718 #[code = 250];
            v719 = hir.int_to_ptr v716 : ptr<byte, i32>;
            hir.store v719, v1141;
            v1188 = arith.constant 16 : i32;
            v724 = arith.add v1142, v1188 : i32 #[overflow = wrapping];
            v725 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v726 = hir.bitcast v725 : ptr<byte, i32>;
            hir.store v726, v724;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v727: i32, v728: i32, v729: i32) {
        ^block82(v727: i32, v728: i32, v729: i32):
            v731 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v732 = hir.bitcast v731 : ptr<byte, i32>;
            v733 = hir.load v732 : i32;
            v734 = arith.constant 16 : i32;
            v735 = arith.sub v733, v734 : i32 #[overflow = wrapping];
            v736 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v737 = hir.bitcast v736 : ptr<byte, i32>;
            hir.store v737, v735;
            v730 = arith.constant 0 : i32;
            v738 = arith.constant 8 : i32;
            v739 = arith.add v735, v738 : i32 #[overflow = wrapping];
            hir.exec @miden:base/note-script@1.0.0/p2id/alloc::alloc::Global::alloc_impl(v739, v728, v729, v730)
            v742 = arith.constant 12 : u32;
            v741 = hir.bitcast v735 : u32;
            v743 = arith.add v741, v742 : u32 #[overflow = checked];
            v744 = arith.constant 4 : u32;
            v745 = arith.mod v743, v744 : u32;
            hir.assertz v745 #[code = 250];
            v746 = hir.int_to_ptr v743 : ptr<byte, i32>;
            v747 = hir.load v746 : i32;
            v749 = arith.constant 8 : u32;
            v748 = hir.bitcast v735 : u32;
            v750 = arith.add v748, v749 : u32 #[overflow = checked];
            v1227 = arith.constant 4 : u32;
            v752 = arith.mod v750, v1227 : u32;
            hir.assertz v752 #[code = 250];
            v753 = hir.int_to_ptr v750 : ptr<byte, i32>;
            v754 = hir.load v753 : i32;
            v755 = hir.bitcast v727 : u32;
            v1226 = arith.constant 4 : u32;
            v757 = arith.mod v755, v1226 : u32;
            hir.assertz v757 #[code = 250];
            v758 = hir.int_to_ptr v755 : ptr<byte, i32>;
            hir.store v758, v754;
            v1225 = arith.constant 4 : u32;
            v759 = hir.bitcast v727 : u32;
            v761 = arith.add v759, v1225 : u32 #[overflow = checked];
            v1224 = arith.constant 4 : u32;
            v763 = arith.mod v761, v1224 : u32;
            hir.assertz v763 #[code = 250];
            v764 = hir.int_to_ptr v761 : ptr<byte, i32>;
            hir.store v764, v747;
            v1223 = arith.constant 16 : i32;
            v766 = arith.add v735, v1223 : i32 #[overflow = wrapping];
            v767 = builtin.global_symbol @miden:base/note-script@1.0.0/p2id/__stack_pointer : ptr<byte, u8>
            v768 = hir.bitcast v767 : ptr<byte, i32>;
            hir.store v768, v766;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v769: i32, v770: i32, v771: i32, v772: i32) {
        ^block84(v769: i32, v770: i32, v771: i32, v772: i32):
            v1243 = arith.constant 0 : i32;
            v773 = arith.constant 0 : i32;
            v774 = arith.eq v771, v773 : i1;
            v775 = arith.zext v774 : u32;
            v776 = hir.bitcast v775 : i32;
            v778 = arith.neq v776, v1243 : i1;
            v1239 = scf.if v778 : i32 {
            ^block154:
                scf.yield v770;
            } else {
            ^block87:
                hir.exec @miden:base/note-script@1.0.0/p2id/__rustc::__rust_no_alloc_shim_is_unstable_v2()
                v1242 = arith.constant 0 : i32;
                v780 = arith.neq v772, v1242 : i1;
                v1238 = scf.if v780 : i32 {
                ^block88:
                    v782 = hir.exec @miden:base/note-script@1.0.0/p2id/__rustc::__rust_alloc_zeroed(v771, v770) : i32
                    scf.yield v782;
                } else {
                ^block89:
                    v781 = hir.exec @miden:base/note-script@1.0.0/p2id/__rustc::__rust_alloc(v771, v770) : i32
                    scf.yield v781;
                };
                scf.yield v1238;
            };
            v786 = arith.constant 4 : u32;
            v785 = hir.bitcast v769 : u32;
            v787 = arith.add v785, v786 : u32 #[overflow = checked];
            v1241 = arith.constant 4 : u32;
            v789 = arith.mod v787, v1241 : u32;
            hir.assertz v789 #[code = 250];
            v790 = hir.int_to_ptr v787 : ptr<byte, i32>;
            hir.store v790, v771;
            v792 = hir.bitcast v769 : u32;
            v1240 = arith.constant 4 : u32;
            v794 = arith.mod v792, v1240 : u32;
            hir.assertz v794 #[code = 250];
            v795 = hir.int_to_ptr v792 : ptr<byte, i32>;
            hir.store v795, v1239;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v796: i32, v797: i32, v798: i32, v799: i32) {
        ^block90(v796: i32, v797: i32, v798: i32, v799: i32):
            v1269 = arith.constant 0 : i32;
            v800 = arith.constant 0 : i32;
            v804 = arith.eq v799, v800 : i1;
            v805 = arith.zext v804 : u32;
            v806 = hir.bitcast v805 : i32;
            v808 = arith.neq v806, v1269 : i1;
            v1256, v1257 = scf.if v808 : i32, i32 {
            ^block158:
                v1268 = arith.constant 0 : i32;
                v802 = arith.constant 4 : i32;
                scf.yield v802, v1268;
            } else {
            ^block93:
                v809 = hir.bitcast v797 : u32;
                v844 = arith.constant 4 : u32;
                v811 = arith.mod v809, v844 : u32;
                hir.assertz v811 #[code = 250];
                v812 = hir.int_to_ptr v809 : ptr<byte, i32>;
                v813 = hir.load v812 : i32;
                v1266 = arith.constant 0 : i32;
                v1267 = arith.constant 0 : i32;
                v815 = arith.eq v813, v1267 : i1;
                v816 = arith.zext v815 : u32;
                v817 = hir.bitcast v816 : i32;
                v819 = arith.neq v817, v1266 : i1;
                v1254 = scf.if v819 : i32 {
                ^block157:
                    v1265 = arith.constant 0 : i32;
                    scf.yield v1265;
                } else {
                ^block94:
                    v1264 = arith.constant 4 : u32;
                    v820 = hir.bitcast v796 : u32;
                    v822 = arith.add v820, v1264 : u32 #[overflow = checked];
                    v1263 = arith.constant 4 : u32;
                    v824 = arith.mod v822, v1263 : u32;
                    hir.assertz v824 #[code = 250];
                    v825 = hir.int_to_ptr v822 : ptr<byte, i32>;
                    hir.store v825, v798;
                    v1262 = arith.constant 4 : u32;
                    v826 = hir.bitcast v797 : u32;
                    v828 = arith.add v826, v1262 : u32 #[overflow = checked];
                    v1261 = arith.constant 4 : u32;
                    v830 = arith.mod v828, v1261 : u32;
                    hir.assertz v830 #[code = 250];
                    v831 = hir.int_to_ptr v828 : ptr<byte, i32>;
                    v832 = hir.load v831 : i32;
                    v833 = hir.bitcast v796 : u32;
                    v1260 = arith.constant 4 : u32;
                    v835 = arith.mod v833, v1260 : u32;
                    hir.assertz v835 #[code = 250];
                    v836 = hir.int_to_ptr v833 : ptr<byte, i32>;
                    hir.store v836, v832;
                    v837 = arith.mul v813, v799 : i32 #[overflow = wrapping];
                    scf.yield v837;
                };
                v838 = arith.constant 8 : i32;
                v1259 = arith.constant 4 : i32;
                v1255 = cf.select v819, v1259, v838 : i32;
                scf.yield v1255, v1254;
            };
            v841 = arith.add v796, v1256 : i32 #[overflow = wrapping];
            v843 = hir.bitcast v841 : u32;
            v1258 = arith.constant 4 : u32;
            v845 = arith.mod v843, v1258 : u32;
            hir.assertz v845 #[code = 250];
            v846 = hir.int_to_ptr v843 : ptr<byte, i32>;
            hir.store v846, v1257;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v847: i32, v848: i32, v849: i32) {
        ^block95(v847: i32, v848: i32, v849: i32):
            v1271 = arith.constant 0 : i32;
            v850 = arith.constant 0 : i32;
            v851 = arith.eq v849, v850 : i1;
            v852 = arith.zext v851 : u32;
            v853 = hir.bitcast v852 : i32;
            v855 = arith.neq v853, v1271 : i1;
            scf.if v855{
            ^block97:
                scf.yield ;
            } else {
            ^block98:
                hir.exec @miden:base/note-script@1.0.0/p2id/__rustc::__rust_dealloc(v847, v849, v848)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v856: i32, v857: i32, v858: i32) {
        ^block99(v856: i32, v857: i32, v858: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v859: i32, v860: i32) -> i32 {
        ^block101(v859: i32, v860: i32):
            v867 = arith.constant 0 : i32;
            v863 = hir.bitcast v860 : u32;
            v862 = hir.bitcast v859 : u32;
            v864 = arith.gt v862, v863 : i1;
            v865 = arith.zext v864 : u32;
            v866 = hir.bitcast v865 : i32;
            v868 = arith.neq v866, v867 : i1;
            v869 = cf.select v868, v859, v860 : i32;
            builtin.ret v869;
        };

        private builtin.function @miden::active_account::get_id(v870: i32) {
        ^block103(v870: i32):
            v871, v872 = hir.exec @miden/active_account/get_id() : felt, felt
            v873 = hir.bitcast v870 : u32;
            v874 = hir.int_to_ptr v873 : ptr<byte, felt>;
            hir.store v874, v871;
            v875 = arith.constant 4 : u32;
            v876 = arith.add v873, v875 : u32 #[overflow = checked];
            v877 = hir.int_to_ptr v876 : ptr<byte, felt>;
            hir.store v877, v872;
            builtin.ret ;
        };

        private builtin.function @miden::active_note::get_inputs(v878: i32) -> i32 {
        ^block107(v878: i32):
            v879, v880 = hir.exec @miden/active_note/get_inputs(v878) : i32, i32
            builtin.ret v879;
        };

        private builtin.function @miden::active_note::get_assets(v882: i32) -> i32 {
        ^block110(v882: i32):
            v883, v884 = hir.exec @miden/active_note/get_assets(v882) : i32, i32
            builtin.ret v883;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.global_variable private @#GOT.data.internal.__memory_base : i32 {
            builtin.ret_imm 0;
        };

        builtin.segment readonly @1048576 = 0x003e64657463616465723c;

        builtin.segment @1048588 = 0x00000000000000000000000a00100000000000010000000100000001;
    };

    public builtin.function @run(v886: felt, v887: felt, v888: felt, v889: felt) {
    ^block112(v886: felt, v887: felt, v888: felt, v889: felt):
        hir.exec @miden:base/note-script@1.0.0/p2id/miden:base/note-script@1.0.0#run(v886, v887, v888, v889)
        builtin.ret ;
    };
};