builtin.component root_ns:root@1.0.0 {
    builtin.module public @adv_load_preimage {
        private builtin.function @__rustc::__rust_alloc(v0: i32, v1: i32) -> i32 {
        ^block4(v0: i32, v1: i32):
            v495 = arith.constant 1048576 : i32;
            v4 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v495, v1, v0) : i32
            builtin.ret v4;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v5: i32, v6: i32) -> i32 {
        ^block6(v5: i32, v6: i32):
            v499 = arith.constant 1048576 : i32;
            v9 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v499, v6, v5) : i32
            v510 = arith.constant 0 : i32;
            v502 = arith.constant 0 : i32;
            v11 = arith.eq v9, v502 : i1;
            v12 = arith.zext v11 : u32;
            v13 = hir.bitcast v12 : i32;
            v15 = arith.neq v13, v510 : i1;
            scf.if v15{
            ^block8:
                scf.yield ;
            } else {
            ^block9:
                v508 = arith.constant 0 : i32;
                v509 = arith.constant 0 : i32;
                v17 = arith.eq v5, v509 : i1;
                v18 = arith.zext v17 : u32;
                v19 = hir.bitcast v18 : i32;
                v21 = arith.neq v19, v508 : i1;
                scf.if v21{
                ^block68:
                    scf.yield ;
                } else {
                ^block10:
                    v497 = arith.constant 0 : u8;
                    v24 = hir.bitcast v5 : u32;
                    v25 = hir.bitcast v9 : u32;
                    v26 = hir.int_to_ptr v25 : ptr<byte, u8>;
                    hir.mem_set v26, v24, v497;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v9;
        };

        public builtin.function @entrypoint(v28: i32, v29: felt, v30: felt, v31: felt, v32: felt) {
        ^block11(v28: i32, v29: felt, v30: felt, v31: felt, v32: felt):
            v37 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v38 = hir.bitcast v37 : ptr<byte, i32>;
            v39 = hir.load v38 : i32;
            v537 = arith.constant 16 : i32;
            v41 = arith.sub v39, v537 : i32 #[overflow = wrapping];
            v42 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v43 = hir.bitcast v42 : ptr<byte, i32>;
            hir.store v43, v41;
            v44 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/intrinsics::advice::adv_push_mapvaln(v32, v31, v30, v29) : felt
            v45 = hir.cast v44 : i64;
            v527 = arith.constant 0 : felt;
            v536 = arith.constant 3 : i32;
            v46 = arith.trunc v45 : i32;
            v48 = arith.band v46, v536 : i32;
            v49 = hir.bitcast v48 : felt;
            hir.assert_eq v49, v527;
            v534 = arith.constant 2 : i64;
            v56 = hir.cast v534 : u32;
            v55 = hir.bitcast v45 : u64;
            v57 = arith.shr v55, v56 : u64;
            v58 = hir.bitcast v57 : i64;
            v59 = arith.trunc v58 : felt;
            v526 = arith.constant 2 : u32;
            v60 = hir.cast v59 : i64;
            v61 = arith.trunc v60 : i32;
            v64 = arith.shl v61, v526 : i32;
            v601 = arith.constant 4 : i32;
            v538 = arith.constant 0 : i32;
            v561 = arith.constant 4 : i32;
            v53 = arith.add v41, v561 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/adv_load_preimage/<alloc::raw_vec::RawVecInner>::try_allocate_in(v53, v64, v538, v601, v601)
            v68 = hir.bitcast v41 : u32;
            v533 = arith.constant 8 : u32;
            v70 = arith.add v68, v533 : u32 #[overflow = checked];
            v532 = arith.constant 4 : u32;
            v72 = arith.mod v70, v532 : u32;
            hir.assertz v72 #[code = 250];
            v73 = hir.int_to_ptr v70 : ptr<byte, i32>;
            v74 = hir.load v73 : i32;
            v600 = arith.constant 4 : u32;
            v77 = arith.add v68, v600 : u32 #[overflow = checked];
            v599 = arith.constant 4 : u32;
            v79 = arith.mod v77, v599 : u32;
            hir.assertz v79 #[code = 250];
            v80 = hir.int_to_ptr v77 : ptr<byte, i32>;
            v81 = hir.load v80 : i32;
            v598 = arith.constant 0 : i32;
            v531 = arith.constant 1 : i32;
            v83 = arith.eq v81, v531 : i1;
            v84 = arith.zext v83 : u32;
            v85 = hir.bitcast v84 : i32;
            v87 = arith.neq v85, v598 : i1;
            v566 = scf.if v87 : u32 {
            ^block14:
                v530 = arith.constant 12 : u32;
                v179 = arith.add v68, v530 : u32 #[overflow = checked];
                v597 = arith.constant 4 : u32;
                v181 = arith.mod v179, v597 : u32;
                hir.assertz v181 #[code = 250];
                v182 = hir.int_to_ptr v179 : ptr<byte, i32>;
                v183 = hir.load v182 : i32;
                hir.exec @root_ns:root@1.0.0/adv_load_preimage/alloc::raw_vec::handle_error(v74, v183)
                v562 = arith.constant 0 : u32;
                scf.yield v562;
            } else {
            ^block15:
                v596 = arith.constant 12 : u32;
                v90 = arith.add v68, v596 : u32 #[overflow = checked];
                v595 = arith.constant 4 : u32;
                v92 = arith.mod v90, v595 : u32;
                hir.assertz v92 #[code = 250];
                v93 = hir.int_to_ptr v90 : ptr<byte, i32>;
                v94 = hir.load v93 : i32;
                v96 = hir.bitcast v94 : u32;
                v594 = arith.constant 2 : u32;
                v98 = arith.shr v96, v594 : u32;
                v99 = hir.bitcast v98 : i32;
                v100 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/miden::core::mem::pipe_preimage_to_memory(v59, v99, v32, v31, v30, v29) : i32
                v101 = hir.bitcast v28 : u32;
                v593 = arith.constant 8 : u32;
                v103 = arith.add v101, v593 : u32 #[overflow = checked];
                v592 = arith.constant 4 : u32;
                v105 = arith.mod v103, v592 : u32;
                hir.assertz v105 #[code = 250];
                v106 = hir.int_to_ptr v103 : ptr<byte, i32>;
                hir.store v106, v64;
                v591 = arith.constant 4 : u32;
                v109 = arith.add v101, v591 : u32 #[overflow = checked];
                v590 = arith.constant 4 : u32;
                v111 = arith.mod v109, v590 : u32;
                hir.assertz v111 #[code = 250];
                v112 = hir.int_to_ptr v109 : ptr<byte, i32>;
                hir.store v112, v94;
                v589 = arith.constant 4 : u32;
                v115 = arith.mod v101, v589 : u32;
                hir.assertz v115 #[code = 250];
                v116 = hir.int_to_ptr v101 : ptr<byte, i32>;
                hir.store v116, v74;
                v587 = arith.constant 0 : i32;
                v588 = arith.constant 0 : i32;
                v118 = arith.eq v64, v588 : i1;
                v119 = arith.zext v118 : u32;
                v120 = hir.bitcast v119 : i32;
                v122 = arith.neq v120, v587 : i1;
                v568 = scf.if v122 : u32 {
                ^block73:
                    v586 = arith.constant 0 : u32;
                    scf.yield v586;
                } else {
                ^block16:
                    v585 = arith.constant 4 : u32;
                    v125 = arith.mod v96, v585 : u32;
                    hir.assertz v125 #[code = 250];
                    v126 = hir.int_to_ptr v96 : ptr<byte, felt>;
                    v127 = hir.load v126 : felt;
                    v525 = arith.constant 1 : felt;
                    hir.assert_eq v127, v525;
                    v584 = arith.constant 4 : u32;
                    v132 = arith.add v96, v584 : u32 #[overflow = checked];
                    v583 = arith.constant 4 : u32;
                    v134 = arith.mod v132, v583 : u32;
                    hir.assertz v134 #[code = 250];
                    v135 = hir.int_to_ptr v132 : ptr<byte, felt>;
                    v136 = hir.load v135 : felt;
                    v524 = arith.constant 2 : felt;
                    hir.assert_eq v136, v524;
                    v140 = hir.bitcast v64 : u32;
                    v582 = arith.constant 0 : i32;
                    v523 = arith.constant 5 : u32;
                    v142 = arith.lte v140, v523 : i1;
                    v143 = arith.zext v142 : u32;
                    v144 = hir.bitcast v143 : i32;
                    v146 = arith.neq v144, v582 : i1;
                    v570 = scf.if v146 : u32 {
                    ^block72:
                        v581 = arith.constant 0 : u32;
                        scf.yield v581;
                    } else {
                    ^block17:
                        v529 = arith.constant 20 : u32;
                        v149 = arith.add v96, v529 : u32 #[overflow = checked];
                        v580 = arith.constant 4 : u32;
                        v151 = arith.mod v149, v580 : u32;
                        hir.assertz v151 #[code = 250];
                        v152 = hir.int_to_ptr v149 : ptr<byte, felt>;
                        v153 = hir.load v152 : felt;
                        v522 = arith.constant 6 : felt;
                        hir.assert_eq v153, v522;
                        v579 = arith.constant 0 : i32;
                        v521 = arith.constant 14 : u32;
                        v159 = arith.lte v140, v521 : i1;
                        v160 = arith.zext v159 : u32;
                        v161 = hir.bitcast v160 : i32;
                        v163 = arith.neq v161, v579 : i1;
                        scf.if v163{
                        ^block71:
                            scf.yield ;
                        } else {
                        ^block18:
                            v528 = arith.constant 56 : u32;
                            v166 = arith.add v96, v528 : u32 #[overflow = checked];
                            v578 = arith.constant 4 : u32;
                            v168 = arith.mod v166, v578 : u32;
                            hir.assertz v168 #[code = 250];
                            v169 = hir.int_to_ptr v166 : ptr<byte, felt>;
                            v170 = hir.load v169 : felt;
                            v520 = arith.constant 15 : felt;
                            hir.assert_eq v170, v520;
                            v577 = arith.constant 16 : i32;
                            v174 = arith.add v41, v577 : i32 #[overflow = wrapping];
                            v175 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
                            v176 = hir.bitcast v175 : ptr<byte, i32>;
                            hir.store v176, v174;
                            scf.yield ;
                        };
                        v564 = arith.constant 1 : u32;
                        v576 = arith.constant 0 : u32;
                        v574 = cf.select v163, v576, v564 : u32;
                        scf.yield v574;
                    };
                    scf.yield v570;
                };
                scf.yield v568;
            };
            v575 = arith.constant 0 : u32;
            v573 = arith.eq v566, v575 : i1;
            cf.cond_br v573 ^block13, ^block75;
        ^block13:
            ub.unreachable ;
        ^block75:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block19:
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v184: i32, v185: i32, v186: i32) -> i32 {
        ^block21(v184: i32, v185: i32, v186: i32):
            v609 = arith.constant 16 : i32;
            v608 = arith.constant 0 : i32;
            v604 = arith.constant 16 : u32;
            v191 = hir.bitcast v185 : u32;
            v193 = arith.gt v191, v604 : i1;
            v194 = arith.zext v193 : u32;
            v195 = hir.bitcast v194 : i32;
            v197 = arith.neq v195, v608 : i1;
            v198 = cf.select v197, v185, v609 : i32;
            v663 = arith.constant 0 : i32;
            v607 = arith.constant -1 : i32;
            v200 = arith.add v198, v607 : i32 #[overflow = wrapping];
            v201 = arith.band v198, v200 : i32;
            v203 = arith.neq v201, v663 : i1;
            v632, v633 = scf.if v203 : i32, u32 {
            ^block82:
                v624 = arith.constant 0 : u32;
                v628 = ub.poison i32 : i32;
                scf.yield v628, v624;
            } else {
            ^block24:
                v205 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/<core::ptr::alignment::Alignment>::max(v185, v198) : i32
                v662 = arith.constant 0 : i32;
                v606 = arith.constant -2147483648 : i32;
                v206 = arith.sub v606, v205 : i32 #[overflow = wrapping];
                v208 = hir.bitcast v206 : u32;
                v207 = hir.bitcast v186 : u32;
                v209 = arith.gt v207, v208 : i1;
                v210 = arith.zext v209 : u32;
                v211 = hir.bitcast v210 : i32;
                v213 = arith.neq v211, v662 : i1;
                v647 = scf.if v213 : i32 {
                ^block81:
                    v661 = ub.poison i32 : i32;
                    scf.yield v661;
                } else {
                ^block25:
                    v659 = arith.constant 0 : i32;
                    v219 = arith.sub v659, v205 : i32 #[overflow = wrapping];
                    v660 = arith.constant -1 : i32;
                    v215 = arith.add v186, v205 : i32 #[overflow = wrapping];
                    v217 = arith.add v215, v660 : i32 #[overflow = wrapping];
                    v220 = arith.band v217, v219 : i32;
                    v221 = hir.bitcast v184 : u32;
                    v605 = arith.constant 4 : u32;
                    v223 = arith.mod v221, v605 : u32;
                    hir.assertz v223 #[code = 250];
                    v224 = hir.int_to_ptr v221 : ptr<byte, i32>;
                    v225 = hir.load v224 : i32;
                    v658 = arith.constant 0 : i32;
                    v227 = arith.neq v225, v658 : i1;
                    scf.if v227{
                    ^block80:
                        scf.yield ;
                    } else {
                    ^block27:
                        v228 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/intrinsics::mem::heap_base() : i32
                        v229 = hir.mem_size  : u32;
                        v657 = arith.constant 4 : u32;
                        v237 = arith.mod v221, v657 : u32;
                        hir.assertz v237 #[code = 250];
                        v656 = arith.constant 16 : u32;
                        v230 = hir.bitcast v229 : i32;
                        v233 = arith.shl v230, v656 : i32;
                        v234 = arith.add v228, v233 : i32 #[overflow = wrapping];
                        v238 = hir.int_to_ptr v221 : ptr<byte, i32>;
                        hir.store v238, v234;
                        scf.yield ;
                    };
                    v241 = hir.bitcast v184 : u32;
                    v655 = arith.constant 4 : u32;
                    v243 = arith.mod v241, v655 : u32;
                    hir.assertz v243 #[code = 250];
                    v244 = hir.int_to_ptr v241 : ptr<byte, i32>;
                    v245 = hir.load v244 : i32;
                    v653 = arith.constant 0 : i32;
                    v654 = arith.constant -1 : i32;
                    v247 = arith.bxor v245, v654 : i32;
                    v249 = hir.bitcast v247 : u32;
                    v248 = hir.bitcast v220 : u32;
                    v250 = arith.gt v248, v249 : i1;
                    v251 = arith.zext v250 : u32;
                    v252 = hir.bitcast v251 : i32;
                    v254 = arith.neq v252, v653 : i1;
                    v646 = scf.if v254 : i32 {
                    ^block28:
                        v652 = arith.constant 0 : i32;
                        scf.yield v652;
                    } else {
                    ^block29:
                        v651 = arith.constant 4 : u32;
                        v258 = arith.mod v241, v651 : u32;
                        hir.assertz v258 #[code = 250];
                        v255 = arith.add v245, v220 : i32 #[overflow = wrapping];
                        v259 = hir.int_to_ptr v241 : ptr<byte, i32>;
                        hir.store v259, v255;
                        v261 = arith.add v245, v205 : i32 #[overflow = wrapping];
                        scf.yield v261;
                    };
                    scf.yield v646;
                };
                v629 = arith.constant 1 : u32;
                v650 = arith.constant 0 : u32;
                v648 = cf.select v213, v650, v629 : u32;
                scf.yield v647, v648;
            };
            v649 = arith.constant 0 : u32;
            v645 = arith.eq v633, v649 : i1;
            cf.cond_br v645 ^block23, ^block84(v632);
        ^block23:
            ub.unreachable ;
        ^block84(v625: i32):
            builtin.ret v625;
        };

        private builtin.function @intrinsics::mem::heap_base() -> i32 {
        ^block30:
            v264 = hir.exec @intrinsics/mem/heap_base() : i32
            builtin.ret v264;
        };

        private builtin.function @intrinsics::advice::adv_push_mapvaln(v266: felt, v267: felt, v268: felt, v269: felt) -> felt {
        ^block34(v266: felt, v267: felt, v268: felt, v269: felt):
            v270 = hir.exec @intrinsics/advice/adv_push_mapvaln(v266, v267, v268, v269) : felt
            builtin.ret v270;
        };

        private builtin.function @miden::core::mem::pipe_preimage_to_memory(v272: felt, v273: i32, v274: felt, v275: felt, v276: felt, v277: felt) -> i32 {
        ^block37(v272: felt, v273: i32, v274: felt, v275: felt, v276: felt, v277: felt):
            v278 = hir.exec @miden/core/mem/pipe_preimage_to_memory(v272, v273, v274, v275, v276, v277) : i32
            builtin.ret v278;
        };

        private builtin.function @<alloc::alloc::Global>::alloc_impl(v280: i32, v281: i32, v282: i32, v283: i32) {
        ^block42(v280: i32, v281: i32, v282: i32, v283: i32):
            v685 = arith.constant 0 : i32;
            v669 = arith.constant 0 : i32;
            v285 = arith.eq v282, v669 : i1;
            v286 = arith.zext v285 : u32;
            v287 = hir.bitcast v286 : i32;
            v289 = arith.neq v287, v685 : i1;
            v681 = scf.if v289 : i32 {
            ^block88:
                scf.yield v281;
            } else {
            ^block45:
                hir.exec @root_ns:root@1.0.0/adv_load_preimage/__rustc::__rust_no_alloc_shim_is_unstable_v2()
                v684 = arith.constant 0 : i32;
                v291 = arith.neq v283, v684 : i1;
                v680 = scf.if v291 : i32 {
                ^block46:
                    v293 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/__rustc::__rust_alloc_zeroed(v282, v281) : i32
                    scf.yield v293;
                } else {
                ^block47:
                    v292 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/__rustc::__rust_alloc(v282, v281) : i32
                    scf.yield v292;
                };
                scf.yield v680;
            };
            v296 = hir.bitcast v280 : u32;
            v664 = arith.constant 4 : u32;
            v298 = arith.add v296, v664 : u32 #[overflow = checked];
            v683 = arith.constant 4 : u32;
            v300 = arith.mod v298, v683 : u32;
            hir.assertz v300 #[code = 250];
            v301 = hir.int_to_ptr v298 : ptr<byte, i32>;
            hir.store v301, v282;
            v682 = arith.constant 4 : u32;
            v305 = arith.mod v296, v682 : u32;
            hir.assertz v305 #[code = 250];
            v306 = hir.int_to_ptr v296 : ptr<byte, i32>;
            hir.store v306, v681;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v307: i32, v308: i32, v309: i32) {
        ^block48(v307: i32, v308: i32, v309: i32):
            v311 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v312 = hir.bitcast v311 : ptr<byte, i32>;
            v313 = hir.load v312 : i32;
            v690 = arith.constant 16 : i32;
            v315 = arith.sub v313, v690 : i32 #[overflow = wrapping];
            v316 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v317 = hir.bitcast v316 : ptr<byte, i32>;
            hir.store v317, v315;
            v691 = arith.constant 0 : i32;
            v689 = arith.constant 8 : i32;
            v319 = arith.add v315, v689 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/adv_load_preimage/<alloc::alloc::Global>::alloc_impl(v319, v308, v309, v691)
            v321 = hir.bitcast v315 : u32;
            v688 = arith.constant 12 : u32;
            v323 = arith.add v321, v688 : u32 #[overflow = checked];
            v687 = arith.constant 4 : u32;
            v325 = arith.mod v323, v687 : u32;
            hir.assertz v325 #[code = 250];
            v326 = hir.int_to_ptr v323 : ptr<byte, i32>;
            v327 = hir.load v326 : i32;
            v686 = arith.constant 8 : u32;
            v330 = arith.add v321, v686 : u32 #[overflow = checked];
            v701 = arith.constant 4 : u32;
            v332 = arith.mod v330, v701 : u32;
            hir.assertz v332 #[code = 250];
            v333 = hir.int_to_ptr v330 : ptr<byte, i32>;
            v334 = hir.load v333 : i32;
            v335 = hir.bitcast v307 : u32;
            v700 = arith.constant 4 : u32;
            v337 = arith.mod v335, v700 : u32;
            hir.assertz v337 #[code = 250];
            v338 = hir.int_to_ptr v335 : ptr<byte, i32>;
            hir.store v338, v334;
            v699 = arith.constant 4 : u32;
            v341 = arith.add v335, v699 : u32 #[overflow = checked];
            v698 = arith.constant 4 : u32;
            v343 = arith.mod v341, v698 : u32;
            hir.assertz v343 #[code = 250];
            v344 = hir.int_to_ptr v341 : ptr<byte, i32>;
            hir.store v344, v327;
            v697 = arith.constant 16 : i32;
            v346 = arith.add v315, v697 : i32 #[overflow = wrapping];
            v347 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v348 = hir.bitcast v347 : ptr<byte, i32>;
            hir.store v348, v346;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::try_allocate_in(v349: i32, v350: i32, v351: i32, v352: i32, v353: i32) {
        ^block50(v349: i32, v350: i32, v351: i32, v352: i32, v353: i32):
            v356 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v357 = hir.bitcast v356 : ptr<byte, i32>;
            v358 = hir.load v357 : i32;
            v709 = arith.constant 16 : i32;
            v360 = arith.sub v358, v709 : i32 #[overflow = wrapping];
            v361 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v362 = hir.bitcast v361 : ptr<byte, i32>;
            hir.store v362, v360;
            v372 = hir.bitcast v350 : u32;
            v373 = arith.zext v372 : u64;
            v374 = hir.bitcast v373 : i64;
            v710 = arith.constant 0 : i32;
            v367 = arith.sub v710, v352 : i32 #[overflow = wrapping];
            v708 = arith.constant -1 : i32;
            v363 = arith.add v352, v353 : i32 #[overflow = wrapping];
            v365 = arith.add v363, v708 : i32 #[overflow = wrapping];
            v368 = arith.band v365, v367 : i32;
            v369 = hir.bitcast v368 : u32;
            v370 = arith.zext v369 : u64;
            v371 = hir.bitcast v370 : i64;
            v375 = arith.mul v371, v374 : i64 #[overflow = wrapping];
            v841 = arith.constant 0 : i32;
            v707 = arith.constant 32 : i64;
            v378 = hir.cast v707 : u32;
            v377 = hir.bitcast v375 : u64;
            v379 = arith.shr v377, v378 : u64;
            v380 = hir.bitcast v379 : i64;
            v381 = arith.trunc v380 : i32;
            v383 = arith.neq v381, v841 : i1;
            v754, v755, v756, v757, v758, v759 = scf.if v383 : i32, i32, i32, i32, i32, u32 {
            ^block91:
                v739 = arith.constant 0 : u32;
                v746 = ub.poison i32 : i32;
                scf.yield v349, v360, v746, v746, v746, v739;
            } else {
            ^block55:
                v384 = arith.trunc v375 : i32;
                v840 = arith.constant 0 : i32;
                v704 = arith.constant -2147483648 : i32;
                v386 = arith.sub v704, v352 : i32 #[overflow = wrapping];
                v388 = hir.bitcast v386 : u32;
                v387 = hir.bitcast v384 : u32;
                v389 = arith.lte v387, v388 : i1;
                v390 = arith.zext v389 : u32;
                v391 = hir.bitcast v390 : i32;
                v393 = arith.neq v391, v840 : i1;
                v802 = scf.if v393 : i32 {
                ^block53:
                    v839 = arith.constant 0 : i32;
                    v404 = arith.neq v384, v839 : i1;
                    v801 = scf.if v404 : i32 {
                    ^block57:
                        v838 = arith.constant 0 : i32;
                        v420 = arith.neq v351, v838 : i1;
                        v800 = scf.if v420 : i32 {
                        ^block60:
                            v724 = arith.constant 1 : i32;
                            hir.exec @root_ns:root@1.0.0/adv_load_preimage/<alloc::alloc::Global>::alloc_impl(v360, v352, v384, v724)
                            v431 = hir.bitcast v360 : u32;
                            v723 = arith.constant 4 : u32;
                            v433 = arith.mod v431, v723 : u32;
                            hir.assertz v433 #[code = 250];
                            v434 = hir.int_to_ptr v431 : ptr<byte, i32>;
                            v435 = hir.load v434 : i32;
                            scf.yield v435;
                        } else {
                        ^block61:
                            v702 = arith.constant 8 : i32;
                            v422 = arith.add v360, v702 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/adv_load_preimage/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v422, v352, v384)
                            v722 = arith.constant 8 : u32;
                            v423 = hir.bitcast v360 : u32;
                            v425 = arith.add v423, v722 : u32 #[overflow = checked];
                            v837 = arith.constant 4 : u32;
                            v427 = arith.mod v425, v837 : u32;
                            hir.assertz v427 #[code = 250];
                            v428 = hir.int_to_ptr v425 : ptr<byte, i32>;
                            v429 = hir.load v428 : i32;
                            scf.yield v429;
                        };
                        v836 = arith.constant 0 : i32;
                        v438 = arith.neq v800, v836 : i1;
                        scf.if v438{
                        ^block62:
                            v455 = hir.bitcast v349 : u32;
                            v835 = arith.constant 8 : u32;
                            v457 = arith.add v455, v835 : u32 #[overflow = checked];
                            v834 = arith.constant 4 : u32;
                            v459 = arith.mod v457, v834 : u32;
                            hir.assertz v459 #[code = 250];
                            v460 = hir.int_to_ptr v457 : ptr<byte, i32>;
                            hir.store v460, v800;
                            v833 = arith.constant 4 : u32;
                            v464 = arith.add v455, v833 : u32 #[overflow = checked];
                            v832 = arith.constant 4 : u32;
                            v466 = arith.mod v464, v832 : u32;
                            hir.assertz v466 #[code = 250];
                            v467 = hir.int_to_ptr v464 : ptr<byte, i32>;
                            hir.store v467, v350;
                            scf.yield ;
                        } else {
                        ^block63:
                            v441 = hir.bitcast v349 : u32;
                            v831 = arith.constant 8 : u32;
                            v443 = arith.add v441, v831 : u32 #[overflow = checked];
                            v830 = arith.constant 4 : u32;
                            v445 = arith.mod v443, v830 : u32;
                            hir.assertz v445 #[code = 250];
                            v446 = hir.int_to_ptr v443 : ptr<byte, i32>;
                            hir.store v446, v384;
                            v829 = arith.constant 4 : u32;
                            v450 = arith.add v441, v829 : u32 #[overflow = checked];
                            v828 = arith.constant 4 : u32;
                            v452 = arith.mod v450, v828 : u32;
                            hir.assertz v452 #[code = 250];
                            v453 = hir.int_to_ptr v450 : ptr<byte, i32>;
                            hir.store v453, v352;
                            scf.yield ;
                        };
                        v826 = arith.constant 1 : i32;
                        v827 = arith.constant 0 : i32;
                        v799 = cf.select v438, v827, v826 : i32;
                        scf.yield v799;
                    } else {
                    ^block58:
                        v405 = hir.bitcast v349 : u32;
                        v825 = arith.constant 8 : u32;
                        v407 = arith.add v405, v825 : u32 #[overflow = checked];
                        v824 = arith.constant 4 : u32;
                        v409 = arith.mod v407, v824 : u32;
                        hir.assertz v409 #[code = 250];
                        v410 = hir.int_to_ptr v407 : ptr<byte, i32>;
                        hir.store v410, v352;
                        v823 = arith.constant 4 : u32;
                        v415 = arith.add v405, v823 : u32 #[overflow = checked];
                        v822 = arith.constant 4 : u32;
                        v417 = arith.mod v415, v822 : u32;
                        hir.assertz v417 #[code = 250];
                        v821 = arith.constant 0 : i32;
                        v418 = hir.int_to_ptr v415 : ptr<byte, i32>;
                        hir.store v418, v821;
                        v820 = arith.constant 0 : i32;
                        scf.yield v820;
                    };
                    scf.yield v801;
                } else {
                ^block56:
                    v819 = ub.poison i32 : i32;
                    scf.yield v819;
                };
                v814 = arith.constant 0 : u32;
                v747 = arith.constant 1 : u32;
                v807 = cf.select v393, v747, v814 : u32;
                v815 = ub.poison i32 : i32;
                v806 = cf.select v393, v360, v815 : i32;
                v816 = ub.poison i32 : i32;
                v805 = cf.select v393, v349, v816 : i32;
                v817 = ub.poison i32 : i32;
                v804 = cf.select v393, v817, v360 : i32;
                v818 = ub.poison i32 : i32;
                v803 = cf.select v393, v818, v349 : i32;
                scf.yield v803, v804, v805, v802, v806, v807;
            };
            v760, v761, v762 = scf.index_switch v759 : i32, i32, i32 
            case 0 {
            ^block54:
                v813 = arith.constant 4 : u32;
                v396 = hir.bitcast v754 : u32;
                v398 = arith.add v396, v813 : u32 #[overflow = checked];
                v812 = arith.constant 4 : u32;
                v400 = arith.mod v398, v812 : u32;
                hir.assertz v400 #[code = 250];
                v811 = arith.constant 0 : i32;
                v401 = hir.int_to_ptr v398 : ptr<byte, i32>;
                hir.store v401, v811;
                v810 = arith.constant 1 : i32;
                scf.yield v754, v810, v755;
            }
            default {
            ^block95:
                scf.yield v756, v757, v758;
            };
            v471 = hir.bitcast v760 : u32;
            v809 = arith.constant 4 : u32;
            v473 = arith.mod v471, v809 : u32;
            hir.assertz v473 #[code = 250];
            v474 = hir.int_to_ptr v471 : ptr<byte, i32>;
            hir.store v474, v761;
            v808 = arith.constant 16 : i32;
            v479 = arith.add v762, v808 : i32 #[overflow = wrapping];
            v480 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v481 = hir.bitcast v480 : ptr<byte, i32>;
            hir.store v481, v479;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v482: i32, v483: i32) {
        ^block64(v482: i32, v483: i32):
            ub.unreachable ;
        };

        private builtin.function @<core::ptr::alignment::Alignment>::max(v484: i32, v485: i32) -> i32 {
        ^block66(v484: i32, v485: i32):
            v842 = arith.constant 0 : i32;
            v488 = hir.bitcast v485 : u32;
            v487 = hir.bitcast v484 : u32;
            v489 = arith.gt v487, v488 : i1;
            v490 = arith.zext v489 : u32;
            v491 = hir.bitcast v490 : i32;
            v493 = arith.neq v491, v842 : i1;
            v494 = cf.select v493, v484, v485 : i32;
            builtin.ret v494;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};