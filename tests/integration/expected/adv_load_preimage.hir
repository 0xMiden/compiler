builtin.component root_ns:root@1.0.0 {
    builtin.module public @adv_load_preimage {
        public builtin.function @entrypoint(v0: i32, v1: felt, v2: felt, v3: felt, v4: felt) {
        ^block4(v0: i32, v1: felt, v2: felt, v3: felt, v4: felt):
            v9 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v10 = hir.bitcast v9 : ptr<byte, i32>;
            v11 = hir.load v10 : i32;
            v12 = arith.constant 16 : i32;
            v13 = arith.sub v11, v12 : i32 #[overflow = wrapping];
            v14 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v15 = hir.bitcast v14 : ptr<byte, i32>;
            hir.store v15, v13;
            v16 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/intrinsics::advice::adv_push_mapvaln(v4, v3, v2, v1) : felt
            v17 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/intrinsics::felt::as_u64(v16) : i64
            v19 = arith.constant 3 : i32;
            v18 = arith.trunc v17 : i32;
            v20 = arith.band v18, v19 : i32;
            v21 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/intrinsics::felt::from_u32(v20) : felt
            v5 = arith.constant 0 : i32;
            v23 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/intrinsics::felt::from_u32(v5) : felt
            hir.exec @root_ns:root@1.0.0/adv_load_preimage/intrinsics::felt::assert_eq(v21, v23)
            v26 = arith.constant 2 : i64;
            v28 = hir.cast v26 : u32;
            v27 = hir.bitcast v17 : u64;
            v29 = arith.shr v27, v28 : u64;
            v30 = hir.bitcast v29 : i64;
            v31 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/intrinsics::felt::from_u64_unchecked(v30) : felt
            v32 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/intrinsics::felt::as_u64(v31) : i64
            v515 = arith.constant 2 : u32;
            v33 = arith.trunc v32 : i32;
            v36 = arith.shl v33, v515 : i32;
            v556 = arith.constant 4 : i32;
            v557 = arith.constant 0 : i32;
            v24 = arith.constant 4 : i32;
            v25 = arith.add v13, v24 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/adv_load_preimage/alloc::raw_vec::RawVecInner<A>::try_allocate_in(v25, v36, v557, v556, v556)
            v41 = arith.constant 8 : u32;
            v40 = hir.bitcast v13 : u32;
            v42 = arith.add v40, v41 : u32 #[overflow = checked];
            v43 = arith.constant 4 : u32;
            v44 = arith.mod v42, v43 : u32;
            hir.assertz v44 #[code = 250];
            v45 = hir.int_to_ptr v42 : ptr<byte, i32>;
            v46 = hir.load v45 : i32;
            v555 = arith.constant 4 : u32;
            v47 = hir.bitcast v13 : u32;
            v49 = arith.add v47, v555 : u32 #[overflow = checked];
            v554 = arith.constant 4 : u32;
            v51 = arith.mod v49, v554 : u32;
            hir.assertz v51 #[code = 250];
            v52 = hir.int_to_ptr v49 : ptr<byte, i32>;
            v53 = hir.load v52 : i32;
            v553 = arith.constant 0 : i32;
            v54 = arith.constant 1 : i32;
            v55 = arith.eq v53, v54 : i1;
            v56 = arith.zext v55 : u32;
            v57 = hir.bitcast v56 : i32;
            v59 = arith.neq v57, v553 : i1;
            v520 = scf.if v59 : u32 {
            ^block7:
                v150 = arith.constant 12 : u32;
                v149 = hir.bitcast v13 : u32;
                v151 = arith.add v149, v150 : u32 #[overflow = checked];
                v552 = arith.constant 4 : u32;
                v153 = arith.mod v151, v552 : u32;
                hir.assertz v153 #[code = 250];
                v154 = hir.int_to_ptr v151 : ptr<byte, i32>;
                v155 = hir.load v154 : i32;
                v156 = arith.constant 1048620 : i32;
                hir.exec @root_ns:root@1.0.0/adv_load_preimage/alloc::raw_vec::handle_error(v46, v155, v156)
                v516 = arith.constant 0 : u32;
                scf.yield v516;
            } else {
            ^block8:
                v551 = arith.constant 12 : u32;
                v60 = hir.bitcast v13 : u32;
                v62 = arith.add v60, v551 : u32 #[overflow = checked];
                v550 = arith.constant 4 : u32;
                v64 = arith.mod v62, v550 : u32;
                hir.assertz v64 #[code = 250];
                v65 = hir.int_to_ptr v62 : ptr<byte, i32>;
                v66 = hir.load v65 : i32;
                v549 = arith.constant 2 : u32;
                v68 = hir.bitcast v66 : u32;
                v70 = arith.shr v68, v549 : u32;
                v71 = hir.bitcast v70 : i32;
                v72 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/std::mem::pipe_preimage_to_memory(v31, v71, v4, v3, v2, v1) : i32
                v548 = arith.constant 8 : u32;
                v73 = hir.bitcast v0 : u32;
                v75 = arith.add v73, v548 : u32 #[overflow = checked];
                v547 = arith.constant 4 : u32;
                v77 = arith.mod v75, v547 : u32;
                hir.assertz v77 #[code = 250];
                v78 = hir.int_to_ptr v75 : ptr<byte, i32>;
                hir.store v78, v36;
                v546 = arith.constant 4 : u32;
                v79 = hir.bitcast v0 : u32;
                v81 = arith.add v79, v546 : u32 #[overflow = checked];
                v545 = arith.constant 4 : u32;
                v83 = arith.mod v81, v545 : u32;
                hir.assertz v83 #[code = 250];
                v84 = hir.int_to_ptr v81 : ptr<byte, i32>;
                hir.store v84, v66;
                v85 = hir.bitcast v0 : u32;
                v544 = arith.constant 4 : u32;
                v87 = arith.mod v85, v544 : u32;
                hir.assertz v87 #[code = 250];
                v88 = hir.int_to_ptr v85 : ptr<byte, i32>;
                hir.store v88, v46;
                v542 = arith.constant 0 : i32;
                v543 = arith.constant 0 : i32;
                v90 = arith.eq v36, v543 : i1;
                v91 = arith.zext v90 : u32;
                v92 = hir.bitcast v91 : i32;
                v94 = arith.neq v92, v542 : i1;
                v522 = scf.if v94 : u32 {
                ^block77:
                    v541 = arith.constant 0 : u32;
                    scf.yield v541;
                } else {
                ^block9:
                    v95 = hir.bitcast v66 : u32;
                    v540 = arith.constant 4 : u32;
                    v97 = arith.mod v95, v540 : u32;
                    hir.assertz v97 #[code = 250];
                    v98 = hir.int_to_ptr v95 : ptr<byte, felt>;
                    v99 = hir.load v98 : felt;
                    v539 = arith.constant 1 : i32;
                    v101 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/intrinsics::felt::from_u32(v539) : felt
                    hir.exec @root_ns:root@1.0.0/adv_load_preimage/intrinsics::felt::assert_eq(v99, v101)
                    v538 = arith.constant 4 : u32;
                    v102 = hir.bitcast v66 : u32;
                    v104 = arith.add v102, v538 : u32 #[overflow = checked];
                    v537 = arith.constant 4 : u32;
                    v106 = arith.mod v104, v537 : u32;
                    hir.assertz v106 #[code = 250];
                    v107 = hir.int_to_ptr v104 : ptr<byte, felt>;
                    v108 = hir.load v107 : felt;
                    v34 = arith.constant 2 : i32;
                    v110 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/intrinsics::felt::from_u32(v34) : felt
                    hir.exec @root_ns:root@1.0.0/adv_load_preimage/intrinsics::felt::assert_eq(v108, v110)
                    v536 = arith.constant 0 : i32;
                    v513 = arith.constant 5 : u32;
                    v112 = hir.bitcast v36 : u32;
                    v114 = arith.lte v112, v513 : i1;
                    v115 = arith.zext v114 : u32;
                    v116 = hir.bitcast v115 : i32;
                    v118 = arith.neq v116, v536 : i1;
                    v524 = scf.if v118 : u32 {
                    ^block76:
                        v535 = arith.constant 0 : u32;
                        scf.yield v535;
                    } else {
                    ^block10:
                        v120 = arith.constant 20 : u32;
                        v119 = hir.bitcast v66 : u32;
                        v121 = arith.add v119, v120 : u32 #[overflow = checked];
                        v534 = arith.constant 4 : u32;
                        v123 = arith.mod v121, v534 : u32;
                        hir.assertz v123 #[code = 250];
                        v124 = hir.int_to_ptr v121 : ptr<byte, felt>;
                        v125 = hir.load v124 : felt;
                        v126 = arith.constant 6 : i32;
                        v127 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/intrinsics::felt::from_u32(v126) : felt
                        hir.exec @root_ns:root@1.0.0/adv_load_preimage/intrinsics::felt::assert_eq(v125, v127)
                        v533 = arith.constant 0 : i32;
                        v512 = arith.constant 14 : u32;
                        v129 = hir.bitcast v36 : u32;
                        v131 = arith.lte v129, v512 : i1;
                        v132 = arith.zext v131 : u32;
                        v133 = hir.bitcast v132 : i32;
                        v135 = arith.neq v133, v533 : i1;
                        scf.if v135{
                        ^block75:
                            scf.yield ;
                        } else {
                        ^block11:
                            v137 = arith.constant 56 : u32;
                            v136 = hir.bitcast v66 : u32;
                            v138 = arith.add v136, v137 : u32 #[overflow = checked];
                            v532 = arith.constant 4 : u32;
                            v140 = arith.mod v138, v532 : u32;
                            hir.assertz v140 #[code = 250];
                            v141 = hir.int_to_ptr v138 : ptr<byte, felt>;
                            v142 = hir.load v141 : felt;
                            v143 = arith.constant 15 : i32;
                            v144 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/intrinsics::felt::from_u32(v143) : felt
                            hir.exec @root_ns:root@1.0.0/adv_load_preimage/intrinsics::felt::assert_eq(v142, v144)
                            v531 = arith.constant 16 : i32;
                            v146 = arith.add v13, v531 : i32 #[overflow = wrapping];
                            v147 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
                            v148 = hir.bitcast v147 : ptr<byte, i32>;
                            hir.store v148, v146;
                            scf.yield ;
                        };
                        v518 = arith.constant 1 : u32;
                        v530 = arith.constant 0 : u32;
                        v528 = cf.select v135, v530, v518 : u32;
                        scf.yield v528;
                    };
                    scf.yield v524;
                };
                scf.yield v522;
            };
            v529 = arith.constant 0 : u32;
            v527 = arith.eq v520, v529 : i1;
            cf.cond_br v527 ^block6, ^block79;
        ^block6:
            ub.unreachable ;
        ^block79:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc(v157: i32, v158: i32) -> i32 {
        ^block12(v157: i32, v158: i32):
            v160 = arith.constant 1048636 : i32;
            v161 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v160, v158, v157) : i32
            builtin.ret v161;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v162: i32, v163: i32) -> i32 {
        ^block14(v162: i32, v163: i32):
            v165 = arith.constant 1048636 : i32;
            v166 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v165, v163, v162) : i32
            v566 = arith.constant 0 : i32;
            v167 = arith.constant 0 : i32;
            v168 = arith.eq v166, v167 : i1;
            v169 = arith.zext v168 : u32;
            v170 = hir.bitcast v169 : i32;
            v172 = arith.neq v170, v566 : i1;
            scf.if v172{
            ^block16:
                scf.yield ;
            } else {
            ^block17:
                v564 = arith.constant 0 : i32;
                v565 = arith.constant 0 : i32;
                v174 = arith.eq v162, v565 : i1;
                v175 = arith.zext v174 : u32;
                v176 = hir.bitcast v175 : i32;
                v178 = arith.neq v176, v564 : i1;
                scf.if v178{
                ^block84:
                    scf.yield ;
                } else {
                ^block18:
                    v558 = arith.constant 0 : u8;
                    v181 = hir.bitcast v162 : u32;
                    v182 = hir.bitcast v166 : u32;
                    v183 = hir.int_to_ptr v182 : ptr<byte, u8>;
                    hir.mem_set v183, v181, v558;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v166;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block19:
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v185: i32, v186: i32, v187: i32) -> i32 {
        ^block21(v185: i32, v186: i32, v187: i32):
            v190 = arith.constant 16 : i32;
            v189 = arith.constant 0 : i32;
            v568 = arith.constant 16 : u32;
            v192 = hir.bitcast v186 : u32;
            v194 = arith.gt v192, v568 : i1;
            v195 = arith.zext v194 : u32;
            v196 = hir.bitcast v195 : i32;
            v198 = arith.neq v196, v189 : i1;
            v199 = cf.select v198, v186, v190 : i32;
            v608 = arith.constant 0 : i32;
            v200 = arith.constant -1 : i32;
            v201 = arith.add v199, v200 : i32 #[overflow = wrapping];
            v202 = arith.band v199, v201 : i32;
            v204 = arith.neq v202, v608 : i1;
            v577, v578 = scf.if v204 : i32, u32 {
            ^block89:
                v569 = arith.constant 0 : u32;
                v573 = ub.poison i32 : i32;
                scf.yield v573, v569;
            } else {
            ^block24:
                v206 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/core::ptr::alignment::Alignment::max(v186, v199) : i32
                v607 = arith.constant 0 : i32;
                v205 = arith.constant -2147483648 : i32;
                v207 = arith.sub v205, v206 : i32 #[overflow = wrapping];
                v209 = hir.bitcast v207 : u32;
                v208 = hir.bitcast v187 : u32;
                v210 = arith.gt v208, v209 : i1;
                v211 = arith.zext v210 : u32;
                v212 = hir.bitcast v211 : i32;
                v214 = arith.neq v212, v607 : i1;
                v592 = scf.if v214 : i32 {
                ^block88:
                    v606 = ub.poison i32 : i32;
                    scf.yield v606;
                } else {
                ^block25:
                    v604 = arith.constant 0 : i32;
                    v220 = arith.sub v604, v206 : i32 #[overflow = wrapping];
                    v605 = arith.constant -1 : i32;
                    v216 = arith.add v187, v206 : i32 #[overflow = wrapping];
                    v218 = arith.add v216, v605 : i32 #[overflow = wrapping];
                    v221 = arith.band v218, v220 : i32;
                    v222 = hir.bitcast v185 : u32;
                    v223 = arith.constant 4 : u32;
                    v224 = arith.mod v222, v223 : u32;
                    hir.assertz v224 #[code = 250];
                    v225 = hir.int_to_ptr v222 : ptr<byte, i32>;
                    v226 = hir.load v225 : i32;
                    v603 = arith.constant 0 : i32;
                    v228 = arith.neq v226, v603 : i1;
                    scf.if v228{
                    ^block87:
                        scf.yield ;
                    } else {
                    ^block27:
                        v229 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/intrinsics::mem::heap_base() : i32
                        v230 = hir.mem_size  : u32;
                        v236 = hir.bitcast v185 : u32;
                        v602 = arith.constant 4 : u32;
                        v238 = arith.mod v236, v602 : u32;
                        hir.assertz v238 #[code = 250];
                        v601 = arith.constant 16 : u32;
                        v231 = hir.bitcast v230 : i32;
                        v234 = arith.shl v231, v601 : i32;
                        v235 = arith.add v229, v234 : i32 #[overflow = wrapping];
                        v239 = hir.int_to_ptr v236 : ptr<byte, i32>;
                        hir.store v239, v235;
                        scf.yield ;
                    };
                    v242 = hir.bitcast v185 : u32;
                    v600 = arith.constant 4 : u32;
                    v244 = arith.mod v242, v600 : u32;
                    hir.assertz v244 #[code = 250];
                    v245 = hir.int_to_ptr v242 : ptr<byte, i32>;
                    v246 = hir.load v245 : i32;
                    v598 = arith.constant 0 : i32;
                    v599 = arith.constant -1 : i32;
                    v248 = arith.bxor v246, v599 : i32;
                    v250 = hir.bitcast v248 : u32;
                    v249 = hir.bitcast v221 : u32;
                    v251 = arith.gt v249, v250 : i1;
                    v252 = arith.zext v251 : u32;
                    v253 = hir.bitcast v252 : i32;
                    v255 = arith.neq v253, v598 : i1;
                    v591 = scf.if v255 : i32 {
                    ^block28:
                        v597 = arith.constant 0 : i32;
                        scf.yield v597;
                    } else {
                    ^block29:
                        v257 = hir.bitcast v185 : u32;
                        v596 = arith.constant 4 : u32;
                        v259 = arith.mod v257, v596 : u32;
                        hir.assertz v259 #[code = 250];
                        v256 = arith.add v246, v221 : i32 #[overflow = wrapping];
                        v260 = hir.int_to_ptr v257 : ptr<byte, i32>;
                        hir.store v260, v256;
                        v262 = arith.add v246, v206 : i32 #[overflow = wrapping];
                        scf.yield v262;
                    };
                    scf.yield v591;
                };
                v574 = arith.constant 1 : u32;
                v595 = arith.constant 0 : u32;
                v593 = cf.select v214, v595, v574 : u32;
                scf.yield v592, v593;
            };
            v594 = arith.constant 0 : u32;
            v590 = arith.eq v578, v594 : i1;
            cf.cond_br v590 ^block23, ^block91(v577);
        ^block23:
            ub.unreachable ;
        ^block91(v570: i32):
            builtin.ret v570;
        };

        private builtin.function @intrinsics::mem::heap_base() -> i32 {
        ^block30:
            v265 = hir.exec @intrinsics/mem/heap_base() : i32
            builtin.ret v265;
        };

        private builtin.function @intrinsics::felt::from_u64_unchecked(v267: i64) -> felt {
        ^block34(v267: i64):
            v268 = hir.cast v267 : felt;
            builtin.ret v268;
        };

        private builtin.function @intrinsics::felt::from_u32(v270: i32) -> felt {
        ^block36(v270: i32):
            v271 = hir.bitcast v270 : felt;
            builtin.ret v271;
        };

        private builtin.function @intrinsics::felt::as_u64(v273: felt) -> i64 {
        ^block38(v273: felt):
            v274 = hir.cast v273 : i64;
            builtin.ret v274;
        };

        private builtin.function @intrinsics::felt::assert_eq(v276: felt, v277: felt) {
        ^block40(v276: felt, v277: felt):
            hir.assert_eq v276, v277;
            builtin.ret ;
        };

        private builtin.function @intrinsics::advice::adv_push_mapvaln(v278: felt, v279: felt, v280: felt, v281: felt) -> felt {
        ^block42(v278: felt, v279: felt, v280: felt, v281: felt):
            v282 = hir.exec @intrinsics/advice/adv_push_mapvaln(v278, v279, v280, v281) : felt
            builtin.ret v282;
        };

        private builtin.function @std::mem::pipe_preimage_to_memory(v284: felt, v285: i32, v286: felt, v287: felt, v288: felt, v289: felt) -> i32 {
        ^block45(v284: felt, v285: i32, v286: felt, v287: felt, v288: felt, v289: felt):
            v290 = hir.exec @std/mem/pipe_preimage_to_memory(v284, v285, v286, v287, v288, v289) : i32
            builtin.ret v290;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::try_allocate_in(v292: i32, v293: i32, v294: i32, v295: i32, v296: i32) {
        ^block49(v292: i32, v293: i32, v294: i32, v295: i32, v296: i32):
            v299 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v300 = hir.bitcast v299 : ptr<byte, i32>;
            v301 = hir.load v300 : i32;
            v302 = arith.constant 16 : i32;
            v303 = arith.sub v301, v302 : i32 #[overflow = wrapping];
            v304 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v305 = hir.bitcast v304 : ptr<byte, i32>;
            hir.store v305, v303;
            v315 = hir.bitcast v293 : u32;
            v316 = arith.zext v315 : u64;
            v317 = hir.bitcast v316 : i64;
            v297 = arith.constant 0 : i32;
            v310 = arith.sub v297, v295 : i32 #[overflow = wrapping];
            v307 = arith.constant -1 : i32;
            v306 = arith.add v295, v296 : i32 #[overflow = wrapping];
            v308 = arith.add v306, v307 : i32 #[overflow = wrapping];
            v311 = arith.band v308, v310 : i32;
            v312 = hir.bitcast v311 : u32;
            v313 = arith.zext v312 : u64;
            v314 = hir.bitcast v313 : i64;
            v318 = arith.mul v314, v317 : i64 #[overflow = wrapping];
            v712 = arith.constant 0 : i32;
            v319 = arith.constant 32 : i64;
            v321 = hir.cast v319 : u32;
            v320 = hir.bitcast v318 : u64;
            v322 = arith.shr v320, v321 : u64;
            v323 = hir.bitcast v322 : i64;
            v324 = arith.trunc v323 : i32;
            v326 = arith.neq v324, v712 : i1;
            v624, v625, v626, v627, v628, v629 = scf.if v326 : i32, i32, i32, i32, i32, u32 {
            ^block95:
                v609 = arith.constant 0 : u32;
                v616 = ub.poison i32 : i32;
                scf.yield v292, v303, v616, v616, v616, v609;
            } else {
            ^block54:
                v327 = arith.trunc v318 : i32;
                v711 = arith.constant 0 : i32;
                v328 = arith.constant -2147483648 : i32;
                v329 = arith.sub v328, v295 : i32 #[overflow = wrapping];
                v331 = hir.bitcast v329 : u32;
                v330 = hir.bitcast v327 : u32;
                v332 = arith.lte v330, v331 : i1;
                v333 = arith.zext v332 : u32;
                v334 = hir.bitcast v333 : i32;
                v336 = arith.neq v334, v711 : i1;
                v672 = scf.if v336 : i32 {
                ^block52:
                    v710 = arith.constant 0 : i32;
                    v347 = arith.neq v327, v710 : i1;
                    v671 = scf.if v347 : i32 {
                    ^block56:
                        v709 = arith.constant 0 : i32;
                        v363 = arith.neq v294, v709 : i1;
                        v670 = scf.if v363 : i32 {
                        ^block59:
                            v345 = arith.constant 1 : i32;
                            hir.exec @root_ns:root@1.0.0/adv_load_preimage/alloc::alloc::Global::alloc_impl(v303, v295, v327, v345)
                            v374 = hir.bitcast v303 : u32;
                            v419 = arith.constant 4 : u32;
                            v376 = arith.mod v374, v419 : u32;
                            hir.assertz v376 #[code = 250];
                            v377 = hir.int_to_ptr v374 : ptr<byte, i32>;
                            v378 = hir.load v377 : i32;
                            scf.yield v378;
                        } else {
                        ^block60:
                            v364 = arith.constant 8 : i32;
                            v365 = arith.add v303, v364 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/adv_load_preimage/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v365, v295, v327)
                            v349 = arith.constant 8 : u32;
                            v366 = hir.bitcast v303 : u32;
                            v368 = arith.add v366, v349 : u32 #[overflow = checked];
                            v708 = arith.constant 4 : u32;
                            v370 = arith.mod v368, v708 : u32;
                            hir.assertz v370 #[code = 250];
                            v371 = hir.int_to_ptr v368 : ptr<byte, i32>;
                            v372 = hir.load v371 : i32;
                            scf.yield v372;
                        };
                        v706 = arith.constant 0 : i32;
                        v707 = arith.constant 0 : i32;
                        v381 = arith.eq v670, v707 : i1;
                        v382 = arith.zext v381 : u32;
                        v383 = hir.bitcast v382 : i32;
                        v385 = arith.neq v383, v706 : i1;
                        scf.if v385{
                        ^block61:
                            v705 = arith.constant 8 : u32;
                            v402 = hir.bitcast v292 : u32;
                            v404 = arith.add v402, v705 : u32 #[overflow = checked];
                            v704 = arith.constant 4 : u32;
                            v406 = arith.mod v404, v704 : u32;
                            hir.assertz v406 #[code = 250];
                            v407 = hir.int_to_ptr v404 : ptr<byte, i32>;
                            hir.store v407, v327;
                            v703 = arith.constant 4 : u32;
                            v409 = hir.bitcast v292 : u32;
                            v411 = arith.add v409, v703 : u32 #[overflow = checked];
                            v702 = arith.constant 4 : u32;
                            v413 = arith.mod v411, v702 : u32;
                            hir.assertz v413 #[code = 250];
                            v414 = hir.int_to_ptr v411 : ptr<byte, i32>;
                            hir.store v414, v295;
                            scf.yield ;
                        } else {
                        ^block62:
                            v701 = arith.constant 8 : u32;
                            v387 = hir.bitcast v292 : u32;
                            v389 = arith.add v387, v701 : u32 #[overflow = checked];
                            v700 = arith.constant 4 : u32;
                            v391 = arith.mod v389, v700 : u32;
                            hir.assertz v391 #[code = 250];
                            v392 = hir.int_to_ptr v389 : ptr<byte, i32>;
                            hir.store v392, v670;
                            v699 = arith.constant 4 : u32;
                            v394 = hir.bitcast v292 : u32;
                            v396 = arith.add v394, v699 : u32 #[overflow = checked];
                            v698 = arith.constant 4 : u32;
                            v398 = arith.mod v396, v698 : u32;
                            hir.assertz v398 #[code = 250];
                            v399 = hir.int_to_ptr v396 : ptr<byte, i32>;
                            hir.store v399, v293;
                            scf.yield ;
                        };
                        v696 = arith.constant 0 : i32;
                        v697 = arith.constant 1 : i32;
                        v669 = cf.select v385, v697, v696 : i32;
                        scf.yield v669;
                    } else {
                    ^block57:
                        v695 = arith.constant 8 : u32;
                        v348 = hir.bitcast v292 : u32;
                        v350 = arith.add v348, v695 : u32 #[overflow = checked];
                        v694 = arith.constant 4 : u32;
                        v352 = arith.mod v350, v694 : u32;
                        hir.assertz v352 #[code = 250];
                        v353 = hir.int_to_ptr v350 : ptr<byte, i32>;
                        hir.store v353, v295;
                        v693 = arith.constant 4 : u32;
                        v356 = hir.bitcast v292 : u32;
                        v358 = arith.add v356, v693 : u32 #[overflow = checked];
                        v692 = arith.constant 4 : u32;
                        v360 = arith.mod v358, v692 : u32;
                        hir.assertz v360 #[code = 250];
                        v691 = arith.constant 0 : i32;
                        v361 = hir.int_to_ptr v358 : ptr<byte, i32>;
                        hir.store v361, v691;
                        v690 = arith.constant 0 : i32;
                        scf.yield v690;
                    };
                    scf.yield v671;
                } else {
                ^block55:
                    v689 = ub.poison i32 : i32;
                    scf.yield v689;
                };
                v684 = arith.constant 0 : u32;
                v617 = arith.constant 1 : u32;
                v677 = cf.select v336, v617, v684 : u32;
                v685 = ub.poison i32 : i32;
                v676 = cf.select v336, v303, v685 : i32;
                v686 = ub.poison i32 : i32;
                v675 = cf.select v336, v292, v686 : i32;
                v687 = ub.poison i32 : i32;
                v674 = cf.select v336, v687, v303 : i32;
                v688 = ub.poison i32 : i32;
                v673 = cf.select v336, v688, v292 : i32;
                scf.yield v673, v674, v675, v672, v676, v677;
            };
            v630, v631, v632 = scf.index_switch v629 : i32, i32, i32 
            case 0 {
            ^block53:
                v683 = arith.constant 4 : u32;
                v339 = hir.bitcast v624 : u32;
                v341 = arith.add v339, v683 : u32 #[overflow = checked];
                v682 = arith.constant 4 : u32;
                v343 = arith.mod v341, v682 : u32;
                hir.assertz v343 #[code = 250];
                v681 = arith.constant 0 : i32;
                v344 = hir.int_to_ptr v341 : ptr<byte, i32>;
                hir.store v344, v681;
                v680 = arith.constant 1 : i32;
                scf.yield v624, v680, v625;
            }
            default {
            ^block99:
                scf.yield v626, v627, v628;
            };
            v418 = hir.bitcast v630 : u32;
            v679 = arith.constant 4 : u32;
            v420 = arith.mod v418, v679 : u32;
            hir.assertz v420 #[code = 250];
            v421 = hir.int_to_ptr v418 : ptr<byte, i32>;
            hir.store v421, v631;
            v678 = arith.constant 16 : i32;
            v426 = arith.add v632, v678 : i32 #[overflow = wrapping];
            v427 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v428 = hir.bitcast v427 : ptr<byte, i32>;
            hir.store v428, v426;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v429: i32, v430: i32, v431: i32) {
        ^block63(v429: i32, v430: i32, v431: i32):
            v433 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v434 = hir.bitcast v433 : ptr<byte, i32>;
            v435 = hir.load v434 : i32;
            v436 = arith.constant 16 : i32;
            v437 = arith.sub v435, v436 : i32 #[overflow = wrapping];
            v438 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v439 = hir.bitcast v438 : ptr<byte, i32>;
            hir.store v439, v437;
            v432 = arith.constant 0 : i32;
            v440 = arith.constant 8 : i32;
            v441 = arith.add v437, v440 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/adv_load_preimage/alloc::alloc::Global::alloc_impl(v441, v430, v431, v432)
            v444 = arith.constant 12 : u32;
            v443 = hir.bitcast v437 : u32;
            v445 = arith.add v443, v444 : u32 #[overflow = checked];
            v446 = arith.constant 4 : u32;
            v447 = arith.mod v445, v446 : u32;
            hir.assertz v447 #[code = 250];
            v448 = hir.int_to_ptr v445 : ptr<byte, i32>;
            v449 = hir.load v448 : i32;
            v451 = arith.constant 8 : u32;
            v450 = hir.bitcast v437 : u32;
            v452 = arith.add v450, v451 : u32 #[overflow = checked];
            v717 = arith.constant 4 : u32;
            v454 = arith.mod v452, v717 : u32;
            hir.assertz v454 #[code = 250];
            v455 = hir.int_to_ptr v452 : ptr<byte, i32>;
            v456 = hir.load v455 : i32;
            v457 = hir.bitcast v429 : u32;
            v716 = arith.constant 4 : u32;
            v459 = arith.mod v457, v716 : u32;
            hir.assertz v459 #[code = 250];
            v460 = hir.int_to_ptr v457 : ptr<byte, i32>;
            hir.store v460, v456;
            v715 = arith.constant 4 : u32;
            v461 = hir.bitcast v429 : u32;
            v463 = arith.add v461, v715 : u32 #[overflow = checked];
            v714 = arith.constant 4 : u32;
            v465 = arith.mod v463, v714 : u32;
            hir.assertz v465 #[code = 250];
            v466 = hir.int_to_ptr v463 : ptr<byte, i32>;
            hir.store v466, v449;
            v713 = arith.constant 16 : i32;
            v468 = arith.add v437, v713 : i32 #[overflow = wrapping];
            v469 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v470 = hir.bitcast v469 : ptr<byte, i32>;
            hir.store v470, v468;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v471: i32, v472: i32, v473: i32, v474: i32) {
        ^block65(v471: i32, v472: i32, v473: i32, v474: i32):
            v733 = arith.constant 0 : i32;
            v475 = arith.constant 0 : i32;
            v476 = arith.eq v473, v475 : i1;
            v477 = arith.zext v476 : u32;
            v478 = hir.bitcast v477 : i32;
            v480 = arith.neq v478, v733 : i1;
            v729 = scf.if v480 : i32 {
            ^block102:
                scf.yield v472;
            } else {
            ^block68:
                hir.exec @root_ns:root@1.0.0/adv_load_preimage/__rustc::__rust_no_alloc_shim_is_unstable_v2()
                v732 = arith.constant 0 : i32;
                v482 = arith.neq v474, v732 : i1;
                v728 = scf.if v482 : i32 {
                ^block69:
                    v484 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/__rustc::__rust_alloc_zeroed(v473, v472) : i32
                    scf.yield v484;
                } else {
                ^block70:
                    v483 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/__rustc::__rust_alloc(v473, v472) : i32
                    scf.yield v483;
                };
                scf.yield v728;
            };
            v488 = arith.constant 4 : u32;
            v487 = hir.bitcast v471 : u32;
            v489 = arith.add v487, v488 : u32 #[overflow = checked];
            v731 = arith.constant 4 : u32;
            v491 = arith.mod v489, v731 : u32;
            hir.assertz v491 #[code = 250];
            v492 = hir.int_to_ptr v489 : ptr<byte, i32>;
            hir.store v492, v473;
            v494 = hir.bitcast v471 : u32;
            v730 = arith.constant 4 : u32;
            v496 = arith.mod v494, v730 : u32;
            hir.assertz v496 #[code = 250];
            v497 = hir.int_to_ptr v494 : ptr<byte, i32>;
            hir.store v497, v729;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v498: i32, v499: i32, v500: i32) {
        ^block71(v498: i32, v499: i32, v500: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v501: i32, v502: i32) -> i32 {
        ^block73(v501: i32, v502: i32):
            v509 = arith.constant 0 : i32;
            v505 = hir.bitcast v502 : u32;
            v504 = hir.bitcast v501 : u32;
            v506 = arith.gt v504, v505 : i1;
            v507 = arith.zext v506 : u32;
            v508 = hir.bitcast v507 : i32;
            v510 = arith.neq v508, v509 : i1;
            v511 = cf.select v510, v501, v502 : i32;
            builtin.ret v511;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.segment readonly @1048576 = 0x00000000000000210000009700000028001000000000000073722e6d656d2f62696c6474732f6372732f302e352e302d7379732d62696c6474732d6e6564696d;
    };
};