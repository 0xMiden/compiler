builtin.component root_ns:root@1.0.0 {
    builtin.module public @adv_load_preimage {
        private builtin.function @miden_stdlib_sys::stdlib::mem::extern_pipe_preimage_to_memory(v0: felt, v1: i32, v2: felt, v3: felt, v4: felt, v5: felt) -> i32 {
        ^block5(v0: felt, v1: i32, v2: felt, v3: felt, v4: felt, v5: felt):
            v6 = hir.exec @std/mem/pipe_preimage_to_memory(v0, v1, v2, v3, v4, v5) : i32
            builtin.ret v6;
        };

        public builtin.function @entrypoint(v8: i32, v9: felt, v10: felt, v11: felt, v12: felt) {
        ^block11(v8: i32, v9: felt, v10: felt, v11: felt, v12: felt):
            v17 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v18 = hir.bitcast v17 : ptr<byte, i32>;
            v19 = hir.load v18 : i32;
            v20 = arith.constant 16 : i32;
            v21 = arith.sub v19, v20 : i32 #[overflow = wrapping];
            v22 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v23 = hir.bitcast v22 : ptr<byte, i32>;
            hir.store v23, v21;
            v24 = hir.exec @intrinsics/advice/adv_push_mapvaln(v12, v11, v10, v9) : felt
            v25 = hir.cast v24 : i64;
            v501 = arith.constant 0 : felt;
            v27 = arith.constant 3 : i32;
            v26 = arith.trunc v25 : i32;
            v28 = arith.band v26, v27 : i32;
            v29 = hir.bitcast v28 : felt;
            hir.assert_eq v29, v501;
            v34 = arith.constant 2 : i64;
            v36 = hir.cast v34 : u32;
            v35 = hir.bitcast v25 : u64;
            v37 = arith.shr v35, v36 : u64;
            v38 = hir.bitcast v37 : i64;
            v39 = hir.cast v38 : felt;
            v500 = arith.constant 2 : u32;
            v40 = hir.cast v39 : i64;
            v41 = arith.trunc v40 : i32;
            v44 = arith.shl v41, v500 : i32;
            v541 = arith.constant 4 : i32;
            v13 = arith.constant 0 : i32;
            v32 = arith.constant 4 : i32;
            v33 = arith.add v21, v32 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/adv_load_preimage/alloc::raw_vec::RawVecInner<A>::try_allocate_in(v33, v44, v13, v541, v541)
            v49 = arith.constant 8 : u32;
            v48 = hir.bitcast v21 : u32;
            v50 = arith.add v48, v49 : u32 #[overflow = checked];
            v51 = arith.constant 4 : u32;
            v52 = arith.mod v50, v51 : u32;
            hir.assertz v52 #[code = 250];
            v53 = hir.int_to_ptr v50 : ptr<byte, i32>;
            v54 = hir.load v53 : i32;
            v540 = arith.constant 4 : u32;
            v55 = hir.bitcast v21 : u32;
            v57 = arith.add v55, v540 : u32 #[overflow = checked];
            v539 = arith.constant 4 : u32;
            v59 = arith.mod v57, v539 : u32;
            hir.assertz v59 #[code = 250];
            v60 = hir.int_to_ptr v57 : ptr<byte, i32>;
            v61 = hir.load v60 : i32;
            v538 = arith.constant 0 : i32;
            v62 = arith.constant 1 : i32;
            v63 = arith.eq v61, v62 : i1;
            v64 = arith.zext v63 : u32;
            v65 = hir.bitcast v64 : i32;
            v67 = arith.neq v65, v538 : i1;
            v506 = scf.if v67 : u32 {
            ^block14:
                v158 = arith.constant 12 : u32;
                v157 = hir.bitcast v21 : u32;
                v159 = arith.add v157, v158 : u32 #[overflow = checked];
                v537 = arith.constant 4 : u32;
                v161 = arith.mod v159, v537 : u32;
                hir.assertz v161 #[code = 250];
                v162 = hir.int_to_ptr v159 : ptr<byte, i32>;
                v163 = hir.load v162 : i32;
                v164 = arith.constant 1048620 : i32;
                hir.exec @root_ns:root@1.0.0/adv_load_preimage/alloc::raw_vec::handle_error(v54, v163, v164)
                v502 = arith.constant 0 : u32;
                scf.yield v502;
            } else {
            ^block15:
                v536 = arith.constant 12 : u32;
                v68 = hir.bitcast v21 : u32;
                v70 = arith.add v68, v536 : u32 #[overflow = checked];
                v535 = arith.constant 4 : u32;
                v72 = arith.mod v70, v535 : u32;
                hir.assertz v72 #[code = 250];
                v73 = hir.int_to_ptr v70 : ptr<byte, i32>;
                v74 = hir.load v73 : i32;
                v534 = arith.constant 2 : u32;
                v76 = hir.bitcast v74 : u32;
                v78 = arith.shr v76, v534 : u32;
                v79 = hir.bitcast v78 : i32;
                v80 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/miden_stdlib_sys::stdlib::mem::extern_pipe_preimage_to_memory(v39, v79, v12, v11, v10, v9) : i32
                v533 = arith.constant 8 : u32;
                v81 = hir.bitcast v8 : u32;
                v83 = arith.add v81, v533 : u32 #[overflow = checked];
                v532 = arith.constant 4 : u32;
                v85 = arith.mod v83, v532 : u32;
                hir.assertz v85 #[code = 250];
                v86 = hir.int_to_ptr v83 : ptr<byte, i32>;
                hir.store v86, v44;
                v531 = arith.constant 4 : u32;
                v87 = hir.bitcast v8 : u32;
                v89 = arith.add v87, v531 : u32 #[overflow = checked];
                v530 = arith.constant 4 : u32;
                v91 = arith.mod v89, v530 : u32;
                hir.assertz v91 #[code = 250];
                v92 = hir.int_to_ptr v89 : ptr<byte, i32>;
                hir.store v92, v74;
                v93 = hir.bitcast v8 : u32;
                v529 = arith.constant 4 : u32;
                v95 = arith.mod v93, v529 : u32;
                hir.assertz v95 #[code = 250];
                v96 = hir.int_to_ptr v93 : ptr<byte, i32>;
                hir.store v96, v54;
                v527 = arith.constant 0 : i32;
                v528 = arith.constant 0 : i32;
                v98 = arith.eq v44, v528 : i1;
                v99 = arith.zext v98 : u32;
                v100 = hir.bitcast v99 : i32;
                v102 = arith.neq v100, v527 : i1;
                v508 = scf.if v102 : u32 {
                ^block65:
                    v526 = arith.constant 0 : u32;
                    scf.yield v526;
                } else {
                ^block16:
                    v103 = hir.bitcast v74 : u32;
                    v525 = arith.constant 4 : u32;
                    v105 = arith.mod v103, v525 : u32;
                    hir.assertz v105 #[code = 250];
                    v106 = hir.int_to_ptr v103 : ptr<byte, felt>;
                    v107 = hir.load v106 : felt;
                    v498 = arith.constant 1 : felt;
                    hir.assert_eq v107, v498;
                    v524 = arith.constant 4 : u32;
                    v110 = hir.bitcast v74 : u32;
                    v112 = arith.add v110, v524 : u32 #[overflow = checked];
                    v523 = arith.constant 4 : u32;
                    v114 = arith.mod v112, v523 : u32;
                    hir.assertz v114 #[code = 250];
                    v115 = hir.int_to_ptr v112 : ptr<byte, felt>;
                    v116 = hir.load v115 : felt;
                    v497 = arith.constant 2 : felt;
                    hir.assert_eq v116, v497;
                    v522 = arith.constant 0 : i32;
                    v496 = arith.constant 5 : u32;
                    v120 = hir.bitcast v44 : u32;
                    v122 = arith.lte v120, v496 : i1;
                    v123 = arith.zext v122 : u32;
                    v124 = hir.bitcast v123 : i32;
                    v126 = arith.neq v124, v522 : i1;
                    v510 = scf.if v126 : u32 {
                    ^block64:
                        v521 = arith.constant 0 : u32;
                        scf.yield v521;
                    } else {
                    ^block17:
                        v128 = arith.constant 20 : u32;
                        v127 = hir.bitcast v74 : u32;
                        v129 = arith.add v127, v128 : u32 #[overflow = checked];
                        v520 = arith.constant 4 : u32;
                        v131 = arith.mod v129, v520 : u32;
                        hir.assertz v131 #[code = 250];
                        v132 = hir.int_to_ptr v129 : ptr<byte, felt>;
                        v133 = hir.load v132 : felt;
                        v495 = arith.constant 6 : felt;
                        hir.assert_eq v133, v495;
                        v519 = arith.constant 0 : i32;
                        v494 = arith.constant 14 : u32;
                        v137 = hir.bitcast v44 : u32;
                        v139 = arith.lte v137, v494 : i1;
                        v140 = arith.zext v139 : u32;
                        v141 = hir.bitcast v140 : i32;
                        v143 = arith.neq v141, v519 : i1;
                        scf.if v143{
                        ^block63:
                            scf.yield ;
                        } else {
                        ^block18:
                            v145 = arith.constant 56 : u32;
                            v144 = hir.bitcast v74 : u32;
                            v146 = arith.add v144, v145 : u32 #[overflow = checked];
                            v518 = arith.constant 4 : u32;
                            v148 = arith.mod v146, v518 : u32;
                            hir.assertz v148 #[code = 250];
                            v149 = hir.int_to_ptr v146 : ptr<byte, felt>;
                            v150 = hir.load v149 : felt;
                            v493 = arith.constant 15 : felt;
                            hir.assert_eq v150, v493;
                            v517 = arith.constant 16 : i32;
                            v154 = arith.add v21, v517 : i32 #[overflow = wrapping];
                            v155 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
                            v156 = hir.bitcast v155 : ptr<byte, i32>;
                            hir.store v156, v154;
                            scf.yield ;
                        };
                        v504 = arith.constant 1 : u32;
                        v516 = arith.constant 0 : u32;
                        v514 = cf.select v143, v516, v504 : u32;
                        scf.yield v514;
                    };
                    scf.yield v510;
                };
                scf.yield v508;
            };
            v515 = arith.constant 0 : u32;
            v513 = arith.eq v506, v515 : i1;
            cf.cond_br v513 ^block13, ^block67;
        ^block13:
            ub.unreachable ;
        ^block67:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc(v165: i32, v166: i32) -> i32 {
        ^block19(v165: i32, v166: i32):
            v168 = arith.constant 1048636 : i32;
            v169 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v168, v166, v165) : i32
            builtin.ret v169;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v170: i32, v171: i32) -> i32 {
        ^block21(v170: i32, v171: i32):
            v173 = arith.constant 1048636 : i32;
            v174 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v173, v171, v170) : i32
            v550 = arith.constant 0 : i32;
            v175 = arith.constant 0 : i32;
            v176 = arith.eq v174, v175 : i1;
            v177 = arith.zext v176 : u32;
            v178 = hir.bitcast v177 : i32;
            v180 = arith.neq v178, v550 : i1;
            scf.if v180{
            ^block23:
                scf.yield ;
            } else {
            ^block24:
                v548 = arith.constant 0 : i32;
                v549 = arith.constant 0 : i32;
                v182 = arith.eq v170, v549 : i1;
                v183 = arith.zext v182 : u32;
                v184 = hir.bitcast v183 : i32;
                v186 = arith.neq v184, v548 : i1;
                scf.if v186{
                ^block72:
                    scf.yield ;
                } else {
                ^block25:
                    v542 = arith.constant 0 : u8;
                    v189 = hir.bitcast v170 : u32;
                    v190 = hir.bitcast v174 : u32;
                    v191 = hir.int_to_ptr v190 : ptr<byte, u8>;
                    hir.mem_set v191, v189, v542;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v174;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block26:
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v193: i32, v194: i32, v195: i32) -> i32 {
        ^block28(v193: i32, v194: i32, v195: i32):
            v198 = arith.constant 16 : i32;
            v197 = arith.constant 0 : i32;
            v552 = arith.constant 16 : u32;
            v200 = hir.bitcast v194 : u32;
            v202 = arith.gt v200, v552 : i1;
            v203 = arith.zext v202 : u32;
            v204 = hir.bitcast v203 : i32;
            v206 = arith.neq v204, v197 : i1;
            v207 = cf.select v206, v194, v198 : i32;
            v592 = arith.constant 0 : i32;
            v208 = arith.constant -1 : i32;
            v209 = arith.add v207, v208 : i32 #[overflow = wrapping];
            v210 = arith.band v207, v209 : i32;
            v212 = arith.neq v210, v592 : i1;
            v561, v562 = scf.if v212 : i32, u32 {
            ^block77:
                v553 = arith.constant 0 : u32;
                v557 = ub.poison i32 : i32;
                scf.yield v557, v553;
            } else {
            ^block31:
                v214 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/core::ptr::alignment::Alignment::max(v194, v207) : i32
                v591 = arith.constant 0 : i32;
                v213 = arith.constant -2147483648 : i32;
                v215 = arith.sub v213, v214 : i32 #[overflow = wrapping];
                v217 = hir.bitcast v215 : u32;
                v216 = hir.bitcast v195 : u32;
                v218 = arith.gt v216, v217 : i1;
                v219 = arith.zext v218 : u32;
                v220 = hir.bitcast v219 : i32;
                v222 = arith.neq v220, v591 : i1;
                v576 = scf.if v222 : i32 {
                ^block76:
                    v590 = ub.poison i32 : i32;
                    scf.yield v590;
                } else {
                ^block32:
                    v588 = arith.constant 0 : i32;
                    v228 = arith.sub v588, v214 : i32 #[overflow = wrapping];
                    v589 = arith.constant -1 : i32;
                    v224 = arith.add v195, v214 : i32 #[overflow = wrapping];
                    v226 = arith.add v224, v589 : i32 #[overflow = wrapping];
                    v229 = arith.band v226, v228 : i32;
                    v230 = hir.bitcast v193 : u32;
                    v231 = arith.constant 4 : u32;
                    v232 = arith.mod v230, v231 : u32;
                    hir.assertz v232 #[code = 250];
                    v233 = hir.int_to_ptr v230 : ptr<byte, i32>;
                    v234 = hir.load v233 : i32;
                    v587 = arith.constant 0 : i32;
                    v236 = arith.neq v234, v587 : i1;
                    scf.if v236{
                    ^block75:
                        scf.yield ;
                    } else {
                    ^block34:
                        v237 = hir.exec @intrinsics/mem/heap_base() : i32
                        v238 = hir.mem_size  : u32;
                        v244 = hir.bitcast v193 : u32;
                        v586 = arith.constant 4 : u32;
                        v246 = arith.mod v244, v586 : u32;
                        hir.assertz v246 #[code = 250];
                        v585 = arith.constant 16 : u32;
                        v239 = hir.bitcast v238 : i32;
                        v242 = arith.shl v239, v585 : i32;
                        v243 = arith.add v237, v242 : i32 #[overflow = wrapping];
                        v247 = hir.int_to_ptr v244 : ptr<byte, i32>;
                        hir.store v247, v243;
                        scf.yield ;
                    };
                    v250 = hir.bitcast v193 : u32;
                    v584 = arith.constant 4 : u32;
                    v252 = arith.mod v250, v584 : u32;
                    hir.assertz v252 #[code = 250];
                    v253 = hir.int_to_ptr v250 : ptr<byte, i32>;
                    v254 = hir.load v253 : i32;
                    v582 = arith.constant 0 : i32;
                    v583 = arith.constant -1 : i32;
                    v256 = arith.bxor v254, v583 : i32;
                    v258 = hir.bitcast v256 : u32;
                    v257 = hir.bitcast v229 : u32;
                    v259 = arith.gt v257, v258 : i1;
                    v260 = arith.zext v259 : u32;
                    v261 = hir.bitcast v260 : i32;
                    v263 = arith.neq v261, v582 : i1;
                    v575 = scf.if v263 : i32 {
                    ^block35:
                        v581 = arith.constant 0 : i32;
                        scf.yield v581;
                    } else {
                    ^block36:
                        v265 = hir.bitcast v193 : u32;
                        v580 = arith.constant 4 : u32;
                        v267 = arith.mod v265, v580 : u32;
                        hir.assertz v267 #[code = 250];
                        v264 = arith.add v254, v229 : i32 #[overflow = wrapping];
                        v268 = hir.int_to_ptr v265 : ptr<byte, i32>;
                        hir.store v268, v264;
                        v270 = arith.add v254, v214 : i32 #[overflow = wrapping];
                        scf.yield v270;
                    };
                    scf.yield v575;
                };
                v558 = arith.constant 1 : u32;
                v579 = arith.constant 0 : u32;
                v577 = cf.select v222, v579, v558 : u32;
                scf.yield v576, v577;
            };
            v578 = arith.constant 0 : u32;
            v574 = arith.eq v562, v578 : i1;
            cf.cond_br v574 ^block30, ^block79(v561);
        ^block30:
            ub.unreachable ;
        ^block79(v554: i32):
            builtin.ret v554;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::try_allocate_in(v273: i32, v274: i32, v275: i32, v276: i32, v277: i32) {
        ^block37(v273: i32, v274: i32, v275: i32, v276: i32, v277: i32):
            v280 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v281 = hir.bitcast v280 : ptr<byte, i32>;
            v282 = hir.load v281 : i32;
            v283 = arith.constant 16 : i32;
            v284 = arith.sub v282, v283 : i32 #[overflow = wrapping];
            v285 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v286 = hir.bitcast v285 : ptr<byte, i32>;
            hir.store v286, v284;
            v296 = hir.bitcast v274 : u32;
            v297 = arith.zext v296 : u64;
            v298 = hir.bitcast v297 : i64;
            v278 = arith.constant 0 : i32;
            v291 = arith.sub v278, v276 : i32 #[overflow = wrapping];
            v288 = arith.constant -1 : i32;
            v287 = arith.add v276, v277 : i32 #[overflow = wrapping];
            v289 = arith.add v287, v288 : i32 #[overflow = wrapping];
            v292 = arith.band v289, v291 : i32;
            v293 = hir.bitcast v292 : u32;
            v294 = arith.zext v293 : u64;
            v295 = hir.bitcast v294 : i64;
            v299 = arith.mul v295, v298 : i64 #[overflow = wrapping];
            v696 = arith.constant 0 : i32;
            v300 = arith.constant 32 : i64;
            v302 = hir.cast v300 : u32;
            v301 = hir.bitcast v299 : u64;
            v303 = arith.shr v301, v302 : u64;
            v304 = hir.bitcast v303 : i64;
            v305 = arith.trunc v304 : i32;
            v307 = arith.neq v305, v696 : i1;
            v608, v609, v610, v611, v612, v613 = scf.if v307 : i32, i32, i32, i32, i32, u32 {
            ^block83:
                v593 = arith.constant 0 : u32;
                v600 = ub.poison i32 : i32;
                scf.yield v273, v284, v600, v600, v600, v593;
            } else {
            ^block42:
                v308 = arith.trunc v299 : i32;
                v695 = arith.constant 0 : i32;
                v309 = arith.constant -2147483648 : i32;
                v310 = arith.sub v309, v276 : i32 #[overflow = wrapping];
                v312 = hir.bitcast v310 : u32;
                v311 = hir.bitcast v308 : u32;
                v313 = arith.lte v311, v312 : i1;
                v314 = arith.zext v313 : u32;
                v315 = hir.bitcast v314 : i32;
                v317 = arith.neq v315, v695 : i1;
                v656 = scf.if v317 : i32 {
                ^block40:
                    v694 = arith.constant 0 : i32;
                    v328 = arith.neq v308, v694 : i1;
                    v655 = scf.if v328 : i32 {
                    ^block44:
                        v693 = arith.constant 0 : i32;
                        v344 = arith.neq v275, v693 : i1;
                        v654 = scf.if v344 : i32 {
                        ^block47:
                            v326 = arith.constant 1 : i32;
                            hir.exec @root_ns:root@1.0.0/adv_load_preimage/alloc::alloc::Global::alloc_impl(v284, v276, v308, v326)
                            v355 = hir.bitcast v284 : u32;
                            v400 = arith.constant 4 : u32;
                            v357 = arith.mod v355, v400 : u32;
                            hir.assertz v357 #[code = 250];
                            v358 = hir.int_to_ptr v355 : ptr<byte, i32>;
                            v359 = hir.load v358 : i32;
                            scf.yield v359;
                        } else {
                        ^block48:
                            v345 = arith.constant 8 : i32;
                            v346 = arith.add v284, v345 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/adv_load_preimage/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v346, v276, v308)
                            v330 = arith.constant 8 : u32;
                            v347 = hir.bitcast v284 : u32;
                            v349 = arith.add v347, v330 : u32 #[overflow = checked];
                            v692 = arith.constant 4 : u32;
                            v351 = arith.mod v349, v692 : u32;
                            hir.assertz v351 #[code = 250];
                            v352 = hir.int_to_ptr v349 : ptr<byte, i32>;
                            v353 = hir.load v352 : i32;
                            scf.yield v353;
                        };
                        v690 = arith.constant 0 : i32;
                        v691 = arith.constant 0 : i32;
                        v362 = arith.eq v654, v691 : i1;
                        v363 = arith.zext v362 : u32;
                        v364 = hir.bitcast v363 : i32;
                        v366 = arith.neq v364, v690 : i1;
                        scf.if v366{
                        ^block49:
                            v689 = arith.constant 8 : u32;
                            v383 = hir.bitcast v273 : u32;
                            v385 = arith.add v383, v689 : u32 #[overflow = checked];
                            v688 = arith.constant 4 : u32;
                            v387 = arith.mod v385, v688 : u32;
                            hir.assertz v387 #[code = 250];
                            v388 = hir.int_to_ptr v385 : ptr<byte, i32>;
                            hir.store v388, v308;
                            v687 = arith.constant 4 : u32;
                            v390 = hir.bitcast v273 : u32;
                            v392 = arith.add v390, v687 : u32 #[overflow = checked];
                            v686 = arith.constant 4 : u32;
                            v394 = arith.mod v392, v686 : u32;
                            hir.assertz v394 #[code = 250];
                            v395 = hir.int_to_ptr v392 : ptr<byte, i32>;
                            hir.store v395, v276;
                            scf.yield ;
                        } else {
                        ^block50:
                            v685 = arith.constant 8 : u32;
                            v368 = hir.bitcast v273 : u32;
                            v370 = arith.add v368, v685 : u32 #[overflow = checked];
                            v684 = arith.constant 4 : u32;
                            v372 = arith.mod v370, v684 : u32;
                            hir.assertz v372 #[code = 250];
                            v373 = hir.int_to_ptr v370 : ptr<byte, i32>;
                            hir.store v373, v654;
                            v683 = arith.constant 4 : u32;
                            v375 = hir.bitcast v273 : u32;
                            v377 = arith.add v375, v683 : u32 #[overflow = checked];
                            v682 = arith.constant 4 : u32;
                            v379 = arith.mod v377, v682 : u32;
                            hir.assertz v379 #[code = 250];
                            v380 = hir.int_to_ptr v377 : ptr<byte, i32>;
                            hir.store v380, v274;
                            scf.yield ;
                        };
                        v680 = arith.constant 0 : i32;
                        v681 = arith.constant 1 : i32;
                        v653 = cf.select v366, v681, v680 : i32;
                        scf.yield v653;
                    } else {
                    ^block45:
                        v679 = arith.constant 8 : u32;
                        v329 = hir.bitcast v273 : u32;
                        v331 = arith.add v329, v679 : u32 #[overflow = checked];
                        v678 = arith.constant 4 : u32;
                        v333 = arith.mod v331, v678 : u32;
                        hir.assertz v333 #[code = 250];
                        v334 = hir.int_to_ptr v331 : ptr<byte, i32>;
                        hir.store v334, v276;
                        v677 = arith.constant 4 : u32;
                        v337 = hir.bitcast v273 : u32;
                        v339 = arith.add v337, v677 : u32 #[overflow = checked];
                        v676 = arith.constant 4 : u32;
                        v341 = arith.mod v339, v676 : u32;
                        hir.assertz v341 #[code = 250];
                        v675 = arith.constant 0 : i32;
                        v342 = hir.int_to_ptr v339 : ptr<byte, i32>;
                        hir.store v342, v675;
                        v674 = arith.constant 0 : i32;
                        scf.yield v674;
                    };
                    scf.yield v655;
                } else {
                ^block43:
                    v673 = ub.poison i32 : i32;
                    scf.yield v673;
                };
                v668 = arith.constant 0 : u32;
                v601 = arith.constant 1 : u32;
                v661 = cf.select v317, v601, v668 : u32;
                v669 = ub.poison i32 : i32;
                v660 = cf.select v317, v284, v669 : i32;
                v670 = ub.poison i32 : i32;
                v659 = cf.select v317, v273, v670 : i32;
                v671 = ub.poison i32 : i32;
                v658 = cf.select v317, v671, v284 : i32;
                v672 = ub.poison i32 : i32;
                v657 = cf.select v317, v672, v273 : i32;
                scf.yield v657, v658, v659, v656, v660, v661;
            };
            v614, v615, v616 = scf.index_switch v613 : i32, i32, i32 
            case 0 {
            ^block41:
                v667 = arith.constant 4 : u32;
                v320 = hir.bitcast v608 : u32;
                v322 = arith.add v320, v667 : u32 #[overflow = checked];
                v666 = arith.constant 4 : u32;
                v324 = arith.mod v322, v666 : u32;
                hir.assertz v324 #[code = 250];
                v665 = arith.constant 0 : i32;
                v325 = hir.int_to_ptr v322 : ptr<byte, i32>;
                hir.store v325, v665;
                v664 = arith.constant 1 : i32;
                scf.yield v608, v664, v609;
            }
            default {
            ^block87:
                scf.yield v610, v611, v612;
            };
            v399 = hir.bitcast v614 : u32;
            v663 = arith.constant 4 : u32;
            v401 = arith.mod v399, v663 : u32;
            hir.assertz v401 #[code = 250];
            v402 = hir.int_to_ptr v399 : ptr<byte, i32>;
            hir.store v402, v615;
            v662 = arith.constant 16 : i32;
            v407 = arith.add v616, v662 : i32 #[overflow = wrapping];
            v408 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v409 = hir.bitcast v408 : ptr<byte, i32>;
            hir.store v409, v407;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v410: i32, v411: i32, v412: i32) {
        ^block51(v410: i32, v411: i32, v412: i32):
            v414 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v415 = hir.bitcast v414 : ptr<byte, i32>;
            v416 = hir.load v415 : i32;
            v417 = arith.constant 16 : i32;
            v418 = arith.sub v416, v417 : i32 #[overflow = wrapping];
            v419 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v420 = hir.bitcast v419 : ptr<byte, i32>;
            hir.store v420, v418;
            v413 = arith.constant 0 : i32;
            v421 = arith.constant 8 : i32;
            v422 = arith.add v418, v421 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/adv_load_preimage/alloc::alloc::Global::alloc_impl(v422, v411, v412, v413)
            v425 = arith.constant 12 : u32;
            v424 = hir.bitcast v418 : u32;
            v426 = arith.add v424, v425 : u32 #[overflow = checked];
            v427 = arith.constant 4 : u32;
            v428 = arith.mod v426, v427 : u32;
            hir.assertz v428 #[code = 250];
            v429 = hir.int_to_ptr v426 : ptr<byte, i32>;
            v430 = hir.load v429 : i32;
            v432 = arith.constant 8 : u32;
            v431 = hir.bitcast v418 : u32;
            v433 = arith.add v431, v432 : u32 #[overflow = checked];
            v701 = arith.constant 4 : u32;
            v435 = arith.mod v433, v701 : u32;
            hir.assertz v435 #[code = 250];
            v436 = hir.int_to_ptr v433 : ptr<byte, i32>;
            v437 = hir.load v436 : i32;
            v438 = hir.bitcast v410 : u32;
            v700 = arith.constant 4 : u32;
            v440 = arith.mod v438, v700 : u32;
            hir.assertz v440 #[code = 250];
            v441 = hir.int_to_ptr v438 : ptr<byte, i32>;
            hir.store v441, v437;
            v699 = arith.constant 4 : u32;
            v442 = hir.bitcast v410 : u32;
            v444 = arith.add v442, v699 : u32 #[overflow = checked];
            v698 = arith.constant 4 : u32;
            v446 = arith.mod v444, v698 : u32;
            hir.assertz v446 #[code = 250];
            v447 = hir.int_to_ptr v444 : ptr<byte, i32>;
            hir.store v447, v430;
            v697 = arith.constant 16 : i32;
            v449 = arith.add v418, v697 : i32 #[overflow = wrapping];
            v450 = builtin.global_symbol @root_ns:root@1.0.0/adv_load_preimage/__stack_pointer : ptr<byte, u8>
            v451 = hir.bitcast v450 : ptr<byte, i32>;
            hir.store v451, v449;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v452: i32, v453: i32, v454: i32, v455: i32) {
        ^block53(v452: i32, v453: i32, v454: i32, v455: i32):
            v717 = arith.constant 0 : i32;
            v456 = arith.constant 0 : i32;
            v457 = arith.eq v454, v456 : i1;
            v458 = arith.zext v457 : u32;
            v459 = hir.bitcast v458 : i32;
            v461 = arith.neq v459, v717 : i1;
            v713 = scf.if v461 : i32 {
            ^block90:
                scf.yield v453;
            } else {
            ^block56:
                hir.exec @root_ns:root@1.0.0/adv_load_preimage/__rustc::__rust_no_alloc_shim_is_unstable_v2()
                v716 = arith.constant 0 : i32;
                v463 = arith.neq v455, v716 : i1;
                v712 = scf.if v463 : i32 {
                ^block57:
                    v465 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/__rustc::__rust_alloc_zeroed(v454, v453) : i32
                    scf.yield v465;
                } else {
                ^block58:
                    v464 = hir.exec @root_ns:root@1.0.0/adv_load_preimage/__rustc::__rust_alloc(v454, v453) : i32
                    scf.yield v464;
                };
                scf.yield v712;
            };
            v469 = arith.constant 4 : u32;
            v468 = hir.bitcast v452 : u32;
            v470 = arith.add v468, v469 : u32 #[overflow = checked];
            v715 = arith.constant 4 : u32;
            v472 = arith.mod v470, v715 : u32;
            hir.assertz v472 #[code = 250];
            v473 = hir.int_to_ptr v470 : ptr<byte, i32>;
            hir.store v473, v454;
            v475 = hir.bitcast v452 : u32;
            v714 = arith.constant 4 : u32;
            v477 = arith.mod v475, v714 : u32;
            hir.assertz v477 #[code = 250];
            v478 = hir.int_to_ptr v475 : ptr<byte, i32>;
            hir.store v478, v713;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v479: i32, v480: i32, v481: i32) {
        ^block59(v479: i32, v480: i32, v481: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v482: i32, v483: i32) -> i32 {
        ^block61(v482: i32, v483: i32):
            v490 = arith.constant 0 : i32;
            v486 = hir.bitcast v483 : u32;
            v485 = hir.bitcast v482 : u32;
            v487 = arith.gt v485, v486 : i1;
            v488 = arith.zext v487 : u32;
            v489 = hir.bitcast v488 : i32;
            v491 = arith.neq v489, v490 : i1;
            v492 = cf.select v491, v482, v483 : i32;
            builtin.ret v492;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.segment readonly @1048576 = 0x00000000000000210000009800000028001000000000000073722e6d656d2f62696c6474732f6372732f302e342e302d7379732d62696c6474732d6e6564696d;
    };
};