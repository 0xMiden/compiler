builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_words {
        private builtin.function @__rustc::__rust_dealloc(v0: i32, v1: i32, v2: i32) {
        ^block4(v0: i32, v1: i32, v2: i32):
            builtin.ret ;
        };

        public builtin.function @entrypoint(v3: i32) -> felt {
        ^block6(v3: i32):
            v7 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v8 = hir.bitcast v7 : ptr<byte, i32>;
            v9 = hir.load v8 : i32;
            v10 = arith.constant 48 : i32;
            v11 = arith.sub v9, v10 : i32 #[overflow = wrapping];
            v12 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v13 = hir.bitcast v12 : ptr<byte, i32>;
            hir.store v13, v11;
            v15 = arith.constant 4 : u32;
            v14 = hir.bitcast v3 : u32;
            v16 = arith.add v14, v15 : u32 #[overflow = checked];
            v307 = arith.constant 4 : u32;
            v18 = arith.mod v16, v307 : u32;
            hir.assertz v18 #[code = 250];
            v19 = hir.int_to_ptr v16 : ptr<byte, i32>;
            v20 = hir.load v19 : i32;
            v22 = arith.constant 8 : u32;
            v21 = hir.bitcast v3 : u32;
            v23 = arith.add v21, v22 : u32 #[overflow = checked];
            v306 = arith.constant 4 : u32;
            v25 = arith.mod v23, v306 : u32;
            hir.assertz v25 #[code = 250];
            v26 = hir.int_to_ptr v23 : ptr<byte, i32>;
            v27 = hir.load v26 : i32;
            v297 = arith.constant 0 : felt;
            hir.assert_eq v297, v297;
            v295 = arith.constant 2 : u32;
            v33 = hir.bitcast v20 : u32;
            v35 = arith.shr v33, v295 : u32;
            v36 = hir.bitcast v35 : i32;
            v41 = arith.constant 16 : i32;
            v42 = arith.add v11, v41 : i32 #[overflow = wrapping];
            v305 = arith.constant 2 : u32;
            v39 = arith.shl v27, v305 : i32;
            v40 = arith.add v36, v39 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_words/std::crypto::hashes::rpo::hash_memory_words(v36, v40, v42)
            v44 = arith.constant 24 : u32;
            v43 = hir.bitcast v11 : u32;
            v45 = arith.add v43, v44 : u32 #[overflow = checked];
            v304 = arith.constant 8 : u32;
            v47 = arith.mod v45, v304 : u32;
            hir.assertz v47 #[code = 250];
            v48 = hir.int_to_ptr v45 : ptr<byte, i64>;
            v49 = hir.load v48 : i64;
            v51 = arith.constant 40 : u32;
            v50 = hir.bitcast v11 : u32;
            v52 = arith.add v50, v51 : u32 #[overflow = checked];
            v303 = arith.constant 8 : u32;
            v54 = arith.mod v52, v303 : u32;
            hir.assertz v54 #[code = 250];
            v55 = hir.int_to_ptr v52 : ptr<byte, i64>;
            hir.store v55, v49;
            v57 = arith.constant 16 : u32;
            v56 = hir.bitcast v11 : u32;
            v58 = arith.add v56, v57 : u32 #[overflow = checked];
            v302 = arith.constant 8 : u32;
            v60 = arith.mod v58, v302 : u32;
            hir.assertz v60 #[code = 250];
            v61 = hir.int_to_ptr v58 : ptr<byte, i64>;
            v62 = hir.load v61 : i64;
            v64 = arith.constant 32 : u32;
            v63 = hir.bitcast v11 : u32;
            v65 = arith.add v63, v64 : u32 #[overflow = checked];
            v301 = arith.constant 8 : u32;
            v67 = arith.mod v65, v301 : u32;
            hir.assertz v67 #[code = 250];
            v68 = hir.int_to_ptr v65 : ptr<byte, i64>;
            hir.store v68, v62;
            v69 = arith.constant 32 : i32;
            v70 = arith.add v11, v69 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_words/<miden_stdlib_sys::intrinsics::word::Word>::reverse(v11, v70)
            v71 = hir.bitcast v11 : u32;
            v300 = arith.constant 4 : u32;
            v73 = arith.mod v71, v300 : u32;
            hir.assertz v73 #[code = 250];
            v74 = hir.int_to_ptr v71 : ptr<byte, felt>;
            v75 = hir.load v74 : felt;
            v299 = arith.constant 16 : i32;
            hir.exec @root_ns:root@1.0.0/hash_words/<alloc::raw_vec::RawVecInner>::deallocate(v3, v299, v299)
            v298 = arith.constant 48 : i32;
            v79 = arith.add v11, v298 : i32 #[overflow = wrapping];
            v80 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v81 = hir.bitcast v80 : ptr<byte, i32>;
            hir.store v81, v79;
            builtin.ret v75;
        };

        private builtin.function @<miden_stdlib_sys::intrinsics::word::Word>::reverse(v82: i32, v83: i32) {
        ^block8(v82: i32, v83: i32):
            v86 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v87 = hir.bitcast v86 : ptr<byte, i32>;
            v88 = hir.load v87 : i32;
            v89 = arith.constant 16 : i32;
            v90 = arith.sub v88, v89 : i32 #[overflow = wrapping];
            v92 = arith.constant 8 : u32;
            v91 = hir.bitcast v83 : u32;
            v93 = arith.add v91, v92 : u32 #[overflow = checked];
            v394 = arith.constant 8 : u32;
            v95 = arith.mod v93, v394 : u32;
            hir.assertz v95 #[code = 250];
            v96 = hir.int_to_ptr v93 : ptr<byte, i64>;
            v97 = hir.load v96 : i64;
            v393 = arith.constant 8 : u32;
            v98 = hir.bitcast v90 : u32;
            v100 = arith.add v98, v393 : u32 #[overflow = checked];
            v101 = arith.constant 4 : u32;
            v102 = arith.mod v100, v101 : u32;
            hir.assertz v102 #[code = 250];
            v103 = hir.int_to_ptr v100 : ptr<byte, i64>;
            hir.store v103, v97;
            v104 = hir.bitcast v83 : u32;
            v392 = arith.constant 8 : u32;
            v106 = arith.mod v104, v392 : u32;
            hir.assertz v106 #[code = 250];
            v107 = hir.int_to_ptr v104 : ptr<byte, i64>;
            v108 = hir.load v107 : i64;
            v109 = hir.bitcast v90 : u32;
            v391 = arith.constant 4 : u32;
            v111 = arith.mod v109, v391 : u32;
            hir.assertz v111 #[code = 250];
            v112 = hir.int_to_ptr v109 : ptr<byte, i64>;
            hir.store v112, v108;
            v113 = arith.constant 12 : i32;
            v114 = arith.add v90, v113 : i32 #[overflow = wrapping];
            v84 = arith.constant 0 : i32;
            v362, v363, v364, v365, v366, v367 = scf.while v84, v90, v114, v82 : i32, i32, i32, i32, i32, i32 {
            ^block40(v368: i32, v369: i32, v370: i32, v371: i32):
                v390 = arith.constant 0 : i32;
                v117 = arith.constant 8 : i32;
                v118 = arith.eq v368, v117 : i1;
                v119 = arith.zext v118 : u32;
                v120 = hir.bitcast v119 : i32;
                v122 = arith.neq v120, v390 : i1;
                v356, v357 = scf.if v122 : i32, i32 {
                ^block39:
                    v316 = ub.poison i32 : i32;
                    scf.yield v316, v316;
                } else {
                ^block13:
                    v124 = arith.add v369, v368 : i32 #[overflow = wrapping];
                    v125 = hir.bitcast v124 : u32;
                    v389 = arith.constant 4 : u32;
                    v127 = arith.mod v125, v389 : u32;
                    hir.assertz v127 #[code = 250];
                    v128 = hir.int_to_ptr v125 : ptr<byte, felt>;
                    v129 = hir.load v128 : felt;
                    v131 = hir.bitcast v370 : u32;
                    v388 = arith.constant 4 : u32;
                    v133 = arith.mod v131, v388 : u32;
                    hir.assertz v133 #[code = 250];
                    v134 = hir.int_to_ptr v131 : ptr<byte, i32>;
                    v135 = hir.load v134 : i32;
                    v136 = hir.bitcast v124 : u32;
                    v387 = arith.constant 4 : u32;
                    v138 = arith.mod v136, v387 : u32;
                    hir.assertz v138 #[code = 250];
                    v139 = hir.int_to_ptr v136 : ptr<byte, i32>;
                    hir.store v139, v135;
                    v140 = hir.bitcast v370 : u32;
                    v386 = arith.constant 4 : u32;
                    v142 = arith.mod v140, v386 : u32;
                    hir.assertz v142 #[code = 250];
                    v143 = hir.int_to_ptr v140 : ptr<byte, felt>;
                    hir.store v143, v129;
                    v146 = arith.constant -4 : i32;
                    v147 = arith.add v370, v146 : i32 #[overflow = wrapping];
                    v144 = arith.constant 4 : i32;
                    v145 = arith.add v368, v144 : i32 #[overflow = wrapping];
                    scf.yield v145, v147;
                };
                v384 = ub.poison i32 : i32;
                v359 = cf.select v122, v384, v371 : i32;
                v385 = ub.poison i32 : i32;
                v358 = cf.select v122, v385, v369 : i32;
                v315 = arith.constant 1 : u32;
                v308 = arith.constant 0 : u32;
                v361 = cf.select v122, v308, v315 : u32;
                v349 = arith.trunc v361 : i1;
                scf.condition v349, v356, v358, v357, v359, v369, v371;
            } do {
            ^block41(v372: i32, v373: i32, v374: i32, v375: i32, v376: i32, v377: i32):
                scf.yield v372, v373, v374, v375;
            };
            v383 = arith.constant 8 : u32;
            v149 = hir.bitcast v366 : u32;
            v151 = arith.add v149, v383 : u32 #[overflow = checked];
            v382 = arith.constant 4 : u32;
            v153 = arith.mod v151, v382 : u32;
            hir.assertz v153 #[code = 250];
            v154 = hir.int_to_ptr v151 : ptr<byte, i64>;
            v155 = hir.load v154 : i64;
            v381 = arith.constant 8 : u32;
            v156 = hir.bitcast v367 : u32;
            v158 = arith.add v156, v381 : u32 #[overflow = checked];
            v380 = arith.constant 8 : u32;
            v160 = arith.mod v158, v380 : u32;
            hir.assertz v160 #[code = 250];
            v161 = hir.int_to_ptr v158 : ptr<byte, i64>;
            hir.store v161, v155;
            v162 = hir.bitcast v366 : u32;
            v379 = arith.constant 4 : u32;
            v164 = arith.mod v162, v379 : u32;
            hir.assertz v164 #[code = 250];
            v165 = hir.int_to_ptr v162 : ptr<byte, i64>;
            v166 = hir.load v165 : i64;
            v167 = hir.bitcast v367 : u32;
            v378 = arith.constant 8 : u32;
            v169 = arith.mod v167, v378 : u32;
            hir.assertz v169 #[code = 250];
            v170 = hir.int_to_ptr v167 : ptr<byte, i64>;
            hir.store v170, v166;
            builtin.ret ;
        };

        private builtin.function @std::crypto::hashes::rpo::hash_memory_words(v171: i32, v172: i32, v173: i32) {
        ^block14(v171: i32, v172: i32, v173: i32):
            v174, v175, v176, v177 = hir.exec @std/crypto/hashes/rpo/hash_memory_words(v171, v172) : felt, felt, felt, felt
            v178 = hir.bitcast v173 : u32;
            v179 = hir.int_to_ptr v178 : ptr<byte, felt>;
            hir.store v179, v174;
            v180 = arith.constant 4 : u32;
            v181 = arith.add v178, v180 : u32 #[overflow = checked];
            v182 = hir.int_to_ptr v181 : ptr<byte, felt>;
            hir.store v182, v175;
            v183 = arith.constant 8 : u32;
            v184 = arith.add v178, v183 : u32 #[overflow = checked];
            v185 = hir.int_to_ptr v184 : ptr<byte, felt>;
            hir.store v185, v176;
            v186 = arith.constant 12 : u32;
            v187 = arith.add v178, v186 : u32 #[overflow = checked];
            v188 = hir.int_to_ptr v187 : ptr<byte, felt>;
            hir.store v188, v177;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::deallocate(v189: i32, v190: i32, v191: i32) {
        ^block20(v189: i32, v190: i32, v191: i32):
            v193 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v194 = hir.bitcast v193 : ptr<byte, i32>;
            v195 = hir.load v194 : i32;
            v196 = arith.constant 16 : i32;
            v197 = arith.sub v195, v196 : i32 #[overflow = wrapping];
            v198 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v199 = hir.bitcast v198 : ptr<byte, i32>;
            hir.store v199, v197;
            v200 = arith.constant 4 : i32;
            v201 = arith.add v197, v200 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_words/<alloc::raw_vec::RawVecInner>::current_memory(v201, v189, v190, v191)
            v203 = arith.constant 8 : u32;
            v202 = hir.bitcast v197 : u32;
            v204 = arith.add v202, v203 : u32 #[overflow = checked];
            v205 = arith.constant 4 : u32;
            v206 = arith.mod v204, v205 : u32;
            hir.assertz v206 #[code = 250];
            v207 = hir.int_to_ptr v204 : ptr<byte, i32>;
            v208 = hir.load v207 : i32;
            v401 = arith.constant 0 : i32;
            v192 = arith.constant 0 : i32;
            v210 = arith.eq v208, v192 : i1;
            v211 = arith.zext v210 : u32;
            v212 = hir.bitcast v211 : i32;
            v214 = arith.neq v212, v401 : i1;
            scf.if v214{
            ^block42:
                scf.yield ;
            } else {
            ^block23:
                v400 = arith.constant 4 : u32;
                v215 = hir.bitcast v197 : u32;
                v217 = arith.add v215, v400 : u32 #[overflow = checked];
                v399 = arith.constant 4 : u32;
                v219 = arith.mod v217, v399 : u32;
                hir.assertz v219 #[code = 250];
                v220 = hir.int_to_ptr v217 : ptr<byte, i32>;
                v221 = hir.load v220 : i32;
                v223 = arith.constant 12 : u32;
                v222 = hir.bitcast v197 : u32;
                v224 = arith.add v222, v223 : u32 #[overflow = checked];
                v398 = arith.constant 4 : u32;
                v226 = arith.mod v224, v398 : u32;
                hir.assertz v226 #[code = 250];
                v227 = hir.int_to_ptr v224 : ptr<byte, i32>;
                v228 = hir.load v227 : i32;
                hir.exec @root_ns:root@1.0.0/hash_words/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v221, v208, v228)
                scf.yield ;
            };
            v397 = arith.constant 16 : i32;
            v231 = arith.add v197, v397 : i32 #[overflow = wrapping];
            v232 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v233 = hir.bitcast v232 : ptr<byte, i32>;
            hir.store v233, v231;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::current_memory(v234: i32, v235: i32, v236: i32, v237: i32) {
        ^block24(v234: i32, v235: i32, v236: i32, v237: i32):
            v427 = arith.constant 0 : i32;
            v238 = arith.constant 0 : i32;
            v242 = arith.eq v237, v238 : i1;
            v243 = arith.zext v242 : u32;
            v244 = hir.bitcast v243 : i32;
            v246 = arith.neq v244, v427 : i1;
            v414, v415 = scf.if v246 : i32, i32 {
            ^block45:
                v426 = arith.constant 0 : i32;
                v240 = arith.constant 4 : i32;
                scf.yield v240, v426;
            } else {
            ^block27:
                v247 = hir.bitcast v235 : u32;
                v282 = arith.constant 4 : u32;
                v249 = arith.mod v247, v282 : u32;
                hir.assertz v249 #[code = 250];
                v250 = hir.int_to_ptr v247 : ptr<byte, i32>;
                v251 = hir.load v250 : i32;
                v424 = arith.constant 0 : i32;
                v425 = arith.constant 0 : i32;
                v253 = arith.eq v251, v425 : i1;
                v254 = arith.zext v253 : u32;
                v255 = hir.bitcast v254 : i32;
                v257 = arith.neq v255, v424 : i1;
                v412 = scf.if v257 : i32 {
                ^block44:
                    v423 = arith.constant 0 : i32;
                    scf.yield v423;
                } else {
                ^block28:
                    v422 = arith.constant 4 : u32;
                    v258 = hir.bitcast v234 : u32;
                    v260 = arith.add v258, v422 : u32 #[overflow = checked];
                    v421 = arith.constant 4 : u32;
                    v262 = arith.mod v260, v421 : u32;
                    hir.assertz v262 #[code = 250];
                    v263 = hir.int_to_ptr v260 : ptr<byte, i32>;
                    hir.store v263, v236;
                    v420 = arith.constant 4 : u32;
                    v264 = hir.bitcast v235 : u32;
                    v266 = arith.add v264, v420 : u32 #[overflow = checked];
                    v419 = arith.constant 4 : u32;
                    v268 = arith.mod v266, v419 : u32;
                    hir.assertz v268 #[code = 250];
                    v269 = hir.int_to_ptr v266 : ptr<byte, i32>;
                    v270 = hir.load v269 : i32;
                    v271 = hir.bitcast v234 : u32;
                    v418 = arith.constant 4 : u32;
                    v273 = arith.mod v271, v418 : u32;
                    hir.assertz v273 #[code = 250];
                    v274 = hir.int_to_ptr v271 : ptr<byte, i32>;
                    hir.store v274, v270;
                    v275 = arith.mul v251, v237 : i32 #[overflow = wrapping];
                    scf.yield v275;
                };
                v276 = arith.constant 8 : i32;
                v417 = arith.constant 4 : i32;
                v413 = cf.select v257, v417, v276 : i32;
                scf.yield v413, v412;
            };
            v279 = arith.add v234, v414 : i32 #[overflow = wrapping];
            v281 = hir.bitcast v279 : u32;
            v416 = arith.constant 4 : u32;
            v283 = arith.mod v281, v416 : u32;
            hir.assertz v283 #[code = 250];
            v284 = hir.int_to_ptr v281 : ptr<byte, i32>;
            hir.store v284, v415;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v285: i32, v286: i32, v287: i32) {
        ^block29(v285: i32, v286: i32, v287: i32):
            v429 = arith.constant 0 : i32;
            v288 = arith.constant 0 : i32;
            v289 = arith.eq v287, v288 : i1;
            v290 = arith.zext v289 : u32;
            v291 = hir.bitcast v290 : i32;
            v293 = arith.neq v291, v429 : i1;
            scf.if v293{
            ^block31:
                scf.yield ;
            } else {
            ^block32:
                hir.exec @root_ns:root@1.0.0/hash_words/__rustc::__rust_dealloc(v285, v287, v286)
                scf.yield ;
            };
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};