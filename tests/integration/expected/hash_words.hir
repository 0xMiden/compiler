builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_words {
        private builtin.function @__rustc::__rust_dealloc(v0: i32, v1: i32, v2: i32) {
        ^block4(v0: i32, v1: i32, v2: i32):
            builtin.ret ;
        };

        public builtin.function @entrypoint(v3: i32) -> felt {
        ^block6(v3: i32):
            v7 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v8 = hir.bitcast v7 : ptr<byte, i32>;
            v9 = hir.load v8 : i32;
            v10 = arith.constant 16 : i32;
            v11 = arith.sub v9, v10 : i32 #[overflow = wrapping];
            v12 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v13 = hir.bitcast v12 : ptr<byte, i32>;
            hir.store v13, v11;
            v15 = arith.constant 4 : u32;
            v14 = hir.bitcast v3 : u32;
            v16 = arith.add v14, v15 : u32 #[overflow = checked];
            v186 = arith.constant 4 : u32;
            v18 = arith.mod v16, v186 : u32;
            hir.assertz v18 #[code = 250];
            v19 = hir.int_to_ptr v16 : ptr<byte, i32>;
            v20 = hir.load v19 : i32;
            v22 = arith.constant 8 : u32;
            v21 = hir.bitcast v3 : u32;
            v23 = arith.add v21, v22 : u32 #[overflow = checked];
            v185 = arith.constant 4 : u32;
            v25 = arith.mod v23, v185 : u32;
            hir.assertz v25 #[code = 250];
            v26 = hir.int_to_ptr v23 : ptr<byte, i32>;
            v27 = hir.load v26 : i32;
            v180 = arith.constant 0 : felt;
            hir.assert_eq v180, v180;
            v178 = arith.constant 2 : u32;
            v33 = hir.bitcast v20 : u32;
            v35 = arith.shr v33, v178 : u32;
            v36 = hir.bitcast v35 : i32;
            v184 = arith.constant 2 : u32;
            v39 = arith.shl v27, v184 : i32;
            v40 = arith.add v36, v39 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_words/std::crypto::hashes::rpo::hash_memory_words(v36, v40, v11)
            v42 = arith.constant 12 : u32;
            v41 = hir.bitcast v11 : u32;
            v43 = arith.add v41, v42 : u32 #[overflow = checked];
            v183 = arith.constant 4 : u32;
            v45 = arith.mod v43, v183 : u32;
            hir.assertz v45 #[code = 250];
            v46 = hir.int_to_ptr v43 : ptr<byte, felt>;
            v47 = hir.load v46 : felt;
            v182 = arith.constant 16 : i32;
            hir.exec @root_ns:root@1.0.0/hash_words/<alloc::raw_vec::RawVecInner>::deallocate(v3, v182, v182)
            v181 = arith.constant 16 : i32;
            v51 = arith.add v11, v181 : i32 #[overflow = wrapping];
            v52 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v53 = hir.bitcast v52 : ptr<byte, i32>;
            hir.store v53, v51;
            builtin.ret v47;
        };

        private builtin.function @std::crypto::hashes::rpo::hash_memory_words(v54: i32, v55: i32, v56: i32) {
        ^block8(v54: i32, v55: i32, v56: i32):
            v57, v58, v59, v60 = hir.exec @std/crypto/hashes/rpo/hash_memory_words(v54, v55) : felt, felt, felt, felt
            v61 = hir.bitcast v56 : u32;
            v62 = hir.int_to_ptr v61 : ptr<byte, felt>;
            hir.store v62, v57;
            v63 = arith.constant 4 : u32;
            v64 = arith.add v61, v63 : u32 #[overflow = checked];
            v65 = hir.int_to_ptr v64 : ptr<byte, felt>;
            hir.store v65, v58;
            v66 = arith.constant 8 : u32;
            v67 = arith.add v61, v66 : u32 #[overflow = checked];
            v68 = hir.int_to_ptr v67 : ptr<byte, felt>;
            hir.store v68, v59;
            v69 = arith.constant 12 : u32;
            v70 = arith.add v61, v69 : u32 #[overflow = checked];
            v71 = hir.int_to_ptr v70 : ptr<byte, felt>;
            hir.store v71, v60;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::deallocate(v72: i32, v73: i32, v74: i32) {
        ^block14(v72: i32, v73: i32, v74: i32):
            v76 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v77 = hir.bitcast v76 : ptr<byte, i32>;
            v78 = hir.load v77 : i32;
            v79 = arith.constant 16 : i32;
            v80 = arith.sub v78, v79 : i32 #[overflow = wrapping];
            v81 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v82 = hir.bitcast v81 : ptr<byte, i32>;
            hir.store v82, v80;
            v83 = arith.constant 4 : i32;
            v84 = arith.add v80, v83 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_words/<alloc::raw_vec::RawVecInner>::current_memory(v84, v72, v73, v74)
            v86 = arith.constant 8 : u32;
            v85 = hir.bitcast v80 : u32;
            v87 = arith.add v85, v86 : u32 #[overflow = checked];
            v88 = arith.constant 4 : u32;
            v89 = arith.mod v87, v88 : u32;
            hir.assertz v89 #[code = 250];
            v90 = hir.int_to_ptr v87 : ptr<byte, i32>;
            v91 = hir.load v90 : i32;
            v193 = arith.constant 0 : i32;
            v75 = arith.constant 0 : i32;
            v93 = arith.eq v91, v75 : i1;
            v94 = arith.zext v93 : u32;
            v95 = hir.bitcast v94 : i32;
            v97 = arith.neq v95, v193 : i1;
            scf.if v97{
            ^block27:
                scf.yield ;
            } else {
            ^block17:
                v192 = arith.constant 4 : u32;
                v98 = hir.bitcast v80 : u32;
                v100 = arith.add v98, v192 : u32 #[overflow = checked];
                v191 = arith.constant 4 : u32;
                v102 = arith.mod v100, v191 : u32;
                hir.assertz v102 #[code = 250];
                v103 = hir.int_to_ptr v100 : ptr<byte, i32>;
                v104 = hir.load v103 : i32;
                v106 = arith.constant 12 : u32;
                v105 = hir.bitcast v80 : u32;
                v107 = arith.add v105, v106 : u32 #[overflow = checked];
                v190 = arith.constant 4 : u32;
                v109 = arith.mod v107, v190 : u32;
                hir.assertz v109 #[code = 250];
                v110 = hir.int_to_ptr v107 : ptr<byte, i32>;
                v111 = hir.load v110 : i32;
                hir.exec @root_ns:root@1.0.0/hash_words/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v104, v91, v111)
                scf.yield ;
            };
            v189 = arith.constant 16 : i32;
            v114 = arith.add v80, v189 : i32 #[overflow = wrapping];
            v115 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v116 = hir.bitcast v115 : ptr<byte, i32>;
            hir.store v116, v114;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::current_memory(v117: i32, v118: i32, v119: i32, v120: i32) {
        ^block18(v117: i32, v118: i32, v119: i32, v120: i32):
            v219 = arith.constant 0 : i32;
            v121 = arith.constant 0 : i32;
            v125 = arith.eq v120, v121 : i1;
            v126 = arith.zext v125 : u32;
            v127 = hir.bitcast v126 : i32;
            v129 = arith.neq v127, v219 : i1;
            v206, v207 = scf.if v129 : i32, i32 {
            ^block30:
                v218 = arith.constant 0 : i32;
                v123 = arith.constant 4 : i32;
                scf.yield v123, v218;
            } else {
            ^block21:
                v130 = hir.bitcast v118 : u32;
                v165 = arith.constant 4 : u32;
                v132 = arith.mod v130, v165 : u32;
                hir.assertz v132 #[code = 250];
                v133 = hir.int_to_ptr v130 : ptr<byte, i32>;
                v134 = hir.load v133 : i32;
                v216 = arith.constant 0 : i32;
                v217 = arith.constant 0 : i32;
                v136 = arith.eq v134, v217 : i1;
                v137 = arith.zext v136 : u32;
                v138 = hir.bitcast v137 : i32;
                v140 = arith.neq v138, v216 : i1;
                v204 = scf.if v140 : i32 {
                ^block29:
                    v215 = arith.constant 0 : i32;
                    scf.yield v215;
                } else {
                ^block22:
                    v214 = arith.constant 4 : u32;
                    v141 = hir.bitcast v117 : u32;
                    v143 = arith.add v141, v214 : u32 #[overflow = checked];
                    v213 = arith.constant 4 : u32;
                    v145 = arith.mod v143, v213 : u32;
                    hir.assertz v145 #[code = 250];
                    v146 = hir.int_to_ptr v143 : ptr<byte, i32>;
                    hir.store v146, v119;
                    v212 = arith.constant 4 : u32;
                    v147 = hir.bitcast v118 : u32;
                    v149 = arith.add v147, v212 : u32 #[overflow = checked];
                    v211 = arith.constant 4 : u32;
                    v151 = arith.mod v149, v211 : u32;
                    hir.assertz v151 #[code = 250];
                    v152 = hir.int_to_ptr v149 : ptr<byte, i32>;
                    v153 = hir.load v152 : i32;
                    v154 = hir.bitcast v117 : u32;
                    v210 = arith.constant 4 : u32;
                    v156 = arith.mod v154, v210 : u32;
                    hir.assertz v156 #[code = 250];
                    v157 = hir.int_to_ptr v154 : ptr<byte, i32>;
                    hir.store v157, v153;
                    v158 = arith.mul v134, v120 : i32 #[overflow = wrapping];
                    scf.yield v158;
                };
                v159 = arith.constant 8 : i32;
                v209 = arith.constant 4 : i32;
                v205 = cf.select v140, v209, v159 : i32;
                scf.yield v205, v204;
            };
            v162 = arith.add v117, v206 : i32 #[overflow = wrapping];
            v164 = hir.bitcast v162 : u32;
            v208 = arith.constant 4 : u32;
            v166 = arith.mod v164, v208 : u32;
            hir.assertz v166 #[code = 250];
            v167 = hir.int_to_ptr v164 : ptr<byte, i32>;
            hir.store v167, v207;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v168: i32, v169: i32, v170: i32) {
        ^block23(v168: i32, v169: i32, v170: i32):
            v221 = arith.constant 0 : i32;
            v171 = arith.constant 0 : i32;
            v172 = arith.eq v170, v171 : i1;
            v173 = arith.zext v172 : u32;
            v174 = hir.bitcast v173 : i32;
            v176 = arith.neq v174, v221 : i1;
            scf.if v176{
            ^block25:
                scf.yield ;
            } else {
            ^block26:
                hir.exec @root_ns:root@1.0.0/hash_words/__rustc::__rust_dealloc(v168, v170, v169)
                scf.yield ;
            };
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};