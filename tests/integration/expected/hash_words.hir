builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_words {
        private builtin.function @__rustc::__rust_dealloc(v0: i32, v1: i32, v2: i32) {
        ^block4(v0: i32, v1: i32, v2: i32):
            builtin.ret ;
        };

        public builtin.function @entrypoint(v3: i32) -> felt {
        ^block6(v3: i32):
            hir.store_local v3 #[local = lv0];
            v5 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v6 = hir.bitcast v5 : ptr<byte, i32>;
            v7 = hir.load v6 : i32;
            v276 = arith.constant 32 : i32;
            v9 = arith.sub v7, v276 : i32 #[overflow = wrapping];
            hir.store_local v9 #[local = lv1];
            v10 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v11 = hir.bitcast v10 : ptr<byte, i32>;
            hir.store v11, v9;
            v12 = hir.load_local  : i32 #[local = lv0];
            v275 = arith.constant 4 : u32;
            v13 = hir.bitcast v12 : u32;
            v15 = arith.add v13, v275 : u32 #[overflow = checked];
            v300 = arith.constant 4 : u32;
            v17 = arith.mod v15, v300 : u32;
            hir.assertz v17 #[code = 250];
            v18 = hir.int_to_ptr v15 : ptr<byte, i32>;
            v19 = hir.load v18 : i32;
            hir.store_local v19 #[local = lv2];
            v20 = hir.load_local  : i32 #[local = lv0];
            v274 = arith.constant 8 : u32;
            v21 = hir.bitcast v20 : u32;
            v23 = arith.add v21, v274 : u32 #[overflow = checked];
            v299 = arith.constant 4 : u32;
            v25 = arith.mod v23, v299 : u32;
            hir.assertz v25 #[code = 250];
            v26 = hir.int_to_ptr v23 : ptr<byte, i32>;
            v27 = hir.load v26 : i32;
            v298 = arith.constant 0 : i64;
            v31 = arith.trunc v298 : felt;
            v286 = arith.constant 0 : i64;
            v29 = arith.trunc v286 : felt;
            hir.assert_eq v29, v31;
            v32 = hir.load_local  : i32 #[local = lv2];
            v267 = arith.constant 2 : u32;
            v34 = hir.bitcast v32 : u32;
            v36 = arith.shr v34, v267 : u32;
            v37 = hir.bitcast v36 : i32;
            hir.store_local v37 #[local = lv2];
            v38 = hir.load_local  : i32 #[local = lv2];
            v44 = hir.load_local  : i32 #[local = lv1];
            v272 = arith.constant 16 : i32;
            v46 = arith.add v44, v272 : i32 #[overflow = wrapping];
            v297 = arith.constant 2 : u32;
            v42 = arith.shl v27, v297 : i32;
            v43 = arith.add v38, v42 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_words/miden::core::crypto::hashes::rpo256::hash_words(v37, v43, v46)
            v47 = hir.load_local  : i32 #[local = lv1];
            v271 = arith.constant 16 : u32;
            v49 = hir.bitcast v47 : u32;
            v51 = arith.add v49, v271 : u32 #[overflow = checked];
            v296 = arith.constant 8 : u32;
            v53 = arith.mod v51, v296 : u32;
            hir.assertz v53 #[code = 250];
            v54 = hir.int_to_ptr v51 : ptr<byte, i64>;
            v55 = hir.load v54 : i64;
            v262, v263 = arith.split v55 : felt, felt;
            v295 = arith.constant 8 : u32;
            v59 = hir.bitcast v47 : u32;
            v61 = arith.add v59, v295 : u32 #[overflow = checked];
            v294 = arith.constant 8 : u32;
            v63 = arith.mod v61, v294 : u32;
            hir.assertz v63 #[code = 250];
            v264 = arith.join v263, v262 : i64;
            v64 = hir.int_to_ptr v61 : ptr<byte, i64>;
            hir.store v64, v264;
            v65 = hir.load_local  : i32 #[local = lv1];
            v270 = arith.constant 24 : u32;
            v67 = hir.bitcast v65 : u32;
            v69 = arith.add v67, v270 : u32 #[overflow = checked];
            v293 = arith.constant 8 : u32;
            v71 = arith.mod v69, v293 : u32;
            hir.assertz v71 #[code = 250];
            v72 = hir.int_to_ptr v69 : ptr<byte, i64>;
            v73 = hir.load v72 : i64;
            v259, v260 = arith.split v73 : felt, felt;
            v77 = hir.bitcast v65 : u32;
            v292 = arith.constant 8 : u32;
            v79 = arith.mod v77, v292 : u32;
            hir.assertz v79 #[code = 250];
            v261 = arith.join v260, v259 : i64;
            v80 = hir.int_to_ptr v77 : ptr<byte, i64>;
            hir.store v80, v261;
            v81 = hir.load_local  : i32 #[local = lv1];
            v268 = arith.constant 1048588 : i32;
            v269 = arith.constant 0 : i32;
            v84 = hir.exec @root_ns:root@1.0.0/hash_words/<miden_field::word::Word as core::ops::index::Index<usize>>::index(v81, v269, v268) : i32
            v85 = hir.bitcast v84 : u32;
            v291 = arith.constant 4 : u32;
            v87 = arith.mod v85, v291 : u32;
            hir.assertz v87 #[code = 250];
            v88 = hir.int_to_ptr v85 : ptr<byte, felt>;
            v89 = hir.load v88 : felt;
            hir.store_local v89 #[local = lv4];
            v90 = hir.load_local  : i32 #[local = lv0];
            v290 = arith.constant 16 : i32;
            hir.exec @root_ns:root@1.0.0/hash_words/<alloc::raw_vec::RawVecInner>::deallocate(v90, v290, v290)
            v93 = hir.load_local  : i32 #[local = lv1];
            v289 = arith.constant 32 : i32;
            v95 = arith.add v93, v289 : i32 #[overflow = wrapping];
            v96 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v97 = hir.bitcast v96 : ptr<byte, i32>;
            hir.store v97, v95;
            v98 = hir.load_local  : felt #[local = lv4];
            builtin.ret v98;
        };

        private builtin.function @miden::core::crypto::hashes::rpo256::hash_words(v99: i32, v100: i32, v101: i32) {
        ^block8(v99: i32, v100: i32, v101: i32):
            v102, v103, v104, v105 = hir.exec @miden/core/crypto/hashes/rpo256/hash_words(v99, v100) : felt, felt, felt, felt
            v106 = hir.bitcast v101 : u32;
            v107 = hir.int_to_ptr v106 : ptr<byte, felt>;
            hir.store v107, v102;
            v303 = arith.constant 4 : u32;
            v109 = arith.add v106, v303 : u32 #[overflow = checked];
            v110 = hir.int_to_ptr v109 : ptr<byte, felt>;
            hir.store v110, v103;
            v302 = arith.constant 8 : u32;
            v112 = arith.add v106, v302 : u32 #[overflow = checked];
            v113 = hir.int_to_ptr v112 : ptr<byte, felt>;
            hir.store v113, v104;
            v301 = arith.constant 12 : u32;
            v115 = arith.add v106, v301 : u32 #[overflow = checked];
            v116 = hir.int_to_ptr v115 : ptr<byte, felt>;
            hir.store v116, v105;
            builtin.ret ;
        };

        private builtin.function @<miden_field::word::Word as core::ops::index::Index<usize>>::index(v117: i32, v118: i32, v119: i32) -> i32 {
        ^block15(v117: i32, v118: i32, v119: i32):
            hir.store_local v117 #[local = lv0];
            hir.store_local v118 #[local = lv1];
            v121 = hir.load_local  : i32 #[local = lv1];
            v308 = arith.constant 0 : i32;
            v307 = arith.constant 3 : u32;
            v123 = hir.bitcast v121 : u32;
            v125 = arith.gt v123, v307 : i1;
            v126 = arith.zext v125 : u32;
            v127 = hir.bitcast v126 : i32;
            v129 = arith.neq v127, v308 : i1;
            cf.cond_br v129 ^block17, ^block18;
        ^block17:
            ub.unreachable ;
        ^block18:
            v130 = hir.load_local  : i32 #[local = lv0];
            v131 = hir.load_local  : i32 #[local = lv1];
            v306 = arith.constant 2 : u32;
            v134 = arith.shl v131, v306 : i32;
            v135 = arith.add v130, v134 : i32 #[overflow = wrapping];
            builtin.ret v135;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::deallocate(v136: i32, v137: i32, v138: i32) {
        ^block19(v136: i32, v137: i32, v138: i32):
            hir.store_local v138 #[local = lv2];
            v139 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v140 = hir.bitcast v139 : ptr<byte, i32>;
            v141 = hir.load v140 : i32;
            v316 = arith.constant 16 : i32;
            v143 = arith.sub v141, v316 : i32 #[overflow = wrapping];
            hir.store_local v143 #[local = lv3];
            v144 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v145 = hir.bitcast v144 : ptr<byte, i32>;
            hir.store v145, v143;
            v146 = hir.load_local  : i32 #[local = lv3];
            v151 = hir.load_local  : i32 #[local = lv2];
            v315 = arith.constant 4 : i32;
            v148 = arith.add v146, v315 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_words/<alloc::raw_vec::RawVecInner>::current_memory(v148, v136, v137, v151)
            v152 = hir.load_local  : i32 #[local = lv3];
            v314 = arith.constant 8 : u32;
            v153 = hir.bitcast v152 : u32;
            v155 = arith.add v153, v314 : u32 #[overflow = checked];
            v313 = arith.constant 4 : u32;
            v157 = arith.mod v155, v313 : u32;
            hir.assertz v157 #[code = 250];
            v158 = hir.int_to_ptr v155 : ptr<byte, i32>;
            v159 = hir.load v158 : i32;
            hir.store_local v159 #[local = lv2];
            v327 = arith.constant 0 : i32;
            v321 = arith.constant 0 : i32;
            v161 = arith.eq v159, v321 : i1;
            v162 = arith.zext v161 : u32;
            v163 = hir.bitcast v162 : i32;
            v165 = arith.neq v163, v327 : i1;
            scf.if v165{
            ^block34:
                scf.yield ;
            } else {
            ^block22:
                v166 = hir.load_local  : i32 #[local = lv3];
                v326 = arith.constant 4 : u32;
                v167 = hir.bitcast v166 : u32;
                v169 = arith.add v167, v326 : u32 #[overflow = checked];
                v325 = arith.constant 4 : u32;
                v171 = arith.mod v169, v325 : u32;
                hir.assertz v171 #[code = 250];
                v172 = hir.int_to_ptr v169 : ptr<byte, i32>;
                v173 = hir.load v172 : i32;
                v174 = hir.load_local  : i32 #[local = lv2];
                v175 = hir.load_local  : i32 #[local = lv3];
                v311 = arith.constant 12 : u32;
                v176 = hir.bitcast v175 : u32;
                v178 = arith.add v176, v311 : u32 #[overflow = checked];
                v324 = arith.constant 4 : u32;
                v180 = arith.mod v178, v324 : u32;
                hir.assertz v180 #[code = 250];
                v181 = hir.int_to_ptr v178 : ptr<byte, i32>;
                v182 = hir.load v181 : i32;
                hir.exec @root_ns:root@1.0.0/hash_words/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v173, v174, v182)
                scf.yield ;
            };
            v183 = hir.load_local  : i32 #[local = lv3];
            v323 = arith.constant 16 : i32;
            v185 = arith.add v183, v323 : i32 #[overflow = wrapping];
            v186 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v187 = hir.bitcast v186 : ptr<byte, i32>;
            hir.store v187, v185;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::current_memory(v188: i32, v189: i32, v190: i32, v191: i32) {
        ^block23(v188: i32, v189: i32, v190: i32, v191: i32):
            hir.store_local v188 #[local = lv0];
            hir.store_local v189 #[local = lv1];
            hir.store_local v190 #[local = lv2];
            hir.store_local v191 #[local = lv3];
            v331 = arith.constant 0 : i32;
            hir.store_local v331 #[local = lv4];
            v330 = arith.constant 4 : i32;
            hir.store_local v330 #[local = lv5];
            v194 = hir.load_local  : i32 #[local = lv3];
            v351 = arith.constant 0 : i32;
            v352 = arith.constant 0 : i32;
            v196 = arith.eq v194, v352 : i1;
            v197 = arith.zext v196 : u32;
            v198 = hir.bitcast v197 : i32;
            v200 = arith.neq v198, v351 : i1;
            scf.if v200{
            ^block37:
                scf.yield ;
            } else {
            ^block26:
                v201 = hir.load_local  : i32 #[local = lv1];
                v202 = hir.bitcast v201 : u32;
                v339 = arith.constant 4 : u32;
                v204 = arith.mod v202, v339 : u32;
                hir.assertz v204 #[code = 250];
                v205 = hir.int_to_ptr v202 : ptr<byte, i32>;
                v206 = hir.load v205 : i32;
                hir.store_local v206 #[local = lv6];
                v349 = arith.constant 0 : i32;
                v350 = arith.constant 0 : i32;
                v208 = arith.eq v206, v350 : i1;
                v209 = arith.zext v208 : u32;
                v210 = hir.bitcast v209 : i32;
                v212 = arith.neq v210, v349 : i1;
                scf.if v212{
                ^block36:
                    scf.yield ;
                } else {
                ^block27:
                    v213 = hir.load_local  : i32 #[local = lv0];
                    v214 = hir.load_local  : i32 #[local = lv2];
                    v348 = arith.constant 4 : u32;
                    v215 = hir.bitcast v213 : u32;
                    v217 = arith.add v215, v348 : u32 #[overflow = checked];
                    v347 = arith.constant 4 : u32;
                    v219 = arith.mod v217, v347 : u32;
                    hir.assertz v219 #[code = 250];
                    v220 = hir.int_to_ptr v217 : ptr<byte, i32>;
                    hir.store v220, v214;
                    v221 = hir.load_local  : i32 #[local = lv0];
                    v222 = hir.load_local  : i32 #[local = lv1];
                    v346 = arith.constant 4 : u32;
                    v223 = hir.bitcast v222 : u32;
                    v225 = arith.add v223, v346 : u32 #[overflow = checked];
                    v345 = arith.constant 4 : u32;
                    v227 = arith.mod v225, v345 : u32;
                    hir.assertz v227 #[code = 250];
                    v228 = hir.int_to_ptr v225 : ptr<byte, i32>;
                    v229 = hir.load v228 : i32;
                    v230 = hir.bitcast v221 : u32;
                    v344 = arith.constant 4 : u32;
                    v232 = arith.mod v230, v344 : u32;
                    hir.assertz v232 #[code = 250];
                    v233 = hir.int_to_ptr v230 : ptr<byte, i32>;
                    hir.store v233, v229;
                    v234 = hir.load_local  : i32 #[local = lv6];
                    v235 = hir.load_local  : i32 #[local = lv3];
                    v236 = arith.mul v234, v235 : i32 #[overflow = wrapping];
                    hir.store_local v236 #[local = lv4];
                    v328 = arith.constant 8 : i32;
                    hir.store_local v328 #[local = lv5];
                    scf.yield ;
                };
                scf.yield ;
            };
            v238 = hir.load_local  : i32 #[local = lv0];
            v239 = hir.load_local  : i32 #[local = lv5];
            v241 = hir.load_local  : i32 #[local = lv4];
            v240 = arith.add v238, v239 : i32 #[overflow = wrapping];
            v242 = hir.bitcast v240 : u32;
            v343 = arith.constant 4 : u32;
            v244 = arith.mod v242, v343 : u32;
            hir.assertz v244 #[code = 250];
            v245 = hir.int_to_ptr v242 : ptr<byte, i32>;
            hir.store v245, v241;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v246: i32, v247: i32, v248: i32) {
        ^block28(v246: i32, v247: i32, v248: i32):
            hir.store_local v246 #[local = lv0];
            hir.store_local v247 #[local = lv1];
            hir.store_local v248 #[local = lv2];
            v249 = hir.load_local  : i32 #[local = lv2];
            v356 = arith.constant 0 : i32;
            v354 = arith.constant 0 : i32;
            v251 = arith.eq v249, v354 : i1;
            v252 = arith.zext v251 : u32;
            v253 = hir.bitcast v252 : i32;
            v255 = arith.neq v253, v356 : i1;
            scf.if v255{
            ^block30:
                scf.yield ;
            } else {
            ^block31:
                v256 = hir.load_local  : i32 #[local = lv0];
                v257 = hir.load_local  : i32 #[local = lv2];
                v258 = hir.load_local  : i32 #[local = lv1];
                hir.exec @root_ns:root@1.0.0/hash_words/__rustc::__rust_dealloc(v256, v257, v258)
                scf.yield ;
            };
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.segment readonly @1048576 = 0x00000000000000000000000a0010000000003e64657463616465723c;
    };
};