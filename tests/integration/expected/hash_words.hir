builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_words {
        private builtin.function @__rustc::__rust_dealloc(v0: i32, v1: i32, v2: i32) {
        ^block4(v0: i32, v1: i32, v2: i32):
            builtin.ret ;
        };

        public builtin.function @entrypoint(v3: i32) -> felt {
        ^block6(v3: i32):
            v7 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v8 = hir.bitcast v7 : ptr<byte, i32>;
            v9 = hir.load v8 : i32;
            v186 = arith.constant 16 : i32;
            v11 = arith.sub v9, v186 : i32 #[overflow = wrapping];
            v12 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v13 = hir.bitcast v12 : ptr<byte, i32>;
            hir.store v13, v11;
            v14 = hir.bitcast v3 : u32;
            v185 = arith.constant 4 : u32;
            v16 = arith.add v14, v185 : u32 #[overflow = checked];
            v198 = arith.constant 4 : u32;
            v18 = arith.mod v16, v198 : u32;
            hir.assertz v18 #[code = 250];
            v19 = hir.int_to_ptr v16 : ptr<byte, i32>;
            v20 = hir.load v19 : i32;
            v184 = arith.constant 8 : u32;
            v23 = arith.add v14, v184 : u32 #[overflow = checked];
            v197 = arith.constant 4 : u32;
            v25 = arith.mod v23, v197 : u32;
            hir.assertz v25 #[code = 250];
            v26 = hir.int_to_ptr v23 : ptr<byte, i32>;
            v27 = hir.load v26 : i32;
            v182 = arith.constant 0 : felt;
            hir.assert_eq v182, v182;
            v181 = arith.constant 2 : u32;
            v33 = hir.bitcast v20 : u32;
            v35 = arith.shr v33, v181 : u32;
            v36 = hir.bitcast v35 : i32;
            v196 = arith.constant 2 : u32;
            v39 = arith.shl v27, v196 : i32;
            v40 = arith.add v36, v39 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_words/miden::core::crypto::hashes::rpo256::hash_words(v36, v40, v11)
            v183 = arith.constant 12 : u32;
            v41 = hir.bitcast v11 : u32;
            v43 = arith.add v41, v183 : u32 #[overflow = checked];
            v195 = arith.constant 4 : u32;
            v45 = arith.mod v43, v195 : u32;
            hir.assertz v45 #[code = 250];
            v46 = hir.int_to_ptr v43 : ptr<byte, felt>;
            v47 = hir.load v46 : felt;
            v194 = arith.constant 16 : i32;
            hir.exec @root_ns:root@1.0.0/hash_words/<alloc::raw_vec::RawVecInner>::deallocate(v3, v194, v194)
            v193 = arith.constant 16 : i32;
            v51 = arith.add v11, v193 : i32 #[overflow = wrapping];
            v52 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v53 = hir.bitcast v52 : ptr<byte, i32>;
            hir.store v53, v51;
            builtin.ret v47;
        };

        private builtin.function @miden::core::crypto::hashes::rpo256::hash_words(v54: i32, v55: i32, v56: i32) {
        ^block8(v54: i32, v55: i32, v56: i32):
            v57, v58, v59, v60 = hir.exec @miden/core/crypto/hashes/rpo256/hash_words(v54, v55) : felt, felt, felt, felt
            v61 = hir.bitcast v56 : u32;
            v62 = hir.int_to_ptr v61 : ptr<byte, felt>;
            hir.store v62, v57;
            v201 = arith.constant 4 : u32;
            v64 = arith.add v61, v201 : u32 #[overflow = checked];
            v65 = hir.int_to_ptr v64 : ptr<byte, felt>;
            hir.store v65, v58;
            v200 = arith.constant 8 : u32;
            v67 = arith.add v61, v200 : u32 #[overflow = checked];
            v68 = hir.int_to_ptr v67 : ptr<byte, felt>;
            hir.store v68, v59;
            v199 = arith.constant 12 : u32;
            v70 = arith.add v61, v199 : u32 #[overflow = checked];
            v71 = hir.int_to_ptr v70 : ptr<byte, felt>;
            hir.store v71, v60;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::deallocate(v72: i32, v73: i32, v74: i32) {
        ^block15(v72: i32, v73: i32, v74: i32):
            v76 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v77 = hir.bitcast v76 : ptr<byte, i32>;
            v78 = hir.load v77 : i32;
            v206 = arith.constant 16 : i32;
            v80 = arith.sub v78, v206 : i32 #[overflow = wrapping];
            v81 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v82 = hir.bitcast v81 : ptr<byte, i32>;
            hir.store v82, v80;
            v205 = arith.constant 4 : i32;
            v84 = arith.add v80, v205 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_words/<alloc::raw_vec::RawVecInner>::current_memory(v84, v72, v73, v74)
            v85 = hir.bitcast v80 : u32;
            v204 = arith.constant 8 : u32;
            v87 = arith.add v85, v204 : u32 #[overflow = checked];
            v203 = arith.constant 4 : u32;
            v89 = arith.mod v87, v203 : u32;
            hir.assertz v89 #[code = 250];
            v90 = hir.int_to_ptr v87 : ptr<byte, i32>;
            v91 = hir.load v90 : i32;
            v219 = arith.constant 0 : i32;
            v212 = arith.constant 0 : i32;
            v93 = arith.eq v91, v212 : i1;
            v94 = arith.zext v93 : u32;
            v95 = hir.bitcast v94 : i32;
            v97 = arith.neq v95, v219 : i1;
            scf.if v97{
            ^block28:
                scf.yield ;
            } else {
            ^block18:
                v218 = arith.constant 4 : u32;
                v100 = arith.add v85, v218 : u32 #[overflow = checked];
                v217 = arith.constant 4 : u32;
                v102 = arith.mod v100, v217 : u32;
                hir.assertz v102 #[code = 250];
                v103 = hir.int_to_ptr v100 : ptr<byte, i32>;
                v104 = hir.load v103 : i32;
                v202 = arith.constant 12 : u32;
                v107 = arith.add v85, v202 : u32 #[overflow = checked];
                v216 = arith.constant 4 : u32;
                v109 = arith.mod v107, v216 : u32;
                hir.assertz v109 #[code = 250];
                v110 = hir.int_to_ptr v107 : ptr<byte, i32>;
                v111 = hir.load v110 : i32;
                hir.exec @root_ns:root@1.0.0/hash_words/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v104, v91, v111)
                scf.yield ;
            };
            v215 = arith.constant 16 : i32;
            v114 = arith.add v80, v215 : i32 #[overflow = wrapping];
            v115 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v116 = hir.bitcast v115 : ptr<byte, i32>;
            hir.store v116, v114;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::current_memory(v117: i32, v118: i32, v119: i32, v120: i32) {
        ^block19(v117: i32, v118: i32, v119: i32, v120: i32):
            v261 = arith.constant 0 : i32;
            v235 = arith.constant 0 : i32;
            v125 = arith.eq v120, v235 : i1;
            v126 = arith.zext v125 : u32;
            v127 = hir.bitcast v126 : i32;
            v129 = arith.neq v127, v261 : i1;
            v248, v249 = scf.if v129 : i32, i32 {
            ^block31:
                v260 = arith.constant 0 : i32;
                v233 = arith.constant 4 : i32;
                scf.yield v233, v260;
            } else {
            ^block22:
                v130 = hir.bitcast v118 : u32;
                v231 = arith.constant 4 : u32;
                v132 = arith.mod v130, v231 : u32;
                hir.assertz v132 #[code = 250];
                v133 = hir.int_to_ptr v130 : ptr<byte, i32>;
                v134 = hir.load v133 : i32;
                v258 = arith.constant 0 : i32;
                v259 = arith.constant 0 : i32;
                v136 = arith.eq v134, v259 : i1;
                v137 = arith.zext v136 : u32;
                v138 = hir.bitcast v137 : i32;
                v140 = arith.neq v138, v258 : i1;
                v246 = scf.if v140 : i32 {
                ^block30:
                    v257 = arith.constant 0 : i32;
                    scf.yield v257;
                } else {
                ^block23:
                    v141 = hir.bitcast v117 : u32;
                    v256 = arith.constant 4 : u32;
                    v143 = arith.add v141, v256 : u32 #[overflow = checked];
                    v255 = arith.constant 4 : u32;
                    v145 = arith.mod v143, v255 : u32;
                    hir.assertz v145 #[code = 250];
                    v146 = hir.int_to_ptr v143 : ptr<byte, i32>;
                    hir.store v146, v119;
                    v254 = arith.constant 4 : u32;
                    v149 = arith.add v130, v254 : u32 #[overflow = checked];
                    v253 = arith.constant 4 : u32;
                    v151 = arith.mod v149, v253 : u32;
                    hir.assertz v151 #[code = 250];
                    v152 = hir.int_to_ptr v149 : ptr<byte, i32>;
                    v153 = hir.load v152 : i32;
                    v252 = arith.constant 4 : u32;
                    v156 = arith.mod v141, v252 : u32;
                    hir.assertz v156 #[code = 250];
                    v157 = hir.int_to_ptr v141 : ptr<byte, i32>;
                    hir.store v157, v153;
                    v158 = arith.mul v134, v120 : i32 #[overflow = wrapping];
                    scf.yield v158;
                };
                v220 = arith.constant 8 : i32;
                v251 = arith.constant 4 : i32;
                v247 = cf.select v140, v251, v220 : i32;
                scf.yield v247, v246;
            };
            v162 = arith.add v117, v248 : i32 #[overflow = wrapping];
            v164 = hir.bitcast v162 : u32;
            v250 = arith.constant 4 : u32;
            v166 = arith.mod v164, v250 : u32;
            hir.assertz v166 #[code = 250];
            v167 = hir.int_to_ptr v164 : ptr<byte, i32>;
            hir.store v167, v249;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v168: i32, v169: i32, v170: i32) {
        ^block24(v168: i32, v169: i32, v170: i32):
            v265 = arith.constant 0 : i32;
            v263 = arith.constant 0 : i32;
            v172 = arith.eq v170, v263 : i1;
            v173 = arith.zext v172 : u32;
            v174 = hir.bitcast v173 : i32;
            v176 = arith.neq v174, v265 : i1;
            scf.if v176{
            ^block26:
                scf.yield ;
            } else {
            ^block27:
                hir.exec @root_ns:root@1.0.0/hash_words/__rustc::__rust_dealloc(v168, v170, v169)
                scf.yield ;
            };
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};