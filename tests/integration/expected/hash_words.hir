builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_words {
        public builtin.function @entrypoint(v0: i32) -> felt {
        ^block4(v0: i32):
            v4 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v5 = hir.bitcast v4 : ptr<byte, i32>;
            v6 = hir.load v5 : i32;
            v7 = arith.constant 48 : i32;
            v8 = arith.sub v6, v7 : i32 #[overflow = wrapping];
            v9 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v10 = hir.bitcast v9 : ptr<byte, i32>;
            hir.store v10, v8;
            v12 = arith.constant 4 : u32;
            v11 = hir.bitcast v0 : u32;
            v13 = arith.add v11, v12 : u32 #[overflow = checked];
            v310 = arith.constant 4 : u32;
            v15 = arith.mod v13, v310 : u32;
            hir.assertz v15 #[code = 250];
            v16 = hir.int_to_ptr v13 : ptr<byte, i32>;
            v17 = hir.load v16 : i32;
            v19 = arith.constant 8 : u32;
            v18 = hir.bitcast v0 : u32;
            v20 = arith.add v18, v19 : u32 #[overflow = checked];
            v309 = arith.constant 4 : u32;
            v22 = arith.mod v20, v309 : u32;
            hir.assertz v22 #[code = 250];
            v23 = hir.int_to_ptr v20 : ptr<byte, i32>;
            v24 = hir.load v23 : i32;
            v2 = arith.constant 0 : i32;
            v26 = hir.exec @root_ns:root@1.0.0/hash_words/intrinsics::felt::from_u32(v2) : felt
            v308 = arith.constant 0 : i32;
            v28 = hir.exec @root_ns:root@1.0.0/hash_words/intrinsics::felt::from_u32(v308) : felt
            hir.exec @root_ns:root@1.0.0/hash_words/intrinsics::felt::assert_eq(v26, v28)
            v37 = arith.constant 16 : i32;
            v38 = arith.add v8, v37 : i32 #[overflow = wrapping];
            v307 = arith.constant 2 : u32;
            v36 = arith.shl v24, v307 : i32;
            v299 = arith.constant 2 : u32;
            v30 = hir.bitcast v17 : u32;
            v32 = arith.shr v30, v299 : u32;
            v33 = hir.bitcast v32 : i32;
            hir.exec @root_ns:root@1.0.0/hash_words/std::crypto::hashes::rpo::hash_memory(v33, v36, v38)
            v40 = arith.constant 24 : u32;
            v39 = hir.bitcast v8 : u32;
            v41 = arith.add v39, v40 : u32 #[overflow = checked];
            v306 = arith.constant 8 : u32;
            v43 = arith.mod v41, v306 : u32;
            hir.assertz v43 #[code = 250];
            v44 = hir.int_to_ptr v41 : ptr<byte, i64>;
            v45 = hir.load v44 : i64;
            v47 = arith.constant 40 : u32;
            v46 = hir.bitcast v8 : u32;
            v48 = arith.add v46, v47 : u32 #[overflow = checked];
            v305 = arith.constant 8 : u32;
            v50 = arith.mod v48, v305 : u32;
            hir.assertz v50 #[code = 250];
            v51 = hir.int_to_ptr v48 : ptr<byte, i64>;
            hir.store v51, v45;
            v53 = arith.constant 16 : u32;
            v52 = hir.bitcast v8 : u32;
            v54 = arith.add v52, v53 : u32 #[overflow = checked];
            v304 = arith.constant 8 : u32;
            v56 = arith.mod v54, v304 : u32;
            hir.assertz v56 #[code = 250];
            v57 = hir.int_to_ptr v54 : ptr<byte, i64>;
            v58 = hir.load v57 : i64;
            v60 = arith.constant 32 : u32;
            v59 = hir.bitcast v8 : u32;
            v61 = arith.add v59, v60 : u32 #[overflow = checked];
            v303 = arith.constant 8 : u32;
            v63 = arith.mod v61, v303 : u32;
            hir.assertz v63 #[code = 250];
            v64 = hir.int_to_ptr v61 : ptr<byte, i64>;
            hir.store v64, v58;
            v65 = arith.constant 32 : i32;
            v66 = arith.add v8, v65 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_words/miden_stdlib_sys::intrinsics::word::Word::reverse(v8, v66)
            v67 = hir.bitcast v8 : u32;
            v302 = arith.constant 4 : u32;
            v69 = arith.mod v67, v302 : u32;
            hir.assertz v69 #[code = 250];
            v70 = hir.int_to_ptr v67 : ptr<byte, felt>;
            v71 = hir.load v70 : felt;
            v301 = arith.constant 16 : i32;
            hir.exec @root_ns:root@1.0.0/hash_words/alloc::raw_vec::RawVecInner<A>::deallocate(v0, v301, v301)
            v300 = arith.constant 48 : i32;
            v75 = arith.add v8, v300 : i32 #[overflow = wrapping];
            v76 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v77 = hir.bitcast v76 : ptr<byte, i32>;
            hir.store v77, v75;
            builtin.ret v71;
        };

        private builtin.function @__rustc::__rust_dealloc(v78: i32, v79: i32, v80: i32) {
        ^block6(v78: i32, v79: i32, v80: i32):
            builtin.ret ;
        };

        private builtin.function @miden_stdlib_sys::intrinsics::word::Word::reverse(v81: i32, v82: i32) {
        ^block8(v81: i32, v82: i32):
            v85 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v86 = hir.bitcast v85 : ptr<byte, i32>;
            v87 = hir.load v86 : i32;
            v88 = arith.constant 16 : i32;
            v89 = arith.sub v87, v88 : i32 #[overflow = wrapping];
            v91 = arith.constant 8 : u32;
            v90 = hir.bitcast v82 : u32;
            v92 = arith.add v90, v91 : u32 #[overflow = checked];
            v397 = arith.constant 8 : u32;
            v94 = arith.mod v92, v397 : u32;
            hir.assertz v94 #[code = 250];
            v95 = hir.int_to_ptr v92 : ptr<byte, i64>;
            v96 = hir.load v95 : i64;
            v396 = arith.constant 8 : u32;
            v97 = hir.bitcast v89 : u32;
            v99 = arith.add v97, v396 : u32 #[overflow = checked];
            v100 = arith.constant 4 : u32;
            v101 = arith.mod v99, v100 : u32;
            hir.assertz v101 #[code = 250];
            v102 = hir.int_to_ptr v99 : ptr<byte, i64>;
            hir.store v102, v96;
            v103 = hir.bitcast v82 : u32;
            v395 = arith.constant 8 : u32;
            v105 = arith.mod v103, v395 : u32;
            hir.assertz v105 #[code = 250];
            v106 = hir.int_to_ptr v103 : ptr<byte, i64>;
            v107 = hir.load v106 : i64;
            v108 = hir.bitcast v89 : u32;
            v394 = arith.constant 4 : u32;
            v110 = arith.mod v108, v394 : u32;
            hir.assertz v110 #[code = 250];
            v111 = hir.int_to_ptr v108 : ptr<byte, i64>;
            hir.store v111, v107;
            v112 = arith.constant 12 : i32;
            v113 = arith.add v89, v112 : i32 #[overflow = wrapping];
            v83 = arith.constant 0 : i32;
            v365, v366, v367, v368, v369, v370 = scf.while v83, v89, v113, v81 : i32, i32, i32, i32, i32, i32 {
            ^block44(v371: i32, v372: i32, v373: i32, v374: i32):
                v393 = arith.constant 0 : i32;
                v116 = arith.constant 8 : i32;
                v117 = arith.eq v371, v116 : i1;
                v118 = arith.zext v117 : u32;
                v119 = hir.bitcast v118 : i32;
                v121 = arith.neq v119, v393 : i1;
                v359, v360 = scf.if v121 : i32, i32 {
                ^block43:
                    v319 = ub.poison i32 : i32;
                    scf.yield v319, v319;
                } else {
                ^block13:
                    v123 = arith.add v372, v371 : i32 #[overflow = wrapping];
                    v124 = hir.bitcast v123 : u32;
                    v392 = arith.constant 4 : u32;
                    v126 = arith.mod v124, v392 : u32;
                    hir.assertz v126 #[code = 250];
                    v127 = hir.int_to_ptr v124 : ptr<byte, felt>;
                    v128 = hir.load v127 : felt;
                    v130 = hir.bitcast v373 : u32;
                    v391 = arith.constant 4 : u32;
                    v132 = arith.mod v130, v391 : u32;
                    hir.assertz v132 #[code = 250];
                    v133 = hir.int_to_ptr v130 : ptr<byte, i32>;
                    v134 = hir.load v133 : i32;
                    v135 = hir.bitcast v123 : u32;
                    v390 = arith.constant 4 : u32;
                    v137 = arith.mod v135, v390 : u32;
                    hir.assertz v137 #[code = 250];
                    v138 = hir.int_to_ptr v135 : ptr<byte, i32>;
                    hir.store v138, v134;
                    v139 = hir.bitcast v373 : u32;
                    v389 = arith.constant 4 : u32;
                    v141 = arith.mod v139, v389 : u32;
                    hir.assertz v141 #[code = 250];
                    v142 = hir.int_to_ptr v139 : ptr<byte, felt>;
                    hir.store v142, v128;
                    v145 = arith.constant -4 : i32;
                    v146 = arith.add v373, v145 : i32 #[overflow = wrapping];
                    v143 = arith.constant 4 : i32;
                    v144 = arith.add v371, v143 : i32 #[overflow = wrapping];
                    scf.yield v144, v146;
                };
                v387 = ub.poison i32 : i32;
                v362 = cf.select v121, v387, v374 : i32;
                v388 = ub.poison i32 : i32;
                v361 = cf.select v121, v388, v372 : i32;
                v318 = arith.constant 1 : u32;
                v311 = arith.constant 0 : u32;
                v364 = cf.select v121, v311, v318 : u32;
                v352 = arith.trunc v364 : i1;
                scf.condition v352, v359, v361, v360, v362, v372, v374;
            } do {
            ^block45(v375: i32, v376: i32, v377: i32, v378: i32, v379: i32, v380: i32):
                scf.yield v375, v376, v377, v378;
            };
            v386 = arith.constant 8 : u32;
            v148 = hir.bitcast v369 : u32;
            v150 = arith.add v148, v386 : u32 #[overflow = checked];
            v385 = arith.constant 4 : u32;
            v152 = arith.mod v150, v385 : u32;
            hir.assertz v152 #[code = 250];
            v153 = hir.int_to_ptr v150 : ptr<byte, i64>;
            v154 = hir.load v153 : i64;
            v384 = arith.constant 8 : u32;
            v155 = hir.bitcast v370 : u32;
            v157 = arith.add v155, v384 : u32 #[overflow = checked];
            v383 = arith.constant 8 : u32;
            v159 = arith.mod v157, v383 : u32;
            hir.assertz v159 #[code = 250];
            v160 = hir.int_to_ptr v157 : ptr<byte, i64>;
            hir.store v160, v154;
            v161 = hir.bitcast v369 : u32;
            v382 = arith.constant 4 : u32;
            v163 = arith.mod v161, v382 : u32;
            hir.assertz v163 #[code = 250];
            v164 = hir.int_to_ptr v161 : ptr<byte, i64>;
            v165 = hir.load v164 : i64;
            v166 = hir.bitcast v370 : u32;
            v381 = arith.constant 8 : u32;
            v168 = arith.mod v166, v381 : u32;
            hir.assertz v168 #[code = 250];
            v169 = hir.int_to_ptr v166 : ptr<byte, i64>;
            hir.store v169, v165;
            builtin.ret ;
        };

        private builtin.function @intrinsics::felt::from_u32(v170: i32) -> felt {
        ^block14(v170: i32):
            v171 = hir.bitcast v170 : felt;
            builtin.ret v171;
        };

        private builtin.function @intrinsics::felt::assert_eq(v173: felt, v174: felt) {
        ^block16(v173: felt, v174: felt):
            hir.assert_eq v173, v174;
            builtin.ret ;
        };

        private builtin.function @std::crypto::hashes::rpo::hash_memory(v175: i32, v176: i32, v177: i32) {
        ^block18(v175: i32, v176: i32, v177: i32):
            v178, v179, v180, v181 = hir.exec @std/crypto/hashes/rpo/hash_memory(v175, v176) : felt, felt, felt, felt
            v182 = hir.bitcast v177 : u32;
            v183 = hir.int_to_ptr v182 : ptr<byte, felt>;
            hir.store v183, v178;
            v184 = arith.constant 4 : u32;
            v185 = arith.add v182, v184 : u32 #[overflow = checked];
            v186 = hir.int_to_ptr v185 : ptr<byte, felt>;
            hir.store v186, v179;
            v187 = arith.constant 8 : u32;
            v188 = arith.add v182, v187 : u32 #[overflow = checked];
            v189 = hir.int_to_ptr v188 : ptr<byte, felt>;
            hir.store v189, v180;
            v190 = arith.constant 12 : u32;
            v191 = arith.add v182, v190 : u32 #[overflow = checked];
            v192 = hir.int_to_ptr v191 : ptr<byte, felt>;
            hir.store v192, v181;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v193: i32, v194: i32, v195: i32) {
        ^block24(v193: i32, v194: i32, v195: i32):
            v197 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v198 = hir.bitcast v197 : ptr<byte, i32>;
            v199 = hir.load v198 : i32;
            v200 = arith.constant 16 : i32;
            v201 = arith.sub v199, v200 : i32 #[overflow = wrapping];
            v202 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v203 = hir.bitcast v202 : ptr<byte, i32>;
            hir.store v203, v201;
            v204 = arith.constant 4 : i32;
            v205 = arith.add v201, v204 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_words/alloc::raw_vec::RawVecInner<A>::current_memory(v205, v193, v194, v195)
            v207 = arith.constant 8 : u32;
            v206 = hir.bitcast v201 : u32;
            v208 = arith.add v206, v207 : u32 #[overflow = checked];
            v209 = arith.constant 4 : u32;
            v210 = arith.mod v208, v209 : u32;
            hir.assertz v210 #[code = 250];
            v211 = hir.int_to_ptr v208 : ptr<byte, i32>;
            v212 = hir.load v211 : i32;
            v404 = arith.constant 0 : i32;
            v196 = arith.constant 0 : i32;
            v214 = arith.eq v212, v196 : i1;
            v215 = arith.zext v214 : u32;
            v216 = hir.bitcast v215 : i32;
            v218 = arith.neq v216, v404 : i1;
            scf.if v218{
            ^block46:
                scf.yield ;
            } else {
            ^block27:
                v403 = arith.constant 4 : u32;
                v219 = hir.bitcast v201 : u32;
                v221 = arith.add v219, v403 : u32 #[overflow = checked];
                v402 = arith.constant 4 : u32;
                v223 = arith.mod v221, v402 : u32;
                hir.assertz v223 #[code = 250];
                v224 = hir.int_to_ptr v221 : ptr<byte, i32>;
                v225 = hir.load v224 : i32;
                v227 = arith.constant 12 : u32;
                v226 = hir.bitcast v201 : u32;
                v228 = arith.add v226, v227 : u32 #[overflow = checked];
                v401 = arith.constant 4 : u32;
                v230 = arith.mod v228, v401 : u32;
                hir.assertz v230 #[code = 250];
                v231 = hir.int_to_ptr v228 : ptr<byte, i32>;
                v232 = hir.load v231 : i32;
                hir.exec @root_ns:root@1.0.0/hash_words/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v225, v212, v232)
                scf.yield ;
            };
            v400 = arith.constant 16 : i32;
            v235 = arith.add v201, v400 : i32 #[overflow = wrapping];
            v236 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v237 = hir.bitcast v236 : ptr<byte, i32>;
            hir.store v237, v235;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v238: i32, v239: i32, v240: i32, v241: i32) {
        ^block28(v238: i32, v239: i32, v240: i32, v241: i32):
            v430 = arith.constant 0 : i32;
            v242 = arith.constant 0 : i32;
            v246 = arith.eq v241, v242 : i1;
            v247 = arith.zext v246 : u32;
            v248 = hir.bitcast v247 : i32;
            v250 = arith.neq v248, v430 : i1;
            v417, v418 = scf.if v250 : i32, i32 {
            ^block49:
                v429 = arith.constant 0 : i32;
                v244 = arith.constant 4 : i32;
                scf.yield v244, v429;
            } else {
            ^block31:
                v251 = hir.bitcast v239 : u32;
                v286 = arith.constant 4 : u32;
                v253 = arith.mod v251, v286 : u32;
                hir.assertz v253 #[code = 250];
                v254 = hir.int_to_ptr v251 : ptr<byte, i32>;
                v255 = hir.load v254 : i32;
                v427 = arith.constant 0 : i32;
                v428 = arith.constant 0 : i32;
                v257 = arith.eq v255, v428 : i1;
                v258 = arith.zext v257 : u32;
                v259 = hir.bitcast v258 : i32;
                v261 = arith.neq v259, v427 : i1;
                v415 = scf.if v261 : i32 {
                ^block48:
                    v426 = arith.constant 0 : i32;
                    scf.yield v426;
                } else {
                ^block32:
                    v425 = arith.constant 4 : u32;
                    v262 = hir.bitcast v238 : u32;
                    v264 = arith.add v262, v425 : u32 #[overflow = checked];
                    v424 = arith.constant 4 : u32;
                    v266 = arith.mod v264, v424 : u32;
                    hir.assertz v266 #[code = 250];
                    v267 = hir.int_to_ptr v264 : ptr<byte, i32>;
                    hir.store v267, v240;
                    v423 = arith.constant 4 : u32;
                    v268 = hir.bitcast v239 : u32;
                    v270 = arith.add v268, v423 : u32 #[overflow = checked];
                    v422 = arith.constant 4 : u32;
                    v272 = arith.mod v270, v422 : u32;
                    hir.assertz v272 #[code = 250];
                    v273 = hir.int_to_ptr v270 : ptr<byte, i32>;
                    v274 = hir.load v273 : i32;
                    v275 = hir.bitcast v238 : u32;
                    v421 = arith.constant 4 : u32;
                    v277 = arith.mod v275, v421 : u32;
                    hir.assertz v277 #[code = 250];
                    v278 = hir.int_to_ptr v275 : ptr<byte, i32>;
                    hir.store v278, v274;
                    v279 = arith.mul v255, v241 : i32 #[overflow = wrapping];
                    scf.yield v279;
                };
                v280 = arith.constant 8 : i32;
                v420 = arith.constant 4 : i32;
                v416 = cf.select v261, v420, v280 : i32;
                scf.yield v416, v415;
            };
            v283 = arith.add v238, v417 : i32 #[overflow = wrapping];
            v285 = hir.bitcast v283 : u32;
            v419 = arith.constant 4 : u32;
            v287 = arith.mod v285, v419 : u32;
            hir.assertz v287 #[code = 250];
            v288 = hir.int_to_ptr v285 : ptr<byte, i32>;
            hir.store v288, v418;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v289: i32, v290: i32, v291: i32) {
        ^block33(v289: i32, v290: i32, v291: i32):
            v432 = arith.constant 0 : i32;
            v292 = arith.constant 0 : i32;
            v293 = arith.eq v291, v292 : i1;
            v294 = arith.zext v293 : u32;
            v295 = hir.bitcast v294 : i32;
            v297 = arith.neq v295, v432 : i1;
            scf.if v297{
            ^block35:
                scf.yield ;
            } else {
            ^block36:
                hir.exec @root_ns:root@1.0.0/hash_words/__rustc::__rust_dealloc(v289, v291, v290)
                scf.yield ;
            };
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};