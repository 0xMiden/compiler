builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_words {
        private builtin.function @__rustc::__rust_dealloc(v0: i32, v1: i32, v2: i32) {
        ^block4(v0: i32, v1: i32, v2: i32):
            builtin.ret ;
        };

        public builtin.function @entrypoint(v3: i32) -> felt {
        ^block6(v3: i32):
            v7 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v8 = hir.bitcast v7 : ptr<byte, i32>;
            v9 = hir.load v8 : i32;
            v10 = arith.constant 48 : i32;
            v11 = arith.sub v9, v10 : i32 #[overflow = wrapping];
            v12 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v13 = hir.bitcast v12 : ptr<byte, i32>;
            hir.store v13, v11;
            v15 = arith.constant 4 : u32;
            v14 = hir.bitcast v3 : u32;
            v16 = arith.add v14, v15 : u32 #[overflow = checked];
            v311 = arith.constant 4 : u32;
            v18 = arith.mod v16, v311 : u32;
            hir.assertz v18 #[code = 250];
            v19 = hir.int_to_ptr v16 : ptr<byte, i32>;
            v20 = hir.load v19 : i32;
            v22 = arith.constant 8 : u32;
            v21 = hir.bitcast v3 : u32;
            v23 = arith.add v21, v22 : u32 #[overflow = checked];
            v310 = arith.constant 4 : u32;
            v25 = arith.mod v23, v310 : u32;
            hir.assertz v25 #[code = 250];
            v26 = hir.int_to_ptr v23 : ptr<byte, i32>;
            v27 = hir.load v26 : i32;
            v5 = arith.constant 0 : i32;
            v29 = hir.exec @root_ns:root@1.0.0/hash_words/intrinsics::felt::from_u32(v5) : felt
            v309 = arith.constant 0 : i32;
            v31 = hir.exec @root_ns:root@1.0.0/hash_words/intrinsics::felt::from_u32(v309) : felt
            hir.exec @root_ns:root@1.0.0/hash_words/intrinsics::felt::assert_eq(v29, v31)
            v300 = arith.constant 2 : u32;
            v33 = hir.bitcast v20 : u32;
            v35 = arith.shr v33, v300 : u32;
            v36 = hir.bitcast v35 : i32;
            v41 = arith.constant 16 : i32;
            v42 = arith.add v11, v41 : i32 #[overflow = wrapping];
            v308 = arith.constant 2 : u32;
            v39 = arith.shl v27, v308 : i32;
            v40 = arith.add v36, v39 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_words/std::crypto::hashes::rpo::hash_memory_words(v36, v40, v42)
            v44 = arith.constant 24 : u32;
            v43 = hir.bitcast v11 : u32;
            v45 = arith.add v43, v44 : u32 #[overflow = checked];
            v307 = arith.constant 8 : u32;
            v47 = arith.mod v45, v307 : u32;
            hir.assertz v47 #[code = 250];
            v48 = hir.int_to_ptr v45 : ptr<byte, i64>;
            v49 = hir.load v48 : i64;
            v51 = arith.constant 40 : u32;
            v50 = hir.bitcast v11 : u32;
            v52 = arith.add v50, v51 : u32 #[overflow = checked];
            v306 = arith.constant 8 : u32;
            v54 = arith.mod v52, v306 : u32;
            hir.assertz v54 #[code = 250];
            v55 = hir.int_to_ptr v52 : ptr<byte, i64>;
            hir.store v55, v49;
            v57 = arith.constant 16 : u32;
            v56 = hir.bitcast v11 : u32;
            v58 = arith.add v56, v57 : u32 #[overflow = checked];
            v305 = arith.constant 8 : u32;
            v60 = arith.mod v58, v305 : u32;
            hir.assertz v60 #[code = 250];
            v61 = hir.int_to_ptr v58 : ptr<byte, i64>;
            v62 = hir.load v61 : i64;
            v64 = arith.constant 32 : u32;
            v63 = hir.bitcast v11 : u32;
            v65 = arith.add v63, v64 : u32 #[overflow = checked];
            v304 = arith.constant 8 : u32;
            v67 = arith.mod v65, v304 : u32;
            hir.assertz v67 #[code = 250];
            v68 = hir.int_to_ptr v65 : ptr<byte, i64>;
            hir.store v68, v62;
            v69 = arith.constant 32 : i32;
            v70 = arith.add v11, v69 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_words/<miden_stdlib_sys::intrinsics::word::Word>::reverse(v11, v70)
            v71 = hir.bitcast v11 : u32;
            v303 = arith.constant 4 : u32;
            v73 = arith.mod v71, v303 : u32;
            hir.assertz v73 #[code = 250];
            v74 = hir.int_to_ptr v71 : ptr<byte, felt>;
            v75 = hir.load v74 : felt;
            v302 = arith.constant 16 : i32;
            hir.exec @root_ns:root@1.0.0/hash_words/<alloc::raw_vec::RawVecInner>::deallocate(v3, v302, v302)
            v301 = arith.constant 48 : i32;
            v79 = arith.add v11, v301 : i32 #[overflow = wrapping];
            v80 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v81 = hir.bitcast v80 : ptr<byte, i32>;
            hir.store v81, v79;
            builtin.ret v75;
        };

        private builtin.function @<miden_stdlib_sys::intrinsics::word::Word>::reverse(v82: i32, v83: i32) {
        ^block8(v82: i32, v83: i32):
            v86 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v87 = hir.bitcast v86 : ptr<byte, i32>;
            v88 = hir.load v87 : i32;
            v89 = arith.constant 16 : i32;
            v90 = arith.sub v88, v89 : i32 #[overflow = wrapping];
            v92 = arith.constant 8 : u32;
            v91 = hir.bitcast v83 : u32;
            v93 = arith.add v91, v92 : u32 #[overflow = checked];
            v398 = arith.constant 8 : u32;
            v95 = arith.mod v93, v398 : u32;
            hir.assertz v95 #[code = 250];
            v96 = hir.int_to_ptr v93 : ptr<byte, i64>;
            v97 = hir.load v96 : i64;
            v397 = arith.constant 8 : u32;
            v98 = hir.bitcast v90 : u32;
            v100 = arith.add v98, v397 : u32 #[overflow = checked];
            v101 = arith.constant 4 : u32;
            v102 = arith.mod v100, v101 : u32;
            hir.assertz v102 #[code = 250];
            v103 = hir.int_to_ptr v100 : ptr<byte, i64>;
            hir.store v103, v97;
            v104 = hir.bitcast v83 : u32;
            v396 = arith.constant 8 : u32;
            v106 = arith.mod v104, v396 : u32;
            hir.assertz v106 #[code = 250];
            v107 = hir.int_to_ptr v104 : ptr<byte, i64>;
            v108 = hir.load v107 : i64;
            v109 = hir.bitcast v90 : u32;
            v395 = arith.constant 4 : u32;
            v111 = arith.mod v109, v395 : u32;
            hir.assertz v111 #[code = 250];
            v112 = hir.int_to_ptr v109 : ptr<byte, i64>;
            hir.store v112, v108;
            v113 = arith.constant 12 : i32;
            v114 = arith.add v90, v113 : i32 #[overflow = wrapping];
            v84 = arith.constant 0 : i32;
            v366, v367, v368, v369, v370, v371 = scf.while v84, v90, v114, v82 : i32, i32, i32, i32, i32, i32 {
            ^block44(v372: i32, v373: i32, v374: i32, v375: i32):
                v394 = arith.constant 0 : i32;
                v117 = arith.constant 8 : i32;
                v118 = arith.eq v372, v117 : i1;
                v119 = arith.zext v118 : u32;
                v120 = hir.bitcast v119 : i32;
                v122 = arith.neq v120, v394 : i1;
                v360, v361 = scf.if v122 : i32, i32 {
                ^block43:
                    v320 = ub.poison i32 : i32;
                    scf.yield v320, v320;
                } else {
                ^block13:
                    v124 = arith.add v373, v372 : i32 #[overflow = wrapping];
                    v125 = hir.bitcast v124 : u32;
                    v393 = arith.constant 4 : u32;
                    v127 = arith.mod v125, v393 : u32;
                    hir.assertz v127 #[code = 250];
                    v128 = hir.int_to_ptr v125 : ptr<byte, felt>;
                    v129 = hir.load v128 : felt;
                    v131 = hir.bitcast v374 : u32;
                    v392 = arith.constant 4 : u32;
                    v133 = arith.mod v131, v392 : u32;
                    hir.assertz v133 #[code = 250];
                    v134 = hir.int_to_ptr v131 : ptr<byte, i32>;
                    v135 = hir.load v134 : i32;
                    v136 = hir.bitcast v124 : u32;
                    v391 = arith.constant 4 : u32;
                    v138 = arith.mod v136, v391 : u32;
                    hir.assertz v138 #[code = 250];
                    v139 = hir.int_to_ptr v136 : ptr<byte, i32>;
                    hir.store v139, v135;
                    v140 = hir.bitcast v374 : u32;
                    v390 = arith.constant 4 : u32;
                    v142 = arith.mod v140, v390 : u32;
                    hir.assertz v142 #[code = 250];
                    v143 = hir.int_to_ptr v140 : ptr<byte, felt>;
                    hir.store v143, v129;
                    v146 = arith.constant -4 : i32;
                    v147 = arith.add v374, v146 : i32 #[overflow = wrapping];
                    v144 = arith.constant 4 : i32;
                    v145 = arith.add v372, v144 : i32 #[overflow = wrapping];
                    scf.yield v145, v147;
                };
                v388 = ub.poison i32 : i32;
                v363 = cf.select v122, v388, v375 : i32;
                v389 = ub.poison i32 : i32;
                v362 = cf.select v122, v389, v373 : i32;
                v319 = arith.constant 1 : u32;
                v312 = arith.constant 0 : u32;
                v365 = cf.select v122, v312, v319 : u32;
                v353 = arith.trunc v365 : i1;
                scf.condition v353, v360, v362, v361, v363, v373, v375;
            } do {
            ^block45(v376: i32, v377: i32, v378: i32, v379: i32, v380: i32, v381: i32):
                scf.yield v376, v377, v378, v379;
            };
            v387 = arith.constant 8 : u32;
            v149 = hir.bitcast v370 : u32;
            v151 = arith.add v149, v387 : u32 #[overflow = checked];
            v386 = arith.constant 4 : u32;
            v153 = arith.mod v151, v386 : u32;
            hir.assertz v153 #[code = 250];
            v154 = hir.int_to_ptr v151 : ptr<byte, i64>;
            v155 = hir.load v154 : i64;
            v385 = arith.constant 8 : u32;
            v156 = hir.bitcast v371 : u32;
            v158 = arith.add v156, v385 : u32 #[overflow = checked];
            v384 = arith.constant 8 : u32;
            v160 = arith.mod v158, v384 : u32;
            hir.assertz v160 #[code = 250];
            v161 = hir.int_to_ptr v158 : ptr<byte, i64>;
            hir.store v161, v155;
            v162 = hir.bitcast v370 : u32;
            v383 = arith.constant 4 : u32;
            v164 = arith.mod v162, v383 : u32;
            hir.assertz v164 #[code = 250];
            v165 = hir.int_to_ptr v162 : ptr<byte, i64>;
            v166 = hir.load v165 : i64;
            v167 = hir.bitcast v371 : u32;
            v382 = arith.constant 8 : u32;
            v169 = arith.mod v167, v382 : u32;
            hir.assertz v169 #[code = 250];
            v170 = hir.int_to_ptr v167 : ptr<byte, i64>;
            hir.store v170, v166;
            builtin.ret ;
        };

        private builtin.function @intrinsics::felt::assert_eq(v171: felt, v172: felt) {
        ^block14(v171: felt, v172: felt):
            hir.assert_eq v171, v172;
            builtin.ret ;
        };

        private builtin.function @intrinsics::felt::from_u32(v173: i32) -> felt {
        ^block16(v173: i32):
            v174 = hir.bitcast v173 : felt;
            builtin.ret v174;
        };

        private builtin.function @std::crypto::hashes::rpo::hash_memory_words(v176: i32, v177: i32, v178: i32) {
        ^block18(v176: i32, v177: i32, v178: i32):
            v179, v180, v181, v182 = hir.exec @std/crypto/hashes/rpo/hash_memory_words(v176, v177) : felt, felt, felt, felt
            v183 = hir.bitcast v178 : u32;
            v184 = hir.int_to_ptr v183 : ptr<byte, felt>;
            hir.store v184, v179;
            v185 = arith.constant 4 : u32;
            v186 = arith.add v183, v185 : u32 #[overflow = checked];
            v187 = hir.int_to_ptr v186 : ptr<byte, felt>;
            hir.store v187, v180;
            v188 = arith.constant 8 : u32;
            v189 = arith.add v183, v188 : u32 #[overflow = checked];
            v190 = hir.int_to_ptr v189 : ptr<byte, felt>;
            hir.store v190, v181;
            v191 = arith.constant 12 : u32;
            v192 = arith.add v183, v191 : u32 #[overflow = checked];
            v193 = hir.int_to_ptr v192 : ptr<byte, felt>;
            hir.store v193, v182;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::deallocate(v194: i32, v195: i32, v196: i32) {
        ^block24(v194: i32, v195: i32, v196: i32):
            v198 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v199 = hir.bitcast v198 : ptr<byte, i32>;
            v200 = hir.load v199 : i32;
            v201 = arith.constant 16 : i32;
            v202 = arith.sub v200, v201 : i32 #[overflow = wrapping];
            v203 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v204 = hir.bitcast v203 : ptr<byte, i32>;
            hir.store v204, v202;
            v205 = arith.constant 4 : i32;
            v206 = arith.add v202, v205 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_words/<alloc::raw_vec::RawVecInner>::current_memory(v206, v194, v195, v196)
            v208 = arith.constant 8 : u32;
            v207 = hir.bitcast v202 : u32;
            v209 = arith.add v207, v208 : u32 #[overflow = checked];
            v210 = arith.constant 4 : u32;
            v211 = arith.mod v209, v210 : u32;
            hir.assertz v211 #[code = 250];
            v212 = hir.int_to_ptr v209 : ptr<byte, i32>;
            v213 = hir.load v212 : i32;
            v405 = arith.constant 0 : i32;
            v197 = arith.constant 0 : i32;
            v215 = arith.eq v213, v197 : i1;
            v216 = arith.zext v215 : u32;
            v217 = hir.bitcast v216 : i32;
            v219 = arith.neq v217, v405 : i1;
            scf.if v219{
            ^block46:
                scf.yield ;
            } else {
            ^block27:
                v404 = arith.constant 4 : u32;
                v220 = hir.bitcast v202 : u32;
                v222 = arith.add v220, v404 : u32 #[overflow = checked];
                v403 = arith.constant 4 : u32;
                v224 = arith.mod v222, v403 : u32;
                hir.assertz v224 #[code = 250];
                v225 = hir.int_to_ptr v222 : ptr<byte, i32>;
                v226 = hir.load v225 : i32;
                v228 = arith.constant 12 : u32;
                v227 = hir.bitcast v202 : u32;
                v229 = arith.add v227, v228 : u32 #[overflow = checked];
                v402 = arith.constant 4 : u32;
                v231 = arith.mod v229, v402 : u32;
                hir.assertz v231 #[code = 250];
                v232 = hir.int_to_ptr v229 : ptr<byte, i32>;
                v233 = hir.load v232 : i32;
                hir.exec @root_ns:root@1.0.0/hash_words/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v226, v213, v233)
                scf.yield ;
            };
            v401 = arith.constant 16 : i32;
            v236 = arith.add v202, v401 : i32 #[overflow = wrapping];
            v237 = builtin.global_symbol @root_ns:root@1.0.0/hash_words/__stack_pointer : ptr<byte, u8>
            v238 = hir.bitcast v237 : ptr<byte, i32>;
            hir.store v238, v236;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::current_memory(v239: i32, v240: i32, v241: i32, v242: i32) {
        ^block28(v239: i32, v240: i32, v241: i32, v242: i32):
            v431 = arith.constant 0 : i32;
            v243 = arith.constant 0 : i32;
            v247 = arith.eq v242, v243 : i1;
            v248 = arith.zext v247 : u32;
            v249 = hir.bitcast v248 : i32;
            v251 = arith.neq v249, v431 : i1;
            v418, v419 = scf.if v251 : i32, i32 {
            ^block49:
                v430 = arith.constant 0 : i32;
                v245 = arith.constant 4 : i32;
                scf.yield v245, v430;
            } else {
            ^block31:
                v252 = hir.bitcast v240 : u32;
                v287 = arith.constant 4 : u32;
                v254 = arith.mod v252, v287 : u32;
                hir.assertz v254 #[code = 250];
                v255 = hir.int_to_ptr v252 : ptr<byte, i32>;
                v256 = hir.load v255 : i32;
                v428 = arith.constant 0 : i32;
                v429 = arith.constant 0 : i32;
                v258 = arith.eq v256, v429 : i1;
                v259 = arith.zext v258 : u32;
                v260 = hir.bitcast v259 : i32;
                v262 = arith.neq v260, v428 : i1;
                v416 = scf.if v262 : i32 {
                ^block48:
                    v427 = arith.constant 0 : i32;
                    scf.yield v427;
                } else {
                ^block32:
                    v426 = arith.constant 4 : u32;
                    v263 = hir.bitcast v239 : u32;
                    v265 = arith.add v263, v426 : u32 #[overflow = checked];
                    v425 = arith.constant 4 : u32;
                    v267 = arith.mod v265, v425 : u32;
                    hir.assertz v267 #[code = 250];
                    v268 = hir.int_to_ptr v265 : ptr<byte, i32>;
                    hir.store v268, v241;
                    v424 = arith.constant 4 : u32;
                    v269 = hir.bitcast v240 : u32;
                    v271 = arith.add v269, v424 : u32 #[overflow = checked];
                    v423 = arith.constant 4 : u32;
                    v273 = arith.mod v271, v423 : u32;
                    hir.assertz v273 #[code = 250];
                    v274 = hir.int_to_ptr v271 : ptr<byte, i32>;
                    v275 = hir.load v274 : i32;
                    v276 = hir.bitcast v239 : u32;
                    v422 = arith.constant 4 : u32;
                    v278 = arith.mod v276, v422 : u32;
                    hir.assertz v278 #[code = 250];
                    v279 = hir.int_to_ptr v276 : ptr<byte, i32>;
                    hir.store v279, v275;
                    v280 = arith.mul v256, v242 : i32 #[overflow = wrapping];
                    scf.yield v280;
                };
                v281 = arith.constant 8 : i32;
                v421 = arith.constant 4 : i32;
                v417 = cf.select v262, v421, v281 : i32;
                scf.yield v417, v416;
            };
            v284 = arith.add v239, v418 : i32 #[overflow = wrapping];
            v286 = hir.bitcast v284 : u32;
            v420 = arith.constant 4 : u32;
            v288 = arith.mod v286, v420 : u32;
            hir.assertz v288 #[code = 250];
            v289 = hir.int_to_ptr v286 : ptr<byte, i32>;
            hir.store v289, v419;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v290: i32, v291: i32, v292: i32) {
        ^block33(v290: i32, v291: i32, v292: i32):
            v433 = arith.constant 0 : i32;
            v293 = arith.constant 0 : i32;
            v294 = arith.eq v292, v293 : i1;
            v295 = arith.zext v294 : u32;
            v296 = hir.bitcast v295 : i32;
            v298 = arith.neq v296, v433 : i1;
            scf.if v298{
            ^block35:
                scf.yield ;
            } else {
            ^block36:
                hir.exec @root_ns:root@1.0.0/hash_words/__rustc::__rust_dealloc(v290, v292, v291)
                scf.yield ;
            };
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};