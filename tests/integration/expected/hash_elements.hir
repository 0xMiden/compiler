builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_elements {
        private builtin.function @__rustc::__rust_dealloc(v0: i32, v1: i32, v2: i32) {
        ^block4(v0: i32, v1: i32, v2: i32):
            builtin.ret ;
        };

        public builtin.function @entrypoint(v3: i32) -> felt {
        ^block6(v3: i32):
            v7 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v8 = hir.bitcast v7 : ptr<byte, i32>;
            v9 = hir.load v8 : i32;
            v10 = arith.constant 48 : i32;
            v11 = arith.sub v9, v10 : i32 #[overflow = wrapping];
            v12 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v13 = hir.bitcast v12 : ptr<byte, i32>;
            hir.store v13, v11;
            v15 = arith.constant 8 : u32;
            v14 = hir.bitcast v3 : u32;
            v16 = arith.add v14, v15 : u32 #[overflow = checked];
            v17 = arith.constant 4 : u32;
            v18 = arith.mod v16, v17 : u32;
            hir.assertz v18 #[code = 250];
            v19 = hir.int_to_ptr v16 : ptr<byte, i32>;
            v20 = hir.load v19 : i32;
            v338 = arith.constant 4 : u32;
            v21 = hir.bitcast v3 : u32;
            v23 = arith.add v21, v338 : u32 #[overflow = checked];
            v337 = arith.constant 4 : u32;
            v25 = arith.mod v23, v337 : u32;
            hir.assertz v25 #[code = 250];
            v26 = hir.int_to_ptr v23 : ptr<byte, i32>;
            v27 = hir.load v26 : i32;
            v323 = arith.constant 2 : u32;
            v29 = hir.bitcast v27 : u32;
            v31 = arith.shr v29, v323 : u32;
            v32 = hir.bitcast v31 : i32;
            v322 = arith.constant 0 : felt;
            v33 = arith.constant 3 : i32;
            v34 = arith.band v32, v33 : i32;
            v35 = hir.bitcast v34 : felt;
            hir.assert_eq v35, v322;
            v335 = arith.constant 0 : i32;
            v5 = arith.constant 0 : i32;
            v336 = arith.constant 3 : i32;
            v39 = arith.band v20, v336 : i32;
            v41 = arith.eq v39, v5 : i1;
            v42 = arith.zext v41 : u32;
            v43 = hir.bitcast v42 : i32;
            v45 = arith.neq v43, v335 : i1;
            scf.if v45{
            ^block9:
                v49 = arith.constant 16 : i32;
                v50 = arith.add v11, v49 : i32 #[overflow = wrapping];
                v48 = arith.add v32, v20 : i32 #[overflow = wrapping];
                hir.exec @root_ns:root@1.0.0/hash_elements/std::crypto::hashes::rpo::hash_memory_words(v32, v48, v50)
                scf.yield ;
            } else {
            ^block10:
                v334 = arith.constant 16 : i32;
                v47 = arith.add v11, v334 : i32 #[overflow = wrapping];
                hir.exec @root_ns:root@1.0.0/hash_elements/std::crypto::hashes::rpo::hash_memory(v32, v20, v47)
                scf.yield ;
            };
            v53 = arith.constant 24 : u32;
            v52 = hir.bitcast v11 : u32;
            v54 = arith.add v52, v53 : u32 #[overflow = checked];
            v333 = arith.constant 8 : u32;
            v56 = arith.mod v54, v333 : u32;
            hir.assertz v56 #[code = 250];
            v57 = hir.int_to_ptr v54 : ptr<byte, i64>;
            v58 = hir.load v57 : i64;
            v60 = arith.constant 40 : u32;
            v59 = hir.bitcast v11 : u32;
            v61 = arith.add v59, v60 : u32 #[overflow = checked];
            v332 = arith.constant 8 : u32;
            v63 = arith.mod v61, v332 : u32;
            hir.assertz v63 #[code = 250];
            v64 = hir.int_to_ptr v61 : ptr<byte, i64>;
            hir.store v64, v58;
            v66 = arith.constant 16 : u32;
            v65 = hir.bitcast v11 : u32;
            v67 = arith.add v65, v66 : u32 #[overflow = checked];
            v331 = arith.constant 8 : u32;
            v69 = arith.mod v67, v331 : u32;
            hir.assertz v69 #[code = 250];
            v70 = hir.int_to_ptr v67 : ptr<byte, i64>;
            v71 = hir.load v70 : i64;
            v73 = arith.constant 32 : u32;
            v72 = hir.bitcast v11 : u32;
            v74 = arith.add v72, v73 : u32 #[overflow = checked];
            v330 = arith.constant 8 : u32;
            v76 = arith.mod v74, v330 : u32;
            hir.assertz v76 #[code = 250];
            v77 = hir.int_to_ptr v74 : ptr<byte, i64>;
            hir.store v77, v71;
            v78 = arith.constant 32 : i32;
            v79 = arith.add v11, v78 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/<miden_stdlib_sys::intrinsics::word::Word>::reverse(v11, v79)
            v81 = arith.constant 4 : i32;
            hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::raw_vec::RawVecInner>::deallocate(v3, v81, v81)
            v83 = hir.bitcast v11 : u32;
            v329 = arith.constant 4 : u32;
            v85 = arith.mod v83, v329 : u32;
            hir.assertz v85 #[code = 250];
            v86 = hir.int_to_ptr v83 : ptr<byte, felt>;
            v87 = hir.load v86 : felt;
            v328 = arith.constant 48 : i32;
            v89 = arith.add v11, v328 : i32 #[overflow = wrapping];
            v90 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v91 = hir.bitcast v90 : ptr<byte, i32>;
            hir.store v91, v89;
            builtin.ret v87;
        };

        private builtin.function @<miden_stdlib_sys::intrinsics::word::Word>::reverse(v92: i32, v93: i32) {
        ^block11(v92: i32, v93: i32):
            v96 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v97 = hir.bitcast v96 : ptr<byte, i32>;
            v98 = hir.load v97 : i32;
            v99 = arith.constant 16 : i32;
            v100 = arith.sub v98, v99 : i32 #[overflow = wrapping];
            v102 = arith.constant 8 : u32;
            v101 = hir.bitcast v93 : u32;
            v103 = arith.add v101, v102 : u32 #[overflow = checked];
            v425 = arith.constant 8 : u32;
            v105 = arith.mod v103, v425 : u32;
            hir.assertz v105 #[code = 250];
            v106 = hir.int_to_ptr v103 : ptr<byte, i64>;
            v107 = hir.load v106 : i64;
            v424 = arith.constant 8 : u32;
            v108 = hir.bitcast v100 : u32;
            v110 = arith.add v108, v424 : u32 #[overflow = checked];
            v111 = arith.constant 4 : u32;
            v112 = arith.mod v110, v111 : u32;
            hir.assertz v112 #[code = 250];
            v113 = hir.int_to_ptr v110 : ptr<byte, i64>;
            hir.store v113, v107;
            v114 = hir.bitcast v93 : u32;
            v423 = arith.constant 8 : u32;
            v116 = arith.mod v114, v423 : u32;
            hir.assertz v116 #[code = 250];
            v117 = hir.int_to_ptr v114 : ptr<byte, i64>;
            v118 = hir.load v117 : i64;
            v119 = hir.bitcast v100 : u32;
            v422 = arith.constant 4 : u32;
            v121 = arith.mod v119, v422 : u32;
            hir.assertz v121 #[code = 250];
            v122 = hir.int_to_ptr v119 : ptr<byte, i64>;
            hir.store v122, v118;
            v123 = arith.constant 12 : i32;
            v124 = arith.add v100, v123 : i32 #[overflow = wrapping];
            v94 = arith.constant 0 : i32;
            v393, v394, v395, v396, v397, v398 = scf.while v94, v100, v124, v92 : i32, i32, i32, i32, i32, i32 {
            ^block46(v399: i32, v400: i32, v401: i32, v402: i32):
                v421 = arith.constant 0 : i32;
                v127 = arith.constant 8 : i32;
                v128 = arith.eq v399, v127 : i1;
                v129 = arith.zext v128 : u32;
                v130 = hir.bitcast v129 : i32;
                v132 = arith.neq v130, v421 : i1;
                v387, v388 = scf.if v132 : i32, i32 {
                ^block45:
                    v347 = ub.poison i32 : i32;
                    scf.yield v347, v347;
                } else {
                ^block16:
                    v134 = arith.add v400, v399 : i32 #[overflow = wrapping];
                    v135 = hir.bitcast v134 : u32;
                    v420 = arith.constant 4 : u32;
                    v137 = arith.mod v135, v420 : u32;
                    hir.assertz v137 #[code = 250];
                    v138 = hir.int_to_ptr v135 : ptr<byte, felt>;
                    v139 = hir.load v138 : felt;
                    v141 = hir.bitcast v401 : u32;
                    v419 = arith.constant 4 : u32;
                    v143 = arith.mod v141, v419 : u32;
                    hir.assertz v143 #[code = 250];
                    v144 = hir.int_to_ptr v141 : ptr<byte, i32>;
                    v145 = hir.load v144 : i32;
                    v146 = hir.bitcast v134 : u32;
                    v418 = arith.constant 4 : u32;
                    v148 = arith.mod v146, v418 : u32;
                    hir.assertz v148 #[code = 250];
                    v149 = hir.int_to_ptr v146 : ptr<byte, i32>;
                    hir.store v149, v145;
                    v150 = hir.bitcast v401 : u32;
                    v417 = arith.constant 4 : u32;
                    v152 = arith.mod v150, v417 : u32;
                    hir.assertz v152 #[code = 250];
                    v153 = hir.int_to_ptr v150 : ptr<byte, felt>;
                    hir.store v153, v139;
                    v156 = arith.constant -4 : i32;
                    v157 = arith.add v401, v156 : i32 #[overflow = wrapping];
                    v154 = arith.constant 4 : i32;
                    v155 = arith.add v399, v154 : i32 #[overflow = wrapping];
                    scf.yield v155, v157;
                };
                v415 = ub.poison i32 : i32;
                v390 = cf.select v132, v415, v402 : i32;
                v416 = ub.poison i32 : i32;
                v389 = cf.select v132, v416, v400 : i32;
                v346 = arith.constant 1 : u32;
                v339 = arith.constant 0 : u32;
                v392 = cf.select v132, v339, v346 : u32;
                v380 = arith.trunc v392 : i1;
                scf.condition v380, v387, v389, v388, v390, v400, v402;
            } do {
            ^block47(v403: i32, v404: i32, v405: i32, v406: i32, v407: i32, v408: i32):
                scf.yield v403, v404, v405, v406;
            };
            v414 = arith.constant 8 : u32;
            v159 = hir.bitcast v397 : u32;
            v161 = arith.add v159, v414 : u32 #[overflow = checked];
            v413 = arith.constant 4 : u32;
            v163 = arith.mod v161, v413 : u32;
            hir.assertz v163 #[code = 250];
            v164 = hir.int_to_ptr v161 : ptr<byte, i64>;
            v165 = hir.load v164 : i64;
            v412 = arith.constant 8 : u32;
            v166 = hir.bitcast v398 : u32;
            v168 = arith.add v166, v412 : u32 #[overflow = checked];
            v411 = arith.constant 8 : u32;
            v170 = arith.mod v168, v411 : u32;
            hir.assertz v170 #[code = 250];
            v171 = hir.int_to_ptr v168 : ptr<byte, i64>;
            hir.store v171, v165;
            v172 = hir.bitcast v397 : u32;
            v410 = arith.constant 4 : u32;
            v174 = arith.mod v172, v410 : u32;
            hir.assertz v174 #[code = 250];
            v175 = hir.int_to_ptr v172 : ptr<byte, i64>;
            v176 = hir.load v175 : i64;
            v177 = hir.bitcast v398 : u32;
            v409 = arith.constant 8 : u32;
            v179 = arith.mod v177, v409 : u32;
            hir.assertz v179 #[code = 250];
            v180 = hir.int_to_ptr v177 : ptr<byte, i64>;
            hir.store v180, v176;
            builtin.ret ;
        };

        private builtin.function @std::crypto::hashes::rpo::hash_memory(v181: i32, v182: i32, v183: i32) {
        ^block17(v181: i32, v182: i32, v183: i32):
            v184, v185, v186, v187 = hir.exec @std/crypto/hashes/rpo/hash_memory(v181, v182) : felt, felt, felt, felt
            v188 = hir.bitcast v183 : u32;
            v189 = hir.int_to_ptr v188 : ptr<byte, felt>;
            hir.store v189, v184;
            v190 = arith.constant 4 : u32;
            v191 = arith.add v188, v190 : u32 #[overflow = checked];
            v192 = hir.int_to_ptr v191 : ptr<byte, felt>;
            hir.store v192, v185;
            v193 = arith.constant 8 : u32;
            v194 = arith.add v188, v193 : u32 #[overflow = checked];
            v195 = hir.int_to_ptr v194 : ptr<byte, felt>;
            hir.store v195, v186;
            v196 = arith.constant 12 : u32;
            v197 = arith.add v188, v196 : u32 #[overflow = checked];
            v198 = hir.int_to_ptr v197 : ptr<byte, felt>;
            hir.store v198, v187;
            builtin.ret ;
        };

        private builtin.function @std::crypto::hashes::rpo::hash_memory_words(v199: i32, v200: i32, v201: i32) {
        ^block23(v199: i32, v200: i32, v201: i32):
            v202, v203, v204, v205 = hir.exec @std/crypto/hashes/rpo/hash_memory_words(v199, v200) : felt, felt, felt, felt
            v206 = hir.bitcast v201 : u32;
            v207 = hir.int_to_ptr v206 : ptr<byte, felt>;
            hir.store v207, v202;
            v208 = arith.constant 4 : u32;
            v209 = arith.add v206, v208 : u32 #[overflow = checked];
            v210 = hir.int_to_ptr v209 : ptr<byte, felt>;
            hir.store v210, v203;
            v211 = arith.constant 8 : u32;
            v212 = arith.add v206, v211 : u32 #[overflow = checked];
            v213 = hir.int_to_ptr v212 : ptr<byte, felt>;
            hir.store v213, v204;
            v214 = arith.constant 12 : u32;
            v215 = arith.add v206, v214 : u32 #[overflow = checked];
            v216 = hir.int_to_ptr v215 : ptr<byte, felt>;
            hir.store v216, v205;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::deallocate(v217: i32, v218: i32, v219: i32) {
        ^block25(v217: i32, v218: i32, v219: i32):
            v221 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v222 = hir.bitcast v221 : ptr<byte, i32>;
            v223 = hir.load v222 : i32;
            v224 = arith.constant 16 : i32;
            v225 = arith.sub v223, v224 : i32 #[overflow = wrapping];
            v226 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v227 = hir.bitcast v226 : ptr<byte, i32>;
            hir.store v227, v225;
            v228 = arith.constant 4 : i32;
            v229 = arith.add v225, v228 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::raw_vec::RawVecInner>::current_memory(v229, v217, v218, v219)
            v231 = arith.constant 8 : u32;
            v230 = hir.bitcast v225 : u32;
            v232 = arith.add v230, v231 : u32 #[overflow = checked];
            v233 = arith.constant 4 : u32;
            v234 = arith.mod v232, v233 : u32;
            hir.assertz v234 #[code = 250];
            v235 = hir.int_to_ptr v232 : ptr<byte, i32>;
            v236 = hir.load v235 : i32;
            v432 = arith.constant 0 : i32;
            v220 = arith.constant 0 : i32;
            v238 = arith.eq v236, v220 : i1;
            v239 = arith.zext v238 : u32;
            v240 = hir.bitcast v239 : i32;
            v242 = arith.neq v240, v432 : i1;
            scf.if v242{
            ^block48:
                scf.yield ;
            } else {
            ^block28:
                v431 = arith.constant 4 : u32;
                v243 = hir.bitcast v225 : u32;
                v245 = arith.add v243, v431 : u32 #[overflow = checked];
                v430 = arith.constant 4 : u32;
                v247 = arith.mod v245, v430 : u32;
                hir.assertz v247 #[code = 250];
                v248 = hir.int_to_ptr v245 : ptr<byte, i32>;
                v249 = hir.load v248 : i32;
                v251 = arith.constant 12 : u32;
                v250 = hir.bitcast v225 : u32;
                v252 = arith.add v250, v251 : u32 #[overflow = checked];
                v429 = arith.constant 4 : u32;
                v254 = arith.mod v252, v429 : u32;
                hir.assertz v254 #[code = 250];
                v255 = hir.int_to_ptr v252 : ptr<byte, i32>;
                v256 = hir.load v255 : i32;
                hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v249, v236, v256)
                scf.yield ;
            };
            v428 = arith.constant 16 : i32;
            v259 = arith.add v225, v428 : i32 #[overflow = wrapping];
            v260 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v261 = hir.bitcast v260 : ptr<byte, i32>;
            hir.store v261, v259;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::current_memory(v262: i32, v263: i32, v264: i32, v265: i32) {
        ^block29(v262: i32, v263: i32, v264: i32, v265: i32):
            v458 = arith.constant 0 : i32;
            v266 = arith.constant 0 : i32;
            v270 = arith.eq v265, v266 : i1;
            v271 = arith.zext v270 : u32;
            v272 = hir.bitcast v271 : i32;
            v274 = arith.neq v272, v458 : i1;
            v445, v446 = scf.if v274 : i32, i32 {
            ^block51:
                v457 = arith.constant 0 : i32;
                v268 = arith.constant 4 : i32;
                scf.yield v268, v457;
            } else {
            ^block32:
                v275 = hir.bitcast v263 : u32;
                v310 = arith.constant 4 : u32;
                v277 = arith.mod v275, v310 : u32;
                hir.assertz v277 #[code = 250];
                v278 = hir.int_to_ptr v275 : ptr<byte, i32>;
                v279 = hir.load v278 : i32;
                v455 = arith.constant 0 : i32;
                v456 = arith.constant 0 : i32;
                v281 = arith.eq v279, v456 : i1;
                v282 = arith.zext v281 : u32;
                v283 = hir.bitcast v282 : i32;
                v285 = arith.neq v283, v455 : i1;
                v443 = scf.if v285 : i32 {
                ^block50:
                    v454 = arith.constant 0 : i32;
                    scf.yield v454;
                } else {
                ^block33:
                    v453 = arith.constant 4 : u32;
                    v286 = hir.bitcast v262 : u32;
                    v288 = arith.add v286, v453 : u32 #[overflow = checked];
                    v452 = arith.constant 4 : u32;
                    v290 = arith.mod v288, v452 : u32;
                    hir.assertz v290 #[code = 250];
                    v291 = hir.int_to_ptr v288 : ptr<byte, i32>;
                    hir.store v291, v264;
                    v451 = arith.constant 4 : u32;
                    v292 = hir.bitcast v263 : u32;
                    v294 = arith.add v292, v451 : u32 #[overflow = checked];
                    v450 = arith.constant 4 : u32;
                    v296 = arith.mod v294, v450 : u32;
                    hir.assertz v296 #[code = 250];
                    v297 = hir.int_to_ptr v294 : ptr<byte, i32>;
                    v298 = hir.load v297 : i32;
                    v299 = hir.bitcast v262 : u32;
                    v449 = arith.constant 4 : u32;
                    v301 = arith.mod v299, v449 : u32;
                    hir.assertz v301 #[code = 250];
                    v302 = hir.int_to_ptr v299 : ptr<byte, i32>;
                    hir.store v302, v298;
                    v303 = arith.mul v279, v265 : i32 #[overflow = wrapping];
                    scf.yield v303;
                };
                v304 = arith.constant 8 : i32;
                v448 = arith.constant 4 : i32;
                v444 = cf.select v285, v448, v304 : i32;
                scf.yield v444, v443;
            };
            v307 = arith.add v262, v445 : i32 #[overflow = wrapping];
            v309 = hir.bitcast v307 : u32;
            v447 = arith.constant 4 : u32;
            v311 = arith.mod v309, v447 : u32;
            hir.assertz v311 #[code = 250];
            v312 = hir.int_to_ptr v309 : ptr<byte, i32>;
            hir.store v312, v446;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v313: i32, v314: i32, v315: i32) {
        ^block34(v313: i32, v314: i32, v315: i32):
            v460 = arith.constant 0 : i32;
            v316 = arith.constant 0 : i32;
            v317 = arith.eq v315, v316 : i1;
            v318 = arith.zext v317 : u32;
            v319 = hir.bitcast v318 : i32;
            v321 = arith.neq v319, v460 : i1;
            scf.if v321{
            ^block36:
                scf.yield ;
            } else {
            ^block37:
                hir.exec @root_ns:root@1.0.0/hash_elements/__rustc::__rust_dealloc(v313, v315, v314)
                scf.yield ;
            };
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};