builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_elements {
        private builtin.function @__rustc::__rust_dealloc(v0: i32, v1: i32, v2: i32) {
        ^block4(v0: i32, v1: i32, v2: i32):
            builtin.ret ;
        };

        public builtin.function @entrypoint(v3: i32) -> felt {
        ^block6(v3: i32):
            hir.store_local v3 #[local = lv0];
            v5 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v6 = hir.bitcast v5 : ptr<byte, i32>;
            v7 = hir.load v6 : i32;
            v241 = arith.constant 16 : i32;
            v9 = arith.sub v7, v241 : i32 #[overflow = wrapping];
            hir.store_local v9 #[local = lv1];
            v10 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v11 = hir.bitcast v10 : ptr<byte, i32>;
            hir.store v11, v9;
            v12 = hir.load_local  : i32 #[local = lv0];
            v240 = arith.constant 8 : u32;
            v13 = hir.bitcast v12 : u32;
            v15 = arith.add v13, v240 : u32 #[overflow = checked];
            v239 = arith.constant 4 : u32;
            v17 = arith.mod v15, v239 : u32;
            hir.assertz v17 #[code = 250];
            v18 = hir.int_to_ptr v15 : ptr<byte, i32>;
            v19 = hir.load v18 : i32;
            hir.store_local v19 #[local = lv2];
            v20 = hir.load_local  : i32 #[local = lv0];
            v255 = arith.constant 4 : u32;
            v21 = hir.bitcast v20 : u32;
            v23 = arith.add v21, v255 : u32 #[overflow = checked];
            v254 = arith.constant 4 : u32;
            v25 = arith.mod v23, v254 : u32;
            hir.assertz v25 #[code = 250];
            v26 = hir.int_to_ptr v23 : ptr<byte, i32>;
            v27 = hir.load v26 : i32;
            v234 = arith.constant 2 : u32;
            v29 = hir.bitcast v27 : u32;
            v31 = arith.shr v29, v234 : u32;
            v32 = hir.bitcast v31 : i32;
            hir.store_local v32 #[local = lv3];
            v233 = arith.constant 0 : felt;
            v238 = arith.constant 3 : i32;
            v34 = arith.band v32, v238 : i32;
            v35 = hir.bitcast v34 : felt;
            hir.assert_eq v35, v233;
            v38 = hir.load_local  : i32 #[local = lv2];
            v252 = arith.constant 0 : i32;
            v244 = arith.constant 0 : i32;
            v253 = arith.constant 3 : i32;
            v40 = arith.band v38, v253 : i32;
            v42 = arith.eq v40, v244 : i1;
            v43 = arith.zext v42 : u32;
            v44 = hir.bitcast v43 : i32;
            v46 = arith.neq v44, v252 : i1;
            scf.if v46{
            ^block9:
                v50 = hir.load_local  : i32 #[local = lv3];
                v52 = hir.load_local  : i32 #[local = lv2];
                v54 = hir.load_local  : i32 #[local = lv1];
                v53 = arith.add v50, v52 : i32 #[overflow = wrapping];
                hir.exec @root_ns:root@1.0.0/hash_elements/miden::core::crypto::hashes::rpo256::hash_words(v50, v53, v54)
                scf.yield ;
            } else {
            ^block10:
                v47 = hir.load_local  : i32 #[local = lv3];
                v48 = hir.load_local  : i32 #[local = lv2];
                v49 = hir.load_local  : i32 #[local = lv1];
                hir.exec @root_ns:root@1.0.0/hash_elements/miden::core::crypto::hashes::rpo256::hash_elements(v47, v48, v49)
                scf.yield ;
            };
            v55 = hir.load_local  : i32 #[local = lv1];
            v236 = arith.constant 12 : u32;
            v56 = hir.bitcast v55 : u32;
            v58 = arith.add v56, v236 : u32 #[overflow = checked];
            v251 = arith.constant 4 : u32;
            v60 = arith.mod v58, v251 : u32;
            hir.assertz v60 #[code = 250];
            v61 = hir.int_to_ptr v58 : ptr<byte, felt>;
            v62 = hir.load v61 : felt;
            hir.store_local v62 #[local = lv4];
            v63 = hir.load_local  : i32 #[local = lv0];
            v235 = arith.constant 4 : i32;
            hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::raw_vec::RawVecInner>::deallocate(v63, v235, v235)
            v66 = hir.load_local  : i32 #[local = lv1];
            v250 = arith.constant 16 : i32;
            v68 = arith.add v66, v250 : i32 #[overflow = wrapping];
            v69 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v70 = hir.bitcast v69 : ptr<byte, i32>;
            hir.store v70, v68;
            v71 = hir.load_local  : felt #[local = lv4];
            builtin.ret v71;
        };

        private builtin.function @miden::core::crypto::hashes::rpo256::hash_elements(v72: i32, v73: i32, v74: i32) {
        ^block11(v72: i32, v73: i32, v74: i32):
            v75, v76, v77, v78 = hir.exec @miden/core/crypto/hashes/rpo256/hash_elements(v72, v73) : felt, felt, felt, felt
            v79 = hir.bitcast v74 : u32;
            v80 = hir.int_to_ptr v79 : ptr<byte, felt>;
            hir.store v80, v75;
            v258 = arith.constant 4 : u32;
            v82 = arith.add v79, v258 : u32 #[overflow = checked];
            v83 = hir.int_to_ptr v82 : ptr<byte, felt>;
            hir.store v83, v76;
            v257 = arith.constant 8 : u32;
            v85 = arith.add v79, v257 : u32 #[overflow = checked];
            v86 = hir.int_to_ptr v85 : ptr<byte, felt>;
            hir.store v86, v77;
            v256 = arith.constant 12 : u32;
            v88 = arith.add v79, v256 : u32 #[overflow = checked];
            v89 = hir.int_to_ptr v88 : ptr<byte, felt>;
            hir.store v89, v78;
            builtin.ret ;
        };

        private builtin.function @miden::core::crypto::hashes::rpo256::hash_words(v90: i32, v91: i32, v92: i32) {
        ^block18(v90: i32, v91: i32, v92: i32):
            v93, v94, v95, v96 = hir.exec @miden/core/crypto/hashes/rpo256/hash_words(v90, v91) : felt, felt, felt, felt
            v97 = hir.bitcast v92 : u32;
            v98 = hir.int_to_ptr v97 : ptr<byte, felt>;
            hir.store v98, v93;
            v261 = arith.constant 4 : u32;
            v100 = arith.add v97, v261 : u32 #[overflow = checked];
            v101 = hir.int_to_ptr v100 : ptr<byte, felt>;
            hir.store v101, v94;
            v260 = arith.constant 8 : u32;
            v103 = arith.add v97, v260 : u32 #[overflow = checked];
            v104 = hir.int_to_ptr v103 : ptr<byte, felt>;
            hir.store v104, v95;
            v259 = arith.constant 12 : u32;
            v106 = arith.add v97, v259 : u32 #[overflow = checked];
            v107 = hir.int_to_ptr v106 : ptr<byte, felt>;
            hir.store v107, v96;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::deallocate(v108: i32, v109: i32, v110: i32) {
        ^block20(v108: i32, v109: i32, v110: i32):
            hir.store_local v110 #[local = lv2];
            v111 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v112 = hir.bitcast v111 : ptr<byte, i32>;
            v113 = hir.load v112 : i32;
            v267 = arith.constant 16 : i32;
            v115 = arith.sub v113, v267 : i32 #[overflow = wrapping];
            hir.store_local v115 #[local = lv3];
            v116 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v117 = hir.bitcast v116 : ptr<byte, i32>;
            hir.store v117, v115;
            v118 = hir.load_local  : i32 #[local = lv3];
            v123 = hir.load_local  : i32 #[local = lv2];
            v266 = arith.constant 4 : i32;
            v120 = arith.add v118, v266 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::raw_vec::RawVecInner>::current_memory(v120, v108, v109, v123)
            v124 = hir.load_local  : i32 #[local = lv3];
            v265 = arith.constant 8 : u32;
            v125 = hir.bitcast v124 : u32;
            v127 = arith.add v125, v265 : u32 #[overflow = checked];
            v264 = arith.constant 4 : u32;
            v129 = arith.mod v127, v264 : u32;
            hir.assertz v129 #[code = 250];
            v130 = hir.int_to_ptr v127 : ptr<byte, i32>;
            v131 = hir.load v130 : i32;
            hir.store_local v131 #[local = lv2];
            v278 = arith.constant 0 : i32;
            v272 = arith.constant 0 : i32;
            v133 = arith.eq v131, v272 : i1;
            v134 = arith.zext v133 : u32;
            v135 = hir.bitcast v134 : i32;
            v137 = arith.neq v135, v278 : i1;
            scf.if v137{
            ^block34:
                scf.yield ;
            } else {
            ^block23:
                v138 = hir.load_local  : i32 #[local = lv3];
                v277 = arith.constant 4 : u32;
                v139 = hir.bitcast v138 : u32;
                v141 = arith.add v139, v277 : u32 #[overflow = checked];
                v276 = arith.constant 4 : u32;
                v143 = arith.mod v141, v276 : u32;
                hir.assertz v143 #[code = 250];
                v144 = hir.int_to_ptr v141 : ptr<byte, i32>;
                v145 = hir.load v144 : i32;
                v146 = hir.load_local  : i32 #[local = lv2];
                v147 = hir.load_local  : i32 #[local = lv3];
                v262 = arith.constant 12 : u32;
                v148 = hir.bitcast v147 : u32;
                v150 = arith.add v148, v262 : u32 #[overflow = checked];
                v275 = arith.constant 4 : u32;
                v152 = arith.mod v150, v275 : u32;
                hir.assertz v152 #[code = 250];
                v153 = hir.int_to_ptr v150 : ptr<byte, i32>;
                v154 = hir.load v153 : i32;
                hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v145, v146, v154)
                scf.yield ;
            };
            v155 = hir.load_local  : i32 #[local = lv3];
            v274 = arith.constant 16 : i32;
            v157 = arith.add v155, v274 : i32 #[overflow = wrapping];
            v158 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v159 = hir.bitcast v158 : ptr<byte, i32>;
            hir.store v159, v157;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::current_memory(v160: i32, v161: i32, v162: i32, v163: i32) {
        ^block24(v160: i32, v161: i32, v162: i32, v163: i32):
            hir.store_local v160 #[local = lv0];
            hir.store_local v161 #[local = lv1];
            hir.store_local v162 #[local = lv2];
            hir.store_local v163 #[local = lv3];
            v282 = arith.constant 0 : i32;
            hir.store_local v282 #[local = lv4];
            v281 = arith.constant 4 : i32;
            hir.store_local v281 #[local = lv5];
            v166 = hir.load_local  : i32 #[local = lv3];
            v302 = arith.constant 0 : i32;
            v303 = arith.constant 0 : i32;
            v168 = arith.eq v166, v303 : i1;
            v169 = arith.zext v168 : u32;
            v170 = hir.bitcast v169 : i32;
            v172 = arith.neq v170, v302 : i1;
            scf.if v172{
            ^block37:
                scf.yield ;
            } else {
            ^block27:
                v173 = hir.load_local  : i32 #[local = lv1];
                v174 = hir.bitcast v173 : u32;
                v290 = arith.constant 4 : u32;
                v176 = arith.mod v174, v290 : u32;
                hir.assertz v176 #[code = 250];
                v177 = hir.int_to_ptr v174 : ptr<byte, i32>;
                v178 = hir.load v177 : i32;
                hir.store_local v178 #[local = lv6];
                v300 = arith.constant 0 : i32;
                v301 = arith.constant 0 : i32;
                v180 = arith.eq v178, v301 : i1;
                v181 = arith.zext v180 : u32;
                v182 = hir.bitcast v181 : i32;
                v184 = arith.neq v182, v300 : i1;
                scf.if v184{
                ^block36:
                    scf.yield ;
                } else {
                ^block28:
                    v185 = hir.load_local  : i32 #[local = lv0];
                    v186 = hir.load_local  : i32 #[local = lv2];
                    v299 = arith.constant 4 : u32;
                    v187 = hir.bitcast v185 : u32;
                    v189 = arith.add v187, v299 : u32 #[overflow = checked];
                    v298 = arith.constant 4 : u32;
                    v191 = arith.mod v189, v298 : u32;
                    hir.assertz v191 #[code = 250];
                    v192 = hir.int_to_ptr v189 : ptr<byte, i32>;
                    hir.store v192, v186;
                    v193 = hir.load_local  : i32 #[local = lv0];
                    v194 = hir.load_local  : i32 #[local = lv1];
                    v297 = arith.constant 4 : u32;
                    v195 = hir.bitcast v194 : u32;
                    v197 = arith.add v195, v297 : u32 #[overflow = checked];
                    v296 = arith.constant 4 : u32;
                    v199 = arith.mod v197, v296 : u32;
                    hir.assertz v199 #[code = 250];
                    v200 = hir.int_to_ptr v197 : ptr<byte, i32>;
                    v201 = hir.load v200 : i32;
                    v202 = hir.bitcast v193 : u32;
                    v295 = arith.constant 4 : u32;
                    v204 = arith.mod v202, v295 : u32;
                    hir.assertz v204 #[code = 250];
                    v205 = hir.int_to_ptr v202 : ptr<byte, i32>;
                    hir.store v205, v201;
                    v206 = hir.load_local  : i32 #[local = lv6];
                    v207 = hir.load_local  : i32 #[local = lv3];
                    v208 = arith.mul v206, v207 : i32 #[overflow = wrapping];
                    hir.store_local v208 #[local = lv4];
                    v279 = arith.constant 8 : i32;
                    hir.store_local v279 #[local = lv5];
                    scf.yield ;
                };
                scf.yield ;
            };
            v210 = hir.load_local  : i32 #[local = lv0];
            v211 = hir.load_local  : i32 #[local = lv5];
            v213 = hir.load_local  : i32 #[local = lv4];
            v212 = arith.add v210, v211 : i32 #[overflow = wrapping];
            v214 = hir.bitcast v212 : u32;
            v294 = arith.constant 4 : u32;
            v216 = arith.mod v214, v294 : u32;
            hir.assertz v216 #[code = 250];
            v217 = hir.int_to_ptr v214 : ptr<byte, i32>;
            hir.store v217, v213;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v218: i32, v219: i32, v220: i32) {
        ^block29(v218: i32, v219: i32, v220: i32):
            hir.store_local v218 #[local = lv0];
            hir.store_local v219 #[local = lv1];
            hir.store_local v220 #[local = lv2];
            v221 = hir.load_local  : i32 #[local = lv2];
            v307 = arith.constant 0 : i32;
            v305 = arith.constant 0 : i32;
            v223 = arith.eq v221, v305 : i1;
            v224 = arith.zext v223 : u32;
            v225 = hir.bitcast v224 : i32;
            v227 = arith.neq v225, v307 : i1;
            scf.if v227{
            ^block31:
                scf.yield ;
            } else {
            ^block32:
                v228 = hir.load_local  : i32 #[local = lv0];
                v229 = hir.load_local  : i32 #[local = lv2];
                v230 = hir.load_local  : i32 #[local = lv1];
                hir.exec @root_ns:root@1.0.0/hash_elements/__rustc::__rust_dealloc(v228, v229, v230)
                scf.yield ;
            };
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};