builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_elements {
        public builtin.function @entrypoint(v0: i32) -> felt {
        ^block4(v0: i32):
            v4 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v5 = hir.bitcast v4 : ptr<byte, i32>;
            v6 = hir.load v5 : i32;
            v7 = arith.constant 48 : i32;
            v8 = arith.sub v6, v7 : i32 #[overflow = wrapping];
            v9 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v10 = hir.bitcast v9 : ptr<byte, i32>;
            hir.store v10, v8;
            v12 = arith.constant 4 : u32;
            v11 = hir.bitcast v0 : u32;
            v13 = arith.add v11, v12 : u32 #[overflow = checked];
            v304 = arith.constant 4 : u32;
            v15 = arith.mod v13, v304 : u32;
            hir.assertz v15 #[code = 250];
            v16 = hir.int_to_ptr v13 : ptr<byte, i32>;
            v17 = hir.load v16 : i32;
            v296 = arith.constant 2 : u32;
            v19 = hir.bitcast v17 : u32;
            v21 = arith.shr v19, v296 : u32;
            v22 = hir.bitcast v21 : i32;
            v23 = arith.constant 3 : i32;
            v24 = arith.band v22, v23 : i32;
            v25 = hir.exec @root_ns:root@1.0.0/hash_elements/intrinsics::felt::from_u32(v24) : felt
            v2 = arith.constant 0 : i32;
            v27 = hir.exec @root_ns:root@1.0.0/hash_elements/intrinsics::felt::from_u32(v2) : felt
            hir.exec @root_ns:root@1.0.0/hash_elements/intrinsics::felt::assert_eq(v25, v27)
            v29 = arith.constant 8 : u32;
            v28 = hir.bitcast v0 : u32;
            v30 = arith.add v28, v29 : u32 #[overflow = checked];
            v303 = arith.constant 4 : u32;
            v32 = arith.mod v30, v303 : u32;
            hir.assertz v32 #[code = 250];
            v33 = hir.int_to_ptr v30 : ptr<byte, i32>;
            v34 = hir.load v33 : i32;
            v35 = arith.constant 16 : i32;
            v36 = arith.add v8, v35 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/std::crypto::hashes::rpo::hash_memory(v22, v34, v36)
            v38 = arith.constant 24 : u32;
            v37 = hir.bitcast v8 : u32;
            v39 = arith.add v37, v38 : u32 #[overflow = checked];
            v302 = arith.constant 8 : u32;
            v41 = arith.mod v39, v302 : u32;
            hir.assertz v41 #[code = 250];
            v42 = hir.int_to_ptr v39 : ptr<byte, i64>;
            v43 = hir.load v42 : i64;
            v45 = arith.constant 40 : u32;
            v44 = hir.bitcast v8 : u32;
            v46 = arith.add v44, v45 : u32 #[overflow = checked];
            v301 = arith.constant 8 : u32;
            v48 = arith.mod v46, v301 : u32;
            hir.assertz v48 #[code = 250];
            v49 = hir.int_to_ptr v46 : ptr<byte, i64>;
            hir.store v49, v43;
            v51 = arith.constant 16 : u32;
            v50 = hir.bitcast v8 : u32;
            v52 = arith.add v50, v51 : u32 #[overflow = checked];
            v300 = arith.constant 8 : u32;
            v54 = arith.mod v52, v300 : u32;
            hir.assertz v54 #[code = 250];
            v55 = hir.int_to_ptr v52 : ptr<byte, i64>;
            v56 = hir.load v55 : i64;
            v58 = arith.constant 32 : u32;
            v57 = hir.bitcast v8 : u32;
            v59 = arith.add v57, v58 : u32 #[overflow = checked];
            v299 = arith.constant 8 : u32;
            v61 = arith.mod v59, v299 : u32;
            hir.assertz v61 #[code = 250];
            v62 = hir.int_to_ptr v59 : ptr<byte, i64>;
            hir.store v62, v56;
            v63 = arith.constant 32 : i32;
            v64 = arith.add v8, v63 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/miden_stdlib_sys::intrinsics::word::Word::reverse(v8, v64)
            v65 = arith.constant 4 : i32;
            hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::RawVecInner<A>::deallocate(v0, v65, v65)
            v67 = hir.bitcast v8 : u32;
            v298 = arith.constant 4 : u32;
            v69 = arith.mod v67, v298 : u32;
            hir.assertz v69 #[code = 250];
            v70 = hir.int_to_ptr v67 : ptr<byte, felt>;
            v71 = hir.load v70 : felt;
            v297 = arith.constant 48 : i32;
            v73 = arith.add v8, v297 : i32 #[overflow = wrapping];
            v74 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v75 = hir.bitcast v74 : ptr<byte, i32>;
            hir.store v75, v73;
            builtin.ret v71;
        };

        private builtin.function @__rustc::__rust_dealloc(v76: i32, v77: i32, v78: i32) {
        ^block6(v76: i32, v77: i32, v78: i32):
            builtin.ret ;
        };

        private builtin.function @miden_stdlib_sys::intrinsics::word::Word::reverse(v79: i32, v80: i32) {
        ^block8(v79: i32, v80: i32):
            v83 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v84 = hir.bitcast v83 : ptr<byte, i32>;
            v85 = hir.load v84 : i32;
            v86 = arith.constant 16 : i32;
            v87 = arith.sub v85, v86 : i32 #[overflow = wrapping];
            v89 = arith.constant 8 : u32;
            v88 = hir.bitcast v80 : u32;
            v90 = arith.add v88, v89 : u32 #[overflow = checked];
            v391 = arith.constant 8 : u32;
            v92 = arith.mod v90, v391 : u32;
            hir.assertz v92 #[code = 250];
            v93 = hir.int_to_ptr v90 : ptr<byte, i64>;
            v94 = hir.load v93 : i64;
            v390 = arith.constant 8 : u32;
            v95 = hir.bitcast v87 : u32;
            v97 = arith.add v95, v390 : u32 #[overflow = checked];
            v98 = arith.constant 4 : u32;
            v99 = arith.mod v97, v98 : u32;
            hir.assertz v99 #[code = 250];
            v100 = hir.int_to_ptr v97 : ptr<byte, i64>;
            hir.store v100, v94;
            v101 = hir.bitcast v80 : u32;
            v389 = arith.constant 8 : u32;
            v103 = arith.mod v101, v389 : u32;
            hir.assertz v103 #[code = 250];
            v104 = hir.int_to_ptr v101 : ptr<byte, i64>;
            v105 = hir.load v104 : i64;
            v106 = hir.bitcast v87 : u32;
            v388 = arith.constant 4 : u32;
            v108 = arith.mod v106, v388 : u32;
            hir.assertz v108 #[code = 250];
            v109 = hir.int_to_ptr v106 : ptr<byte, i64>;
            hir.store v109, v105;
            v110 = arith.constant 12 : i32;
            v111 = arith.add v87, v110 : i32 #[overflow = wrapping];
            v81 = arith.constant 0 : i32;
            v359, v360, v361, v362, v363, v364 = scf.while v81, v87, v111, v79 : i32, i32, i32, i32, i32, i32 {
            ^block44(v365: i32, v366: i32, v367: i32, v368: i32):
                v387 = arith.constant 0 : i32;
                v114 = arith.constant 8 : i32;
                v115 = arith.eq v365, v114 : i1;
                v116 = arith.zext v115 : u32;
                v117 = hir.bitcast v116 : i32;
                v119 = arith.neq v117, v387 : i1;
                v353, v354 = scf.if v119 : i32, i32 {
                ^block43:
                    v313 = ub.poison i32 : i32;
                    scf.yield v313, v313;
                } else {
                ^block13:
                    v121 = arith.add v366, v365 : i32 #[overflow = wrapping];
                    v122 = hir.bitcast v121 : u32;
                    v386 = arith.constant 4 : u32;
                    v124 = arith.mod v122, v386 : u32;
                    hir.assertz v124 #[code = 250];
                    v125 = hir.int_to_ptr v122 : ptr<byte, felt>;
                    v126 = hir.load v125 : felt;
                    v128 = hir.bitcast v367 : u32;
                    v385 = arith.constant 4 : u32;
                    v130 = arith.mod v128, v385 : u32;
                    hir.assertz v130 #[code = 250];
                    v131 = hir.int_to_ptr v128 : ptr<byte, i32>;
                    v132 = hir.load v131 : i32;
                    v133 = hir.bitcast v121 : u32;
                    v384 = arith.constant 4 : u32;
                    v135 = arith.mod v133, v384 : u32;
                    hir.assertz v135 #[code = 250];
                    v136 = hir.int_to_ptr v133 : ptr<byte, i32>;
                    hir.store v136, v132;
                    v137 = hir.bitcast v367 : u32;
                    v383 = arith.constant 4 : u32;
                    v139 = arith.mod v137, v383 : u32;
                    hir.assertz v139 #[code = 250];
                    v140 = hir.int_to_ptr v137 : ptr<byte, felt>;
                    hir.store v140, v126;
                    v143 = arith.constant -4 : i32;
                    v144 = arith.add v367, v143 : i32 #[overflow = wrapping];
                    v141 = arith.constant 4 : i32;
                    v142 = arith.add v365, v141 : i32 #[overflow = wrapping];
                    scf.yield v142, v144;
                };
                v381 = ub.poison i32 : i32;
                v356 = cf.select v119, v381, v368 : i32;
                v382 = ub.poison i32 : i32;
                v355 = cf.select v119, v382, v366 : i32;
                v312 = arith.constant 1 : u32;
                v305 = arith.constant 0 : u32;
                v358 = cf.select v119, v305, v312 : u32;
                v346 = arith.trunc v358 : i1;
                scf.condition v346, v353, v355, v354, v356, v366, v368;
            } do {
            ^block45(v369: i32, v370: i32, v371: i32, v372: i32, v373: i32, v374: i32):
                scf.yield v369, v370, v371, v372;
            };
            v380 = arith.constant 8 : u32;
            v146 = hir.bitcast v363 : u32;
            v148 = arith.add v146, v380 : u32 #[overflow = checked];
            v379 = arith.constant 4 : u32;
            v150 = arith.mod v148, v379 : u32;
            hir.assertz v150 #[code = 250];
            v151 = hir.int_to_ptr v148 : ptr<byte, i64>;
            v152 = hir.load v151 : i64;
            v378 = arith.constant 8 : u32;
            v153 = hir.bitcast v364 : u32;
            v155 = arith.add v153, v378 : u32 #[overflow = checked];
            v377 = arith.constant 8 : u32;
            v157 = arith.mod v155, v377 : u32;
            hir.assertz v157 #[code = 250];
            v158 = hir.int_to_ptr v155 : ptr<byte, i64>;
            hir.store v158, v152;
            v159 = hir.bitcast v363 : u32;
            v376 = arith.constant 4 : u32;
            v161 = arith.mod v159, v376 : u32;
            hir.assertz v161 #[code = 250];
            v162 = hir.int_to_ptr v159 : ptr<byte, i64>;
            v163 = hir.load v162 : i64;
            v164 = hir.bitcast v364 : u32;
            v375 = arith.constant 8 : u32;
            v166 = arith.mod v164, v375 : u32;
            hir.assertz v166 #[code = 250];
            v167 = hir.int_to_ptr v164 : ptr<byte, i64>;
            hir.store v167, v163;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v168: i32, v169: i32, v170: i32) {
        ^block14(v168: i32, v169: i32, v170: i32):
            v172 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v173 = hir.bitcast v172 : ptr<byte, i32>;
            v174 = hir.load v173 : i32;
            v175 = arith.constant 16 : i32;
            v176 = arith.sub v174, v175 : i32 #[overflow = wrapping];
            v177 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v178 = hir.bitcast v177 : ptr<byte, i32>;
            hir.store v178, v176;
            v179 = arith.constant 4 : i32;
            v180 = arith.add v176, v179 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::RawVecInner<A>::current_memory(v180, v168, v169, v170)
            v182 = arith.constant 8 : u32;
            v181 = hir.bitcast v176 : u32;
            v183 = arith.add v181, v182 : u32 #[overflow = checked];
            v184 = arith.constant 4 : u32;
            v185 = arith.mod v183, v184 : u32;
            hir.assertz v185 #[code = 250];
            v186 = hir.int_to_ptr v183 : ptr<byte, i32>;
            v187 = hir.load v186 : i32;
            v398 = arith.constant 0 : i32;
            v171 = arith.constant 0 : i32;
            v189 = arith.eq v187, v171 : i1;
            v190 = arith.zext v189 : u32;
            v191 = hir.bitcast v190 : i32;
            v193 = arith.neq v191, v398 : i1;
            scf.if v193{
            ^block46:
                scf.yield ;
            } else {
            ^block17:
                v397 = arith.constant 4 : u32;
                v194 = hir.bitcast v176 : u32;
                v196 = arith.add v194, v397 : u32 #[overflow = checked];
                v396 = arith.constant 4 : u32;
                v198 = arith.mod v196, v396 : u32;
                hir.assertz v198 #[code = 250];
                v199 = hir.int_to_ptr v196 : ptr<byte, i32>;
                v200 = hir.load v199 : i32;
                v202 = arith.constant 12 : u32;
                v201 = hir.bitcast v176 : u32;
                v203 = arith.add v201, v202 : u32 #[overflow = checked];
                v395 = arith.constant 4 : u32;
                v205 = arith.mod v203, v395 : u32;
                hir.assertz v205 #[code = 250];
                v206 = hir.int_to_ptr v203 : ptr<byte, i32>;
                v207 = hir.load v206 : i32;
                hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v200, v187, v207)
                scf.yield ;
            };
            v394 = arith.constant 16 : i32;
            v210 = arith.add v176, v394 : i32 #[overflow = wrapping];
            v211 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v212 = hir.bitcast v211 : ptr<byte, i32>;
            hir.store v212, v210;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v213: i32, v214: i32, v215: i32, v216: i32) {
        ^block18(v213: i32, v214: i32, v215: i32, v216: i32):
            v424 = arith.constant 0 : i32;
            v217 = arith.constant 0 : i32;
            v221 = arith.eq v216, v217 : i1;
            v222 = arith.zext v221 : u32;
            v223 = hir.bitcast v222 : i32;
            v225 = arith.neq v223, v424 : i1;
            v411, v412 = scf.if v225 : i32, i32 {
            ^block49:
                v423 = arith.constant 0 : i32;
                v219 = arith.constant 4 : i32;
                scf.yield v219, v423;
            } else {
            ^block21:
                v226 = hir.bitcast v214 : u32;
                v261 = arith.constant 4 : u32;
                v228 = arith.mod v226, v261 : u32;
                hir.assertz v228 #[code = 250];
                v229 = hir.int_to_ptr v226 : ptr<byte, i32>;
                v230 = hir.load v229 : i32;
                v421 = arith.constant 0 : i32;
                v422 = arith.constant 0 : i32;
                v232 = arith.eq v230, v422 : i1;
                v233 = arith.zext v232 : u32;
                v234 = hir.bitcast v233 : i32;
                v236 = arith.neq v234, v421 : i1;
                v409 = scf.if v236 : i32 {
                ^block48:
                    v420 = arith.constant 0 : i32;
                    scf.yield v420;
                } else {
                ^block22:
                    v419 = arith.constant 4 : u32;
                    v237 = hir.bitcast v213 : u32;
                    v239 = arith.add v237, v419 : u32 #[overflow = checked];
                    v418 = arith.constant 4 : u32;
                    v241 = arith.mod v239, v418 : u32;
                    hir.assertz v241 #[code = 250];
                    v242 = hir.int_to_ptr v239 : ptr<byte, i32>;
                    hir.store v242, v215;
                    v417 = arith.constant 4 : u32;
                    v243 = hir.bitcast v214 : u32;
                    v245 = arith.add v243, v417 : u32 #[overflow = checked];
                    v416 = arith.constant 4 : u32;
                    v247 = arith.mod v245, v416 : u32;
                    hir.assertz v247 #[code = 250];
                    v248 = hir.int_to_ptr v245 : ptr<byte, i32>;
                    v249 = hir.load v248 : i32;
                    v250 = hir.bitcast v213 : u32;
                    v415 = arith.constant 4 : u32;
                    v252 = arith.mod v250, v415 : u32;
                    hir.assertz v252 #[code = 250];
                    v253 = hir.int_to_ptr v250 : ptr<byte, i32>;
                    hir.store v253, v249;
                    v254 = arith.mul v230, v216 : i32 #[overflow = wrapping];
                    scf.yield v254;
                };
                v255 = arith.constant 8 : i32;
                v414 = arith.constant 4 : i32;
                v410 = cf.select v236, v414, v255 : i32;
                scf.yield v410, v409;
            };
            v258 = arith.add v213, v411 : i32 #[overflow = wrapping];
            v260 = hir.bitcast v258 : u32;
            v413 = arith.constant 4 : u32;
            v262 = arith.mod v260, v413 : u32;
            hir.assertz v262 #[code = 250];
            v263 = hir.int_to_ptr v260 : ptr<byte, i32>;
            hir.store v263, v412;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v264: i32, v265: i32, v266: i32) {
        ^block23(v264: i32, v265: i32, v266: i32):
            v426 = arith.constant 0 : i32;
            v267 = arith.constant 0 : i32;
            v268 = arith.eq v266, v267 : i1;
            v269 = arith.zext v268 : u32;
            v270 = hir.bitcast v269 : i32;
            v272 = arith.neq v270, v426 : i1;
            scf.if v272{
            ^block25:
                scf.yield ;
            } else {
            ^block26:
                hir.exec @root_ns:root@1.0.0/hash_elements/__rustc::__rust_dealloc(v264, v266, v265)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @intrinsics::felt::from_u32(v273: i32) -> felt {
        ^block27(v273: i32):
            v274 = hir.bitcast v273 : felt;
            builtin.ret v274;
        };

        private builtin.function @intrinsics::felt::assert_eq(v276: felt, v277: felt) {
        ^block29(v276: felt, v277: felt):
            hir.assert_eq v276, v277;
            builtin.ret ;
        };

        private builtin.function @std::crypto::hashes::rpo::hash_memory(v278: i32, v279: i32, v280: i32) {
        ^block31(v278: i32, v279: i32, v280: i32):
            v281, v282, v283, v284 = hir.exec @std/crypto/hashes/rpo/hash_memory(v278, v279) : felt, felt, felt, felt
            v285 = hir.bitcast v280 : u32;
            v286 = hir.int_to_ptr v285 : ptr<byte, felt>;
            hir.store v286, v281;
            v287 = arith.constant 4 : u32;
            v288 = arith.add v285, v287 : u32 #[overflow = checked];
            v289 = hir.int_to_ptr v288 : ptr<byte, felt>;
            hir.store v289, v282;
            v290 = arith.constant 8 : u32;
            v291 = arith.add v285, v290 : u32 #[overflow = checked];
            v292 = hir.int_to_ptr v291 : ptr<byte, felt>;
            hir.store v292, v283;
            v293 = arith.constant 12 : u32;
            v294 = arith.add v285, v293 : u32 #[overflow = checked];
            v295 = hir.int_to_ptr v294 : ptr<byte, felt>;
            hir.store v295, v284;
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};