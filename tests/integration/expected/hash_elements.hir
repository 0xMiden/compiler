builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_elements {
        public builtin.function @entrypoint(v0: i32) -> felt {
        ^block4(v0: i32):
            v4 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v5 = hir.bitcast v4 : ptr<byte, i32>;
            v6 = hir.load v5 : i32;
            v7 = arith.constant 48 : i32;
            v8 = arith.sub v6, v7 : i32 #[overflow = wrapping];
            v9 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v10 = hir.bitcast v9 : ptr<byte, i32>;
            hir.store v10, v8;
            v12 = arith.constant 8 : u32;
            v11 = hir.bitcast v0 : u32;
            v13 = arith.add v11, v12 : u32 #[overflow = checked];
            v14 = arith.constant 4 : u32;
            v15 = arith.mod v13, v14 : u32;
            hir.assertz v15 #[code = 250];
            v16 = hir.int_to_ptr v13 : ptr<byte, i32>;
            v17 = hir.load v16 : i32;
            v343 = arith.constant 4 : u32;
            v18 = hir.bitcast v0 : u32;
            v20 = arith.add v18, v343 : u32 #[overflow = checked];
            v342 = arith.constant 4 : u32;
            v22 = arith.mod v20, v342 : u32;
            hir.assertz v22 #[code = 250];
            v23 = hir.int_to_ptr v20 : ptr<byte, i32>;
            v24 = hir.load v23 : i32;
            v327 = arith.constant 2 : u32;
            v26 = hir.bitcast v24 : u32;
            v28 = arith.shr v26, v327 : u32;
            v29 = hir.bitcast v28 : i32;
            v30 = arith.constant 3 : i32;
            v31 = arith.band v29, v30 : i32;
            v32 = hir.exec @root_ns:root@1.0.0/hash_elements/intrinsics::felt::from_u32(v31) : felt
            v2 = arith.constant 0 : i32;
            v34 = hir.exec @root_ns:root@1.0.0/hash_elements/intrinsics::felt::from_u32(v2) : felt
            hir.exec @root_ns:root@1.0.0/hash_elements/intrinsics::felt::assert_eq(v32, v34)
            v339 = arith.constant 0 : i32;
            v340 = arith.constant 0 : i32;
            v341 = arith.constant 3 : i32;
            v36 = arith.band v17, v341 : i32;
            v38 = arith.eq v36, v340 : i1;
            v39 = arith.zext v38 : u32;
            v40 = hir.bitcast v39 : i32;
            v42 = arith.neq v40, v339 : i1;
            scf.if v42{
            ^block7:
                v46 = arith.constant 16 : i32;
                v47 = arith.add v8, v46 : i32 #[overflow = wrapping];
                v45 = arith.add v29, v17 : i32 #[overflow = wrapping];
                hir.exec @root_ns:root@1.0.0/hash_elements/std::crypto::hashes::rpo::hash_memory_words(v29, v45, v47)
                scf.yield ;
            } else {
            ^block8:
                v338 = arith.constant 16 : i32;
                v44 = arith.add v8, v338 : i32 #[overflow = wrapping];
                hir.exec @root_ns:root@1.0.0/hash_elements/std::crypto::hashes::rpo::hash_memory(v29, v17, v44)
                scf.yield ;
            };
            v50 = arith.constant 24 : u32;
            v49 = hir.bitcast v8 : u32;
            v51 = arith.add v49, v50 : u32 #[overflow = checked];
            v337 = arith.constant 8 : u32;
            v53 = arith.mod v51, v337 : u32;
            hir.assertz v53 #[code = 250];
            v54 = hir.int_to_ptr v51 : ptr<byte, i64>;
            v55 = hir.load v54 : i64;
            v57 = arith.constant 40 : u32;
            v56 = hir.bitcast v8 : u32;
            v58 = arith.add v56, v57 : u32 #[overflow = checked];
            v336 = arith.constant 8 : u32;
            v60 = arith.mod v58, v336 : u32;
            hir.assertz v60 #[code = 250];
            v61 = hir.int_to_ptr v58 : ptr<byte, i64>;
            hir.store v61, v55;
            v63 = arith.constant 16 : u32;
            v62 = hir.bitcast v8 : u32;
            v64 = arith.add v62, v63 : u32 #[overflow = checked];
            v335 = arith.constant 8 : u32;
            v66 = arith.mod v64, v335 : u32;
            hir.assertz v66 #[code = 250];
            v67 = hir.int_to_ptr v64 : ptr<byte, i64>;
            v68 = hir.load v67 : i64;
            v70 = arith.constant 32 : u32;
            v69 = hir.bitcast v8 : u32;
            v71 = arith.add v69, v70 : u32 #[overflow = checked];
            v334 = arith.constant 8 : u32;
            v73 = arith.mod v71, v334 : u32;
            hir.assertz v73 #[code = 250];
            v74 = hir.int_to_ptr v71 : ptr<byte, i64>;
            hir.store v74, v68;
            v75 = arith.constant 32 : i32;
            v76 = arith.add v8, v75 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/miden_stdlib_sys::intrinsics::word::Word::reverse(v8, v76)
            v78 = arith.constant 4 : i32;
            hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::RawVecInner<A>::deallocate(v0, v78, v78)
            v80 = hir.bitcast v8 : u32;
            v333 = arith.constant 4 : u32;
            v82 = arith.mod v80, v333 : u32;
            hir.assertz v82 #[code = 250];
            v83 = hir.int_to_ptr v80 : ptr<byte, felt>;
            v84 = hir.load v83 : felt;
            v332 = arith.constant 48 : i32;
            v86 = arith.add v8, v332 : i32 #[overflow = wrapping];
            v87 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v88 = hir.bitcast v87 : ptr<byte, i32>;
            hir.store v88, v86;
            builtin.ret v84;
        };

        private builtin.function @__rustc::__rust_dealloc(v89: i32, v90: i32, v91: i32) {
        ^block9(v89: i32, v90: i32, v91: i32):
            builtin.ret ;
        };

        private builtin.function @miden_stdlib_sys::intrinsics::word::Word::reverse(v92: i32, v93: i32) {
        ^block11(v92: i32, v93: i32):
            v96 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v97 = hir.bitcast v96 : ptr<byte, i32>;
            v98 = hir.load v97 : i32;
            v99 = arith.constant 16 : i32;
            v100 = arith.sub v98, v99 : i32 #[overflow = wrapping];
            v102 = arith.constant 8 : u32;
            v101 = hir.bitcast v93 : u32;
            v103 = arith.add v101, v102 : u32 #[overflow = checked];
            v430 = arith.constant 8 : u32;
            v105 = arith.mod v103, v430 : u32;
            hir.assertz v105 #[code = 250];
            v106 = hir.int_to_ptr v103 : ptr<byte, i64>;
            v107 = hir.load v106 : i64;
            v429 = arith.constant 8 : u32;
            v108 = hir.bitcast v100 : u32;
            v110 = arith.add v108, v429 : u32 #[overflow = checked];
            v111 = arith.constant 4 : u32;
            v112 = arith.mod v110, v111 : u32;
            hir.assertz v112 #[code = 250];
            v113 = hir.int_to_ptr v110 : ptr<byte, i64>;
            hir.store v113, v107;
            v114 = hir.bitcast v93 : u32;
            v428 = arith.constant 8 : u32;
            v116 = arith.mod v114, v428 : u32;
            hir.assertz v116 #[code = 250];
            v117 = hir.int_to_ptr v114 : ptr<byte, i64>;
            v118 = hir.load v117 : i64;
            v119 = hir.bitcast v100 : u32;
            v427 = arith.constant 4 : u32;
            v121 = arith.mod v119, v427 : u32;
            hir.assertz v121 #[code = 250];
            v122 = hir.int_to_ptr v119 : ptr<byte, i64>;
            hir.store v122, v118;
            v123 = arith.constant 12 : i32;
            v124 = arith.add v100, v123 : i32 #[overflow = wrapping];
            v94 = arith.constant 0 : i32;
            v398, v399, v400, v401, v402, v403 = scf.while v94, v100, v124, v92 : i32, i32, i32, i32, i32, i32 {
            ^block50(v404: i32, v405: i32, v406: i32, v407: i32):
                v426 = arith.constant 0 : i32;
                v127 = arith.constant 8 : i32;
                v128 = arith.eq v404, v127 : i1;
                v129 = arith.zext v128 : u32;
                v130 = hir.bitcast v129 : i32;
                v132 = arith.neq v130, v426 : i1;
                v392, v393 = scf.if v132 : i32, i32 {
                ^block49:
                    v352 = ub.poison i32 : i32;
                    scf.yield v352, v352;
                } else {
                ^block16:
                    v134 = arith.add v405, v404 : i32 #[overflow = wrapping];
                    v135 = hir.bitcast v134 : u32;
                    v425 = arith.constant 4 : u32;
                    v137 = arith.mod v135, v425 : u32;
                    hir.assertz v137 #[code = 250];
                    v138 = hir.int_to_ptr v135 : ptr<byte, felt>;
                    v139 = hir.load v138 : felt;
                    v141 = hir.bitcast v406 : u32;
                    v424 = arith.constant 4 : u32;
                    v143 = arith.mod v141, v424 : u32;
                    hir.assertz v143 #[code = 250];
                    v144 = hir.int_to_ptr v141 : ptr<byte, i32>;
                    v145 = hir.load v144 : i32;
                    v146 = hir.bitcast v134 : u32;
                    v423 = arith.constant 4 : u32;
                    v148 = arith.mod v146, v423 : u32;
                    hir.assertz v148 #[code = 250];
                    v149 = hir.int_to_ptr v146 : ptr<byte, i32>;
                    hir.store v149, v145;
                    v150 = hir.bitcast v406 : u32;
                    v422 = arith.constant 4 : u32;
                    v152 = arith.mod v150, v422 : u32;
                    hir.assertz v152 #[code = 250];
                    v153 = hir.int_to_ptr v150 : ptr<byte, felt>;
                    hir.store v153, v139;
                    v156 = arith.constant -4 : i32;
                    v157 = arith.add v406, v156 : i32 #[overflow = wrapping];
                    v154 = arith.constant 4 : i32;
                    v155 = arith.add v404, v154 : i32 #[overflow = wrapping];
                    scf.yield v155, v157;
                };
                v420 = ub.poison i32 : i32;
                v395 = cf.select v132, v420, v407 : i32;
                v421 = ub.poison i32 : i32;
                v394 = cf.select v132, v421, v405 : i32;
                v351 = arith.constant 1 : u32;
                v344 = arith.constant 0 : u32;
                v397 = cf.select v132, v344, v351 : u32;
                v385 = arith.trunc v397 : i1;
                scf.condition v385, v392, v394, v393, v395, v405, v407;
            } do {
            ^block51(v408: i32, v409: i32, v410: i32, v411: i32, v412: i32, v413: i32):
                scf.yield v408, v409, v410, v411;
            };
            v419 = arith.constant 8 : u32;
            v159 = hir.bitcast v402 : u32;
            v161 = arith.add v159, v419 : u32 #[overflow = checked];
            v418 = arith.constant 4 : u32;
            v163 = arith.mod v161, v418 : u32;
            hir.assertz v163 #[code = 250];
            v164 = hir.int_to_ptr v161 : ptr<byte, i64>;
            v165 = hir.load v164 : i64;
            v417 = arith.constant 8 : u32;
            v166 = hir.bitcast v403 : u32;
            v168 = arith.add v166, v417 : u32 #[overflow = checked];
            v416 = arith.constant 8 : u32;
            v170 = arith.mod v168, v416 : u32;
            hir.assertz v170 #[code = 250];
            v171 = hir.int_to_ptr v168 : ptr<byte, i64>;
            hir.store v171, v165;
            v172 = hir.bitcast v402 : u32;
            v415 = arith.constant 4 : u32;
            v174 = arith.mod v172, v415 : u32;
            hir.assertz v174 #[code = 250];
            v175 = hir.int_to_ptr v172 : ptr<byte, i64>;
            v176 = hir.load v175 : i64;
            v177 = hir.bitcast v403 : u32;
            v414 = arith.constant 8 : u32;
            v179 = arith.mod v177, v414 : u32;
            hir.assertz v179 #[code = 250];
            v180 = hir.int_to_ptr v177 : ptr<byte, i64>;
            hir.store v180, v176;
            builtin.ret ;
        };

        private builtin.function @intrinsics::felt::from_u32(v181: i32) -> felt {
        ^block17(v181: i32):
            v182 = hir.bitcast v181 : felt;
            builtin.ret v182;
        };

        private builtin.function @intrinsics::felt::assert_eq(v184: felt, v185: felt) {
        ^block19(v184: felt, v185: felt):
            hir.assert_eq v184, v185;
            builtin.ret ;
        };

        private builtin.function @std::crypto::hashes::rpo::hash_memory(v186: i32, v187: i32, v188: i32) {
        ^block21(v186: i32, v187: i32, v188: i32):
            v189, v190, v191, v192 = hir.exec @std/crypto/hashes/rpo/hash_memory(v186, v187) : felt, felt, felt, felt
            v193 = hir.bitcast v188 : u32;
            v194 = hir.int_to_ptr v193 : ptr<byte, felt>;
            hir.store v194, v189;
            v195 = arith.constant 4 : u32;
            v196 = arith.add v193, v195 : u32 #[overflow = checked];
            v197 = hir.int_to_ptr v196 : ptr<byte, felt>;
            hir.store v197, v190;
            v198 = arith.constant 8 : u32;
            v199 = arith.add v193, v198 : u32 #[overflow = checked];
            v200 = hir.int_to_ptr v199 : ptr<byte, felt>;
            hir.store v200, v191;
            v201 = arith.constant 12 : u32;
            v202 = arith.add v193, v201 : u32 #[overflow = checked];
            v203 = hir.int_to_ptr v202 : ptr<byte, felt>;
            hir.store v203, v192;
            builtin.ret ;
        };

        private builtin.function @std::crypto::hashes::rpo::hash_memory_words(v204: i32, v205: i32, v206: i32) {
        ^block27(v204: i32, v205: i32, v206: i32):
            v207, v208, v209, v210 = hir.exec @std/crypto/hashes/rpo/hash_memory_words(v204, v205) : felt, felt, felt, felt
            v211 = hir.bitcast v206 : u32;
            v212 = hir.int_to_ptr v211 : ptr<byte, felt>;
            hir.store v212, v207;
            v213 = arith.constant 4 : u32;
            v214 = arith.add v211, v213 : u32 #[overflow = checked];
            v215 = hir.int_to_ptr v214 : ptr<byte, felt>;
            hir.store v215, v208;
            v216 = arith.constant 8 : u32;
            v217 = arith.add v211, v216 : u32 #[overflow = checked];
            v218 = hir.int_to_ptr v217 : ptr<byte, felt>;
            hir.store v218, v209;
            v219 = arith.constant 12 : u32;
            v220 = arith.add v211, v219 : u32 #[overflow = checked];
            v221 = hir.int_to_ptr v220 : ptr<byte, felt>;
            hir.store v221, v210;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v222: i32, v223: i32, v224: i32) {
        ^block29(v222: i32, v223: i32, v224: i32):
            v226 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v227 = hir.bitcast v226 : ptr<byte, i32>;
            v228 = hir.load v227 : i32;
            v229 = arith.constant 16 : i32;
            v230 = arith.sub v228, v229 : i32 #[overflow = wrapping];
            v231 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v232 = hir.bitcast v231 : ptr<byte, i32>;
            hir.store v232, v230;
            v233 = arith.constant 4 : i32;
            v234 = arith.add v230, v233 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::RawVecInner<A>::current_memory(v234, v222, v223, v224)
            v236 = arith.constant 8 : u32;
            v235 = hir.bitcast v230 : u32;
            v237 = arith.add v235, v236 : u32 #[overflow = checked];
            v238 = arith.constant 4 : u32;
            v239 = arith.mod v237, v238 : u32;
            hir.assertz v239 #[code = 250];
            v240 = hir.int_to_ptr v237 : ptr<byte, i32>;
            v241 = hir.load v240 : i32;
            v437 = arith.constant 0 : i32;
            v225 = arith.constant 0 : i32;
            v243 = arith.eq v241, v225 : i1;
            v244 = arith.zext v243 : u32;
            v245 = hir.bitcast v244 : i32;
            v247 = arith.neq v245, v437 : i1;
            scf.if v247{
            ^block52:
                scf.yield ;
            } else {
            ^block32:
                v436 = arith.constant 4 : u32;
                v248 = hir.bitcast v230 : u32;
                v250 = arith.add v248, v436 : u32 #[overflow = checked];
                v435 = arith.constant 4 : u32;
                v252 = arith.mod v250, v435 : u32;
                hir.assertz v252 #[code = 250];
                v253 = hir.int_to_ptr v250 : ptr<byte, i32>;
                v254 = hir.load v253 : i32;
                v256 = arith.constant 12 : u32;
                v255 = hir.bitcast v230 : u32;
                v257 = arith.add v255, v256 : u32 #[overflow = checked];
                v434 = arith.constant 4 : u32;
                v259 = arith.mod v257, v434 : u32;
                hir.assertz v259 #[code = 250];
                v260 = hir.int_to_ptr v257 : ptr<byte, i32>;
                v261 = hir.load v260 : i32;
                hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v254, v241, v261)
                scf.yield ;
            };
            v433 = arith.constant 16 : i32;
            v264 = arith.add v230, v433 : i32 #[overflow = wrapping];
            v265 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v266 = hir.bitcast v265 : ptr<byte, i32>;
            hir.store v266, v264;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v267: i32, v268: i32, v269: i32, v270: i32) {
        ^block33(v267: i32, v268: i32, v269: i32, v270: i32):
            v463 = arith.constant 0 : i32;
            v271 = arith.constant 0 : i32;
            v275 = arith.eq v270, v271 : i1;
            v276 = arith.zext v275 : u32;
            v277 = hir.bitcast v276 : i32;
            v279 = arith.neq v277, v463 : i1;
            v450, v451 = scf.if v279 : i32, i32 {
            ^block55:
                v462 = arith.constant 0 : i32;
                v273 = arith.constant 4 : i32;
                scf.yield v273, v462;
            } else {
            ^block36:
                v280 = hir.bitcast v268 : u32;
                v315 = arith.constant 4 : u32;
                v282 = arith.mod v280, v315 : u32;
                hir.assertz v282 #[code = 250];
                v283 = hir.int_to_ptr v280 : ptr<byte, i32>;
                v284 = hir.load v283 : i32;
                v460 = arith.constant 0 : i32;
                v461 = arith.constant 0 : i32;
                v286 = arith.eq v284, v461 : i1;
                v287 = arith.zext v286 : u32;
                v288 = hir.bitcast v287 : i32;
                v290 = arith.neq v288, v460 : i1;
                v448 = scf.if v290 : i32 {
                ^block54:
                    v459 = arith.constant 0 : i32;
                    scf.yield v459;
                } else {
                ^block37:
                    v458 = arith.constant 4 : u32;
                    v291 = hir.bitcast v267 : u32;
                    v293 = arith.add v291, v458 : u32 #[overflow = checked];
                    v457 = arith.constant 4 : u32;
                    v295 = arith.mod v293, v457 : u32;
                    hir.assertz v295 #[code = 250];
                    v296 = hir.int_to_ptr v293 : ptr<byte, i32>;
                    hir.store v296, v269;
                    v456 = arith.constant 4 : u32;
                    v297 = hir.bitcast v268 : u32;
                    v299 = arith.add v297, v456 : u32 #[overflow = checked];
                    v455 = arith.constant 4 : u32;
                    v301 = arith.mod v299, v455 : u32;
                    hir.assertz v301 #[code = 250];
                    v302 = hir.int_to_ptr v299 : ptr<byte, i32>;
                    v303 = hir.load v302 : i32;
                    v304 = hir.bitcast v267 : u32;
                    v454 = arith.constant 4 : u32;
                    v306 = arith.mod v304, v454 : u32;
                    hir.assertz v306 #[code = 250];
                    v307 = hir.int_to_ptr v304 : ptr<byte, i32>;
                    hir.store v307, v303;
                    v308 = arith.mul v284, v270 : i32 #[overflow = wrapping];
                    scf.yield v308;
                };
                v309 = arith.constant 8 : i32;
                v453 = arith.constant 4 : i32;
                v449 = cf.select v290, v453, v309 : i32;
                scf.yield v449, v448;
            };
            v312 = arith.add v267, v450 : i32 #[overflow = wrapping];
            v314 = hir.bitcast v312 : u32;
            v452 = arith.constant 4 : u32;
            v316 = arith.mod v314, v452 : u32;
            hir.assertz v316 #[code = 250];
            v317 = hir.int_to_ptr v314 : ptr<byte, i32>;
            hir.store v317, v451;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v318: i32, v319: i32, v320: i32) {
        ^block38(v318: i32, v319: i32, v320: i32):
            v465 = arith.constant 0 : i32;
            v321 = arith.constant 0 : i32;
            v322 = arith.eq v320, v321 : i1;
            v323 = arith.zext v322 : u32;
            v324 = hir.bitcast v323 : i32;
            v326 = arith.neq v324, v465 : i1;
            scf.if v326{
            ^block40:
                scf.yield ;
            } else {
            ^block41:
                hir.exec @root_ns:root@1.0.0/hash_elements/__rustc::__rust_dealloc(v318, v320, v319)
                scf.yield ;
            };
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};