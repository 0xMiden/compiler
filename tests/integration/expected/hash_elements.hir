builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_elements {
        private builtin.function @miden_stdlib_sys::stdlib::crypto::hashes::extern_hash_memory(v0: i32, v1: i32, v2: i32) {
        ^block3(v0: i32, v1: i32, v2: i32):
            v3, v4, v5, v6 = hir.exec @std/crypto/hashes/rpo/hash_memory(v0, v1) : felt, felt, felt, felt
            v7 = hir.bitcast v2 : u32;
            v8 = hir.int_to_ptr v7 : ptr<byte, felt>;
            hir.store v8, v3;
            v9 = arith.constant 4 : u32;
            v10 = arith.add v7, v9 : u32 #[overflow = checked];
            v11 = hir.int_to_ptr v10 : ptr<byte, felt>;
            hir.store v11, v4;
            v12 = arith.constant 8 : u32;
            v13 = arith.add v7, v12 : u32 #[overflow = checked];
            v14 = hir.int_to_ptr v13 : ptr<byte, felt>;
            hir.store v14, v5;
            v15 = arith.constant 12 : u32;
            v16 = arith.add v7, v15 : u32 #[overflow = checked];
            v17 = hir.int_to_ptr v16 : ptr<byte, felt>;
            hir.store v17, v6;
            builtin.ret ;
        };

        public builtin.function @entrypoint(v18: i32) -> felt {
        ^block10(v18: i32):
            v22 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v23 = hir.bitcast v22 : ptr<byte, i32>;
            v24 = hir.load v23 : i32;
            v27 = arith.constant -32 : i32;
            v25 = arith.constant 32 : i32;
            v26 = arith.sub v24, v25 : i32 #[overflow = wrapping];
            v28 = arith.band v26, v27 : i32;
            v29 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v30 = hir.bitcast v29 : ptr<byte, i32>;
            hir.store v30, v28;
            v32 = arith.constant 4 : u32;
            v31 = hir.bitcast v18 : u32;
            v33 = arith.add v31, v32 : u32 #[overflow = checked];
            v178 = arith.constant 4 : u32;
            v35 = arith.mod v33, v178 : u32;
            hir.assertz v35 #[code = 250];
            v36 = hir.int_to_ptr v33 : ptr<byte, i32>;
            v37 = hir.load v36 : i32;
            v175 = arith.constant 2 : u32;
            v39 = hir.bitcast v37 : u32;
            v41 = arith.shr v39, v175 : u32;
            v42 = hir.bitcast v41 : i32;
            v174 = arith.constant 0 : felt;
            v43 = arith.constant 3 : i32;
            v44 = arith.band v42, v43 : i32;
            v45 = hir.bitcast v44 : felt;
            hir.assert_eq v45, v174;
            v49 = arith.constant 8 : u32;
            v48 = hir.bitcast v18 : u32;
            v50 = arith.add v48, v49 : u32 #[overflow = checked];
            v177 = arith.constant 4 : u32;
            v52 = arith.mod v50, v177 : u32;
            hir.assertz v52 #[code = 250];
            v53 = hir.int_to_ptr v50 : ptr<byte, i32>;
            v54 = hir.load v53 : i32;
            hir.exec @root_ns:root@1.0.0/hash_elements/miden_stdlib_sys::stdlib::crypto::hashes::extern_hash_memory(v42, v54, v28)
            v56 = arith.constant 12 : u32;
            v55 = hir.bitcast v28 : u32;
            v57 = arith.add v55, v56 : u32 #[overflow = checked];
            v176 = arith.constant 4 : u32;
            v59 = arith.mod v57, v176 : u32;
            hir.assertz v59 #[code = 250];
            v60 = hir.int_to_ptr v57 : ptr<byte, felt>;
            v61 = hir.load v60 : felt;
            v62 = arith.constant 4 : i32;
            hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::RawVecInner<A>::deallocate(v18, v62, v62)
            v64 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v65 = hir.bitcast v64 : ptr<byte, i32>;
            hir.store v65, v24;
            builtin.ret v61;
        };

        private builtin.function @__rustc::__rust_dealloc(v66: i32, v67: i32, v68: i32) {
        ^block12(v66: i32, v67: i32, v68: i32):
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v69: i32, v70: i32, v71: i32) {
        ^block14(v69: i32, v70: i32, v71: i32):
            v73 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v74 = hir.bitcast v73 : ptr<byte, i32>;
            v75 = hir.load v74 : i32;
            v76 = arith.constant 16 : i32;
            v77 = arith.sub v75, v76 : i32 #[overflow = wrapping];
            v78 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v79 = hir.bitcast v78 : ptr<byte, i32>;
            hir.store v79, v77;
            v80 = arith.constant 4 : i32;
            v81 = arith.add v77, v80 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::RawVecInner<A>::current_memory(v81, v69, v70, v71)
            v83 = arith.constant 8 : u32;
            v82 = hir.bitcast v77 : u32;
            v84 = arith.add v82, v83 : u32 #[overflow = checked];
            v85 = arith.constant 4 : u32;
            v86 = arith.mod v84, v85 : u32;
            hir.assertz v86 #[code = 250];
            v87 = hir.int_to_ptr v84 : ptr<byte, i32>;
            v88 = hir.load v87 : i32;
            v185 = arith.constant 0 : i32;
            v72 = arith.constant 0 : i32;
            v90 = arith.eq v88, v72 : i1;
            v91 = arith.zext v90 : u32;
            v92 = hir.bitcast v91 : i32;
            v94 = arith.neq v92, v185 : i1;
            scf.if v94{
            ^block27:
                scf.yield ;
            } else {
            ^block17:
                v184 = arith.constant 4 : u32;
                v95 = hir.bitcast v77 : u32;
                v97 = arith.add v95, v184 : u32 #[overflow = checked];
                v183 = arith.constant 4 : u32;
                v99 = arith.mod v97, v183 : u32;
                hir.assertz v99 #[code = 250];
                v100 = hir.int_to_ptr v97 : ptr<byte, i32>;
                v101 = hir.load v100 : i32;
                v103 = arith.constant 12 : u32;
                v102 = hir.bitcast v77 : u32;
                v104 = arith.add v102, v103 : u32 #[overflow = checked];
                v182 = arith.constant 4 : u32;
                v106 = arith.mod v104, v182 : u32;
                hir.assertz v106 #[code = 250];
                v107 = hir.int_to_ptr v104 : ptr<byte, i32>;
                v108 = hir.load v107 : i32;
                hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v101, v88, v108)
                scf.yield ;
            };
            v181 = arith.constant 16 : i32;
            v111 = arith.add v77, v181 : i32 #[overflow = wrapping];
            v112 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v113 = hir.bitcast v112 : ptr<byte, i32>;
            hir.store v113, v111;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v114: i32, v115: i32, v116: i32, v117: i32) {
        ^block18(v114: i32, v115: i32, v116: i32, v117: i32):
            v211 = arith.constant 0 : i32;
            v118 = arith.constant 0 : i32;
            v122 = arith.eq v117, v118 : i1;
            v123 = arith.zext v122 : u32;
            v124 = hir.bitcast v123 : i32;
            v126 = arith.neq v124, v211 : i1;
            v198, v199 = scf.if v126 : i32, i32 {
            ^block30:
                v210 = arith.constant 0 : i32;
                v120 = arith.constant 4 : i32;
                scf.yield v120, v210;
            } else {
            ^block21:
                v127 = hir.bitcast v115 : u32;
                v162 = arith.constant 4 : u32;
                v129 = arith.mod v127, v162 : u32;
                hir.assertz v129 #[code = 250];
                v130 = hir.int_to_ptr v127 : ptr<byte, i32>;
                v131 = hir.load v130 : i32;
                v208 = arith.constant 0 : i32;
                v209 = arith.constant 0 : i32;
                v133 = arith.eq v131, v209 : i1;
                v134 = arith.zext v133 : u32;
                v135 = hir.bitcast v134 : i32;
                v137 = arith.neq v135, v208 : i1;
                v196 = scf.if v137 : i32 {
                ^block29:
                    v207 = arith.constant 0 : i32;
                    scf.yield v207;
                } else {
                ^block22:
                    v206 = arith.constant 4 : u32;
                    v138 = hir.bitcast v114 : u32;
                    v140 = arith.add v138, v206 : u32 #[overflow = checked];
                    v205 = arith.constant 4 : u32;
                    v142 = arith.mod v140, v205 : u32;
                    hir.assertz v142 #[code = 250];
                    v143 = hir.int_to_ptr v140 : ptr<byte, i32>;
                    hir.store v143, v116;
                    v204 = arith.constant 4 : u32;
                    v144 = hir.bitcast v115 : u32;
                    v146 = arith.add v144, v204 : u32 #[overflow = checked];
                    v203 = arith.constant 4 : u32;
                    v148 = arith.mod v146, v203 : u32;
                    hir.assertz v148 #[code = 250];
                    v149 = hir.int_to_ptr v146 : ptr<byte, i32>;
                    v150 = hir.load v149 : i32;
                    v151 = hir.bitcast v114 : u32;
                    v202 = arith.constant 4 : u32;
                    v153 = arith.mod v151, v202 : u32;
                    hir.assertz v153 #[code = 250];
                    v154 = hir.int_to_ptr v151 : ptr<byte, i32>;
                    hir.store v154, v150;
                    v155 = arith.mul v131, v117 : i32 #[overflow = wrapping];
                    scf.yield v155;
                };
                v156 = arith.constant 8 : i32;
                v201 = arith.constant 4 : i32;
                v197 = cf.select v137, v201, v156 : i32;
                scf.yield v197, v196;
            };
            v159 = arith.add v114, v198 : i32 #[overflow = wrapping];
            v161 = hir.bitcast v159 : u32;
            v200 = arith.constant 4 : u32;
            v163 = arith.mod v161, v200 : u32;
            hir.assertz v163 #[code = 250];
            v164 = hir.int_to_ptr v161 : ptr<byte, i32>;
            hir.store v164, v199;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v165: i32, v166: i32, v167: i32) {
        ^block23(v165: i32, v166: i32, v167: i32):
            v213 = arith.constant 0 : i32;
            v168 = arith.constant 0 : i32;
            v169 = arith.eq v167, v168 : i1;
            v170 = arith.zext v169 : u32;
            v171 = hir.bitcast v170 : i32;
            v173 = arith.neq v171, v213 : i1;
            scf.if v173{
            ^block25:
                scf.yield ;
            } else {
            ^block26:
                hir.exec @root_ns:root@1.0.0/hash_elements/__rustc::__rust_dealloc(v165, v167, v166)
                scf.yield ;
            };
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};