builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_elements {
        private builtin.function @__rustc::__rust_dealloc(v0: i32, v1: i32, v2: i32) {
        ^block4(v0: i32, v1: i32, v2: i32):
            builtin.ret ;
        };

        public builtin.function @entrypoint(v3: i32) -> felt {
        ^block6(v3: i32):
            v7 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v8 = hir.bitcast v7 : ptr<byte, i32>;
            v9 = hir.load v8 : i32;
            v10 = arith.constant 16 : i32;
            v11 = arith.sub v9, v10 : i32 #[overflow = wrapping];
            v12 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v13 = hir.bitcast v12 : ptr<byte, i32>;
            hir.store v13, v11;
            v15 = arith.constant 8 : u32;
            v14 = hir.bitcast v3 : u32;
            v16 = arith.add v14, v15 : u32 #[overflow = checked];
            v17 = arith.constant 4 : u32;
            v18 = arith.mod v16, v17 : u32;
            hir.assertz v18 #[code = 250];
            v19 = hir.int_to_ptr v16 : ptr<byte, i32>;
            v20 = hir.load v19 : i32;
            v184 = arith.constant 4 : u32;
            v21 = hir.bitcast v3 : u32;
            v23 = arith.add v21, v184 : u32 #[overflow = checked];
            v183 = arith.constant 4 : u32;
            v25 = arith.mod v23, v183 : u32;
            hir.assertz v25 #[code = 250];
            v26 = hir.int_to_ptr v23 : ptr<byte, i32>;
            v27 = hir.load v26 : i32;
            v174 = arith.constant 2 : u32;
            v29 = hir.bitcast v27 : u32;
            v31 = arith.shr v29, v174 : u32;
            v32 = hir.bitcast v31 : i32;
            v173 = arith.constant 0 : felt;
            v33 = arith.constant 3 : i32;
            v34 = arith.band v32, v33 : i32;
            v35 = hir.bitcast v34 : felt;
            hir.assert_eq v35, v173;
            v181 = arith.constant 0 : i32;
            v5 = arith.constant 0 : i32;
            v182 = arith.constant 3 : i32;
            v39 = arith.band v20, v182 : i32;
            v41 = arith.eq v39, v5 : i1;
            v42 = arith.zext v41 : u32;
            v43 = hir.bitcast v42 : i32;
            v45 = arith.neq v43, v181 : i1;
            scf.if v45{
            ^block9:
                v46 = arith.add v32, v20 : i32 #[overflow = wrapping];
                hir.exec @root_ns:root@1.0.0/hash_elements/miden::core::crypto::hashes::rpo::hash_memory_words(v32, v46, v11)
                scf.yield ;
            } else {
            ^block10:
                hir.exec @root_ns:root@1.0.0/hash_elements/miden::core::crypto::hashes::rpo::hash_memory(v32, v20, v11)
                scf.yield ;
            };
            v49 = arith.constant 12 : u32;
            v48 = hir.bitcast v11 : u32;
            v50 = arith.add v48, v49 : u32 #[overflow = checked];
            v180 = arith.constant 4 : u32;
            v52 = arith.mod v50, v180 : u32;
            hir.assertz v52 #[code = 250];
            v53 = hir.int_to_ptr v50 : ptr<byte, felt>;
            v54 = hir.load v53 : felt;
            v56 = arith.constant 4 : i32;
            hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::raw_vec::RawVecInner>::deallocate(v3, v56, v56)
            v179 = arith.constant 16 : i32;
            v59 = arith.add v11, v179 : i32 #[overflow = wrapping];
            v60 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v61 = hir.bitcast v60 : ptr<byte, i32>;
            hir.store v61, v59;
            builtin.ret v54;
        };

        private builtin.function @miden::core::crypto::hashes::rpo::hash_memory(v62: i32, v63: i32, v64: i32) {
        ^block11(v62: i32, v63: i32, v64: i32):
            ub.unreachable ;
        };

        private builtin.function @miden::core::crypto::hashes::rpo::hash_memory_words(v65: i32, v66: i32, v67: i32) {
        ^block13(v65: i32, v66: i32, v67: i32):
            ub.unreachable ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::deallocate(v68: i32, v69: i32, v70: i32) {
        ^block15(v68: i32, v69: i32, v70: i32):
            v72 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v73 = hir.bitcast v72 : ptr<byte, i32>;
            v74 = hir.load v73 : i32;
            v75 = arith.constant 16 : i32;
            v76 = arith.sub v74, v75 : i32 #[overflow = wrapping];
            v77 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v78 = hir.bitcast v77 : ptr<byte, i32>;
            hir.store v78, v76;
            v79 = arith.constant 4 : i32;
            v80 = arith.add v76, v79 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::raw_vec::RawVecInner>::current_memory(v80, v68, v69, v70)
            v82 = arith.constant 8 : u32;
            v81 = hir.bitcast v76 : u32;
            v83 = arith.add v81, v82 : u32 #[overflow = checked];
            v84 = arith.constant 4 : u32;
            v85 = arith.mod v83, v84 : u32;
            hir.assertz v85 #[code = 250];
            v86 = hir.int_to_ptr v83 : ptr<byte, i32>;
            v87 = hir.load v86 : i32;
            v191 = arith.constant 0 : i32;
            v71 = arith.constant 0 : i32;
            v89 = arith.eq v87, v71 : i1;
            v90 = arith.zext v89 : u32;
            v91 = hir.bitcast v90 : i32;
            v93 = arith.neq v91, v191 : i1;
            scf.if v93{
            ^block29:
                scf.yield ;
            } else {
            ^block18:
                v190 = arith.constant 4 : u32;
                v94 = hir.bitcast v76 : u32;
                v96 = arith.add v94, v190 : u32 #[overflow = checked];
                v189 = arith.constant 4 : u32;
                v98 = arith.mod v96, v189 : u32;
                hir.assertz v98 #[code = 250];
                v99 = hir.int_to_ptr v96 : ptr<byte, i32>;
                v100 = hir.load v99 : i32;
                v102 = arith.constant 12 : u32;
                v101 = hir.bitcast v76 : u32;
                v103 = arith.add v101, v102 : u32 #[overflow = checked];
                v188 = arith.constant 4 : u32;
                v105 = arith.mod v103, v188 : u32;
                hir.assertz v105 #[code = 250];
                v106 = hir.int_to_ptr v103 : ptr<byte, i32>;
                v107 = hir.load v106 : i32;
                hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v100, v87, v107)
                scf.yield ;
            };
            v187 = arith.constant 16 : i32;
            v110 = arith.add v76, v187 : i32 #[overflow = wrapping];
            v111 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v112 = hir.bitcast v111 : ptr<byte, i32>;
            hir.store v112, v110;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::current_memory(v113: i32, v114: i32, v115: i32, v116: i32) {
        ^block19(v113: i32, v114: i32, v115: i32, v116: i32):
            v217 = arith.constant 0 : i32;
            v117 = arith.constant 0 : i32;
            v121 = arith.eq v116, v117 : i1;
            v122 = arith.zext v121 : u32;
            v123 = hir.bitcast v122 : i32;
            v125 = arith.neq v123, v217 : i1;
            v204, v205 = scf.if v125 : i32, i32 {
            ^block32:
                v216 = arith.constant 0 : i32;
                v119 = arith.constant 4 : i32;
                scf.yield v119, v216;
            } else {
            ^block22:
                v126 = hir.bitcast v114 : u32;
                v161 = arith.constant 4 : u32;
                v128 = arith.mod v126, v161 : u32;
                hir.assertz v128 #[code = 250];
                v129 = hir.int_to_ptr v126 : ptr<byte, i32>;
                v130 = hir.load v129 : i32;
                v214 = arith.constant 0 : i32;
                v215 = arith.constant 0 : i32;
                v132 = arith.eq v130, v215 : i1;
                v133 = arith.zext v132 : u32;
                v134 = hir.bitcast v133 : i32;
                v136 = arith.neq v134, v214 : i1;
                v202 = scf.if v136 : i32 {
                ^block31:
                    v213 = arith.constant 0 : i32;
                    scf.yield v213;
                } else {
                ^block23:
                    v212 = arith.constant 4 : u32;
                    v137 = hir.bitcast v113 : u32;
                    v139 = arith.add v137, v212 : u32 #[overflow = checked];
                    v211 = arith.constant 4 : u32;
                    v141 = arith.mod v139, v211 : u32;
                    hir.assertz v141 #[code = 250];
                    v142 = hir.int_to_ptr v139 : ptr<byte, i32>;
                    hir.store v142, v115;
                    v210 = arith.constant 4 : u32;
                    v143 = hir.bitcast v114 : u32;
                    v145 = arith.add v143, v210 : u32 #[overflow = checked];
                    v209 = arith.constant 4 : u32;
                    v147 = arith.mod v145, v209 : u32;
                    hir.assertz v147 #[code = 250];
                    v148 = hir.int_to_ptr v145 : ptr<byte, i32>;
                    v149 = hir.load v148 : i32;
                    v150 = hir.bitcast v113 : u32;
                    v208 = arith.constant 4 : u32;
                    v152 = arith.mod v150, v208 : u32;
                    hir.assertz v152 #[code = 250];
                    v153 = hir.int_to_ptr v150 : ptr<byte, i32>;
                    hir.store v153, v149;
                    v154 = arith.mul v130, v116 : i32 #[overflow = wrapping];
                    scf.yield v154;
                };
                v155 = arith.constant 8 : i32;
                v207 = arith.constant 4 : i32;
                v203 = cf.select v136, v207, v155 : i32;
                scf.yield v203, v202;
            };
            v158 = arith.add v113, v204 : i32 #[overflow = wrapping];
            v160 = hir.bitcast v158 : u32;
            v206 = arith.constant 4 : u32;
            v162 = arith.mod v160, v206 : u32;
            hir.assertz v162 #[code = 250];
            v163 = hir.int_to_ptr v160 : ptr<byte, i32>;
            hir.store v163, v205;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v164: i32, v165: i32, v166: i32) {
        ^block24(v164: i32, v165: i32, v166: i32):
            v219 = arith.constant 0 : i32;
            v167 = arith.constant 0 : i32;
            v168 = arith.eq v166, v167 : i1;
            v169 = arith.zext v168 : u32;
            v170 = hir.bitcast v169 : i32;
            v172 = arith.neq v170, v219 : i1;
            scf.if v172{
            ^block26:
                scf.yield ;
            } else {
            ^block27:
                hir.exec @root_ns:root@1.0.0/hash_elements/__rustc::__rust_dealloc(v164, v166, v165)
                scf.yield ;
            };
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};