builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_elements {
        private builtin.function @miden_stdlib_sys::stdlib::crypto::hashes::extern_hash_memory(v0: i32, v1: i32, v2: i32) {
        ^block3(v0: i32, v1: i32, v2: i32):
            v3, v4, v5, v6 = hir.exec @std/crypto/hashes/rpo/hash_memory(v0, v1) : felt, felt, felt, felt
            v7 = hir.bitcast v2 : u32;
            v8 = hir.int_to_ptr v7 : ptr<byte, felt>;
            hir.store v8, v3;
            v9 = arith.constant 4 : u32;
            v10 = arith.add v7, v9 : u32 #[overflow = checked];
            v11 = hir.int_to_ptr v10 : ptr<byte, felt>;
            hir.store v11, v4;
            v12 = arith.constant 8 : u32;
            v13 = arith.add v7, v12 : u32 #[overflow = checked];
            v14 = hir.int_to_ptr v13 : ptr<byte, felt>;
            hir.store v14, v5;
            v15 = arith.constant 12 : u32;
            v16 = arith.add v7, v15 : u32 #[overflow = checked];
            v17 = hir.int_to_ptr v16 : ptr<byte, felt>;
            hir.store v17, v6;
            builtin.ret ;
        };

        public builtin.function @entrypoint(v18: felt, v19: felt, v20: felt, v21: felt, v22: felt, v23: felt, v24: felt, v25: felt) -> felt {
        ^block12(v18: felt, v19: felt, v20: felt, v21: felt, v22: felt, v23: felt, v24: felt, v25: felt):
            v28 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v29 = hir.bitcast v28 : ptr<byte, i32>;
            v30 = hir.load v29 : i32;
            v33 = arith.constant -32 : i32;
            v31 = arith.constant 96 : i32;
            v32 = arith.sub v30, v31 : i32 #[overflow = wrapping];
            v34 = arith.band v32, v33 : i32;
            v35 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v36 = hir.bitcast v35 : ptr<byte, i32>;
            hir.store v36, v34;
            v38 = arith.constant 48 : u32;
            v37 = hir.bitcast v34 : u32;
            v39 = arith.add v37, v38 : u32 #[overflow = checked];
            v40 = arith.constant 4 : u32;
            v41 = arith.mod v39, v40 : u32;
            hir.assertz v41 #[code = 250];
            v42 = hir.int_to_ptr v39 : ptr<byte, felt>;
            hir.store v42, v25;
            v44 = arith.constant 44 : u32;
            v43 = hir.bitcast v34 : u32;
            v45 = arith.add v43, v44 : u32 #[overflow = checked];
            v758 = arith.constant 4 : u32;
            v47 = arith.mod v45, v758 : u32;
            hir.assertz v47 #[code = 250];
            v48 = hir.int_to_ptr v45 : ptr<byte, felt>;
            hir.store v48, v24;
            v50 = arith.constant 40 : u32;
            v49 = hir.bitcast v34 : u32;
            v51 = arith.add v49, v50 : u32 #[overflow = checked];
            v757 = arith.constant 4 : u32;
            v53 = arith.mod v51, v757 : u32;
            hir.assertz v53 #[code = 250];
            v54 = hir.int_to_ptr v51 : ptr<byte, felt>;
            hir.store v54, v23;
            v56 = arith.constant 36 : u32;
            v55 = hir.bitcast v34 : u32;
            v57 = arith.add v55, v56 : u32 #[overflow = checked];
            v756 = arith.constant 4 : u32;
            v59 = arith.mod v57, v756 : u32;
            hir.assertz v59 #[code = 250];
            v60 = hir.int_to_ptr v57 : ptr<byte, felt>;
            hir.store v60, v22;
            v62 = arith.constant 32 : u32;
            v61 = hir.bitcast v34 : u32;
            v63 = arith.add v61, v62 : u32 #[overflow = checked];
            v755 = arith.constant 4 : u32;
            v65 = arith.mod v63, v755 : u32;
            hir.assertz v65 #[code = 250];
            v66 = hir.int_to_ptr v63 : ptr<byte, felt>;
            hir.store v66, v21;
            v68 = arith.constant 28 : u32;
            v67 = hir.bitcast v34 : u32;
            v69 = arith.add v67, v68 : u32 #[overflow = checked];
            v754 = arith.constant 4 : u32;
            v71 = arith.mod v69, v754 : u32;
            hir.assertz v71 #[code = 250];
            v72 = hir.int_to_ptr v69 : ptr<byte, felt>;
            hir.store v72, v20;
            v74 = arith.constant 24 : u32;
            v73 = hir.bitcast v34 : u32;
            v75 = arith.add v73, v74 : u32 #[overflow = checked];
            v753 = arith.constant 4 : u32;
            v77 = arith.mod v75, v753 : u32;
            hir.assertz v77 #[code = 250];
            v78 = hir.int_to_ptr v75 : ptr<byte, felt>;
            hir.store v78, v19;
            v80 = arith.constant 20 : u32;
            v79 = hir.bitcast v34 : u32;
            v81 = arith.add v79, v80 : u32 #[overflow = checked];
            v752 = arith.constant 4 : u32;
            v83 = arith.mod v81, v752 : u32;
            hir.assertz v83 #[code = 250];
            v84 = hir.int_to_ptr v81 : ptr<byte, felt>;
            hir.store v84, v18;
            v27 = arith.constant 0 : i32;
            v87 = arith.constant 12 : i32;
            v85 = arith.constant 20 : i32;
            v86 = arith.add v34, v85 : i32 #[overflow = wrapping];
            v88 = arith.band v86, v87 : i32;
            v90 = arith.neq v88, v27 : i1;
            v701, v702, v703, v704 = scf.if v90 : i32, i32, i32, u32 {
            ^block16:
                v102 = arith.constant 4 : i32;
                v751 = arith.constant 0 : i32;
                v221 = arith.constant 8 : i32;
                v223 = arith.constant 64 : i32;
                v99 = arith.add v34, v223 : i32 #[overflow = wrapping];
                hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::RawVecInner<A>::try_allocate_in(v99, v221, v751, v102, v102)
                v105 = arith.constant 68 : u32;
                v104 = hir.bitcast v34 : u32;
                v106 = arith.add v104, v105 : u32 #[overflow = checked];
                v750 = arith.constant 4 : u32;
                v108 = arith.mod v106, v750 : u32;
                hir.assertz v108 #[code = 250];
                v109 = hir.int_to_ptr v106 : ptr<byte, i32>;
                v110 = hir.load v109 : i32;
                v112 = arith.constant 64 : u32;
                v111 = hir.bitcast v34 : u32;
                v113 = arith.add v111, v112 : u32 #[overflow = checked];
                v749 = arith.constant 4 : u32;
                v115 = arith.mod v113, v749 : u32;
                hir.assertz v115 #[code = 250];
                v116 = hir.int_to_ptr v113 : ptr<byte, i32>;
                v117 = hir.load v116 : i32;
                v748 = arith.constant 0 : i32;
                v118 = arith.constant 1 : i32;
                v119 = arith.eq v117, v118 : i1;
                v120 = arith.zext v119 : u32;
                v121 = hir.bitcast v120 : i32;
                v123 = arith.neq v121, v748 : i1;
                v711 = scf.if v123 : i32 {
                ^block14:
                    v236 = arith.constant 72 : u32;
                    v235 = hir.bitcast v34 : u32;
                    v237 = arith.add v235, v236 : u32 #[overflow = checked];
                    v747 = arith.constant 4 : u32;
                    v239 = arith.mod v237, v747 : u32;
                    hir.assertz v239 #[code = 250];
                    v240 = hir.int_to_ptr v237 : ptr<byte, i32>;
                    v241 = hir.load v240 : i32;
                    v242 = arith.constant 1048628 : i32;
                    hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::handle_error(v110, v241, v242)
                    v695 = ub.poison i32 : i32;
                    scf.yield v695;
                } else {
                ^block18:
                    v746 = arith.constant 72 : u32;
                    v124 = hir.bitcast v34 : u32;
                    v126 = arith.add v124, v746 : u32 #[overflow = checked];
                    v745 = arith.constant 4 : u32;
                    v128 = arith.mod v126, v745 : u32;
                    hir.assertz v128 #[code = 250];
                    v129 = hir.int_to_ptr v126 : ptr<byte, i32>;
                    v130 = hir.load v129 : i32;
                    v132 = arith.constant 56 : u32;
                    v131 = hir.bitcast v34 : u32;
                    v133 = arith.add v131, v132 : u32 #[overflow = checked];
                    v744 = arith.constant 4 : u32;
                    v135 = arith.mod v133, v744 : u32;
                    hir.assertz v135 #[code = 250];
                    v136 = hir.int_to_ptr v133 : ptr<byte, i32>;
                    hir.store v136, v130;
                    v138 = arith.constant 52 : u32;
                    v137 = hir.bitcast v34 : u32;
                    v139 = arith.add v137, v138 : u32 #[overflow = checked];
                    v743 = arith.constant 4 : u32;
                    v141 = arith.mod v139, v743 : u32;
                    hir.assertz v141 #[code = 250];
                    v142 = hir.int_to_ptr v139 : ptr<byte, i32>;
                    hir.store v142, v110;
                    v742 = arith.constant 20 : u32;
                    v143 = hir.bitcast v34 : u32;
                    v145 = arith.add v143, v742 : u32 #[overflow = checked];
                    v741 = arith.constant 4 : u32;
                    v147 = arith.mod v145, v741 : u32;
                    hir.assertz v147 #[code = 250];
                    v148 = hir.int_to_ptr v145 : ptr<byte, i64>;
                    v149 = hir.load v148 : i64;
                    v150 = hir.bitcast v130 : u32;
                    v740 = arith.constant 4 : u32;
                    v152 = arith.mod v150, v740 : u32;
                    hir.assertz v152 #[code = 250];
                    v153 = hir.int_to_ptr v150 : ptr<byte, i64>;
                    hir.store v153, v149;
                    v154 = arith.constant 16 : i32;
                    v739 = arith.constant 20 : i32;
                    v157 = arith.add v34, v739 : i32 #[overflow = wrapping];
                    v159 = arith.add v157, v154 : i32 #[overflow = wrapping];
                    v160 = hir.bitcast v159 : u32;
                    v738 = arith.constant 4 : u32;
                    v162 = arith.mod v160, v738 : u32;
                    hir.assertz v162 #[code = 250];
                    v163 = hir.int_to_ptr v160 : ptr<byte, i64>;
                    v164 = hir.load v163 : i64;
                    v737 = arith.constant 16 : i32;
                    v155 = arith.add v130, v737 : i32 #[overflow = wrapping];
                    v165 = hir.bitcast v155 : u32;
                    v736 = arith.constant 4 : u32;
                    v167 = arith.mod v165, v736 : u32;
                    hir.assertz v167 #[code = 250];
                    v168 = hir.int_to_ptr v165 : ptr<byte, i64>;
                    hir.store v168, v164;
                    v169 = arith.constant 24 : i32;
                    v735 = arith.constant 20 : i32;
                    v172 = arith.add v34, v735 : i32 #[overflow = wrapping];
                    v174 = arith.add v172, v169 : i32 #[overflow = wrapping];
                    v175 = hir.bitcast v174 : u32;
                    v734 = arith.constant 4 : u32;
                    v177 = arith.mod v175, v734 : u32;
                    hir.assertz v177 #[code = 250];
                    v178 = hir.int_to_ptr v175 : ptr<byte, i64>;
                    v179 = hir.load v178 : i64;
                    v733 = arith.constant 24 : i32;
                    v170 = arith.add v130, v733 : i32 #[overflow = wrapping];
                    v180 = hir.bitcast v170 : u32;
                    v732 = arith.constant 4 : u32;
                    v182 = arith.mod v180, v732 : u32;
                    hir.assertz v182 #[code = 250];
                    v183 = hir.int_to_ptr v180 : ptr<byte, i64>;
                    hir.store v183, v179;
                    v186 = arith.constant 60 : u32;
                    v185 = hir.bitcast v34 : u32;
                    v187 = arith.add v185, v186 : u32 #[overflow = checked];
                    v731 = arith.constant 4 : u32;
                    v189 = arith.mod v187, v731 : u32;
                    hir.assertz v189 #[code = 250];
                    v730 = arith.constant 8 : i32;
                    v190 = hir.int_to_ptr v187 : ptr<byte, i32>;
                    hir.store v190, v730;
                    v728 = arith.constant 8 : i32;
                    v729 = arith.constant 20 : i32;
                    v194 = arith.add v34, v729 : i32 #[overflow = wrapping];
                    v196 = arith.add v194, v728 : i32 #[overflow = wrapping];
                    v197 = hir.bitcast v196 : u32;
                    v727 = arith.constant 4 : u32;
                    v199 = arith.mod v197, v727 : u32;
                    hir.assertz v199 #[code = 250];
                    v200 = hir.int_to_ptr v197 : ptr<byte, i64>;
                    v201 = hir.load v200 : i64;
                    v726 = arith.constant 8 : i32;
                    v192 = arith.add v130, v726 : i32 #[overflow = wrapping];
                    v202 = hir.bitcast v192 : u32;
                    v725 = arith.constant 4 : u32;
                    v204 = arith.mod v202, v725 : u32;
                    hir.assertz v204 #[code = 250];
                    v205 = hir.int_to_ptr v202 : ptr<byte, i64>;
                    hir.store v205, v201;
                    v688 = arith.constant 2 : u32;
                    v207 = hir.bitcast v130 : u32;
                    v209 = arith.shr v207, v688 : u32;
                    v210 = hir.bitcast v209 : i32;
                    v686 = arith.constant 0 : felt;
                    v211 = arith.constant 3 : i32;
                    v212 = arith.band v210, v211 : i32;
                    v213 = hir.bitcast v212 : felt;
                    hir.assert_eq v213, v686;
                    v724 = arith.constant 4 : i32;
                    v216 = arith.constant 52 : i32;
                    v217 = arith.add v34, v216 : i32 #[overflow = wrapping];
                    hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::RawVecInner<A>::deallocate(v217, v724, v724)
                    scf.yield v210;
                };
                v689 = arith.constant 0 : u32;
                v696 = arith.constant 1 : u32;
                v714 = cf.select v123, v696, v689 : u32;
                v722 = ub.poison i32 : i32;
                v713 = cf.select v123, v722, v30 : i32;
                v723 = ub.poison i32 : i32;
                v712 = cf.select v123, v723, v34 : i32;
                scf.yield v711, v712, v713, v714;
            } else {
            ^block17:
                v719 = arith.constant 0 : u32;
                v720 = arith.constant 2 : u32;
                v721 = arith.constant 20 : i32;
                v92 = arith.add v34, v721 : i32 #[overflow = wrapping];
                v94 = hir.bitcast v92 : u32;
                v96 = arith.shr v94, v720 : u32;
                v97 = hir.bitcast v96 : i32;
                scf.yield v97, v34, v30, v719;
            };
            v718 = arith.constant 0 : u32;
            v710 = arith.eq v704, v718 : i1;
            cf.cond_br v710 ^block15, ^block76;
        ^block15:
            v716 = arith.constant 64 : i32;
            v224 = arith.add v702, v716 : i32 #[overflow = wrapping];
            v717 = arith.constant 8 : i32;
            hir.exec @root_ns:root@1.0.0/hash_elements/miden_stdlib_sys::stdlib::crypto::hashes::extern_hash_memory(v701, v717, v224)
            v226 = arith.constant 76 : u32;
            v225 = hir.bitcast v702 : u32;
            v227 = arith.add v225, v226 : u32 #[overflow = checked];
            v715 = arith.constant 4 : u32;
            v229 = arith.mod v227, v715 : u32;
            hir.assertz v229 #[code = 250];
            v230 = hir.int_to_ptr v227 : ptr<byte, felt>;
            v231 = hir.load v230 : felt;
            v233 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v234 = hir.bitcast v233 : ptr<byte, i32>;
            hir.store v234, v703;
            builtin.ret v231;
        ^block76:
            ub.unreachable ;
        };

        private builtin.function @__rustc::__rust_alloc(v243: i32, v244: i32) -> i32 {
        ^block19(v243: i32, v244: i32):
            v246 = arith.constant 1048644 : i32;
            v247 = hir.exec @root_ns:root@1.0.0/hash_elements/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v246, v244, v243) : i32
            builtin.ret v247;
        };

        private builtin.function @__rustc::__rust_dealloc(v248: i32, v249: i32, v250: i32) {
        ^block21(v248: i32, v249: i32, v250: i32):
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v251: i32, v252: i32) -> i32 {
        ^block23(v251: i32, v252: i32):
            v254 = arith.constant 1048644 : i32;
            v255 = hir.exec @root_ns:root@1.0.0/hash_elements/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v254, v252, v251) : i32
            v767 = arith.constant 0 : i32;
            v256 = arith.constant 0 : i32;
            v257 = arith.eq v255, v256 : i1;
            v258 = arith.zext v257 : u32;
            v259 = hir.bitcast v258 : i32;
            v261 = arith.neq v259, v767 : i1;
            scf.if v261{
            ^block25:
                scf.yield ;
            } else {
            ^block26:
                v765 = arith.constant 0 : i32;
                v766 = arith.constant 0 : i32;
                v263 = arith.eq v251, v766 : i1;
                v264 = arith.zext v263 : u32;
                v265 = hir.bitcast v264 : i32;
                v267 = arith.neq v265, v765 : i1;
                scf.if v267{
                ^block80:
                    scf.yield ;
                } else {
                ^block27:
                    v759 = arith.constant 0 : u8;
                    v270 = hir.bitcast v251 : u32;
                    v271 = hir.bitcast v255 : u32;
                    v272 = hir.int_to_ptr v271 : ptr<byte, u8>;
                    hir.mem_set v272, v270, v759;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v255;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v274: i32, v275: i32, v276: i32) -> i32 {
        ^block28(v274: i32, v275: i32, v276: i32):
            v279 = arith.constant 16 : i32;
            v278 = arith.constant 0 : i32;
            v769 = arith.constant 16 : u32;
            v281 = hir.bitcast v275 : u32;
            v283 = arith.gt v281, v769 : i1;
            v284 = arith.zext v283 : u32;
            v285 = hir.bitcast v284 : i32;
            v287 = arith.neq v285, v278 : i1;
            v288 = cf.select v287, v275, v279 : i32;
            v808 = arith.constant 0 : i32;
            v289 = arith.constant -1 : i32;
            v290 = arith.add v288, v289 : i32 #[overflow = wrapping];
            v291 = arith.band v288, v290 : i32;
            v293 = arith.neq v291, v808 : i1;
            v778, v779 = scf.if v293 : i32, u32 {
            ^block85:
                v770 = arith.constant 0 : u32;
                v774 = ub.poison i32 : i32;
                scf.yield v774, v770;
            } else {
            ^block31:
                v295 = hir.exec @root_ns:root@1.0.0/hash_elements/core::ptr::alignment::Alignment::max(v275, v288) : i32
                v807 = arith.constant 0 : i32;
                v294 = arith.constant -2147483648 : i32;
                v296 = arith.sub v294, v295 : i32 #[overflow = wrapping];
                v298 = hir.bitcast v296 : u32;
                v297 = hir.bitcast v276 : u32;
                v299 = arith.gt v297, v298 : i1;
                v300 = arith.zext v299 : u32;
                v301 = hir.bitcast v300 : i32;
                v303 = arith.neq v301, v807 : i1;
                v793 = scf.if v303 : i32 {
                ^block84:
                    v806 = ub.poison i32 : i32;
                    scf.yield v806;
                } else {
                ^block32:
                    v804 = arith.constant 0 : i32;
                    v309 = arith.sub v804, v295 : i32 #[overflow = wrapping];
                    v805 = arith.constant -1 : i32;
                    v305 = arith.add v276, v295 : i32 #[overflow = wrapping];
                    v307 = arith.add v305, v805 : i32 #[overflow = wrapping];
                    v310 = arith.band v307, v309 : i32;
                    v311 = hir.bitcast v274 : u32;
                    v312 = arith.constant 4 : u32;
                    v313 = arith.mod v311, v312 : u32;
                    hir.assertz v313 #[code = 250];
                    v314 = hir.int_to_ptr v311 : ptr<byte, i32>;
                    v315 = hir.load v314 : i32;
                    v803 = arith.constant 0 : i32;
                    v317 = arith.neq v315, v803 : i1;
                    scf.if v317{
                    ^block83:
                        scf.yield ;
                    } else {
                    ^block34:
                        v318 = hir.exec @intrinsics/mem/heap_base() : i32
                        v319 = hir.mem_size  : u32;
                        v325 = hir.bitcast v274 : u32;
                        v802 = arith.constant 4 : u32;
                        v327 = arith.mod v325, v802 : u32;
                        hir.assertz v327 #[code = 250];
                        v801 = arith.constant 16 : u32;
                        v320 = hir.bitcast v319 : i32;
                        v323 = arith.shl v320, v801 : i32;
                        v324 = arith.add v318, v323 : i32 #[overflow = wrapping];
                        v328 = hir.int_to_ptr v325 : ptr<byte, i32>;
                        hir.store v328, v324;
                        scf.yield ;
                    };
                    v331 = hir.bitcast v274 : u32;
                    v800 = arith.constant 4 : u32;
                    v333 = arith.mod v331, v800 : u32;
                    hir.assertz v333 #[code = 250];
                    v334 = hir.int_to_ptr v331 : ptr<byte, i32>;
                    v335 = hir.load v334 : i32;
                    v799 = arith.constant 0 : i32;
                    v339 = hir.bitcast v310 : u32;
                    v329 = arith.constant 268435456 : i32;
                    v336 = arith.sub v329, v335 : i32 #[overflow = wrapping];
                    v338 = hir.bitcast v336 : u32;
                    v340 = arith.lt v338, v339 : i1;
                    v341 = arith.zext v340 : u32;
                    v342 = hir.bitcast v341 : i32;
                    v344 = arith.neq v342, v799 : i1;
                    v792 = scf.if v344 : i32 {
                    ^block35:
                        v798 = arith.constant 0 : i32;
                        scf.yield v798;
                    } else {
                    ^block36:
                        v346 = hir.bitcast v274 : u32;
                        v797 = arith.constant 4 : u32;
                        v348 = arith.mod v346, v797 : u32;
                        hir.assertz v348 #[code = 250];
                        v345 = arith.add v335, v310 : i32 #[overflow = wrapping];
                        v349 = hir.int_to_ptr v346 : ptr<byte, i32>;
                        hir.store v349, v345;
                        v351 = arith.add v335, v295 : i32 #[overflow = wrapping];
                        scf.yield v351;
                    };
                    scf.yield v792;
                };
                v775 = arith.constant 1 : u32;
                v796 = arith.constant 0 : u32;
                v794 = cf.select v303, v796, v775 : u32;
                scf.yield v793, v794;
            };
            v795 = arith.constant 0 : u32;
            v791 = arith.eq v779, v795 : i1;
            cf.cond_br v791 ^block30, ^block87(v778);
        ^block30:
            ub.unreachable ;
        ^block87(v771: i32):
            builtin.ret v771;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v354: i32, v355: i32, v356: i32) {
        ^block37(v354: i32, v355: i32, v356: i32):
            v358 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v359 = hir.bitcast v358 : ptr<byte, i32>;
            v360 = hir.load v359 : i32;
            v361 = arith.constant 16 : i32;
            v362 = arith.sub v360, v361 : i32 #[overflow = wrapping];
            v363 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v364 = hir.bitcast v363 : ptr<byte, i32>;
            hir.store v364, v362;
            v365 = arith.constant 4 : i32;
            v366 = arith.add v362, v365 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::RawVecInner<A>::current_memory(v366, v354, v355, v356)
            v368 = arith.constant 8 : u32;
            v367 = hir.bitcast v362 : u32;
            v369 = arith.add v367, v368 : u32 #[overflow = checked];
            v370 = arith.constant 4 : u32;
            v371 = arith.mod v369, v370 : u32;
            hir.assertz v371 #[code = 250];
            v372 = hir.int_to_ptr v369 : ptr<byte, i32>;
            v373 = hir.load v372 : i32;
            v815 = arith.constant 0 : i32;
            v357 = arith.constant 0 : i32;
            v375 = arith.eq v373, v357 : i1;
            v376 = arith.zext v375 : u32;
            v377 = hir.bitcast v376 : i32;
            v379 = arith.neq v377, v815 : i1;
            scf.if v379{
            ^block91:
                scf.yield ;
            } else {
            ^block40:
                v814 = arith.constant 4 : u32;
                v380 = hir.bitcast v362 : u32;
                v382 = arith.add v380, v814 : u32 #[overflow = checked];
                v813 = arith.constant 4 : u32;
                v384 = arith.mod v382, v813 : u32;
                hir.assertz v384 #[code = 250];
                v385 = hir.int_to_ptr v382 : ptr<byte, i32>;
                v386 = hir.load v385 : i32;
                v388 = arith.constant 12 : u32;
                v387 = hir.bitcast v362 : u32;
                v389 = arith.add v387, v388 : u32 #[overflow = checked];
                v812 = arith.constant 4 : u32;
                v391 = arith.mod v389, v812 : u32;
                hir.assertz v391 #[code = 250];
                v392 = hir.int_to_ptr v389 : ptr<byte, i32>;
                v393 = hir.load v392 : i32;
                hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v386, v373, v393)
                scf.yield ;
            };
            v811 = arith.constant 16 : i32;
            v396 = arith.add v362, v811 : i32 #[overflow = wrapping];
            v397 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v398 = hir.bitcast v397 : ptr<byte, i32>;
            hir.store v398, v396;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::try_allocate_in(v399: i32, v400: i32, v401: i32, v402: i32, v403: i32) {
        ^block41(v399: i32, v400: i32, v401: i32, v402: i32, v403: i32):
            v406 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v407 = hir.bitcast v406 : ptr<byte, i32>;
            v408 = hir.load v407 : i32;
            v409 = arith.constant 16 : i32;
            v410 = arith.sub v408, v409 : i32 #[overflow = wrapping];
            v411 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v412 = hir.bitcast v411 : ptr<byte, i32>;
            hir.store v412, v410;
            v422 = hir.bitcast v400 : u32;
            v423 = arith.zext v422 : u64;
            v424 = hir.bitcast v423 : i64;
            v404 = arith.constant 0 : i32;
            v417 = arith.sub v404, v402 : i32 #[overflow = wrapping];
            v414 = arith.constant -1 : i32;
            v413 = arith.add v402, v403 : i32 #[overflow = wrapping];
            v415 = arith.add v413, v414 : i32 #[overflow = wrapping];
            v418 = arith.band v415, v417 : i32;
            v419 = hir.bitcast v418 : u32;
            v420 = arith.zext v419 : u64;
            v421 = hir.bitcast v420 : i64;
            v425 = arith.mul v421, v424 : i64 #[overflow = wrapping];
            v919 = arith.constant 0 : i32;
            v426 = arith.constant 32 : i64;
            v428 = hir.cast v426 : u32;
            v427 = hir.bitcast v425 : u64;
            v429 = arith.shr v427, v428 : u64;
            v430 = hir.bitcast v429 : i64;
            v431 = arith.trunc v430 : i32;
            v433 = arith.neq v431, v919 : i1;
            v831, v832, v833, v834, v835, v836 = scf.if v433 : i32, i32, i32, i32, i32, u32 {
            ^block93:
                v816 = arith.constant 0 : u32;
                v823 = ub.poison i32 : i32;
                scf.yield v399, v410, v823, v823, v823, v816;
            } else {
            ^block46:
                v434 = arith.trunc v425 : i32;
                v918 = arith.constant 0 : i32;
                v435 = arith.constant -2147483648 : i32;
                v436 = arith.sub v435, v402 : i32 #[overflow = wrapping];
                v438 = hir.bitcast v436 : u32;
                v437 = hir.bitcast v434 : u32;
                v439 = arith.lte v437, v438 : i1;
                v440 = arith.zext v439 : u32;
                v441 = hir.bitcast v440 : i32;
                v443 = arith.neq v441, v918 : i1;
                v879 = scf.if v443 : i32 {
                ^block44:
                    v917 = arith.constant 0 : i32;
                    v454 = arith.neq v434, v917 : i1;
                    v878 = scf.if v454 : i32 {
                    ^block48:
                        v916 = arith.constant 0 : i32;
                        v470 = arith.neq v401, v916 : i1;
                        v877 = scf.if v470 : i32 {
                        ^block51:
                            v452 = arith.constant 1 : i32;
                            hir.exec @root_ns:root@1.0.0/hash_elements/alloc::alloc::Global::alloc_impl(v410, v402, v434, v452)
                            v481 = hir.bitcast v410 : u32;
                            v526 = arith.constant 4 : u32;
                            v483 = arith.mod v481, v526 : u32;
                            hir.assertz v483 #[code = 250];
                            v484 = hir.int_to_ptr v481 : ptr<byte, i32>;
                            v485 = hir.load v484 : i32;
                            scf.yield v485;
                        } else {
                        ^block52:
                            v471 = arith.constant 8 : i32;
                            v472 = arith.add v410, v471 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v472, v402, v434)
                            v456 = arith.constant 8 : u32;
                            v473 = hir.bitcast v410 : u32;
                            v475 = arith.add v473, v456 : u32 #[overflow = checked];
                            v915 = arith.constant 4 : u32;
                            v477 = arith.mod v475, v915 : u32;
                            hir.assertz v477 #[code = 250];
                            v478 = hir.int_to_ptr v475 : ptr<byte, i32>;
                            v479 = hir.load v478 : i32;
                            scf.yield v479;
                        };
                        v913 = arith.constant 0 : i32;
                        v914 = arith.constant 0 : i32;
                        v488 = arith.eq v877, v914 : i1;
                        v489 = arith.zext v488 : u32;
                        v490 = hir.bitcast v489 : i32;
                        v492 = arith.neq v490, v913 : i1;
                        scf.if v492{
                        ^block53:
                            v912 = arith.constant 8 : u32;
                            v509 = hir.bitcast v399 : u32;
                            v511 = arith.add v509, v912 : u32 #[overflow = checked];
                            v911 = arith.constant 4 : u32;
                            v513 = arith.mod v511, v911 : u32;
                            hir.assertz v513 #[code = 250];
                            v514 = hir.int_to_ptr v511 : ptr<byte, i32>;
                            hir.store v514, v434;
                            v910 = arith.constant 4 : u32;
                            v516 = hir.bitcast v399 : u32;
                            v518 = arith.add v516, v910 : u32 #[overflow = checked];
                            v909 = arith.constant 4 : u32;
                            v520 = arith.mod v518, v909 : u32;
                            hir.assertz v520 #[code = 250];
                            v521 = hir.int_to_ptr v518 : ptr<byte, i32>;
                            hir.store v521, v402;
                            scf.yield ;
                        } else {
                        ^block54:
                            v908 = arith.constant 8 : u32;
                            v494 = hir.bitcast v399 : u32;
                            v496 = arith.add v494, v908 : u32 #[overflow = checked];
                            v907 = arith.constant 4 : u32;
                            v498 = arith.mod v496, v907 : u32;
                            hir.assertz v498 #[code = 250];
                            v499 = hir.int_to_ptr v496 : ptr<byte, i32>;
                            hir.store v499, v877;
                            v906 = arith.constant 4 : u32;
                            v501 = hir.bitcast v399 : u32;
                            v503 = arith.add v501, v906 : u32 #[overflow = checked];
                            v905 = arith.constant 4 : u32;
                            v505 = arith.mod v503, v905 : u32;
                            hir.assertz v505 #[code = 250];
                            v506 = hir.int_to_ptr v503 : ptr<byte, i32>;
                            hir.store v506, v400;
                            scf.yield ;
                        };
                        v903 = arith.constant 0 : i32;
                        v904 = arith.constant 1 : i32;
                        v876 = cf.select v492, v904, v903 : i32;
                        scf.yield v876;
                    } else {
                    ^block49:
                        v902 = arith.constant 8 : u32;
                        v455 = hir.bitcast v399 : u32;
                        v457 = arith.add v455, v902 : u32 #[overflow = checked];
                        v901 = arith.constant 4 : u32;
                        v459 = arith.mod v457, v901 : u32;
                        hir.assertz v459 #[code = 250];
                        v460 = hir.int_to_ptr v457 : ptr<byte, i32>;
                        hir.store v460, v402;
                        v900 = arith.constant 4 : u32;
                        v463 = hir.bitcast v399 : u32;
                        v465 = arith.add v463, v900 : u32 #[overflow = checked];
                        v899 = arith.constant 4 : u32;
                        v467 = arith.mod v465, v899 : u32;
                        hir.assertz v467 #[code = 250];
                        v898 = arith.constant 0 : i32;
                        v468 = hir.int_to_ptr v465 : ptr<byte, i32>;
                        hir.store v468, v898;
                        v897 = arith.constant 0 : i32;
                        scf.yield v897;
                    };
                    scf.yield v878;
                } else {
                ^block47:
                    v896 = ub.poison i32 : i32;
                    scf.yield v896;
                };
                v891 = arith.constant 0 : u32;
                v824 = arith.constant 1 : u32;
                v884 = cf.select v443, v824, v891 : u32;
                v892 = ub.poison i32 : i32;
                v883 = cf.select v443, v410, v892 : i32;
                v893 = ub.poison i32 : i32;
                v882 = cf.select v443, v399, v893 : i32;
                v894 = ub.poison i32 : i32;
                v881 = cf.select v443, v894, v410 : i32;
                v895 = ub.poison i32 : i32;
                v880 = cf.select v443, v895, v399 : i32;
                scf.yield v880, v881, v882, v879, v883, v884;
            };
            v837, v838, v839 = scf.index_switch v836 : i32, i32, i32 
            case 0 {
            ^block45:
                v890 = arith.constant 4 : u32;
                v446 = hir.bitcast v831 : u32;
                v448 = arith.add v446, v890 : u32 #[overflow = checked];
                v889 = arith.constant 4 : u32;
                v450 = arith.mod v448, v889 : u32;
                hir.assertz v450 #[code = 250];
                v888 = arith.constant 0 : i32;
                v451 = hir.int_to_ptr v448 : ptr<byte, i32>;
                hir.store v451, v888;
                v887 = arith.constant 1 : i32;
                scf.yield v831, v887, v832;
            }
            default {
            ^block97:
                scf.yield v833, v834, v835;
            };
            v525 = hir.bitcast v837 : u32;
            v886 = arith.constant 4 : u32;
            v527 = arith.mod v525, v886 : u32;
            hir.assertz v527 #[code = 250];
            v528 = hir.int_to_ptr v525 : ptr<byte, i32>;
            hir.store v528, v838;
            v885 = arith.constant 16 : i32;
            v533 = arith.add v839, v885 : i32 #[overflow = wrapping];
            v534 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v535 = hir.bitcast v534 : ptr<byte, i32>;
            hir.store v535, v533;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v536: i32, v537: i32, v538: i32) {
        ^block55(v536: i32, v537: i32, v538: i32):
            v540 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v541 = hir.bitcast v540 : ptr<byte, i32>;
            v542 = hir.load v541 : i32;
            v543 = arith.constant 16 : i32;
            v544 = arith.sub v542, v543 : i32 #[overflow = wrapping];
            v545 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v546 = hir.bitcast v545 : ptr<byte, i32>;
            hir.store v546, v544;
            v539 = arith.constant 0 : i32;
            v547 = arith.constant 8 : i32;
            v548 = arith.add v544, v547 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/alloc::alloc::Global::alloc_impl(v548, v537, v538, v539)
            v551 = arith.constant 12 : u32;
            v550 = hir.bitcast v544 : u32;
            v552 = arith.add v550, v551 : u32 #[overflow = checked];
            v553 = arith.constant 4 : u32;
            v554 = arith.mod v552, v553 : u32;
            hir.assertz v554 #[code = 250];
            v555 = hir.int_to_ptr v552 : ptr<byte, i32>;
            v556 = hir.load v555 : i32;
            v558 = arith.constant 8 : u32;
            v557 = hir.bitcast v544 : u32;
            v559 = arith.add v557, v558 : u32 #[overflow = checked];
            v924 = arith.constant 4 : u32;
            v561 = arith.mod v559, v924 : u32;
            hir.assertz v561 #[code = 250];
            v562 = hir.int_to_ptr v559 : ptr<byte, i32>;
            v563 = hir.load v562 : i32;
            v564 = hir.bitcast v536 : u32;
            v923 = arith.constant 4 : u32;
            v566 = arith.mod v564, v923 : u32;
            hir.assertz v566 #[code = 250];
            v567 = hir.int_to_ptr v564 : ptr<byte, i32>;
            hir.store v567, v563;
            v922 = arith.constant 4 : u32;
            v568 = hir.bitcast v536 : u32;
            v570 = arith.add v568, v922 : u32 #[overflow = checked];
            v921 = arith.constant 4 : u32;
            v572 = arith.mod v570, v921 : u32;
            hir.assertz v572 #[code = 250];
            v573 = hir.int_to_ptr v570 : ptr<byte, i32>;
            hir.store v573, v556;
            v920 = arith.constant 16 : i32;
            v575 = arith.add v544, v920 : i32 #[overflow = wrapping];
            v576 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v577 = hir.bitcast v576 : ptr<byte, i32>;
            hir.store v577, v575;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v578: i32, v579: i32, v580: i32, v581: i32) {
        ^block57(v578: i32, v579: i32, v580: i32, v581: i32):
            v940 = arith.constant 0 : i32;
            v582 = arith.constant 0 : i32;
            v583 = arith.eq v580, v582 : i1;
            v584 = arith.zext v583 : u32;
            v585 = hir.bitcast v584 : i32;
            v587 = arith.neq v585, v940 : i1;
            v936 = scf.if v587 : i32 {
            ^block100:
                scf.yield v579;
            } else {
            ^block60:
                v939 = arith.constant 0 : i32;
                v596 = arith.neq v581, v939 : i1;
                v935 = scf.if v596 : i32 {
                ^block61:
                    v598 = hir.exec @root_ns:root@1.0.0/hash_elements/__rustc::__rust_alloc_zeroed(v580, v579) : i32
                    scf.yield v598;
                } else {
                ^block62:
                    v597 = hir.exec @root_ns:root@1.0.0/hash_elements/__rustc::__rust_alloc(v580, v579) : i32
                    scf.yield v597;
                };
                scf.yield v935;
            };
            v602 = arith.constant 4 : u32;
            v601 = hir.bitcast v578 : u32;
            v603 = arith.add v601, v602 : u32 #[overflow = checked];
            v938 = arith.constant 4 : u32;
            v605 = arith.mod v603, v938 : u32;
            hir.assertz v605 #[code = 250];
            v606 = hir.int_to_ptr v603 : ptr<byte, i32>;
            hir.store v606, v580;
            v608 = hir.bitcast v578 : u32;
            v937 = arith.constant 4 : u32;
            v610 = arith.mod v608, v937 : u32;
            hir.assertz v610 #[code = 250];
            v611 = hir.int_to_ptr v608 : ptr<byte, i32>;
            hir.store v611, v936;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v612: i32, v613: i32, v614: i32, v615: i32) {
        ^block63(v612: i32, v613: i32, v614: i32, v615: i32):
            v966 = arith.constant 0 : i32;
            v616 = arith.constant 0 : i32;
            v620 = arith.eq v615, v616 : i1;
            v621 = arith.zext v620 : u32;
            v622 = hir.bitcast v621 : i32;
            v624 = arith.neq v622, v966 : i1;
            v953, v954 = scf.if v624 : i32, i32 {
            ^block104:
                v965 = arith.constant 0 : i32;
                v618 = arith.constant 4 : i32;
                scf.yield v618, v965;
            } else {
            ^block66:
                v625 = hir.bitcast v613 : u32;
                v660 = arith.constant 4 : u32;
                v627 = arith.mod v625, v660 : u32;
                hir.assertz v627 #[code = 250];
                v628 = hir.int_to_ptr v625 : ptr<byte, i32>;
                v629 = hir.load v628 : i32;
                v963 = arith.constant 0 : i32;
                v964 = arith.constant 0 : i32;
                v631 = arith.eq v629, v964 : i1;
                v632 = arith.zext v631 : u32;
                v633 = hir.bitcast v632 : i32;
                v635 = arith.neq v633, v963 : i1;
                v951 = scf.if v635 : i32 {
                ^block103:
                    v962 = arith.constant 0 : i32;
                    scf.yield v962;
                } else {
                ^block67:
                    v961 = arith.constant 4 : u32;
                    v636 = hir.bitcast v612 : u32;
                    v638 = arith.add v636, v961 : u32 #[overflow = checked];
                    v960 = arith.constant 4 : u32;
                    v640 = arith.mod v638, v960 : u32;
                    hir.assertz v640 #[code = 250];
                    v641 = hir.int_to_ptr v638 : ptr<byte, i32>;
                    hir.store v641, v614;
                    v959 = arith.constant 4 : u32;
                    v642 = hir.bitcast v613 : u32;
                    v644 = arith.add v642, v959 : u32 #[overflow = checked];
                    v958 = arith.constant 4 : u32;
                    v646 = arith.mod v644, v958 : u32;
                    hir.assertz v646 #[code = 250];
                    v647 = hir.int_to_ptr v644 : ptr<byte, i32>;
                    v648 = hir.load v647 : i32;
                    v649 = hir.bitcast v612 : u32;
                    v957 = arith.constant 4 : u32;
                    v651 = arith.mod v649, v957 : u32;
                    hir.assertz v651 #[code = 250];
                    v652 = hir.int_to_ptr v649 : ptr<byte, i32>;
                    hir.store v652, v648;
                    v653 = arith.mul v629, v615 : i32 #[overflow = wrapping];
                    scf.yield v653;
                };
                v654 = arith.constant 8 : i32;
                v956 = arith.constant 4 : i32;
                v952 = cf.select v635, v956, v654 : i32;
                scf.yield v952, v951;
            };
            v657 = arith.add v612, v953 : i32 #[overflow = wrapping];
            v659 = hir.bitcast v657 : u32;
            v955 = arith.constant 4 : u32;
            v661 = arith.mod v659, v955 : u32;
            hir.assertz v661 #[code = 250];
            v662 = hir.int_to_ptr v659 : ptr<byte, i32>;
            hir.store v662, v954;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v663: i32, v664: i32, v665: i32) {
        ^block68(v663: i32, v664: i32, v665: i32):
            v968 = arith.constant 0 : i32;
            v666 = arith.constant 0 : i32;
            v667 = arith.eq v665, v666 : i1;
            v668 = arith.zext v667 : u32;
            v669 = hir.bitcast v668 : i32;
            v671 = arith.neq v669, v968 : i1;
            scf.if v671{
            ^block70:
                scf.yield ;
            } else {
            ^block71:
                hir.exec @root_ns:root@1.0.0/hash_elements/__rustc::__rust_dealloc(v663, v665, v664)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v672: i32, v673: i32, v674: i32) {
        ^block72(v672: i32, v673: i32, v674: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v675: i32, v676: i32) -> i32 {
        ^block74(v675: i32, v676: i32):
            v683 = arith.constant 0 : i32;
            v679 = hir.bitcast v676 : u32;
            v678 = hir.bitcast v675 : u32;
            v680 = arith.gt v678, v679 : i1;
            v681 = arith.zext v680 : u32;
            v682 = hir.bitcast v681 : i32;
            v684 = arith.neq v682, v683 : i1;
            v685 = cf.select v684, v675, v676 : i32;
            builtin.ret v685;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.segment readonly @1048576 = 0x0000002a000000d50000003200100000000073722e7365687361682f6f74707972632f62696c6474732f6372732f352e312e302d7379732d62696c6474732d6e6564696d;
    };
};