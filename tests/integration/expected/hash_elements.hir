builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_elements {
        public builtin.function @entrypoint(v0: i32) -> felt {
        ^block4(v0: i32):
            v4 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v5 = hir.bitcast v4 : ptr<byte, i32>;
            v6 = hir.load v5 : i32;
            v7 = arith.constant 48 : i32;
            v8 = arith.sub v6, v7 : i32 #[overflow = wrapping];
            v9 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v10 = hir.bitcast v9 : ptr<byte, i32>;
            hir.store v10, v8;
            v12 = arith.constant 4 : u32;
            v11 = hir.bitcast v0 : u32;
            v13 = arith.add v11, v12 : u32 #[overflow = checked];
            v304 = arith.constant 4 : u32;
            v15 = arith.mod v13, v304 : u32;
            hir.assertz v15 #[code = 250];
            v16 = hir.int_to_ptr v13 : ptr<byte, i32>;
            v17 = hir.load v16 : i32;
            v296 = arith.constant 2 : u32;
            v19 = hir.bitcast v17 : u32;
            v21 = arith.shr v19, v296 : u32;
            v22 = hir.bitcast v21 : i32;
            v23 = arith.constant 3 : i32;
            v24 = arith.band v22, v23 : i32;
            v25 = hir.exec @root_ns:root@1.0.0/hash_elements/intrinsics::felt::from_u32(v24) : felt
            v2 = arith.constant 0 : i32;
            v27 = hir.exec @root_ns:root@1.0.0/hash_elements/intrinsics::felt::from_u32(v2) : felt
            hir.exec @root_ns:root@1.0.0/hash_elements/intrinsics::felt::assert_eq(v25, v27)
            v29 = arith.constant 8 : u32;
            v28 = hir.bitcast v0 : u32;
            v30 = arith.add v28, v29 : u32 #[overflow = checked];
            v303 = arith.constant 4 : u32;
            v32 = arith.mod v30, v303 : u32;
            hir.assertz v32 #[code = 250];
            v33 = hir.int_to_ptr v30 : ptr<byte, i32>;
            v34 = hir.load v33 : i32;
            v35 = arith.constant 16 : i32;
            v36 = arith.add v8, v35 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/std::crypto::hashes::rpo::hash_memory(v22, v34, v36)
            v38 = arith.constant 24 : u32;
            v37 = hir.bitcast v8 : u32;
            v39 = arith.add v37, v38 : u32 #[overflow = checked];
            v302 = arith.constant 8 : u32;
            v41 = arith.mod v39, v302 : u32;
            hir.assertz v41 #[code = 250];
            v42 = hir.int_to_ptr v39 : ptr<byte, i64>;
            v43 = hir.load v42 : i64;
            v45 = arith.constant 40 : u32;
            v44 = hir.bitcast v8 : u32;
            v46 = arith.add v44, v45 : u32 #[overflow = checked];
            v301 = arith.constant 8 : u32;
            v48 = arith.mod v46, v301 : u32;
            hir.assertz v48 #[code = 250];
            v49 = hir.int_to_ptr v46 : ptr<byte, i64>;
            hir.store v49, v43;
            v51 = arith.constant 16 : u32;
            v50 = hir.bitcast v8 : u32;
            v52 = arith.add v50, v51 : u32 #[overflow = checked];
            v300 = arith.constant 8 : u32;
            v54 = arith.mod v52, v300 : u32;
            hir.assertz v54 #[code = 250];
            v55 = hir.int_to_ptr v52 : ptr<byte, i64>;
            v56 = hir.load v55 : i64;
            v58 = arith.constant 32 : u32;
            v57 = hir.bitcast v8 : u32;
            v59 = arith.add v57, v58 : u32 #[overflow = checked];
            v299 = arith.constant 8 : u32;
            v61 = arith.mod v59, v299 : u32;
            hir.assertz v61 #[code = 250];
            v62 = hir.int_to_ptr v59 : ptr<byte, i64>;
            hir.store v62, v56;
            v63 = arith.constant 32 : i32;
            v64 = arith.add v8, v63 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/miden_stdlib_sys::intrinsics::word::Word::reverse(v8, v64)
            v65 = arith.constant 4 : i32;
            hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::RawVecInner<A>::deallocate(v0, v65, v65)
            v67 = hir.bitcast v8 : u32;
            v298 = arith.constant 4 : u32;
            v69 = arith.mod v67, v298 : u32;
            hir.assertz v69 #[code = 250];
            v70 = hir.int_to_ptr v67 : ptr<byte, felt>;
            v71 = hir.load v70 : felt;
            v297 = arith.constant 48 : i32;
            v73 = arith.add v8, v297 : i32 #[overflow = wrapping];
            v74 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v75 = hir.bitcast v74 : ptr<byte, i32>;
            hir.store v75, v73;
            builtin.ret v71;
        };

        private builtin.function @__rustc::__rust_dealloc(v76: i32, v77: i32, v78: i32) {
        ^block6(v76: i32, v77: i32, v78: i32):
            builtin.ret ;
        };

        private builtin.function @miden_stdlib_sys::intrinsics::word::Word::reverse(v79: i32, v80: i32) {
        ^block8(v79: i32, v80: i32):
            v83 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v84 = hir.bitcast v83 : ptr<byte, i32>;
            v85 = hir.load v84 : i32;
            v86 = arith.constant 16 : i32;
            v87 = arith.sub v85, v86 : i32 #[overflow = wrapping];
            v89 = arith.constant 8 : u32;
            v88 = hir.bitcast v80 : u32;
            v90 = arith.add v88, v89 : u32 #[overflow = checked];
            v391 = arith.constant 8 : u32;
            v92 = arith.mod v90, v391 : u32;
            hir.assertz v92 #[code = 250];
            v93 = hir.int_to_ptr v90 : ptr<byte, i64>;
            v94 = hir.load v93 : i64;
            v390 = arith.constant 8 : u32;
            v95 = hir.bitcast v87 : u32;
            v97 = arith.add v95, v390 : u32 #[overflow = checked];
            v98 = arith.constant 4 : u32;
            v99 = arith.mod v97, v98 : u32;
            hir.assertz v99 #[code = 250];
            v100 = hir.int_to_ptr v97 : ptr<byte, i64>;
            hir.store v100, v94;
            v101 = hir.bitcast v80 : u32;
            v389 = arith.constant 8 : u32;
            v103 = arith.mod v101, v389 : u32;
            hir.assertz v103 #[code = 250];
            v104 = hir.int_to_ptr v101 : ptr<byte, i64>;
            v105 = hir.load v104 : i64;
            v106 = hir.bitcast v87 : u32;
            v388 = arith.constant 4 : u32;
            v108 = arith.mod v106, v388 : u32;
            hir.assertz v108 #[code = 250];
            v109 = hir.int_to_ptr v106 : ptr<byte, i64>;
            hir.store v109, v105;
            v110 = arith.constant 12 : i32;
            v111 = arith.add v87, v110 : i32 #[overflow = wrapping];
            v81 = arith.constant 0 : i32;
            v359, v360, v361, v362, v363, v364 = scf.while v81, v87, v111, v79 : i32, i32, i32, i32, i32, i32 {
            ^block44(v365: i32, v366: i32, v367: i32, v368: i32):
                v387 = arith.constant 0 : i32;
                v114 = arith.constant 8 : i32;
                v115 = arith.eq v365, v114 : i1;
                v116 = arith.zext v115 : u32;
                v117 = hir.bitcast v116 : i32;
                v119 = arith.neq v117, v387 : i1;
                v353, v354 = scf.if v119 : i32, i32 {
                ^block43:
                    v313 = ub.poison i32 : i32;
                    scf.yield v313, v313;
                } else {
                ^block13:
                    v121 = arith.add v366, v365 : i32 #[overflow = wrapping];
                    v122 = hir.bitcast v121 : u32;
                    v386 = arith.constant 4 : u32;
                    v124 = arith.mod v122, v386 : u32;
                    hir.assertz v124 #[code = 250];
                    v125 = hir.int_to_ptr v122 : ptr<byte, felt>;
                    v126 = hir.load v125 : felt;
                    v128 = hir.bitcast v367 : u32;
                    v385 = arith.constant 4 : u32;
                    v130 = arith.mod v128, v385 : u32;
                    hir.assertz v130 #[code = 250];
                    v131 = hir.int_to_ptr v128 : ptr<byte, i32>;
                    v132 = hir.load v131 : i32;
                    v133 = hir.bitcast v121 : u32;
                    v384 = arith.constant 4 : u32;
                    v135 = arith.mod v133, v384 : u32;
                    hir.assertz v135 #[code = 250];
                    v136 = hir.int_to_ptr v133 : ptr<byte, i32>;
                    hir.store v136, v132;
                    v137 = hir.bitcast v367 : u32;
                    v383 = arith.constant 4 : u32;
                    v139 = arith.mod v137, v383 : u32;
                    hir.assertz v139 #[code = 250];
                    v140 = hir.int_to_ptr v137 : ptr<byte, felt>;
                    hir.store v140, v126;
                    v143 = arith.constant -4 : i32;
                    v144 = arith.add v367, v143 : i32 #[overflow = wrapping];
                    v141 = arith.constant 4 : i32;
                    v142 = arith.add v365, v141 : i32 #[overflow = wrapping];
                    scf.yield v142, v144;
                };
                v381 = ub.poison i32 : i32;
                v356 = cf.select v119, v381, v368 : i32;
                v382 = ub.poison i32 : i32;
                v355 = cf.select v119, v382, v366 : i32;
                v312 = arith.constant 1 : u32;
                v305 = arith.constant 0 : u32;
                v358 = cf.select v119, v305, v312 : u32;
                v346 = arith.trunc v358 : i1;
                scf.condition v346, v353, v355, v354, v356, v366, v368;
            } do {
            ^block45(v369: i32, v370: i32, v371: i32, v372: i32, v373: i32, v374: i32):
                scf.yield v369, v370, v371, v372;
            };
            v380 = arith.constant 8 : u32;
            v146 = hir.bitcast v363 : u32;
            v148 = arith.add v146, v380 : u32 #[overflow = checked];
            v379 = arith.constant 4 : u32;
            v150 = arith.mod v148, v379 : u32;
            hir.assertz v150 #[code = 250];
            v151 = hir.int_to_ptr v148 : ptr<byte, i64>;
            v152 = hir.load v151 : i64;
            v378 = arith.constant 8 : u32;
            v153 = hir.bitcast v364 : u32;
            v155 = arith.add v153, v378 : u32 #[overflow = checked];
            v377 = arith.constant 8 : u32;
            v157 = arith.mod v155, v377 : u32;
            hir.assertz v157 #[code = 250];
            v158 = hir.int_to_ptr v155 : ptr<byte, i64>;
            hir.store v158, v152;
            v159 = hir.bitcast v363 : u32;
            v376 = arith.constant 4 : u32;
            v161 = arith.mod v159, v376 : u32;
            hir.assertz v161 #[code = 250];
            v162 = hir.int_to_ptr v159 : ptr<byte, i64>;
            v163 = hir.load v162 : i64;
            v164 = hir.bitcast v364 : u32;
            v375 = arith.constant 8 : u32;
            v166 = arith.mod v164, v375 : u32;
            hir.assertz v166 #[code = 250];
            v167 = hir.int_to_ptr v164 : ptr<byte, i64>;
            hir.store v167, v163;
            builtin.ret ;
        };

        private builtin.function @std::crypto::hashes::rpo::hash_memory(v168: i32, v169: i32, v170: i32) {
        ^block14(v168: i32, v169: i32, v170: i32):
            v171, v172, v173, v174 = hir.exec @std/crypto/hashes/rpo/hash_memory(v168, v169) : felt, felt, felt, felt
            v175 = hir.bitcast v170 : u32;
            v176 = hir.int_to_ptr v175 : ptr<byte, felt>;
            hir.store v176, v171;
            v177 = arith.constant 4 : u32;
            v178 = arith.add v175, v177 : u32 #[overflow = checked];
            v179 = hir.int_to_ptr v178 : ptr<byte, felt>;
            hir.store v179, v172;
            v180 = arith.constant 8 : u32;
            v181 = arith.add v175, v180 : u32 #[overflow = checked];
            v182 = hir.int_to_ptr v181 : ptr<byte, felt>;
            hir.store v182, v173;
            v183 = arith.constant 12 : u32;
            v184 = arith.add v175, v183 : u32 #[overflow = checked];
            v185 = hir.int_to_ptr v184 : ptr<byte, felt>;
            hir.store v185, v174;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v186: i32, v187: i32, v188: i32) {
        ^block20(v186: i32, v187: i32, v188: i32):
            v190 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v191 = hir.bitcast v190 : ptr<byte, i32>;
            v192 = hir.load v191 : i32;
            v193 = arith.constant 16 : i32;
            v194 = arith.sub v192, v193 : i32 #[overflow = wrapping];
            v195 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v196 = hir.bitcast v195 : ptr<byte, i32>;
            hir.store v196, v194;
            v197 = arith.constant 4 : i32;
            v198 = arith.add v194, v197 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::RawVecInner<A>::current_memory(v198, v186, v187, v188)
            v200 = arith.constant 8 : u32;
            v199 = hir.bitcast v194 : u32;
            v201 = arith.add v199, v200 : u32 #[overflow = checked];
            v202 = arith.constant 4 : u32;
            v203 = arith.mod v201, v202 : u32;
            hir.assertz v203 #[code = 250];
            v204 = hir.int_to_ptr v201 : ptr<byte, i32>;
            v205 = hir.load v204 : i32;
            v398 = arith.constant 0 : i32;
            v189 = arith.constant 0 : i32;
            v207 = arith.eq v205, v189 : i1;
            v208 = arith.zext v207 : u32;
            v209 = hir.bitcast v208 : i32;
            v211 = arith.neq v209, v398 : i1;
            scf.if v211{
            ^block46:
                scf.yield ;
            } else {
            ^block23:
                v397 = arith.constant 4 : u32;
                v212 = hir.bitcast v194 : u32;
                v214 = arith.add v212, v397 : u32 #[overflow = checked];
                v396 = arith.constant 4 : u32;
                v216 = arith.mod v214, v396 : u32;
                hir.assertz v216 #[code = 250];
                v217 = hir.int_to_ptr v214 : ptr<byte, i32>;
                v218 = hir.load v217 : i32;
                v220 = arith.constant 12 : u32;
                v219 = hir.bitcast v194 : u32;
                v221 = arith.add v219, v220 : u32 #[overflow = checked];
                v395 = arith.constant 4 : u32;
                v223 = arith.mod v221, v395 : u32;
                hir.assertz v223 #[code = 250];
                v224 = hir.int_to_ptr v221 : ptr<byte, i32>;
                v225 = hir.load v224 : i32;
                hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v218, v205, v225)
                scf.yield ;
            };
            v394 = arith.constant 16 : i32;
            v228 = arith.add v194, v394 : i32 #[overflow = wrapping];
            v229 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v230 = hir.bitcast v229 : ptr<byte, i32>;
            hir.store v230, v228;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v231: i32, v232: i32, v233: i32, v234: i32) {
        ^block24(v231: i32, v232: i32, v233: i32, v234: i32):
            v424 = arith.constant 0 : i32;
            v235 = arith.constant 0 : i32;
            v239 = arith.eq v234, v235 : i1;
            v240 = arith.zext v239 : u32;
            v241 = hir.bitcast v240 : i32;
            v243 = arith.neq v241, v424 : i1;
            v411, v412 = scf.if v243 : i32, i32 {
            ^block49:
                v423 = arith.constant 0 : i32;
                v237 = arith.constant 4 : i32;
                scf.yield v237, v423;
            } else {
            ^block27:
                v244 = hir.bitcast v232 : u32;
                v279 = arith.constant 4 : u32;
                v246 = arith.mod v244, v279 : u32;
                hir.assertz v246 #[code = 250];
                v247 = hir.int_to_ptr v244 : ptr<byte, i32>;
                v248 = hir.load v247 : i32;
                v421 = arith.constant 0 : i32;
                v422 = arith.constant 0 : i32;
                v250 = arith.eq v248, v422 : i1;
                v251 = arith.zext v250 : u32;
                v252 = hir.bitcast v251 : i32;
                v254 = arith.neq v252, v421 : i1;
                v409 = scf.if v254 : i32 {
                ^block48:
                    v420 = arith.constant 0 : i32;
                    scf.yield v420;
                } else {
                ^block28:
                    v419 = arith.constant 4 : u32;
                    v255 = hir.bitcast v231 : u32;
                    v257 = arith.add v255, v419 : u32 #[overflow = checked];
                    v418 = arith.constant 4 : u32;
                    v259 = arith.mod v257, v418 : u32;
                    hir.assertz v259 #[code = 250];
                    v260 = hir.int_to_ptr v257 : ptr<byte, i32>;
                    hir.store v260, v233;
                    v417 = arith.constant 4 : u32;
                    v261 = hir.bitcast v232 : u32;
                    v263 = arith.add v261, v417 : u32 #[overflow = checked];
                    v416 = arith.constant 4 : u32;
                    v265 = arith.mod v263, v416 : u32;
                    hir.assertz v265 #[code = 250];
                    v266 = hir.int_to_ptr v263 : ptr<byte, i32>;
                    v267 = hir.load v266 : i32;
                    v268 = hir.bitcast v231 : u32;
                    v415 = arith.constant 4 : u32;
                    v270 = arith.mod v268, v415 : u32;
                    hir.assertz v270 #[code = 250];
                    v271 = hir.int_to_ptr v268 : ptr<byte, i32>;
                    hir.store v271, v267;
                    v272 = arith.mul v248, v234 : i32 #[overflow = wrapping];
                    scf.yield v272;
                };
                v273 = arith.constant 8 : i32;
                v414 = arith.constant 4 : i32;
                v410 = cf.select v254, v414, v273 : i32;
                scf.yield v410, v409;
            };
            v276 = arith.add v231, v411 : i32 #[overflow = wrapping];
            v278 = hir.bitcast v276 : u32;
            v413 = arith.constant 4 : u32;
            v280 = arith.mod v278, v413 : u32;
            hir.assertz v280 #[code = 250];
            v281 = hir.int_to_ptr v278 : ptr<byte, i32>;
            hir.store v281, v412;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v282: i32, v283: i32, v284: i32) {
        ^block29(v282: i32, v283: i32, v284: i32):
            v426 = arith.constant 0 : i32;
            v285 = arith.constant 0 : i32;
            v286 = arith.eq v284, v285 : i1;
            v287 = arith.zext v286 : u32;
            v288 = hir.bitcast v287 : i32;
            v290 = arith.neq v288, v426 : i1;
            scf.if v290{
            ^block31:
                scf.yield ;
            } else {
            ^block32:
                hir.exec @root_ns:root@1.0.0/hash_elements/__rustc::__rust_dealloc(v282, v284, v283)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @intrinsics::felt::from_u32(v291: i32) -> felt {
        ^block33(v291: i32):
            v292 = hir.bitcast v291 : felt;
            builtin.ret v292;
        };

        private builtin.function @intrinsics::felt::assert_eq(v294: felt, v295: felt) {
        ^block35(v294: felt, v295: felt):
            hir.assert_eq v294, v295;
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};