builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_elements {
        private builtin.function @miden_stdlib_sys::stdlib::crypto::hashes::extern_hash_memory(v0: i32, v1: i32, v2: i32) {
        ^block3(v0: i32, v1: i32, v2: i32):
            v3, v4, v5, v6 = hir.exec @std/crypto/hashes/rpo/hash_memory(v0, v1) : felt, felt, felt, felt
            v7 = hir.bitcast v2 : u32;
            v8 = hir.int_to_ptr v7 : ptr<byte, felt>;
            hir.store v8, v3;
            v9 = arith.constant 4 : u32;
            v10 = arith.add v7, v9 : u32 #[overflow = checked];
            v11 = hir.int_to_ptr v10 : ptr<byte, felt>;
            hir.store v11, v4;
            v12 = arith.constant 8 : u32;
            v13 = arith.add v7, v12 : u32 #[overflow = checked];
            v14 = hir.int_to_ptr v13 : ptr<byte, felt>;
            hir.store v14, v5;
            v15 = arith.constant 12 : u32;
            v16 = arith.add v7, v15 : u32 #[overflow = checked];
            v17 = hir.int_to_ptr v16 : ptr<byte, felt>;
            hir.store v17, v6;
            builtin.ret ;
        };

        public builtin.function @entrypoint(v18: i32) -> felt {
        ^block10(v18: i32):
            v22 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v23 = hir.bitcast v22 : ptr<byte, i32>;
            v24 = hir.load v23 : i32;
            v25 = arith.constant 48 : i32;
            v26 = arith.sub v24, v25 : i32 #[overflow = wrapping];
            v27 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v28 = hir.bitcast v27 : ptr<byte, i32>;
            hir.store v28, v26;
            v30 = arith.constant 4 : u32;
            v29 = hir.bitcast v18 : u32;
            v31 = arith.add v29, v30 : u32 #[overflow = checked];
            v300 = arith.constant 4 : u32;
            v33 = arith.mod v31, v300 : u32;
            hir.assertz v33 #[code = 250];
            v34 = hir.int_to_ptr v31 : ptr<byte, i32>;
            v35 = hir.load v34 : i32;
            v292 = arith.constant 2 : u32;
            v37 = hir.bitcast v35 : u32;
            v39 = arith.shr v37, v292 : u32;
            v40 = hir.bitcast v39 : i32;
            v291 = arith.constant 0 : felt;
            v41 = arith.constant 3 : i32;
            v42 = arith.band v40, v41 : i32;
            v43 = hir.bitcast v42 : felt;
            hir.assert_eq v43, v291;
            v47 = arith.constant 8 : u32;
            v46 = hir.bitcast v18 : u32;
            v48 = arith.add v46, v47 : u32 #[overflow = checked];
            v299 = arith.constant 4 : u32;
            v50 = arith.mod v48, v299 : u32;
            hir.assertz v50 #[code = 250];
            v51 = hir.int_to_ptr v48 : ptr<byte, i32>;
            v52 = hir.load v51 : i32;
            v53 = arith.constant 16 : i32;
            v54 = arith.add v26, v53 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/miden_stdlib_sys::stdlib::crypto::hashes::extern_hash_memory(v40, v52, v54)
            v56 = arith.constant 24 : u32;
            v55 = hir.bitcast v26 : u32;
            v57 = arith.add v55, v56 : u32 #[overflow = checked];
            v298 = arith.constant 8 : u32;
            v59 = arith.mod v57, v298 : u32;
            hir.assertz v59 #[code = 250];
            v60 = hir.int_to_ptr v57 : ptr<byte, i64>;
            v61 = hir.load v60 : i64;
            v63 = arith.constant 40 : u32;
            v62 = hir.bitcast v26 : u32;
            v64 = arith.add v62, v63 : u32 #[overflow = checked];
            v297 = arith.constant 8 : u32;
            v66 = arith.mod v64, v297 : u32;
            hir.assertz v66 #[code = 250];
            v67 = hir.int_to_ptr v64 : ptr<byte, i64>;
            hir.store v67, v61;
            v69 = arith.constant 16 : u32;
            v68 = hir.bitcast v26 : u32;
            v70 = arith.add v68, v69 : u32 #[overflow = checked];
            v296 = arith.constant 8 : u32;
            v72 = arith.mod v70, v296 : u32;
            hir.assertz v72 #[code = 250];
            v73 = hir.int_to_ptr v70 : ptr<byte, i64>;
            v74 = hir.load v73 : i64;
            v76 = arith.constant 32 : u32;
            v75 = hir.bitcast v26 : u32;
            v77 = arith.add v75, v76 : u32 #[overflow = checked];
            v295 = arith.constant 8 : u32;
            v79 = arith.mod v77, v295 : u32;
            hir.assertz v79 #[code = 250];
            v80 = hir.int_to_ptr v77 : ptr<byte, i64>;
            hir.store v80, v74;
            v81 = arith.constant 32 : i32;
            v82 = arith.add v26, v81 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/miden_stdlib_sys::intrinsics::word::Word::reverse(v26, v82)
            v83 = arith.constant 4 : i32;
            hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::RawVecInner<A>::deallocate(v18, v83, v83)
            v85 = hir.bitcast v26 : u32;
            v294 = arith.constant 4 : u32;
            v87 = arith.mod v85, v294 : u32;
            hir.assertz v87 #[code = 250];
            v88 = hir.int_to_ptr v85 : ptr<byte, felt>;
            v89 = hir.load v88 : felt;
            v293 = arith.constant 48 : i32;
            v91 = arith.add v26, v293 : i32 #[overflow = wrapping];
            v92 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v93 = hir.bitcast v92 : ptr<byte, i32>;
            hir.store v93, v91;
            builtin.ret v89;
        };

        private builtin.function @__rustc::__rust_dealloc(v94: i32, v95: i32, v96: i32) {
        ^block12(v94: i32, v95: i32, v96: i32):
            builtin.ret ;
        };

        private builtin.function @miden_stdlib_sys::intrinsics::word::Word::reverse(v97: i32, v98: i32) {
        ^block14(v97: i32, v98: i32):
            v101 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v102 = hir.bitcast v101 : ptr<byte, i32>;
            v103 = hir.load v102 : i32;
            v104 = arith.constant 16 : i32;
            v105 = arith.sub v103, v104 : i32 #[overflow = wrapping];
            v107 = arith.constant 8 : u32;
            v106 = hir.bitcast v98 : u32;
            v108 = arith.add v106, v107 : u32 #[overflow = checked];
            v387 = arith.constant 8 : u32;
            v110 = arith.mod v108, v387 : u32;
            hir.assertz v110 #[code = 250];
            v111 = hir.int_to_ptr v108 : ptr<byte, i64>;
            v112 = hir.load v111 : i64;
            v386 = arith.constant 8 : u32;
            v113 = hir.bitcast v105 : u32;
            v115 = arith.add v113, v386 : u32 #[overflow = checked];
            v116 = arith.constant 4 : u32;
            v117 = arith.mod v115, v116 : u32;
            hir.assertz v117 #[code = 250];
            v118 = hir.int_to_ptr v115 : ptr<byte, i64>;
            hir.store v118, v112;
            v119 = hir.bitcast v98 : u32;
            v385 = arith.constant 8 : u32;
            v121 = arith.mod v119, v385 : u32;
            hir.assertz v121 #[code = 250];
            v122 = hir.int_to_ptr v119 : ptr<byte, i64>;
            v123 = hir.load v122 : i64;
            v124 = hir.bitcast v105 : u32;
            v384 = arith.constant 4 : u32;
            v126 = arith.mod v124, v384 : u32;
            hir.assertz v126 #[code = 250];
            v127 = hir.int_to_ptr v124 : ptr<byte, i64>;
            hir.store v127, v123;
            v128 = arith.constant 12 : i32;
            v129 = arith.add v105, v128 : i32 #[overflow = wrapping];
            v99 = arith.constant 0 : i32;
            v355, v356, v357, v358, v359, v360 = scf.while v99, v105, v129, v97 : i32, i32, i32, i32, i32, i32 {
            ^block40(v361: i32, v362: i32, v363: i32, v364: i32):
                v383 = arith.constant 0 : i32;
                v132 = arith.constant 8 : i32;
                v133 = arith.eq v361, v132 : i1;
                v134 = arith.zext v133 : u32;
                v135 = hir.bitcast v134 : i32;
                v137 = arith.neq v135, v383 : i1;
                v349, v350 = scf.if v137 : i32, i32 {
                ^block39:
                    v309 = ub.poison i32 : i32;
                    scf.yield v309, v309;
                } else {
                ^block19:
                    v139 = arith.add v362, v361 : i32 #[overflow = wrapping];
                    v140 = hir.bitcast v139 : u32;
                    v382 = arith.constant 4 : u32;
                    v142 = arith.mod v140, v382 : u32;
                    hir.assertz v142 #[code = 250];
                    v143 = hir.int_to_ptr v140 : ptr<byte, felt>;
                    v144 = hir.load v143 : felt;
                    v146 = hir.bitcast v363 : u32;
                    v381 = arith.constant 4 : u32;
                    v148 = arith.mod v146, v381 : u32;
                    hir.assertz v148 #[code = 250];
                    v149 = hir.int_to_ptr v146 : ptr<byte, i32>;
                    v150 = hir.load v149 : i32;
                    v151 = hir.bitcast v139 : u32;
                    v380 = arith.constant 4 : u32;
                    v153 = arith.mod v151, v380 : u32;
                    hir.assertz v153 #[code = 250];
                    v154 = hir.int_to_ptr v151 : ptr<byte, i32>;
                    hir.store v154, v150;
                    v155 = hir.bitcast v363 : u32;
                    v379 = arith.constant 4 : u32;
                    v157 = arith.mod v155, v379 : u32;
                    hir.assertz v157 #[code = 250];
                    v158 = hir.int_to_ptr v155 : ptr<byte, felt>;
                    hir.store v158, v144;
                    v161 = arith.constant -4 : i32;
                    v162 = arith.add v363, v161 : i32 #[overflow = wrapping];
                    v159 = arith.constant 4 : i32;
                    v160 = arith.add v361, v159 : i32 #[overflow = wrapping];
                    scf.yield v160, v162;
                };
                v377 = ub.poison i32 : i32;
                v352 = cf.select v137, v377, v364 : i32;
                v378 = ub.poison i32 : i32;
                v351 = cf.select v137, v378, v362 : i32;
                v308 = arith.constant 1 : u32;
                v301 = arith.constant 0 : u32;
                v354 = cf.select v137, v301, v308 : u32;
                v342 = arith.trunc v354 : i1;
                scf.condition v342, v349, v351, v350, v352, v362, v364;
            } do {
            ^block41(v365: i32, v366: i32, v367: i32, v368: i32, v369: i32, v370: i32):
                scf.yield v365, v366, v367, v368;
            };
            v376 = arith.constant 8 : u32;
            v164 = hir.bitcast v359 : u32;
            v166 = arith.add v164, v376 : u32 #[overflow = checked];
            v375 = arith.constant 4 : u32;
            v168 = arith.mod v166, v375 : u32;
            hir.assertz v168 #[code = 250];
            v169 = hir.int_to_ptr v166 : ptr<byte, i64>;
            v170 = hir.load v169 : i64;
            v374 = arith.constant 8 : u32;
            v171 = hir.bitcast v360 : u32;
            v173 = arith.add v171, v374 : u32 #[overflow = checked];
            v373 = arith.constant 8 : u32;
            v175 = arith.mod v173, v373 : u32;
            hir.assertz v175 #[code = 250];
            v176 = hir.int_to_ptr v173 : ptr<byte, i64>;
            hir.store v176, v170;
            v177 = hir.bitcast v359 : u32;
            v372 = arith.constant 4 : u32;
            v179 = arith.mod v177, v372 : u32;
            hir.assertz v179 #[code = 250];
            v180 = hir.int_to_ptr v177 : ptr<byte, i64>;
            v181 = hir.load v180 : i64;
            v182 = hir.bitcast v360 : u32;
            v371 = arith.constant 8 : u32;
            v184 = arith.mod v182, v371 : u32;
            hir.assertz v184 #[code = 250];
            v185 = hir.int_to_ptr v182 : ptr<byte, i64>;
            hir.store v185, v181;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v186: i32, v187: i32, v188: i32) {
        ^block20(v186: i32, v187: i32, v188: i32):
            v190 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v191 = hir.bitcast v190 : ptr<byte, i32>;
            v192 = hir.load v191 : i32;
            v193 = arith.constant 16 : i32;
            v194 = arith.sub v192, v193 : i32 #[overflow = wrapping];
            v195 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v196 = hir.bitcast v195 : ptr<byte, i32>;
            hir.store v196, v194;
            v197 = arith.constant 4 : i32;
            v198 = arith.add v194, v197 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::RawVecInner<A>::current_memory(v198, v186, v187, v188)
            v200 = arith.constant 8 : u32;
            v199 = hir.bitcast v194 : u32;
            v201 = arith.add v199, v200 : u32 #[overflow = checked];
            v202 = arith.constant 4 : u32;
            v203 = arith.mod v201, v202 : u32;
            hir.assertz v203 #[code = 250];
            v204 = hir.int_to_ptr v201 : ptr<byte, i32>;
            v205 = hir.load v204 : i32;
            v394 = arith.constant 0 : i32;
            v189 = arith.constant 0 : i32;
            v207 = arith.eq v205, v189 : i1;
            v208 = arith.zext v207 : u32;
            v209 = hir.bitcast v208 : i32;
            v211 = arith.neq v209, v394 : i1;
            scf.if v211{
            ^block42:
                scf.yield ;
            } else {
            ^block23:
                v393 = arith.constant 4 : u32;
                v212 = hir.bitcast v194 : u32;
                v214 = arith.add v212, v393 : u32 #[overflow = checked];
                v392 = arith.constant 4 : u32;
                v216 = arith.mod v214, v392 : u32;
                hir.assertz v216 #[code = 250];
                v217 = hir.int_to_ptr v214 : ptr<byte, i32>;
                v218 = hir.load v217 : i32;
                v220 = arith.constant 12 : u32;
                v219 = hir.bitcast v194 : u32;
                v221 = arith.add v219, v220 : u32 #[overflow = checked];
                v391 = arith.constant 4 : u32;
                v223 = arith.mod v221, v391 : u32;
                hir.assertz v223 #[code = 250];
                v224 = hir.int_to_ptr v221 : ptr<byte, i32>;
                v225 = hir.load v224 : i32;
                hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v218, v205, v225)
                scf.yield ;
            };
            v390 = arith.constant 16 : i32;
            v228 = arith.add v194, v390 : i32 #[overflow = wrapping];
            v229 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v230 = hir.bitcast v229 : ptr<byte, i32>;
            hir.store v230, v228;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v231: i32, v232: i32, v233: i32, v234: i32) {
        ^block24(v231: i32, v232: i32, v233: i32, v234: i32):
            v420 = arith.constant 0 : i32;
            v235 = arith.constant 0 : i32;
            v239 = arith.eq v234, v235 : i1;
            v240 = arith.zext v239 : u32;
            v241 = hir.bitcast v240 : i32;
            v243 = arith.neq v241, v420 : i1;
            v407, v408 = scf.if v243 : i32, i32 {
            ^block45:
                v419 = arith.constant 0 : i32;
                v237 = arith.constant 4 : i32;
                scf.yield v237, v419;
            } else {
            ^block27:
                v244 = hir.bitcast v232 : u32;
                v279 = arith.constant 4 : u32;
                v246 = arith.mod v244, v279 : u32;
                hir.assertz v246 #[code = 250];
                v247 = hir.int_to_ptr v244 : ptr<byte, i32>;
                v248 = hir.load v247 : i32;
                v417 = arith.constant 0 : i32;
                v418 = arith.constant 0 : i32;
                v250 = arith.eq v248, v418 : i1;
                v251 = arith.zext v250 : u32;
                v252 = hir.bitcast v251 : i32;
                v254 = arith.neq v252, v417 : i1;
                v405 = scf.if v254 : i32 {
                ^block44:
                    v416 = arith.constant 0 : i32;
                    scf.yield v416;
                } else {
                ^block28:
                    v415 = arith.constant 4 : u32;
                    v255 = hir.bitcast v231 : u32;
                    v257 = arith.add v255, v415 : u32 #[overflow = checked];
                    v414 = arith.constant 4 : u32;
                    v259 = arith.mod v257, v414 : u32;
                    hir.assertz v259 #[code = 250];
                    v260 = hir.int_to_ptr v257 : ptr<byte, i32>;
                    hir.store v260, v233;
                    v413 = arith.constant 4 : u32;
                    v261 = hir.bitcast v232 : u32;
                    v263 = arith.add v261, v413 : u32 #[overflow = checked];
                    v412 = arith.constant 4 : u32;
                    v265 = arith.mod v263, v412 : u32;
                    hir.assertz v265 #[code = 250];
                    v266 = hir.int_to_ptr v263 : ptr<byte, i32>;
                    v267 = hir.load v266 : i32;
                    v268 = hir.bitcast v231 : u32;
                    v411 = arith.constant 4 : u32;
                    v270 = arith.mod v268, v411 : u32;
                    hir.assertz v270 #[code = 250];
                    v271 = hir.int_to_ptr v268 : ptr<byte, i32>;
                    hir.store v271, v267;
                    v272 = arith.mul v248, v234 : i32 #[overflow = wrapping];
                    scf.yield v272;
                };
                v273 = arith.constant 8 : i32;
                v410 = arith.constant 4 : i32;
                v406 = cf.select v254, v410, v273 : i32;
                scf.yield v406, v405;
            };
            v276 = arith.add v231, v407 : i32 #[overflow = wrapping];
            v278 = hir.bitcast v276 : u32;
            v409 = arith.constant 4 : u32;
            v280 = arith.mod v278, v409 : u32;
            hir.assertz v280 #[code = 250];
            v281 = hir.int_to_ptr v278 : ptr<byte, i32>;
            hir.store v281, v408;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v282: i32, v283: i32, v284: i32) {
        ^block29(v282: i32, v283: i32, v284: i32):
            v422 = arith.constant 0 : i32;
            v285 = arith.constant 0 : i32;
            v286 = arith.eq v284, v285 : i1;
            v287 = arith.zext v286 : u32;
            v288 = hir.bitcast v287 : i32;
            v290 = arith.neq v288, v422 : i1;
            scf.if v290{
            ^block31:
                scf.yield ;
            } else {
            ^block32:
                hir.exec @root_ns:root@1.0.0/hash_elements/__rustc::__rust_dealloc(v282, v284, v283)
                scf.yield ;
            };
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};