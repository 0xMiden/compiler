builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_elements {
        private builtin.function @__rustc::__rust_dealloc(v0: i32, v1: i32, v2: i32) {
        ^block4(v0: i32, v1: i32, v2: i32):
            builtin.ret ;
        };

        public builtin.function @entrypoint(v3: i32) -> felt {
        ^block6(v3: i32):
            v7 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v8 = hir.bitcast v7 : ptr<byte, i32>;
            v9 = hir.load v8 : i32;
            v212 = arith.constant 16 : i32;
            v11 = arith.sub v9, v212 : i32 #[overflow = wrapping];
            v12 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v13 = hir.bitcast v12 : ptr<byte, i32>;
            hir.store v13, v11;
            v14 = hir.bitcast v3 : u32;
            v211 = arith.constant 8 : u32;
            v16 = arith.add v14, v211 : u32 #[overflow = checked];
            v210 = arith.constant 4 : u32;
            v18 = arith.mod v16, v210 : u32;
            hir.assertz v18 #[code = 250];
            v19 = hir.int_to_ptr v16 : ptr<byte, i32>;
            v20 = hir.load v19 : i32;
            v229 = arith.constant 4 : u32;
            v23 = arith.add v14, v229 : u32 #[overflow = checked];
            v228 = arith.constant 4 : u32;
            v25 = arith.mod v23, v228 : u32;
            hir.assertz v25 #[code = 250];
            v26 = hir.int_to_ptr v23 : ptr<byte, i32>;
            v27 = hir.load v26 : i32;
            v206 = arith.constant 2 : u32;
            v29 = hir.bitcast v27 : u32;
            v31 = arith.shr v29, v206 : u32;
            v32 = hir.bitcast v31 : i32;
            v205 = arith.constant 0 : felt;
            v209 = arith.constant 3 : i32;
            v34 = arith.band v32, v209 : i32;
            v35 = hir.bitcast v34 : felt;
            hir.assert_eq v35, v205;
            v226 = arith.constant 0 : i32;
            v216 = arith.constant 0 : i32;
            v227 = arith.constant 3 : i32;
            v39 = arith.band v20, v227 : i32;
            v41 = arith.eq v39, v216 : i1;
            v42 = arith.zext v41 : u32;
            v43 = hir.bitcast v42 : i32;
            v45 = arith.neq v43, v226 : i1;
            scf.if v45{
            ^block9:
                v46 = arith.add v32, v20 : i32 #[overflow = wrapping];
                hir.exec @root_ns:root@1.0.0/hash_elements/miden::core::crypto::hashes::rpo256::hash_words(v32, v46, v11)
                scf.yield ;
            } else {
            ^block10:
                hir.exec @root_ns:root@1.0.0/hash_elements/miden::core::crypto::hashes::rpo256::hash_elements(v32, v20, v11)
                scf.yield ;
            };
            v208 = arith.constant 12 : u32;
            v48 = hir.bitcast v11 : u32;
            v50 = arith.add v48, v208 : u32 #[overflow = checked];
            v225 = arith.constant 4 : u32;
            v52 = arith.mod v50, v225 : u32;
            hir.assertz v52 #[code = 250];
            v53 = hir.int_to_ptr v50 : ptr<byte, felt>;
            v54 = hir.load v53 : felt;
            v207 = arith.constant 4 : i32;
            hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::raw_vec::RawVecInner>::deallocate(v3, v207, v207)
            v224 = arith.constant 16 : i32;
            v59 = arith.add v11, v224 : i32 #[overflow = wrapping];
            v60 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v61 = hir.bitcast v60 : ptr<byte, i32>;
            hir.store v61, v59;
            builtin.ret v54;
        };

        private builtin.function @miden::core::crypto::hashes::rpo256::hash_elements(v62: i32, v63: i32, v64: i32) {
        ^block11(v62: i32, v63: i32, v64: i32):
            v65, v66, v67, v68 = hir.exec @miden/core/crypto/hashes/rpo256/hash_elements(v62, v63) : felt, felt, felt, felt
            v69 = hir.bitcast v64 : u32;
            v70 = hir.int_to_ptr v69 : ptr<byte, felt>;
            hir.store v70, v65;
            v232 = arith.constant 4 : u32;
            v72 = arith.add v69, v232 : u32 #[overflow = checked];
            v73 = hir.int_to_ptr v72 : ptr<byte, felt>;
            hir.store v73, v66;
            v231 = arith.constant 8 : u32;
            v75 = arith.add v69, v231 : u32 #[overflow = checked];
            v76 = hir.int_to_ptr v75 : ptr<byte, felt>;
            hir.store v76, v67;
            v230 = arith.constant 12 : u32;
            v78 = arith.add v69, v230 : u32 #[overflow = checked];
            v79 = hir.int_to_ptr v78 : ptr<byte, felt>;
            hir.store v79, v68;
            builtin.ret ;
        };

        private builtin.function @miden::core::crypto::hashes::rpo256::hash_words(v80: i32, v81: i32, v82: i32) {
        ^block18(v80: i32, v81: i32, v82: i32):
            v83, v84, v85, v86 = hir.exec @miden/core/crypto/hashes/rpo256/hash_words(v80, v81) : felt, felt, felt, felt
            v87 = hir.bitcast v82 : u32;
            v88 = hir.int_to_ptr v87 : ptr<byte, felt>;
            hir.store v88, v83;
            v235 = arith.constant 4 : u32;
            v90 = arith.add v87, v235 : u32 #[overflow = checked];
            v91 = hir.int_to_ptr v90 : ptr<byte, felt>;
            hir.store v91, v84;
            v234 = arith.constant 8 : u32;
            v93 = arith.add v87, v234 : u32 #[overflow = checked];
            v94 = hir.int_to_ptr v93 : ptr<byte, felt>;
            hir.store v94, v85;
            v233 = arith.constant 12 : u32;
            v96 = arith.add v87, v233 : u32 #[overflow = checked];
            v97 = hir.int_to_ptr v96 : ptr<byte, felt>;
            hir.store v97, v86;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::deallocate(v98: i32, v99: i32, v100: i32) {
        ^block20(v98: i32, v99: i32, v100: i32):
            v102 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v103 = hir.bitcast v102 : ptr<byte, i32>;
            v104 = hir.load v103 : i32;
            v240 = arith.constant 16 : i32;
            v106 = arith.sub v104, v240 : i32 #[overflow = wrapping];
            v107 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v108 = hir.bitcast v107 : ptr<byte, i32>;
            hir.store v108, v106;
            v239 = arith.constant 4 : i32;
            v110 = arith.add v106, v239 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::raw_vec::RawVecInner>::current_memory(v110, v98, v99, v100)
            v111 = hir.bitcast v106 : u32;
            v238 = arith.constant 8 : u32;
            v113 = arith.add v111, v238 : u32 #[overflow = checked];
            v237 = arith.constant 4 : u32;
            v115 = arith.mod v113, v237 : u32;
            hir.assertz v115 #[code = 250];
            v116 = hir.int_to_ptr v113 : ptr<byte, i32>;
            v117 = hir.load v116 : i32;
            v253 = arith.constant 0 : i32;
            v246 = arith.constant 0 : i32;
            v119 = arith.eq v117, v246 : i1;
            v120 = arith.zext v119 : u32;
            v121 = hir.bitcast v120 : i32;
            v123 = arith.neq v121, v253 : i1;
            scf.if v123{
            ^block34:
                scf.yield ;
            } else {
            ^block23:
                v252 = arith.constant 4 : u32;
                v126 = arith.add v111, v252 : u32 #[overflow = checked];
                v251 = arith.constant 4 : u32;
                v128 = arith.mod v126, v251 : u32;
                hir.assertz v128 #[code = 250];
                v129 = hir.int_to_ptr v126 : ptr<byte, i32>;
                v130 = hir.load v129 : i32;
                v236 = arith.constant 12 : u32;
                v133 = arith.add v111, v236 : u32 #[overflow = checked];
                v250 = arith.constant 4 : u32;
                v135 = arith.mod v133, v250 : u32;
                hir.assertz v135 #[code = 250];
                v136 = hir.int_to_ptr v133 : ptr<byte, i32>;
                v137 = hir.load v136 : i32;
                hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v130, v117, v137)
                scf.yield ;
            };
            v249 = arith.constant 16 : i32;
            v140 = arith.add v106, v249 : i32 #[overflow = wrapping];
            v141 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v142 = hir.bitcast v141 : ptr<byte, i32>;
            hir.store v142, v140;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::current_memory(v143: i32, v144: i32, v145: i32, v146: i32) {
        ^block24(v143: i32, v144: i32, v145: i32, v146: i32):
            v295 = arith.constant 0 : i32;
            v269 = arith.constant 0 : i32;
            v151 = arith.eq v146, v269 : i1;
            v152 = arith.zext v151 : u32;
            v153 = hir.bitcast v152 : i32;
            v155 = arith.neq v153, v295 : i1;
            v282, v283 = scf.if v155 : i32, i32 {
            ^block37:
                v294 = arith.constant 0 : i32;
                v267 = arith.constant 4 : i32;
                scf.yield v267, v294;
            } else {
            ^block27:
                v156 = hir.bitcast v144 : u32;
                v265 = arith.constant 4 : u32;
                v158 = arith.mod v156, v265 : u32;
                hir.assertz v158 #[code = 250];
                v159 = hir.int_to_ptr v156 : ptr<byte, i32>;
                v160 = hir.load v159 : i32;
                v292 = arith.constant 0 : i32;
                v293 = arith.constant 0 : i32;
                v162 = arith.eq v160, v293 : i1;
                v163 = arith.zext v162 : u32;
                v164 = hir.bitcast v163 : i32;
                v166 = arith.neq v164, v292 : i1;
                v280 = scf.if v166 : i32 {
                ^block36:
                    v291 = arith.constant 0 : i32;
                    scf.yield v291;
                } else {
                ^block28:
                    v167 = hir.bitcast v143 : u32;
                    v290 = arith.constant 4 : u32;
                    v169 = arith.add v167, v290 : u32 #[overflow = checked];
                    v289 = arith.constant 4 : u32;
                    v171 = arith.mod v169, v289 : u32;
                    hir.assertz v171 #[code = 250];
                    v172 = hir.int_to_ptr v169 : ptr<byte, i32>;
                    hir.store v172, v145;
                    v288 = arith.constant 4 : u32;
                    v175 = arith.add v156, v288 : u32 #[overflow = checked];
                    v287 = arith.constant 4 : u32;
                    v177 = arith.mod v175, v287 : u32;
                    hir.assertz v177 #[code = 250];
                    v178 = hir.int_to_ptr v175 : ptr<byte, i32>;
                    v179 = hir.load v178 : i32;
                    v286 = arith.constant 4 : u32;
                    v182 = arith.mod v167, v286 : u32;
                    hir.assertz v182 #[code = 250];
                    v183 = hir.int_to_ptr v167 : ptr<byte, i32>;
                    hir.store v183, v179;
                    v184 = arith.mul v160, v146 : i32 #[overflow = wrapping];
                    scf.yield v184;
                };
                v254 = arith.constant 8 : i32;
                v285 = arith.constant 4 : i32;
                v281 = cf.select v166, v285, v254 : i32;
                scf.yield v281, v280;
            };
            v188 = arith.add v143, v282 : i32 #[overflow = wrapping];
            v190 = hir.bitcast v188 : u32;
            v284 = arith.constant 4 : u32;
            v192 = arith.mod v190, v284 : u32;
            hir.assertz v192 #[code = 250];
            v193 = hir.int_to_ptr v190 : ptr<byte, i32>;
            hir.store v193, v283;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v194: i32, v195: i32, v196: i32) {
        ^block29(v194: i32, v195: i32, v196: i32):
            v299 = arith.constant 0 : i32;
            v297 = arith.constant 0 : i32;
            v198 = arith.eq v196, v297 : i1;
            v199 = arith.zext v198 : u32;
            v200 = hir.bitcast v199 : i32;
            v202 = arith.neq v200, v299 : i1;
            scf.if v202{
            ^block31:
                scf.yield ;
            } else {
            ^block32:
                hir.exec @root_ns:root@1.0.0/hash_elements/__rustc::__rust_dealloc(v194, v196, v195)
                scf.yield ;
            };
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};