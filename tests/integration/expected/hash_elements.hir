builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_elements {
        private builtin.function @miden_stdlib_sys::stdlib::crypto::hashes::extern_hash_memory(v0: i32, v1: i32, v2: i32) {
        ^block3(v0: i32, v1: i32, v2: i32):
            v3, v4, v5, v6 = hir.exec @std/crypto/hashes/rpo/hash_memory(v0, v1) : felt, felt, felt, felt
            v7 = hir.bitcast v2 : u32;
            v8 = hir.int_to_ptr v7 : ptr<byte, felt>;
            hir.store v8, v3;
            v9 = arith.constant 4 : u32;
            v10 = arith.add v7, v9 : u32 #[overflow = checked];
            v11 = hir.int_to_ptr v10 : ptr<byte, felt>;
            hir.store v11, v4;
            v12 = arith.constant 8 : u32;
            v13 = arith.add v7, v12 : u32 #[overflow = checked];
            v14 = hir.int_to_ptr v13 : ptr<byte, felt>;
            hir.store v14, v5;
            v15 = arith.constant 12 : u32;
            v16 = arith.add v7, v15 : u32 #[overflow = checked];
            v17 = hir.int_to_ptr v16 : ptr<byte, felt>;
            hir.store v17, v6;
            builtin.ret ;
        };

        public builtin.function @entrypoint(v18: i32) -> felt {
        ^block10(v18: i32):
            v22 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v23 = hir.bitcast v22 : ptr<byte, i32>;
            v24 = hir.load v23 : i32;
            v25 = arith.constant 16 : i32;
            v26 = arith.sub v24, v25 : i32 #[overflow = wrapping];
            v27 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v28 = hir.bitcast v27 : ptr<byte, i32>;
            hir.store v28, v26;
            v30 = arith.constant 4 : u32;
            v29 = hir.bitcast v18 : u32;
            v31 = arith.add v29, v30 : u32 #[overflow = checked];
            v179 = arith.constant 4 : u32;
            v33 = arith.mod v31, v179 : u32;
            hir.assertz v33 #[code = 250];
            v34 = hir.int_to_ptr v31 : ptr<byte, i32>;
            v35 = hir.load v34 : i32;
            v175 = arith.constant 2 : u32;
            v37 = hir.bitcast v35 : u32;
            v39 = arith.shr v37, v175 : u32;
            v40 = hir.bitcast v39 : i32;
            v174 = arith.constant 0 : felt;
            v41 = arith.constant 3 : i32;
            v42 = arith.band v40, v41 : i32;
            v43 = hir.bitcast v42 : felt;
            hir.assert_eq v43, v174;
            v47 = arith.constant 8 : u32;
            v46 = hir.bitcast v18 : u32;
            v48 = arith.add v46, v47 : u32 #[overflow = checked];
            v178 = arith.constant 4 : u32;
            v50 = arith.mod v48, v178 : u32;
            hir.assertz v50 #[code = 250];
            v51 = hir.int_to_ptr v48 : ptr<byte, i32>;
            v52 = hir.load v51 : i32;
            hir.exec @root_ns:root@1.0.0/hash_elements/miden_stdlib_sys::stdlib::crypto::hashes::extern_hash_memory(v40, v52, v26)
            v54 = arith.constant 12 : u32;
            v53 = hir.bitcast v26 : u32;
            v55 = arith.add v53, v54 : u32 #[overflow = checked];
            v177 = arith.constant 4 : u32;
            v57 = arith.mod v55, v177 : u32;
            hir.assertz v57 #[code = 250];
            v58 = hir.int_to_ptr v55 : ptr<byte, felt>;
            v59 = hir.load v58 : felt;
            v60 = arith.constant 4 : i32;
            hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::RawVecInner<A>::deallocate(v18, v60, v60)
            v176 = arith.constant 16 : i32;
            v63 = arith.add v26, v176 : i32 #[overflow = wrapping];
            v64 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v65 = hir.bitcast v64 : ptr<byte, i32>;
            hir.store v65, v63;
            builtin.ret v59;
        };

        private builtin.function @__rustc::__rust_dealloc(v66: i32, v67: i32, v68: i32) {
        ^block12(v66: i32, v67: i32, v68: i32):
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v69: i32, v70: i32, v71: i32) {
        ^block14(v69: i32, v70: i32, v71: i32):
            v73 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v74 = hir.bitcast v73 : ptr<byte, i32>;
            v75 = hir.load v74 : i32;
            v76 = arith.constant 16 : i32;
            v77 = arith.sub v75, v76 : i32 #[overflow = wrapping];
            v78 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v79 = hir.bitcast v78 : ptr<byte, i32>;
            hir.store v79, v77;
            v80 = arith.constant 4 : i32;
            v81 = arith.add v77, v80 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::RawVecInner<A>::current_memory(v81, v69, v70, v71)
            v83 = arith.constant 8 : u32;
            v82 = hir.bitcast v77 : u32;
            v84 = arith.add v82, v83 : u32 #[overflow = checked];
            v85 = arith.constant 4 : u32;
            v86 = arith.mod v84, v85 : u32;
            hir.assertz v86 #[code = 250];
            v87 = hir.int_to_ptr v84 : ptr<byte, i32>;
            v88 = hir.load v87 : i32;
            v186 = arith.constant 0 : i32;
            v72 = arith.constant 0 : i32;
            v90 = arith.eq v88, v72 : i1;
            v91 = arith.zext v90 : u32;
            v92 = hir.bitcast v91 : i32;
            v94 = arith.neq v92, v186 : i1;
            scf.if v94{
            ^block27:
                scf.yield ;
            } else {
            ^block17:
                v185 = arith.constant 4 : u32;
                v95 = hir.bitcast v77 : u32;
                v97 = arith.add v95, v185 : u32 #[overflow = checked];
                v184 = arith.constant 4 : u32;
                v99 = arith.mod v97, v184 : u32;
                hir.assertz v99 #[code = 250];
                v100 = hir.int_to_ptr v97 : ptr<byte, i32>;
                v101 = hir.load v100 : i32;
                v103 = arith.constant 12 : u32;
                v102 = hir.bitcast v77 : u32;
                v104 = arith.add v102, v103 : u32 #[overflow = checked];
                v183 = arith.constant 4 : u32;
                v106 = arith.mod v104, v183 : u32;
                hir.assertz v106 #[code = 250];
                v107 = hir.int_to_ptr v104 : ptr<byte, i32>;
                v108 = hir.load v107 : i32;
                hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v101, v88, v108)
                scf.yield ;
            };
            v182 = arith.constant 16 : i32;
            v111 = arith.add v77, v182 : i32 #[overflow = wrapping];
            v112 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v113 = hir.bitcast v112 : ptr<byte, i32>;
            hir.store v113, v111;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v114: i32, v115: i32, v116: i32, v117: i32) {
        ^block18(v114: i32, v115: i32, v116: i32, v117: i32):
            v212 = arith.constant 0 : i32;
            v118 = arith.constant 0 : i32;
            v122 = arith.eq v117, v118 : i1;
            v123 = arith.zext v122 : u32;
            v124 = hir.bitcast v123 : i32;
            v126 = arith.neq v124, v212 : i1;
            v199, v200 = scf.if v126 : i32, i32 {
            ^block30:
                v211 = arith.constant 0 : i32;
                v120 = arith.constant 4 : i32;
                scf.yield v120, v211;
            } else {
            ^block21:
                v127 = hir.bitcast v115 : u32;
                v162 = arith.constant 4 : u32;
                v129 = arith.mod v127, v162 : u32;
                hir.assertz v129 #[code = 250];
                v130 = hir.int_to_ptr v127 : ptr<byte, i32>;
                v131 = hir.load v130 : i32;
                v209 = arith.constant 0 : i32;
                v210 = arith.constant 0 : i32;
                v133 = arith.eq v131, v210 : i1;
                v134 = arith.zext v133 : u32;
                v135 = hir.bitcast v134 : i32;
                v137 = arith.neq v135, v209 : i1;
                v197 = scf.if v137 : i32 {
                ^block29:
                    v208 = arith.constant 0 : i32;
                    scf.yield v208;
                } else {
                ^block22:
                    v207 = arith.constant 4 : u32;
                    v138 = hir.bitcast v114 : u32;
                    v140 = arith.add v138, v207 : u32 #[overflow = checked];
                    v206 = arith.constant 4 : u32;
                    v142 = arith.mod v140, v206 : u32;
                    hir.assertz v142 #[code = 250];
                    v143 = hir.int_to_ptr v140 : ptr<byte, i32>;
                    hir.store v143, v116;
                    v205 = arith.constant 4 : u32;
                    v144 = hir.bitcast v115 : u32;
                    v146 = arith.add v144, v205 : u32 #[overflow = checked];
                    v204 = arith.constant 4 : u32;
                    v148 = arith.mod v146, v204 : u32;
                    hir.assertz v148 #[code = 250];
                    v149 = hir.int_to_ptr v146 : ptr<byte, i32>;
                    v150 = hir.load v149 : i32;
                    v151 = hir.bitcast v114 : u32;
                    v203 = arith.constant 4 : u32;
                    v153 = arith.mod v151, v203 : u32;
                    hir.assertz v153 #[code = 250];
                    v154 = hir.int_to_ptr v151 : ptr<byte, i32>;
                    hir.store v154, v150;
                    v155 = arith.mul v131, v117 : i32 #[overflow = wrapping];
                    scf.yield v155;
                };
                v156 = arith.constant 8 : i32;
                v202 = arith.constant 4 : i32;
                v198 = cf.select v137, v202, v156 : i32;
                scf.yield v198, v197;
            };
            v159 = arith.add v114, v199 : i32 #[overflow = wrapping];
            v161 = hir.bitcast v159 : u32;
            v201 = arith.constant 4 : u32;
            v163 = arith.mod v161, v201 : u32;
            hir.assertz v163 #[code = 250];
            v164 = hir.int_to_ptr v161 : ptr<byte, i32>;
            hir.store v164, v200;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v165: i32, v166: i32, v167: i32) {
        ^block23(v165: i32, v166: i32, v167: i32):
            v214 = arith.constant 0 : i32;
            v168 = arith.constant 0 : i32;
            v169 = arith.eq v167, v168 : i1;
            v170 = arith.zext v169 : u32;
            v171 = hir.bitcast v170 : i32;
            v173 = arith.neq v171, v214 : i1;
            scf.if v173{
            ^block25:
                scf.yield ;
            } else {
            ^block26:
                hir.exec @root_ns:root@1.0.0/hash_elements/__rustc::__rust_dealloc(v165, v167, v166)
                scf.yield ;
            };
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};