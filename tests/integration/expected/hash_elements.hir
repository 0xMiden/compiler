builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_elements {
        private builtin.function @__rustc::__rust_dealloc(v0: i32, v1: i32, v2: i32) {
        ^block4(v0: i32, v1: i32, v2: i32):
            builtin.ret ;
        };

        public builtin.function @entrypoint(v3: i32) -> felt {
        ^block6(v3: i32):
            v7 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v8 = hir.bitcast v7 : ptr<byte, i32>;
            v9 = hir.load v8 : i32;
            v10 = arith.constant 16 : i32;
            v11 = arith.sub v9, v10 : i32 #[overflow = wrapping];
            v12 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v13 = hir.bitcast v12 : ptr<byte, i32>;
            hir.store v13, v11;
            v15 = arith.constant 8 : u32;
            v14 = hir.bitcast v3 : u32;
            v16 = arith.add v14, v15 : u32 #[overflow = checked];
            v17 = arith.constant 4 : u32;
            v18 = arith.mod v16, v17 : u32;
            hir.assertz v18 #[code = 250];
            v19 = hir.int_to_ptr v16 : ptr<byte, i32>;
            v20 = hir.load v19 : i32;
            v214 = arith.constant 4 : u32;
            v21 = hir.bitcast v3 : u32;
            v23 = arith.add v21, v214 : u32 #[overflow = checked];
            v213 = arith.constant 4 : u32;
            v25 = arith.mod v23, v213 : u32;
            hir.assertz v25 #[code = 250];
            v26 = hir.int_to_ptr v23 : ptr<byte, i32>;
            v27 = hir.load v26 : i32;
            v204 = arith.constant 2 : u32;
            v29 = hir.bitcast v27 : u32;
            v31 = arith.shr v29, v204 : u32;
            v32 = hir.bitcast v31 : i32;
            v203 = arith.constant 0 : felt;
            v33 = arith.constant 3 : i32;
            v34 = arith.band v32, v33 : i32;
            v35 = hir.bitcast v34 : felt;
            hir.assert_eq v35, v203;
            v211 = arith.constant 0 : i32;
            v5 = arith.constant 0 : i32;
            v212 = arith.constant 3 : i32;
            v39 = arith.band v20, v212 : i32;
            v41 = arith.eq v39, v5 : i1;
            v42 = arith.zext v41 : u32;
            v43 = hir.bitcast v42 : i32;
            v45 = arith.neq v43, v211 : i1;
            scf.if v45{
            ^block9:
                v46 = arith.add v32, v20 : i32 #[overflow = wrapping];
                hir.exec @root_ns:root@1.0.0/hash_elements/std::crypto::hashes::rpo::hash_memory_words(v32, v46, v11)
                scf.yield ;
            } else {
            ^block10:
                hir.exec @root_ns:root@1.0.0/hash_elements/std::crypto::hashes::rpo::hash_memory(v32, v20, v11)
                scf.yield ;
            };
            v49 = arith.constant 12 : u32;
            v48 = hir.bitcast v11 : u32;
            v50 = arith.add v48, v49 : u32 #[overflow = checked];
            v210 = arith.constant 4 : u32;
            v52 = arith.mod v50, v210 : u32;
            hir.assertz v52 #[code = 250];
            v53 = hir.int_to_ptr v50 : ptr<byte, felt>;
            v54 = hir.load v53 : felt;
            v56 = arith.constant 4 : i32;
            hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::raw_vec::RawVecInner>::deallocate(v3, v56, v56)
            v209 = arith.constant 16 : i32;
            v59 = arith.add v11, v209 : i32 #[overflow = wrapping];
            v60 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v61 = hir.bitcast v60 : ptr<byte, i32>;
            hir.store v61, v59;
            builtin.ret v54;
        };

        private builtin.function @std::crypto::hashes::rpo::hash_memory(v62: i32, v63: i32, v64: i32) {
        ^block11(v62: i32, v63: i32, v64: i32):
            v65, v66, v67, v68 = hir.exec @std/crypto/hashes/rpo/hash_memory(v62, v63) : felt, felt, felt, felt
            v69 = hir.bitcast v64 : u32;
            v70 = hir.int_to_ptr v69 : ptr<byte, felt>;
            hir.store v70, v65;
            v71 = arith.constant 4 : u32;
            v72 = arith.add v69, v71 : u32 #[overflow = checked];
            v73 = hir.int_to_ptr v72 : ptr<byte, felt>;
            hir.store v73, v66;
            v74 = arith.constant 8 : u32;
            v75 = arith.add v69, v74 : u32 #[overflow = checked];
            v76 = hir.int_to_ptr v75 : ptr<byte, felt>;
            hir.store v76, v67;
            v77 = arith.constant 12 : u32;
            v78 = arith.add v69, v77 : u32 #[overflow = checked];
            v79 = hir.int_to_ptr v78 : ptr<byte, felt>;
            hir.store v79, v68;
            builtin.ret ;
        };

        private builtin.function @std::crypto::hashes::rpo::hash_memory_words(v80: i32, v81: i32, v82: i32) {
        ^block17(v80: i32, v81: i32, v82: i32):
            v83, v84, v85, v86 = hir.exec @std/crypto/hashes/rpo/hash_memory_words(v80, v81) : felt, felt, felt, felt
            v87 = hir.bitcast v82 : u32;
            v88 = hir.int_to_ptr v87 : ptr<byte, felt>;
            hir.store v88, v83;
            v89 = arith.constant 4 : u32;
            v90 = arith.add v87, v89 : u32 #[overflow = checked];
            v91 = hir.int_to_ptr v90 : ptr<byte, felt>;
            hir.store v91, v84;
            v92 = arith.constant 8 : u32;
            v93 = arith.add v87, v92 : u32 #[overflow = checked];
            v94 = hir.int_to_ptr v93 : ptr<byte, felt>;
            hir.store v94, v85;
            v95 = arith.constant 12 : u32;
            v96 = arith.add v87, v95 : u32 #[overflow = checked];
            v97 = hir.int_to_ptr v96 : ptr<byte, felt>;
            hir.store v97, v86;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::deallocate(v98: i32, v99: i32, v100: i32) {
        ^block19(v98: i32, v99: i32, v100: i32):
            v102 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v103 = hir.bitcast v102 : ptr<byte, i32>;
            v104 = hir.load v103 : i32;
            v105 = arith.constant 16 : i32;
            v106 = arith.sub v104, v105 : i32 #[overflow = wrapping];
            v107 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v108 = hir.bitcast v107 : ptr<byte, i32>;
            hir.store v108, v106;
            v109 = arith.constant 4 : i32;
            v110 = arith.add v106, v109 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::raw_vec::RawVecInner>::current_memory(v110, v98, v99, v100)
            v112 = arith.constant 8 : u32;
            v111 = hir.bitcast v106 : u32;
            v113 = arith.add v111, v112 : u32 #[overflow = checked];
            v114 = arith.constant 4 : u32;
            v115 = arith.mod v113, v114 : u32;
            hir.assertz v115 #[code = 250];
            v116 = hir.int_to_ptr v113 : ptr<byte, i32>;
            v117 = hir.load v116 : i32;
            v221 = arith.constant 0 : i32;
            v101 = arith.constant 0 : i32;
            v119 = arith.eq v117, v101 : i1;
            v120 = arith.zext v119 : u32;
            v121 = hir.bitcast v120 : i32;
            v123 = arith.neq v121, v221 : i1;
            scf.if v123{
            ^block33:
                scf.yield ;
            } else {
            ^block22:
                v220 = arith.constant 4 : u32;
                v124 = hir.bitcast v106 : u32;
                v126 = arith.add v124, v220 : u32 #[overflow = checked];
                v219 = arith.constant 4 : u32;
                v128 = arith.mod v126, v219 : u32;
                hir.assertz v128 #[code = 250];
                v129 = hir.int_to_ptr v126 : ptr<byte, i32>;
                v130 = hir.load v129 : i32;
                v132 = arith.constant 12 : u32;
                v131 = hir.bitcast v106 : u32;
                v133 = arith.add v131, v132 : u32 #[overflow = checked];
                v218 = arith.constant 4 : u32;
                v135 = arith.mod v133, v218 : u32;
                hir.assertz v135 #[code = 250];
                v136 = hir.int_to_ptr v133 : ptr<byte, i32>;
                v137 = hir.load v136 : i32;
                hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v130, v117, v137)
                scf.yield ;
            };
            v217 = arith.constant 16 : i32;
            v140 = arith.add v106, v217 : i32 #[overflow = wrapping];
            v141 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v142 = hir.bitcast v141 : ptr<byte, i32>;
            hir.store v142, v140;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::current_memory(v143: i32, v144: i32, v145: i32, v146: i32) {
        ^block23(v143: i32, v144: i32, v145: i32, v146: i32):
            v247 = arith.constant 0 : i32;
            v147 = arith.constant 0 : i32;
            v151 = arith.eq v146, v147 : i1;
            v152 = arith.zext v151 : u32;
            v153 = hir.bitcast v152 : i32;
            v155 = arith.neq v153, v247 : i1;
            v234, v235 = scf.if v155 : i32, i32 {
            ^block36:
                v246 = arith.constant 0 : i32;
                v149 = arith.constant 4 : i32;
                scf.yield v149, v246;
            } else {
            ^block26:
                v156 = hir.bitcast v144 : u32;
                v191 = arith.constant 4 : u32;
                v158 = arith.mod v156, v191 : u32;
                hir.assertz v158 #[code = 250];
                v159 = hir.int_to_ptr v156 : ptr<byte, i32>;
                v160 = hir.load v159 : i32;
                v244 = arith.constant 0 : i32;
                v245 = arith.constant 0 : i32;
                v162 = arith.eq v160, v245 : i1;
                v163 = arith.zext v162 : u32;
                v164 = hir.bitcast v163 : i32;
                v166 = arith.neq v164, v244 : i1;
                v232 = scf.if v166 : i32 {
                ^block35:
                    v243 = arith.constant 0 : i32;
                    scf.yield v243;
                } else {
                ^block27:
                    v242 = arith.constant 4 : u32;
                    v167 = hir.bitcast v143 : u32;
                    v169 = arith.add v167, v242 : u32 #[overflow = checked];
                    v241 = arith.constant 4 : u32;
                    v171 = arith.mod v169, v241 : u32;
                    hir.assertz v171 #[code = 250];
                    v172 = hir.int_to_ptr v169 : ptr<byte, i32>;
                    hir.store v172, v145;
                    v240 = arith.constant 4 : u32;
                    v173 = hir.bitcast v144 : u32;
                    v175 = arith.add v173, v240 : u32 #[overflow = checked];
                    v239 = arith.constant 4 : u32;
                    v177 = arith.mod v175, v239 : u32;
                    hir.assertz v177 #[code = 250];
                    v178 = hir.int_to_ptr v175 : ptr<byte, i32>;
                    v179 = hir.load v178 : i32;
                    v180 = hir.bitcast v143 : u32;
                    v238 = arith.constant 4 : u32;
                    v182 = arith.mod v180, v238 : u32;
                    hir.assertz v182 #[code = 250];
                    v183 = hir.int_to_ptr v180 : ptr<byte, i32>;
                    hir.store v183, v179;
                    v184 = arith.mul v160, v146 : i32 #[overflow = wrapping];
                    scf.yield v184;
                };
                v185 = arith.constant 8 : i32;
                v237 = arith.constant 4 : i32;
                v233 = cf.select v166, v237, v185 : i32;
                scf.yield v233, v232;
            };
            v188 = arith.add v143, v234 : i32 #[overflow = wrapping];
            v190 = hir.bitcast v188 : u32;
            v236 = arith.constant 4 : u32;
            v192 = arith.mod v190, v236 : u32;
            hir.assertz v192 #[code = 250];
            v193 = hir.int_to_ptr v190 : ptr<byte, i32>;
            hir.store v193, v235;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v194: i32, v195: i32, v196: i32) {
        ^block28(v194: i32, v195: i32, v196: i32):
            v249 = arith.constant 0 : i32;
            v197 = arith.constant 0 : i32;
            v198 = arith.eq v196, v197 : i1;
            v199 = arith.zext v198 : u32;
            v200 = hir.bitcast v199 : i32;
            v202 = arith.neq v200, v249 : i1;
            scf.if v202{
            ^block30:
                scf.yield ;
            } else {
            ^block31:
                hir.exec @root_ns:root@1.0.0/hash_elements/__rustc::__rust_dealloc(v194, v196, v195)
                scf.yield ;
            };
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};