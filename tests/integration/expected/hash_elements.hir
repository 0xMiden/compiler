builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_elements {
        private builtin.function @miden_stdlib_sys::stdlib::crypto::hashes::extern_hash_memory(v0: i32, v1: i32, v2: i32) {
        ^block3(v0: i32, v1: i32, v2: i32):
            v3, v4, v5, v6 = hir.exec @std/crypto/hashes/rpo/hash_memory(v0, v1) : felt, felt, felt, felt
            v7 = hir.bitcast v2 : u32;
            v8 = hir.int_to_ptr v7 : ptr<byte, felt>;
            hir.store v8, v3;
            v9 = arith.constant 4 : u32;
            v10 = arith.add v7, v9 : u32 #[overflow = checked];
            v11 = hir.int_to_ptr v10 : ptr<byte, felt>;
            hir.store v11, v4;
            v12 = arith.constant 8 : u32;
            v13 = arith.add v7, v12 : u32 #[overflow = checked];
            v14 = hir.int_to_ptr v13 : ptr<byte, felt>;
            hir.store v14, v5;
            v15 = arith.constant 12 : u32;
            v16 = arith.add v7, v15 : u32 #[overflow = checked];
            v17 = hir.int_to_ptr v16 : ptr<byte, felt>;
            hir.store v17, v6;
            builtin.ret ;
        };

        public builtin.function @entrypoint(v18: i32) -> felt {
        ^block12(v18: i32):
            v22 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v23 = hir.bitcast v22 : ptr<byte, i32>;
            v24 = hir.load v23 : i32;
            v27 = arith.constant -32 : i32;
            v25 = arith.constant 64 : i32;
            v26 = arith.sub v24, v25 : i32 #[overflow = wrapping];
            v28 = arith.band v26, v27 : i32;
            v29 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v30 = hir.bitcast v29 : ptr<byte, i32>;
            hir.store v30, v28;
            v32 = arith.constant 4 : u32;
            v31 = hir.bitcast v18 : u32;
            v33 = arith.add v31, v32 : u32 #[overflow = checked];
            v642 = arith.constant 4 : u32;
            v35 = arith.mod v33, v642 : u32;
            hir.assertz v35 #[code = 250];
            v36 = hir.int_to_ptr v33 : ptr<byte, i32>;
            v37 = hir.load v36 : i32;
            v38 = hir.bitcast v18 : u32;
            v641 = arith.constant 4 : u32;
            v40 = arith.mod v38, v641 : u32;
            hir.assertz v40 #[code = 250];
            v41 = hir.int_to_ptr v38 : ptr<byte, i32>;
            v42 = hir.load v41 : i32;
            v20 = arith.constant 0 : i32;
            v43 = arith.constant 12 : i32;
            v44 = arith.band v42, v43 : i32;
            v46 = arith.neq v44, v20 : i1;
            v606, v607, v608 = scf.if v46 : i32, i32, u32 {
            ^block16:
                v53 = arith.constant 4 : i32;
                v640 = arith.constant 0 : i32;
                hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::RawVecInner<A>::try_allocate_in(v28, v37, v640, v53, v53)
                v639 = arith.constant 4 : u32;
                v55 = hir.bitcast v28 : u32;
                v57 = arith.add v55, v639 : u32 #[overflow = checked];
                v638 = arith.constant 4 : u32;
                v59 = arith.mod v57, v638 : u32;
                hir.assertz v59 #[code = 250];
                v60 = hir.int_to_ptr v57 : ptr<byte, i32>;
                v61 = hir.load v60 : i32;
                v62 = hir.bitcast v28 : u32;
                v637 = arith.constant 4 : u32;
                v64 = arith.mod v62, v637 : u32;
                hir.assertz v64 #[code = 250];
                v65 = hir.int_to_ptr v62 : ptr<byte, i32>;
                v66 = hir.load v65 : i32;
                v636 = arith.constant 0 : i32;
                v67 = arith.constant 1 : i32;
                v68 = arith.eq v66, v67 : i1;
                v69 = arith.zext v68 : u32;
                v70 = hir.bitcast v69 : i32;
                v72 = arith.neq v70, v636 : i1;
                scf.if v72{
                ^block14:
                    v142 = arith.constant 8 : u32;
                    v141 = hir.bitcast v28 : u32;
                    v143 = arith.add v141, v142 : u32 #[overflow = checked];
                    v635 = arith.constant 4 : u32;
                    v145 = arith.mod v143, v635 : u32;
                    hir.assertz v145 #[code = 250];
                    v146 = hir.int_to_ptr v143 : ptr<byte, i32>;
                    v147 = hir.load v146 : i32;
                    v148 = arith.constant 1048628 : i32;
                    hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::handle_error(v61, v147, v148)
                    scf.yield ;
                } else {
                ^block18:
                    v634 = arith.constant 8 : u32;
                    v73 = hir.bitcast v28 : u32;
                    v75 = arith.add v73, v634 : u32 #[overflow = checked];
                    v633 = arith.constant 4 : u32;
                    v77 = arith.mod v75, v633 : u32;
                    hir.assertz v77 #[code = 250];
                    v78 = hir.int_to_ptr v75 : ptr<byte, i32>;
                    v79 = hir.load v78 : i32;
                    v81 = arith.constant 56 : u32;
                    v80 = hir.bitcast v28 : u32;
                    v82 = arith.add v80, v81 : u32 #[overflow = checked];
                    v632 = arith.constant 4 : u32;
                    v84 = arith.mod v82, v632 : u32;
                    hir.assertz v84 #[code = 250];
                    v85 = hir.int_to_ptr v82 : ptr<byte, i32>;
                    hir.store v85, v79;
                    v87 = arith.constant 52 : u32;
                    v86 = hir.bitcast v28 : u32;
                    v88 = arith.add v86, v87 : u32 #[overflow = checked];
                    v631 = arith.constant 4 : u32;
                    v90 = arith.mod v88, v631 : u32;
                    hir.assertz v90 #[code = 250];
                    v91 = hir.int_to_ptr v88 : ptr<byte, i32>;
                    hir.store v91, v61;
                    v595 = arith.constant 2 : u32;
                    v94 = arith.shl v37, v595 : i32;
                    v629 = arith.constant 0 : i32;
                    v630 = arith.constant 0 : i32;
                    v96 = arith.eq v94, v630 : i1;
                    v97 = arith.zext v96 : u32;
                    v98 = hir.bitcast v97 : i32;
                    v100 = arith.neq v98, v629 : i1;
                    scf.if v100{
                    ^block78:
                        scf.yield ;
                    } else {
                    ^block20:
                        v101 = hir.bitcast v94 : u32;
                        v102 = hir.bitcast v79 : u32;
                        v103 = hir.int_to_ptr v102 : ptr<byte, u8>;
                        v104 = hir.bitcast v42 : u32;
                        v105 = hir.int_to_ptr v104 : ptr<byte, u8>;
                        hir.mem_cpy v105, v103, v101;
                        scf.yield ;
                    };
                    v109 = arith.constant 60 : u32;
                    v108 = hir.bitcast v28 : u32;
                    v110 = arith.add v108, v109 : u32 #[overflow = checked];
                    v628 = arith.constant 4 : u32;
                    v112 = arith.mod v110, v628 : u32;
                    hir.assertz v112 #[code = 250];
                    v113 = hir.int_to_ptr v110 : ptr<byte, i32>;
                    hir.store v113, v37;
                    v627 = arith.constant 2 : u32;
                    v116 = hir.bitcast v79 : u32;
                    v118 = arith.shr v116, v627 : u32;
                    v119 = hir.bitcast v118 : i32;
                    v592 = arith.constant 0 : felt;
                    v120 = arith.constant 3 : i32;
                    v121 = arith.band v119, v120 : i32;
                    v122 = hir.bitcast v121 : felt;
                    hir.assert_eq v122, v592;
                    hir.exec @root_ns:root@1.0.0/hash_elements/miden_stdlib_sys::stdlib::crypto::hashes::extern_hash_memory(v119, v37, v28)
                    v626 = arith.constant 4 : i32;
                    v125 = arith.constant 52 : i32;
                    v126 = arith.add v28, v125 : i32 #[overflow = wrapping];
                    hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::RawVecInner<A>::deallocate(v126, v626, v626)
                    scf.yield ;
                };
                v596 = arith.constant 0 : u32;
                v602 = arith.constant 1 : u32;
                v620 = cf.select v72, v602, v596 : u32;
                v625 = ub.poison i32 : i32;
                v619 = cf.select v72, v625, v24 : i32;
                v601 = ub.poison i32 : i32;
                v618 = cf.select v72, v601, v28 : i32;
                scf.yield v618, v619, v620;
            } else {
            ^block17:
                v624 = arith.constant 2 : u32;
                v48 = hir.bitcast v42 : u32;
                v50 = arith.shr v48, v624 : u32;
                v51 = hir.bitcast v50 : i32;
                hir.exec @root_ns:root@1.0.0/hash_elements/miden_stdlib_sys::stdlib::crypto::hashes::extern_hash_memory(v51, v37, v28)
                v623 = arith.constant 0 : u32;
                scf.yield v28, v24, v623;
            };
            v622 = arith.constant 0 : u32;
            v617 = arith.eq v608, v622 : i1;
            cf.cond_br v617 ^block15, ^block79;
        ^block15:
            v131 = arith.constant 12 : u32;
            v130 = hir.bitcast v606 : u32;
            v132 = arith.add v130, v131 : u32 #[overflow = checked];
            v621 = arith.constant 4 : u32;
            v134 = arith.mod v132, v621 : u32;
            hir.assertz v134 #[code = 250];
            v135 = hir.int_to_ptr v132 : ptr<byte, felt>;
            v136 = hir.load v135 : felt;
            v139 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v140 = hir.bitcast v139 : ptr<byte, i32>;
            hir.store v140, v607;
            builtin.ret v136;
        ^block79:
            ub.unreachable ;
        };

        private builtin.function @__rustc::__rust_alloc(v149: i32, v150: i32) -> i32 {
        ^block21(v149: i32, v150: i32):
            v152 = arith.constant 1048644 : i32;
            v153 = hir.exec @root_ns:root@1.0.0/hash_elements/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v152, v150, v149) : i32
            builtin.ret v153;
        };

        private builtin.function @__rustc::__rust_dealloc(v154: i32, v155: i32, v156: i32) {
        ^block23(v154: i32, v155: i32, v156: i32):
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v157: i32, v158: i32) -> i32 {
        ^block25(v157: i32, v158: i32):
            v160 = arith.constant 1048644 : i32;
            v161 = hir.exec @root_ns:root@1.0.0/hash_elements/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v160, v158, v157) : i32
            v651 = arith.constant 0 : i32;
            v162 = arith.constant 0 : i32;
            v163 = arith.eq v161, v162 : i1;
            v164 = arith.zext v163 : u32;
            v165 = hir.bitcast v164 : i32;
            v167 = arith.neq v165, v651 : i1;
            scf.if v167{
            ^block27:
                scf.yield ;
            } else {
            ^block28:
                v649 = arith.constant 0 : i32;
                v650 = arith.constant 0 : i32;
                v169 = arith.eq v157, v650 : i1;
                v170 = arith.zext v169 : u32;
                v171 = hir.bitcast v170 : i32;
                v173 = arith.neq v171, v649 : i1;
                scf.if v173{
                ^block83:
                    scf.yield ;
                } else {
                ^block29:
                    v643 = arith.constant 0 : u8;
                    v176 = hir.bitcast v157 : u32;
                    v177 = hir.bitcast v161 : u32;
                    v178 = hir.int_to_ptr v177 : ptr<byte, u8>;
                    hir.mem_set v178, v176, v643;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v161;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v180: i32, v181: i32, v182: i32) -> i32 {
        ^block30(v180: i32, v181: i32, v182: i32):
            v185 = arith.constant 16 : i32;
            v184 = arith.constant 0 : i32;
            v653 = arith.constant 16 : u32;
            v187 = hir.bitcast v181 : u32;
            v189 = arith.gt v187, v653 : i1;
            v190 = arith.zext v189 : u32;
            v191 = hir.bitcast v190 : i32;
            v193 = arith.neq v191, v184 : i1;
            v194 = cf.select v193, v181, v185 : i32;
            v692 = arith.constant 0 : i32;
            v195 = arith.constant -1 : i32;
            v196 = arith.add v194, v195 : i32 #[overflow = wrapping];
            v197 = arith.band v194, v196 : i32;
            v199 = arith.neq v197, v692 : i1;
            v662, v663 = scf.if v199 : i32, u32 {
            ^block88:
                v654 = arith.constant 0 : u32;
                v658 = ub.poison i32 : i32;
                scf.yield v658, v654;
            } else {
            ^block33:
                v201 = hir.exec @root_ns:root@1.0.0/hash_elements/core::ptr::alignment::Alignment::max(v181, v194) : i32
                v691 = arith.constant 0 : i32;
                v200 = arith.constant -2147483648 : i32;
                v202 = arith.sub v200, v201 : i32 #[overflow = wrapping];
                v204 = hir.bitcast v202 : u32;
                v203 = hir.bitcast v182 : u32;
                v205 = arith.gt v203, v204 : i1;
                v206 = arith.zext v205 : u32;
                v207 = hir.bitcast v206 : i32;
                v209 = arith.neq v207, v691 : i1;
                v677 = scf.if v209 : i32 {
                ^block87:
                    v690 = ub.poison i32 : i32;
                    scf.yield v690;
                } else {
                ^block34:
                    v688 = arith.constant 0 : i32;
                    v215 = arith.sub v688, v201 : i32 #[overflow = wrapping];
                    v689 = arith.constant -1 : i32;
                    v211 = arith.add v182, v201 : i32 #[overflow = wrapping];
                    v213 = arith.add v211, v689 : i32 #[overflow = wrapping];
                    v216 = arith.band v213, v215 : i32;
                    v217 = hir.bitcast v180 : u32;
                    v218 = arith.constant 4 : u32;
                    v219 = arith.mod v217, v218 : u32;
                    hir.assertz v219 #[code = 250];
                    v220 = hir.int_to_ptr v217 : ptr<byte, i32>;
                    v221 = hir.load v220 : i32;
                    v687 = arith.constant 0 : i32;
                    v223 = arith.neq v221, v687 : i1;
                    scf.if v223{
                    ^block86:
                        scf.yield ;
                    } else {
                    ^block36:
                        v224 = hir.exec @intrinsics/mem/heap_base() : i32
                        v225 = hir.mem_size  : u32;
                        v231 = hir.bitcast v180 : u32;
                        v686 = arith.constant 4 : u32;
                        v233 = arith.mod v231, v686 : u32;
                        hir.assertz v233 #[code = 250];
                        v685 = arith.constant 16 : u32;
                        v226 = hir.bitcast v225 : i32;
                        v229 = arith.shl v226, v685 : i32;
                        v230 = arith.add v224, v229 : i32 #[overflow = wrapping];
                        v234 = hir.int_to_ptr v231 : ptr<byte, i32>;
                        hir.store v234, v230;
                        scf.yield ;
                    };
                    v237 = hir.bitcast v180 : u32;
                    v684 = arith.constant 4 : u32;
                    v239 = arith.mod v237, v684 : u32;
                    hir.assertz v239 #[code = 250];
                    v240 = hir.int_to_ptr v237 : ptr<byte, i32>;
                    v241 = hir.load v240 : i32;
                    v683 = arith.constant 0 : i32;
                    v245 = hir.bitcast v216 : u32;
                    v235 = arith.constant 268435456 : i32;
                    v242 = arith.sub v235, v241 : i32 #[overflow = wrapping];
                    v244 = hir.bitcast v242 : u32;
                    v246 = arith.lt v244, v245 : i1;
                    v247 = arith.zext v246 : u32;
                    v248 = hir.bitcast v247 : i32;
                    v250 = arith.neq v248, v683 : i1;
                    v676 = scf.if v250 : i32 {
                    ^block37:
                        v682 = arith.constant 0 : i32;
                        scf.yield v682;
                    } else {
                    ^block38:
                        v252 = hir.bitcast v180 : u32;
                        v681 = arith.constant 4 : u32;
                        v254 = arith.mod v252, v681 : u32;
                        hir.assertz v254 #[code = 250];
                        v251 = arith.add v241, v216 : i32 #[overflow = wrapping];
                        v255 = hir.int_to_ptr v252 : ptr<byte, i32>;
                        hir.store v255, v251;
                        v257 = arith.add v241, v201 : i32 #[overflow = wrapping];
                        scf.yield v257;
                    };
                    scf.yield v676;
                };
                v659 = arith.constant 1 : u32;
                v680 = arith.constant 0 : u32;
                v678 = cf.select v209, v680, v659 : u32;
                scf.yield v677, v678;
            };
            v679 = arith.constant 0 : u32;
            v675 = arith.eq v663, v679 : i1;
            cf.cond_br v675 ^block32, ^block90(v662);
        ^block32:
            ub.unreachable ;
        ^block90(v655: i32):
            builtin.ret v655;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v260: i32, v261: i32, v262: i32) {
        ^block39(v260: i32, v261: i32, v262: i32):
            v264 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v265 = hir.bitcast v264 : ptr<byte, i32>;
            v266 = hir.load v265 : i32;
            v267 = arith.constant 16 : i32;
            v268 = arith.sub v266, v267 : i32 #[overflow = wrapping];
            v269 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v270 = hir.bitcast v269 : ptr<byte, i32>;
            hir.store v270, v268;
            v271 = arith.constant 4 : i32;
            v272 = arith.add v268, v271 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/alloc::raw_vec::RawVecInner<A>::current_memory(v272, v260, v261, v262)
            v274 = arith.constant 8 : u32;
            v273 = hir.bitcast v268 : u32;
            v275 = arith.add v273, v274 : u32 #[overflow = checked];
            v276 = arith.constant 4 : u32;
            v277 = arith.mod v275, v276 : u32;
            hir.assertz v277 #[code = 250];
            v278 = hir.int_to_ptr v275 : ptr<byte, i32>;
            v279 = hir.load v278 : i32;
            v699 = arith.constant 0 : i32;
            v263 = arith.constant 0 : i32;
            v281 = arith.eq v279, v263 : i1;
            v282 = arith.zext v281 : u32;
            v283 = hir.bitcast v282 : i32;
            v285 = arith.neq v283, v699 : i1;
            scf.if v285{
            ^block94:
                scf.yield ;
            } else {
            ^block42:
                v698 = arith.constant 4 : u32;
                v286 = hir.bitcast v268 : u32;
                v288 = arith.add v286, v698 : u32 #[overflow = checked];
                v697 = arith.constant 4 : u32;
                v290 = arith.mod v288, v697 : u32;
                hir.assertz v290 #[code = 250];
                v291 = hir.int_to_ptr v288 : ptr<byte, i32>;
                v292 = hir.load v291 : i32;
                v294 = arith.constant 12 : u32;
                v293 = hir.bitcast v268 : u32;
                v295 = arith.add v293, v294 : u32 #[overflow = checked];
                v696 = arith.constant 4 : u32;
                v297 = arith.mod v295, v696 : u32;
                hir.assertz v297 #[code = 250];
                v298 = hir.int_to_ptr v295 : ptr<byte, i32>;
                v299 = hir.load v298 : i32;
                hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v292, v279, v299)
                scf.yield ;
            };
            v695 = arith.constant 16 : i32;
            v302 = arith.add v268, v695 : i32 #[overflow = wrapping];
            v303 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v304 = hir.bitcast v303 : ptr<byte, i32>;
            hir.store v304, v302;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::try_allocate_in(v305: i32, v306: i32, v307: i32, v308: i32, v309: i32) {
        ^block43(v305: i32, v306: i32, v307: i32, v308: i32, v309: i32):
            v312 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v313 = hir.bitcast v312 : ptr<byte, i32>;
            v314 = hir.load v313 : i32;
            v315 = arith.constant 16 : i32;
            v316 = arith.sub v314, v315 : i32 #[overflow = wrapping];
            v317 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v318 = hir.bitcast v317 : ptr<byte, i32>;
            hir.store v318, v316;
            v328 = hir.bitcast v306 : u32;
            v329 = arith.zext v328 : u64;
            v330 = hir.bitcast v329 : i64;
            v310 = arith.constant 0 : i32;
            v323 = arith.sub v310, v308 : i32 #[overflow = wrapping];
            v320 = arith.constant -1 : i32;
            v319 = arith.add v308, v309 : i32 #[overflow = wrapping];
            v321 = arith.add v319, v320 : i32 #[overflow = wrapping];
            v324 = arith.band v321, v323 : i32;
            v325 = hir.bitcast v324 : u32;
            v326 = arith.zext v325 : u64;
            v327 = hir.bitcast v326 : i64;
            v331 = arith.mul v327, v330 : i64 #[overflow = wrapping];
            v803 = arith.constant 0 : i32;
            v332 = arith.constant 32 : i64;
            v334 = hir.cast v332 : u32;
            v333 = hir.bitcast v331 : u64;
            v335 = arith.shr v333, v334 : u64;
            v336 = hir.bitcast v335 : i64;
            v337 = arith.trunc v336 : i32;
            v339 = arith.neq v337, v803 : i1;
            v715, v716, v717, v718, v719, v720 = scf.if v339 : i32, i32, i32, i32, i32, u32 {
            ^block96:
                v700 = arith.constant 0 : u32;
                v707 = ub.poison i32 : i32;
                scf.yield v305, v316, v707, v707, v707, v700;
            } else {
            ^block48:
                v340 = arith.trunc v331 : i32;
                v802 = arith.constant 0 : i32;
                v341 = arith.constant -2147483648 : i32;
                v342 = arith.sub v341, v308 : i32 #[overflow = wrapping];
                v344 = hir.bitcast v342 : u32;
                v343 = hir.bitcast v340 : u32;
                v345 = arith.lte v343, v344 : i1;
                v346 = arith.zext v345 : u32;
                v347 = hir.bitcast v346 : i32;
                v349 = arith.neq v347, v802 : i1;
                v763 = scf.if v349 : i32 {
                ^block46:
                    v801 = arith.constant 0 : i32;
                    v360 = arith.neq v340, v801 : i1;
                    v762 = scf.if v360 : i32 {
                    ^block50:
                        v800 = arith.constant 0 : i32;
                        v376 = arith.neq v307, v800 : i1;
                        v761 = scf.if v376 : i32 {
                        ^block53:
                            v358 = arith.constant 1 : i32;
                            hir.exec @root_ns:root@1.0.0/hash_elements/alloc::alloc::Global::alloc_impl(v316, v308, v340, v358)
                            v387 = hir.bitcast v316 : u32;
                            v432 = arith.constant 4 : u32;
                            v389 = arith.mod v387, v432 : u32;
                            hir.assertz v389 #[code = 250];
                            v390 = hir.int_to_ptr v387 : ptr<byte, i32>;
                            v391 = hir.load v390 : i32;
                            scf.yield v391;
                        } else {
                        ^block54:
                            v377 = arith.constant 8 : i32;
                            v378 = arith.add v316, v377 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/hash_elements/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v378, v308, v340)
                            v362 = arith.constant 8 : u32;
                            v379 = hir.bitcast v316 : u32;
                            v381 = arith.add v379, v362 : u32 #[overflow = checked];
                            v799 = arith.constant 4 : u32;
                            v383 = arith.mod v381, v799 : u32;
                            hir.assertz v383 #[code = 250];
                            v384 = hir.int_to_ptr v381 : ptr<byte, i32>;
                            v385 = hir.load v384 : i32;
                            scf.yield v385;
                        };
                        v797 = arith.constant 0 : i32;
                        v798 = arith.constant 0 : i32;
                        v394 = arith.eq v761, v798 : i1;
                        v395 = arith.zext v394 : u32;
                        v396 = hir.bitcast v395 : i32;
                        v398 = arith.neq v396, v797 : i1;
                        scf.if v398{
                        ^block55:
                            v796 = arith.constant 8 : u32;
                            v415 = hir.bitcast v305 : u32;
                            v417 = arith.add v415, v796 : u32 #[overflow = checked];
                            v795 = arith.constant 4 : u32;
                            v419 = arith.mod v417, v795 : u32;
                            hir.assertz v419 #[code = 250];
                            v420 = hir.int_to_ptr v417 : ptr<byte, i32>;
                            hir.store v420, v340;
                            v794 = arith.constant 4 : u32;
                            v422 = hir.bitcast v305 : u32;
                            v424 = arith.add v422, v794 : u32 #[overflow = checked];
                            v793 = arith.constant 4 : u32;
                            v426 = arith.mod v424, v793 : u32;
                            hir.assertz v426 #[code = 250];
                            v427 = hir.int_to_ptr v424 : ptr<byte, i32>;
                            hir.store v427, v308;
                            scf.yield ;
                        } else {
                        ^block56:
                            v792 = arith.constant 8 : u32;
                            v400 = hir.bitcast v305 : u32;
                            v402 = arith.add v400, v792 : u32 #[overflow = checked];
                            v791 = arith.constant 4 : u32;
                            v404 = arith.mod v402, v791 : u32;
                            hir.assertz v404 #[code = 250];
                            v405 = hir.int_to_ptr v402 : ptr<byte, i32>;
                            hir.store v405, v761;
                            v790 = arith.constant 4 : u32;
                            v407 = hir.bitcast v305 : u32;
                            v409 = arith.add v407, v790 : u32 #[overflow = checked];
                            v789 = arith.constant 4 : u32;
                            v411 = arith.mod v409, v789 : u32;
                            hir.assertz v411 #[code = 250];
                            v412 = hir.int_to_ptr v409 : ptr<byte, i32>;
                            hir.store v412, v306;
                            scf.yield ;
                        };
                        v787 = arith.constant 0 : i32;
                        v788 = arith.constant 1 : i32;
                        v760 = cf.select v398, v788, v787 : i32;
                        scf.yield v760;
                    } else {
                    ^block51:
                        v786 = arith.constant 8 : u32;
                        v361 = hir.bitcast v305 : u32;
                        v363 = arith.add v361, v786 : u32 #[overflow = checked];
                        v785 = arith.constant 4 : u32;
                        v365 = arith.mod v363, v785 : u32;
                        hir.assertz v365 #[code = 250];
                        v366 = hir.int_to_ptr v363 : ptr<byte, i32>;
                        hir.store v366, v308;
                        v784 = arith.constant 4 : u32;
                        v369 = hir.bitcast v305 : u32;
                        v371 = arith.add v369, v784 : u32 #[overflow = checked];
                        v783 = arith.constant 4 : u32;
                        v373 = arith.mod v371, v783 : u32;
                        hir.assertz v373 #[code = 250];
                        v782 = arith.constant 0 : i32;
                        v374 = hir.int_to_ptr v371 : ptr<byte, i32>;
                        hir.store v374, v782;
                        v781 = arith.constant 0 : i32;
                        scf.yield v781;
                    };
                    scf.yield v762;
                } else {
                ^block49:
                    v780 = ub.poison i32 : i32;
                    scf.yield v780;
                };
                v775 = arith.constant 0 : u32;
                v708 = arith.constant 1 : u32;
                v768 = cf.select v349, v708, v775 : u32;
                v776 = ub.poison i32 : i32;
                v767 = cf.select v349, v316, v776 : i32;
                v777 = ub.poison i32 : i32;
                v766 = cf.select v349, v305, v777 : i32;
                v778 = ub.poison i32 : i32;
                v765 = cf.select v349, v778, v316 : i32;
                v779 = ub.poison i32 : i32;
                v764 = cf.select v349, v779, v305 : i32;
                scf.yield v764, v765, v766, v763, v767, v768;
            };
            v721, v722, v723 = scf.index_switch v720 : i32, i32, i32 
            case 0 {
            ^block47:
                v774 = arith.constant 4 : u32;
                v352 = hir.bitcast v715 : u32;
                v354 = arith.add v352, v774 : u32 #[overflow = checked];
                v773 = arith.constant 4 : u32;
                v356 = arith.mod v354, v773 : u32;
                hir.assertz v356 #[code = 250];
                v772 = arith.constant 0 : i32;
                v357 = hir.int_to_ptr v354 : ptr<byte, i32>;
                hir.store v357, v772;
                v771 = arith.constant 1 : i32;
                scf.yield v715, v771, v716;
            }
            default {
            ^block100:
                scf.yield v717, v718, v719;
            };
            v431 = hir.bitcast v721 : u32;
            v770 = arith.constant 4 : u32;
            v433 = arith.mod v431, v770 : u32;
            hir.assertz v433 #[code = 250];
            v434 = hir.int_to_ptr v431 : ptr<byte, i32>;
            hir.store v434, v722;
            v769 = arith.constant 16 : i32;
            v439 = arith.add v723, v769 : i32 #[overflow = wrapping];
            v440 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v441 = hir.bitcast v440 : ptr<byte, i32>;
            hir.store v441, v439;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v442: i32, v443: i32, v444: i32) {
        ^block57(v442: i32, v443: i32, v444: i32):
            v446 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v447 = hir.bitcast v446 : ptr<byte, i32>;
            v448 = hir.load v447 : i32;
            v449 = arith.constant 16 : i32;
            v450 = arith.sub v448, v449 : i32 #[overflow = wrapping];
            v451 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v452 = hir.bitcast v451 : ptr<byte, i32>;
            hir.store v452, v450;
            v445 = arith.constant 0 : i32;
            v453 = arith.constant 8 : i32;
            v454 = arith.add v450, v453 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements/alloc::alloc::Global::alloc_impl(v454, v443, v444, v445)
            v457 = arith.constant 12 : u32;
            v456 = hir.bitcast v450 : u32;
            v458 = arith.add v456, v457 : u32 #[overflow = checked];
            v459 = arith.constant 4 : u32;
            v460 = arith.mod v458, v459 : u32;
            hir.assertz v460 #[code = 250];
            v461 = hir.int_to_ptr v458 : ptr<byte, i32>;
            v462 = hir.load v461 : i32;
            v464 = arith.constant 8 : u32;
            v463 = hir.bitcast v450 : u32;
            v465 = arith.add v463, v464 : u32 #[overflow = checked];
            v808 = arith.constant 4 : u32;
            v467 = arith.mod v465, v808 : u32;
            hir.assertz v467 #[code = 250];
            v468 = hir.int_to_ptr v465 : ptr<byte, i32>;
            v469 = hir.load v468 : i32;
            v470 = hir.bitcast v442 : u32;
            v807 = arith.constant 4 : u32;
            v472 = arith.mod v470, v807 : u32;
            hir.assertz v472 #[code = 250];
            v473 = hir.int_to_ptr v470 : ptr<byte, i32>;
            hir.store v473, v469;
            v806 = arith.constant 4 : u32;
            v474 = hir.bitcast v442 : u32;
            v476 = arith.add v474, v806 : u32 #[overflow = checked];
            v805 = arith.constant 4 : u32;
            v478 = arith.mod v476, v805 : u32;
            hir.assertz v478 #[code = 250];
            v479 = hir.int_to_ptr v476 : ptr<byte, i32>;
            hir.store v479, v462;
            v804 = arith.constant 16 : i32;
            v481 = arith.add v450, v804 : i32 #[overflow = wrapping];
            v482 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements/__stack_pointer : ptr<byte, u8>
            v483 = hir.bitcast v482 : ptr<byte, i32>;
            hir.store v483, v481;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v484: i32, v485: i32, v486: i32, v487: i32) {
        ^block59(v484: i32, v485: i32, v486: i32, v487: i32):
            v824 = arith.constant 0 : i32;
            v488 = arith.constant 0 : i32;
            v489 = arith.eq v486, v488 : i1;
            v490 = arith.zext v489 : u32;
            v491 = hir.bitcast v490 : i32;
            v493 = arith.neq v491, v824 : i1;
            v820 = scf.if v493 : i32 {
            ^block103:
                scf.yield v485;
            } else {
            ^block62:
                v823 = arith.constant 0 : i32;
                v502 = arith.neq v487, v823 : i1;
                v819 = scf.if v502 : i32 {
                ^block63:
                    v504 = hir.exec @root_ns:root@1.0.0/hash_elements/__rustc::__rust_alloc_zeroed(v486, v485) : i32
                    scf.yield v504;
                } else {
                ^block64:
                    v503 = hir.exec @root_ns:root@1.0.0/hash_elements/__rustc::__rust_alloc(v486, v485) : i32
                    scf.yield v503;
                };
                scf.yield v819;
            };
            v508 = arith.constant 4 : u32;
            v507 = hir.bitcast v484 : u32;
            v509 = arith.add v507, v508 : u32 #[overflow = checked];
            v822 = arith.constant 4 : u32;
            v511 = arith.mod v509, v822 : u32;
            hir.assertz v511 #[code = 250];
            v512 = hir.int_to_ptr v509 : ptr<byte, i32>;
            hir.store v512, v486;
            v514 = hir.bitcast v484 : u32;
            v821 = arith.constant 4 : u32;
            v516 = arith.mod v514, v821 : u32;
            hir.assertz v516 #[code = 250];
            v517 = hir.int_to_ptr v514 : ptr<byte, i32>;
            hir.store v517, v820;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v518: i32, v519: i32, v520: i32, v521: i32) {
        ^block65(v518: i32, v519: i32, v520: i32, v521: i32):
            v850 = arith.constant 0 : i32;
            v522 = arith.constant 0 : i32;
            v526 = arith.eq v521, v522 : i1;
            v527 = arith.zext v526 : u32;
            v528 = hir.bitcast v527 : i32;
            v530 = arith.neq v528, v850 : i1;
            v837, v838 = scf.if v530 : i32, i32 {
            ^block107:
                v849 = arith.constant 0 : i32;
                v524 = arith.constant 4 : i32;
                scf.yield v524, v849;
            } else {
            ^block68:
                v531 = hir.bitcast v519 : u32;
                v566 = arith.constant 4 : u32;
                v533 = arith.mod v531, v566 : u32;
                hir.assertz v533 #[code = 250];
                v534 = hir.int_to_ptr v531 : ptr<byte, i32>;
                v535 = hir.load v534 : i32;
                v847 = arith.constant 0 : i32;
                v848 = arith.constant 0 : i32;
                v537 = arith.eq v535, v848 : i1;
                v538 = arith.zext v537 : u32;
                v539 = hir.bitcast v538 : i32;
                v541 = arith.neq v539, v847 : i1;
                v835 = scf.if v541 : i32 {
                ^block106:
                    v846 = arith.constant 0 : i32;
                    scf.yield v846;
                } else {
                ^block69:
                    v845 = arith.constant 4 : u32;
                    v542 = hir.bitcast v518 : u32;
                    v544 = arith.add v542, v845 : u32 #[overflow = checked];
                    v844 = arith.constant 4 : u32;
                    v546 = arith.mod v544, v844 : u32;
                    hir.assertz v546 #[code = 250];
                    v547 = hir.int_to_ptr v544 : ptr<byte, i32>;
                    hir.store v547, v520;
                    v843 = arith.constant 4 : u32;
                    v548 = hir.bitcast v519 : u32;
                    v550 = arith.add v548, v843 : u32 #[overflow = checked];
                    v842 = arith.constant 4 : u32;
                    v552 = arith.mod v550, v842 : u32;
                    hir.assertz v552 #[code = 250];
                    v553 = hir.int_to_ptr v550 : ptr<byte, i32>;
                    v554 = hir.load v553 : i32;
                    v555 = hir.bitcast v518 : u32;
                    v841 = arith.constant 4 : u32;
                    v557 = arith.mod v555, v841 : u32;
                    hir.assertz v557 #[code = 250];
                    v558 = hir.int_to_ptr v555 : ptr<byte, i32>;
                    hir.store v558, v554;
                    v559 = arith.mul v535, v521 : i32 #[overflow = wrapping];
                    scf.yield v559;
                };
                v560 = arith.constant 8 : i32;
                v840 = arith.constant 4 : i32;
                v836 = cf.select v541, v840, v560 : i32;
                scf.yield v836, v835;
            };
            v563 = arith.add v518, v837 : i32 #[overflow = wrapping];
            v565 = hir.bitcast v563 : u32;
            v839 = arith.constant 4 : u32;
            v567 = arith.mod v565, v839 : u32;
            hir.assertz v567 #[code = 250];
            v568 = hir.int_to_ptr v565 : ptr<byte, i32>;
            hir.store v568, v838;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v569: i32, v570: i32, v571: i32) {
        ^block70(v569: i32, v570: i32, v571: i32):
            v852 = arith.constant 0 : i32;
            v572 = arith.constant 0 : i32;
            v573 = arith.eq v571, v572 : i1;
            v574 = arith.zext v573 : u32;
            v575 = hir.bitcast v574 : i32;
            v577 = arith.neq v575, v852 : i1;
            scf.if v577{
            ^block72:
                scf.yield ;
            } else {
            ^block73:
                hir.exec @root_ns:root@1.0.0/hash_elements/__rustc::__rust_dealloc(v569, v571, v570)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v578: i32, v579: i32, v580: i32) {
        ^block74(v578: i32, v579: i32, v580: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v581: i32, v582: i32) -> i32 {
        ^block76(v581: i32, v582: i32):
            v589 = arith.constant 0 : i32;
            v585 = hir.bitcast v582 : u32;
            v584 = hir.bitcast v581 : u32;
            v586 = arith.gt v584, v585 : i1;
            v587 = arith.zext v586 : u32;
            v588 = hir.bitcast v587 : i32;
            v590 = arith.neq v588, v589 : i1;
            v591 = cf.select v590, v581, v582 : i32;
            builtin.ret v591;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.segment readonly @1048576 = 0x0000002a000000db0000003200100000000073722e7365687361682f6f74707972632f62696c6474732f6372732f352e312e302d7379732d62696c6474732d6e6564696d;
    };
};