builtin.component root_ns:root@1.0.0 {
    builtin.module public @vec_alloc_new {
        public builtin.function @entrypoint(v0: felt) -> felt {
        ^block6(v0: felt):
            v4 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_new/__stack_pointer : ptr<byte, u8>
            v5 = hir.bitcast v4 : ptr<byte, i32>;
            v6 = hir.load v5 : i32;
            v7 = arith.constant 32 : i32;
            v8 = arith.sub v6, v7 : i32 #[overflow = wrapping];
            v9 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_new/__stack_pointer : ptr<byte, u8>
            v10 = hir.bitcast v9 : ptr<byte, i32>;
            hir.store v10, v8;
            v15 = arith.constant 4 : i32;
            v2 = arith.constant 0 : i32;
            v13 = arith.constant 1 : i32;
            v11 = arith.constant 20 : i32;
            v12 = arith.add v8, v11 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/vec_alloc_new/alloc::raw_vec::RawVecInner<A>::try_allocate_in(v12, v13, v2, v15, v15)
            v18 = arith.constant 24 : u32;
            v17 = hir.bitcast v8 : u32;
            v19 = arith.add v17, v18 : u32 #[overflow = checked];
            v20 = arith.constant 4 : u32;
            v21 = arith.mod v19, v20 : u32;
            hir.assertz v21 #[code = 250];
            v22 = hir.int_to_ptr v19 : ptr<byte, i32>;
            v23 = hir.load v22 : i32;
            v25 = arith.constant 20 : u32;
            v24 = hir.bitcast v8 : u32;
            v26 = arith.add v24, v25 : u32 #[overflow = checked];
            v535 = arith.constant 4 : u32;
            v28 = arith.mod v26, v535 : u32;
            hir.assertz v28 #[code = 250];
            v29 = hir.int_to_ptr v26 : ptr<byte, i32>;
            v30 = hir.load v29 : i32;
            v533 = arith.constant 0 : i32;
            v534 = arith.constant 1 : i32;
            v32 = arith.neq v30, v534 : i1;
            v33 = arith.zext v32 : u32;
            v34 = hir.bitcast v33 : i32;
            v36 = arith.neq v34, v533 : i1;
            cf.cond_br v36 ^block8, ^block9;
        ^block8:
            v47 = arith.constant 16 : u32;
            v46 = hir.bitcast v8 : u32;
            v48 = arith.add v46, v47 : u32 #[overflow = checked];
            v532 = arith.constant 4 : u32;
            v50 = arith.mod v48, v532 : u32;
            hir.assertz v50 #[code = 250];
            v531 = arith.constant 0 : i32;
            v51 = hir.int_to_ptr v48 : ptr<byte, i32>;
            hir.store v51, v531;
            v53 = arith.constant 28 : u32;
            v52 = hir.bitcast v8 : u32;
            v54 = arith.add v52, v53 : u32 #[overflow = checked];
            v530 = arith.constant 4 : u32;
            v56 = arith.mod v54, v530 : u32;
            hir.assertz v56 #[code = 250];
            v57 = hir.int_to_ptr v54 : ptr<byte, i32>;
            v58 = hir.load v57 : i32;
            v60 = arith.constant 12 : u32;
            v59 = hir.bitcast v8 : u32;
            v61 = arith.add v59, v60 : u32 #[overflow = checked];
            v529 = arith.constant 4 : u32;
            v63 = arith.mod v61, v529 : u32;
            hir.assertz v63 #[code = 250];
            v64 = hir.int_to_ptr v61 : ptr<byte, i32>;
            hir.store v64, v58;
            v66 = arith.constant 8 : u32;
            v65 = hir.bitcast v8 : u32;
            v67 = arith.add v65, v66 : u32 #[overflow = checked];
            v528 = arith.constant 4 : u32;
            v69 = arith.mod v67, v528 : u32;
            hir.assertz v69 #[code = 250];
            v70 = hir.int_to_ptr v67 : ptr<byte, i32>;
            hir.store v70, v23;
            v521 = arith.constant 1114128 : felt;
            v71 = hir.bitcast v58 : felt;
            hir.assert_eq v71, v521;
            v527 = arith.constant 4 : i32;
            v76 = arith.constant 8 : i32;
            v77 = arith.add v8, v76 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/vec_alloc_new/alloc::raw_vec::RawVecInner<A>::deallocate(v77, v527, v527)
            v526 = arith.constant 32 : i32;
            v81 = arith.add v8, v526 : i32 #[overflow = wrapping];
            v82 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_new/__stack_pointer : ptr<byte, u8>
            v83 = hir.bitcast v82 : ptr<byte, i32>;
            hir.store v83, v81;
            v520 = arith.constant 0 : felt;
            builtin.ret v520;
        ^block9:
            v525 = arith.constant 28 : u32;
            v37 = hir.bitcast v8 : u32;
            v39 = arith.add v37, v525 : u32 #[overflow = checked];
            v524 = arith.constant 4 : u32;
            v41 = arith.mod v39, v524 : u32;
            hir.assertz v41 #[code = 250];
            v42 = hir.int_to_ptr v39 : ptr<byte, i32>;
            v43 = hir.load v42 : i32;
            v44 = arith.constant 1048588 : i32;
            hir.exec @root_ns:root@1.0.0/vec_alloc_new/alloc::raw_vec::handle_error(v23, v43, v44)
            ub.unreachable ;
        };

        private builtin.function @__rustc::__rust_alloc(v84: i32, v85: i32) -> i32 {
        ^block10(v84: i32, v85: i32):
            v87 = arith.constant 1048604 : i32;
            v88 = hir.exec @root_ns:root@1.0.0/vec_alloc_new/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v87, v85, v84) : i32
            builtin.ret v88;
        };

        private builtin.function @__rustc::__rust_dealloc(v89: i32, v90: i32, v91: i32) {
        ^block12(v89: i32, v90: i32, v91: i32):
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v92: i32, v93: i32) -> i32 {
        ^block14(v92: i32, v93: i32):
            v95 = arith.constant 1048604 : i32;
            v96 = hir.exec @root_ns:root@1.0.0/vec_alloc_new/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v95, v93, v92) : i32
            v544 = arith.constant 0 : i32;
            v97 = arith.constant 0 : i32;
            v98 = arith.eq v96, v97 : i1;
            v99 = arith.zext v98 : u32;
            v100 = hir.bitcast v99 : i32;
            v102 = arith.neq v100, v544 : i1;
            scf.if v102{
            ^block16:
                scf.yield ;
            } else {
            ^block17:
                v542 = arith.constant 0 : i32;
                v543 = arith.constant 0 : i32;
                v104 = arith.eq v92, v543 : i1;
                v105 = arith.zext v104 : u32;
                v106 = hir.bitcast v105 : i32;
                v108 = arith.neq v106, v542 : i1;
                scf.if v108{
                ^block71:
                    scf.yield ;
                } else {
                ^block18:
                    v536 = arith.constant 0 : u8;
                    v111 = hir.bitcast v92 : u32;
                    v112 = hir.bitcast v96 : u32;
                    v113 = hir.int_to_ptr v112 : ptr<byte, u8>;
                    hir.mem_set v113, v111, v536;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v96;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block19:
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v115: i32, v116: i32, v117: i32) -> i32 {
        ^block21(v115: i32, v116: i32, v117: i32):
            v120 = arith.constant 16 : i32;
            v119 = arith.constant 0 : i32;
            v546 = arith.constant 16 : u32;
            v122 = hir.bitcast v116 : u32;
            v124 = arith.gt v122, v546 : i1;
            v125 = arith.zext v124 : u32;
            v126 = hir.bitcast v125 : i32;
            v128 = arith.neq v126, v119 : i1;
            v129 = cf.select v128, v116, v120 : i32;
            v585 = arith.constant 0 : i32;
            v130 = arith.constant -1 : i32;
            v131 = arith.add v129, v130 : i32 #[overflow = wrapping];
            v132 = arith.band v129, v131 : i32;
            v134 = arith.neq v132, v585 : i1;
            v555, v556 = scf.if v134 : i32, u32 {
            ^block76:
                v547 = arith.constant 0 : u32;
                v551 = ub.poison i32 : i32;
                scf.yield v551, v547;
            } else {
            ^block24:
                v136 = hir.exec @root_ns:root@1.0.0/vec_alloc_new/core::ptr::alignment::Alignment::max(v116, v129) : i32
                v584 = arith.constant 0 : i32;
                v135 = arith.constant -2147483648 : i32;
                v137 = arith.sub v135, v136 : i32 #[overflow = wrapping];
                v139 = hir.bitcast v137 : u32;
                v138 = hir.bitcast v117 : u32;
                v140 = arith.gt v138, v139 : i1;
                v141 = arith.zext v140 : u32;
                v142 = hir.bitcast v141 : i32;
                v144 = arith.neq v142, v584 : i1;
                v570 = scf.if v144 : i32 {
                ^block75:
                    v583 = ub.poison i32 : i32;
                    scf.yield v583;
                } else {
                ^block25:
                    v581 = arith.constant 0 : i32;
                    v150 = arith.sub v581, v136 : i32 #[overflow = wrapping];
                    v582 = arith.constant -1 : i32;
                    v146 = arith.add v117, v136 : i32 #[overflow = wrapping];
                    v148 = arith.add v146, v582 : i32 #[overflow = wrapping];
                    v151 = arith.band v148, v150 : i32;
                    v152 = hir.bitcast v115 : u32;
                    v153 = arith.constant 4 : u32;
                    v154 = arith.mod v152, v153 : u32;
                    hir.assertz v154 #[code = 250];
                    v155 = hir.int_to_ptr v152 : ptr<byte, i32>;
                    v156 = hir.load v155 : i32;
                    v580 = arith.constant 0 : i32;
                    v158 = arith.neq v156, v580 : i1;
                    scf.if v158{
                    ^block74:
                        scf.yield ;
                    } else {
                    ^block27:
                        v159 = hir.exec @intrinsics/mem/heap_base() : i32
                        v160 = hir.mem_size  : u32;
                        v166 = hir.bitcast v115 : u32;
                        v579 = arith.constant 4 : u32;
                        v168 = arith.mod v166, v579 : u32;
                        hir.assertz v168 #[code = 250];
                        v578 = arith.constant 16 : u32;
                        v161 = hir.bitcast v160 : i32;
                        v164 = arith.shl v161, v578 : i32;
                        v165 = arith.add v159, v164 : i32 #[overflow = wrapping];
                        v169 = hir.int_to_ptr v166 : ptr<byte, i32>;
                        hir.store v169, v165;
                        scf.yield ;
                    };
                    v172 = hir.bitcast v115 : u32;
                    v577 = arith.constant 4 : u32;
                    v174 = arith.mod v172, v577 : u32;
                    hir.assertz v174 #[code = 250];
                    v175 = hir.int_to_ptr v172 : ptr<byte, i32>;
                    v176 = hir.load v175 : i32;
                    v576 = arith.constant 0 : i32;
                    v180 = hir.bitcast v151 : u32;
                    v170 = arith.constant 268435456 : i32;
                    v177 = arith.sub v170, v176 : i32 #[overflow = wrapping];
                    v179 = hir.bitcast v177 : u32;
                    v181 = arith.lt v179, v180 : i1;
                    v182 = arith.zext v181 : u32;
                    v183 = hir.bitcast v182 : i32;
                    v185 = arith.neq v183, v576 : i1;
                    v569 = scf.if v185 : i32 {
                    ^block28:
                        v575 = arith.constant 0 : i32;
                        scf.yield v575;
                    } else {
                    ^block29:
                        v187 = hir.bitcast v115 : u32;
                        v574 = arith.constant 4 : u32;
                        v189 = arith.mod v187, v574 : u32;
                        hir.assertz v189 #[code = 250];
                        v186 = arith.add v176, v151 : i32 #[overflow = wrapping];
                        v190 = hir.int_to_ptr v187 : ptr<byte, i32>;
                        hir.store v190, v186;
                        v192 = arith.add v176, v136 : i32 #[overflow = wrapping];
                        scf.yield v192;
                    };
                    scf.yield v569;
                };
                v552 = arith.constant 1 : u32;
                v573 = arith.constant 0 : u32;
                v571 = cf.select v144, v573, v552 : u32;
                scf.yield v570, v571;
            };
            v572 = arith.constant 0 : u32;
            v568 = arith.eq v556, v572 : i1;
            cf.cond_br v568 ^block23, ^block78(v555);
        ^block23:
            ub.unreachable ;
        ^block78(v548: i32):
            builtin.ret v548;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v195: i32, v196: i32, v197: i32) {
        ^block30(v195: i32, v196: i32, v197: i32):
            v199 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_new/__stack_pointer : ptr<byte, u8>
            v200 = hir.bitcast v199 : ptr<byte, i32>;
            v201 = hir.load v200 : i32;
            v202 = arith.constant 16 : i32;
            v203 = arith.sub v201, v202 : i32 #[overflow = wrapping];
            v204 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_new/__stack_pointer : ptr<byte, u8>
            v205 = hir.bitcast v204 : ptr<byte, i32>;
            hir.store v205, v203;
            v206 = arith.constant 4 : i32;
            v207 = arith.add v203, v206 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/vec_alloc_new/alloc::raw_vec::RawVecInner<A>::current_memory(v207, v195, v196, v197)
            v209 = arith.constant 8 : u32;
            v208 = hir.bitcast v203 : u32;
            v210 = arith.add v208, v209 : u32 #[overflow = checked];
            v211 = arith.constant 4 : u32;
            v212 = arith.mod v210, v211 : u32;
            hir.assertz v212 #[code = 250];
            v213 = hir.int_to_ptr v210 : ptr<byte, i32>;
            v214 = hir.load v213 : i32;
            v592 = arith.constant 0 : i32;
            v198 = arith.constant 0 : i32;
            v216 = arith.eq v214, v198 : i1;
            v217 = arith.zext v216 : u32;
            v218 = hir.bitcast v217 : i32;
            v220 = arith.neq v218, v592 : i1;
            scf.if v220{
            ^block82:
                scf.yield ;
            } else {
            ^block33:
                v591 = arith.constant 4 : u32;
                v221 = hir.bitcast v203 : u32;
                v223 = arith.add v221, v591 : u32 #[overflow = checked];
                v590 = arith.constant 4 : u32;
                v225 = arith.mod v223, v590 : u32;
                hir.assertz v225 #[code = 250];
                v226 = hir.int_to_ptr v223 : ptr<byte, i32>;
                v227 = hir.load v226 : i32;
                v229 = arith.constant 12 : u32;
                v228 = hir.bitcast v203 : u32;
                v230 = arith.add v228, v229 : u32 #[overflow = checked];
                v589 = arith.constant 4 : u32;
                v232 = arith.mod v230, v589 : u32;
                hir.assertz v232 #[code = 250];
                v233 = hir.int_to_ptr v230 : ptr<byte, i32>;
                v234 = hir.load v233 : i32;
                hir.exec @root_ns:root@1.0.0/vec_alloc_new/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v227, v214, v234)
                scf.yield ;
            };
            v588 = arith.constant 16 : i32;
            v237 = arith.add v203, v588 : i32 #[overflow = wrapping];
            v238 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_new/__stack_pointer : ptr<byte, u8>
            v239 = hir.bitcast v238 : ptr<byte, i32>;
            hir.store v239, v237;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::try_allocate_in(v240: i32, v241: i32, v242: i32, v243: i32, v244: i32) {
        ^block34(v240: i32, v241: i32, v242: i32, v243: i32, v244: i32):
            v247 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_new/__stack_pointer : ptr<byte, u8>
            v248 = hir.bitcast v247 : ptr<byte, i32>;
            v249 = hir.load v248 : i32;
            v250 = arith.constant 16 : i32;
            v251 = arith.sub v249, v250 : i32 #[overflow = wrapping];
            v252 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_new/__stack_pointer : ptr<byte, u8>
            v253 = hir.bitcast v252 : ptr<byte, i32>;
            hir.store v253, v251;
            v263 = hir.bitcast v241 : u32;
            v264 = arith.zext v263 : u64;
            v265 = hir.bitcast v264 : i64;
            v245 = arith.constant 0 : i32;
            v258 = arith.sub v245, v243 : i32 #[overflow = wrapping];
            v255 = arith.constant -1 : i32;
            v254 = arith.add v243, v244 : i32 #[overflow = wrapping];
            v256 = arith.add v254, v255 : i32 #[overflow = wrapping];
            v259 = arith.band v256, v258 : i32;
            v260 = hir.bitcast v259 : u32;
            v261 = arith.zext v260 : u64;
            v262 = hir.bitcast v261 : i64;
            v266 = arith.mul v262, v265 : i64 #[overflow = wrapping];
            v696 = arith.constant 0 : i32;
            v267 = arith.constant 32 : i64;
            v269 = hir.cast v267 : u32;
            v268 = hir.bitcast v266 : u64;
            v270 = arith.shr v268, v269 : u64;
            v271 = hir.bitcast v270 : i64;
            v272 = arith.trunc v271 : i32;
            v274 = arith.neq v272, v696 : i1;
            v608, v609, v610, v611, v612, v613 = scf.if v274 : i32, i32, i32, i32, i32, u32 {
            ^block84:
                v593 = arith.constant 0 : u32;
                v600 = ub.poison i32 : i32;
                scf.yield v240, v251, v600, v600, v600, v593;
            } else {
            ^block39:
                v275 = arith.trunc v266 : i32;
                v695 = arith.constant 0 : i32;
                v276 = arith.constant -2147483648 : i32;
                v277 = arith.sub v276, v243 : i32 #[overflow = wrapping];
                v279 = hir.bitcast v277 : u32;
                v278 = hir.bitcast v275 : u32;
                v280 = arith.lte v278, v279 : i1;
                v281 = arith.zext v280 : u32;
                v282 = hir.bitcast v281 : i32;
                v284 = arith.neq v282, v695 : i1;
                v656 = scf.if v284 : i32 {
                ^block37:
                    v694 = arith.constant 0 : i32;
                    v295 = arith.neq v275, v694 : i1;
                    v655 = scf.if v295 : i32 {
                    ^block41:
                        v693 = arith.constant 0 : i32;
                        v311 = arith.neq v242, v693 : i1;
                        v654 = scf.if v311 : i32 {
                        ^block44:
                            v293 = arith.constant 1 : i32;
                            hir.exec @root_ns:root@1.0.0/vec_alloc_new/alloc::alloc::Global::alloc_impl(v251, v243, v275, v293)
                            v322 = hir.bitcast v251 : u32;
                            v367 = arith.constant 4 : u32;
                            v324 = arith.mod v322, v367 : u32;
                            hir.assertz v324 #[code = 250];
                            v325 = hir.int_to_ptr v322 : ptr<byte, i32>;
                            v326 = hir.load v325 : i32;
                            scf.yield v326;
                        } else {
                        ^block45:
                            v312 = arith.constant 8 : i32;
                            v313 = arith.add v251, v312 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/vec_alloc_new/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v313, v243, v275)
                            v297 = arith.constant 8 : u32;
                            v314 = hir.bitcast v251 : u32;
                            v316 = arith.add v314, v297 : u32 #[overflow = checked];
                            v692 = arith.constant 4 : u32;
                            v318 = arith.mod v316, v692 : u32;
                            hir.assertz v318 #[code = 250];
                            v319 = hir.int_to_ptr v316 : ptr<byte, i32>;
                            v320 = hir.load v319 : i32;
                            scf.yield v320;
                        };
                        v690 = arith.constant 0 : i32;
                        v691 = arith.constant 0 : i32;
                        v329 = arith.eq v654, v691 : i1;
                        v330 = arith.zext v329 : u32;
                        v331 = hir.bitcast v330 : i32;
                        v333 = arith.neq v331, v690 : i1;
                        scf.if v333{
                        ^block46:
                            v689 = arith.constant 8 : u32;
                            v350 = hir.bitcast v240 : u32;
                            v352 = arith.add v350, v689 : u32 #[overflow = checked];
                            v688 = arith.constant 4 : u32;
                            v354 = arith.mod v352, v688 : u32;
                            hir.assertz v354 #[code = 250];
                            v355 = hir.int_to_ptr v352 : ptr<byte, i32>;
                            hir.store v355, v275;
                            v687 = arith.constant 4 : u32;
                            v357 = hir.bitcast v240 : u32;
                            v359 = arith.add v357, v687 : u32 #[overflow = checked];
                            v686 = arith.constant 4 : u32;
                            v361 = arith.mod v359, v686 : u32;
                            hir.assertz v361 #[code = 250];
                            v362 = hir.int_to_ptr v359 : ptr<byte, i32>;
                            hir.store v362, v243;
                            scf.yield ;
                        } else {
                        ^block47:
                            v685 = arith.constant 8 : u32;
                            v335 = hir.bitcast v240 : u32;
                            v337 = arith.add v335, v685 : u32 #[overflow = checked];
                            v684 = arith.constant 4 : u32;
                            v339 = arith.mod v337, v684 : u32;
                            hir.assertz v339 #[code = 250];
                            v340 = hir.int_to_ptr v337 : ptr<byte, i32>;
                            hir.store v340, v654;
                            v683 = arith.constant 4 : u32;
                            v342 = hir.bitcast v240 : u32;
                            v344 = arith.add v342, v683 : u32 #[overflow = checked];
                            v682 = arith.constant 4 : u32;
                            v346 = arith.mod v344, v682 : u32;
                            hir.assertz v346 #[code = 250];
                            v347 = hir.int_to_ptr v344 : ptr<byte, i32>;
                            hir.store v347, v241;
                            scf.yield ;
                        };
                        v680 = arith.constant 0 : i32;
                        v681 = arith.constant 1 : i32;
                        v653 = cf.select v333, v681, v680 : i32;
                        scf.yield v653;
                    } else {
                    ^block42:
                        v679 = arith.constant 8 : u32;
                        v296 = hir.bitcast v240 : u32;
                        v298 = arith.add v296, v679 : u32 #[overflow = checked];
                        v678 = arith.constant 4 : u32;
                        v300 = arith.mod v298, v678 : u32;
                        hir.assertz v300 #[code = 250];
                        v301 = hir.int_to_ptr v298 : ptr<byte, i32>;
                        hir.store v301, v243;
                        v677 = arith.constant 4 : u32;
                        v304 = hir.bitcast v240 : u32;
                        v306 = arith.add v304, v677 : u32 #[overflow = checked];
                        v676 = arith.constant 4 : u32;
                        v308 = arith.mod v306, v676 : u32;
                        hir.assertz v308 #[code = 250];
                        v675 = arith.constant 0 : i32;
                        v309 = hir.int_to_ptr v306 : ptr<byte, i32>;
                        hir.store v309, v675;
                        v674 = arith.constant 0 : i32;
                        scf.yield v674;
                    };
                    scf.yield v655;
                } else {
                ^block40:
                    v673 = ub.poison i32 : i32;
                    scf.yield v673;
                };
                v668 = arith.constant 0 : u32;
                v601 = arith.constant 1 : u32;
                v661 = cf.select v284, v601, v668 : u32;
                v669 = ub.poison i32 : i32;
                v660 = cf.select v284, v251, v669 : i32;
                v670 = ub.poison i32 : i32;
                v659 = cf.select v284, v240, v670 : i32;
                v671 = ub.poison i32 : i32;
                v658 = cf.select v284, v671, v251 : i32;
                v672 = ub.poison i32 : i32;
                v657 = cf.select v284, v672, v240 : i32;
                scf.yield v657, v658, v659, v656, v660, v661;
            };
            v614, v615, v616 = scf.index_switch v613 : i32, i32, i32 
            case 0 {
            ^block38:
                v667 = arith.constant 4 : u32;
                v287 = hir.bitcast v608 : u32;
                v289 = arith.add v287, v667 : u32 #[overflow = checked];
                v666 = arith.constant 4 : u32;
                v291 = arith.mod v289, v666 : u32;
                hir.assertz v291 #[code = 250];
                v665 = arith.constant 0 : i32;
                v292 = hir.int_to_ptr v289 : ptr<byte, i32>;
                hir.store v292, v665;
                v664 = arith.constant 1 : i32;
                scf.yield v608, v664, v609;
            }
            default {
            ^block88:
                scf.yield v610, v611, v612;
            };
            v366 = hir.bitcast v614 : u32;
            v663 = arith.constant 4 : u32;
            v368 = arith.mod v366, v663 : u32;
            hir.assertz v368 #[code = 250];
            v369 = hir.int_to_ptr v366 : ptr<byte, i32>;
            hir.store v369, v615;
            v662 = arith.constant 16 : i32;
            v374 = arith.add v616, v662 : i32 #[overflow = wrapping];
            v375 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_new/__stack_pointer : ptr<byte, u8>
            v376 = hir.bitcast v375 : ptr<byte, i32>;
            hir.store v376, v374;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v377: i32, v378: i32, v379: i32) {
        ^block48(v377: i32, v378: i32, v379: i32):
            v381 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_new/__stack_pointer : ptr<byte, u8>
            v382 = hir.bitcast v381 : ptr<byte, i32>;
            v383 = hir.load v382 : i32;
            v384 = arith.constant 16 : i32;
            v385 = arith.sub v383, v384 : i32 #[overflow = wrapping];
            v386 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_new/__stack_pointer : ptr<byte, u8>
            v387 = hir.bitcast v386 : ptr<byte, i32>;
            hir.store v387, v385;
            v380 = arith.constant 0 : i32;
            v388 = arith.constant 8 : i32;
            v389 = arith.add v385, v388 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/vec_alloc_new/alloc::alloc::Global::alloc_impl(v389, v378, v379, v380)
            v392 = arith.constant 12 : u32;
            v391 = hir.bitcast v385 : u32;
            v393 = arith.add v391, v392 : u32 #[overflow = checked];
            v394 = arith.constant 4 : u32;
            v395 = arith.mod v393, v394 : u32;
            hir.assertz v395 #[code = 250];
            v396 = hir.int_to_ptr v393 : ptr<byte, i32>;
            v397 = hir.load v396 : i32;
            v399 = arith.constant 8 : u32;
            v398 = hir.bitcast v385 : u32;
            v400 = arith.add v398, v399 : u32 #[overflow = checked];
            v701 = arith.constant 4 : u32;
            v402 = arith.mod v400, v701 : u32;
            hir.assertz v402 #[code = 250];
            v403 = hir.int_to_ptr v400 : ptr<byte, i32>;
            v404 = hir.load v403 : i32;
            v405 = hir.bitcast v377 : u32;
            v700 = arith.constant 4 : u32;
            v407 = arith.mod v405, v700 : u32;
            hir.assertz v407 #[code = 250];
            v408 = hir.int_to_ptr v405 : ptr<byte, i32>;
            hir.store v408, v404;
            v699 = arith.constant 4 : u32;
            v409 = hir.bitcast v377 : u32;
            v411 = arith.add v409, v699 : u32 #[overflow = checked];
            v698 = arith.constant 4 : u32;
            v413 = arith.mod v411, v698 : u32;
            hir.assertz v413 #[code = 250];
            v414 = hir.int_to_ptr v411 : ptr<byte, i32>;
            hir.store v414, v397;
            v697 = arith.constant 16 : i32;
            v416 = arith.add v385, v697 : i32 #[overflow = wrapping];
            v417 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_new/__stack_pointer : ptr<byte, u8>
            v418 = hir.bitcast v417 : ptr<byte, i32>;
            hir.store v418, v416;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v419: i32, v420: i32, v421: i32, v422: i32) {
        ^block50(v419: i32, v420: i32, v421: i32, v422: i32):
            v717 = arith.constant 0 : i32;
            v423 = arith.constant 0 : i32;
            v424 = arith.eq v421, v423 : i1;
            v425 = arith.zext v424 : u32;
            v426 = hir.bitcast v425 : i32;
            v428 = arith.neq v426, v717 : i1;
            v713 = scf.if v428 : i32 {
            ^block91:
                scf.yield v420;
            } else {
            ^block53:
                hir.exec @root_ns:root@1.0.0/vec_alloc_new/__rustc::__rust_no_alloc_shim_is_unstable_v2()
                v716 = arith.constant 0 : i32;
                v430 = arith.neq v422, v716 : i1;
                v712 = scf.if v430 : i32 {
                ^block54:
                    v432 = hir.exec @root_ns:root@1.0.0/vec_alloc_new/__rustc::__rust_alloc_zeroed(v421, v420) : i32
                    scf.yield v432;
                } else {
                ^block55:
                    v431 = hir.exec @root_ns:root@1.0.0/vec_alloc_new/__rustc::__rust_alloc(v421, v420) : i32
                    scf.yield v431;
                };
                scf.yield v712;
            };
            v436 = arith.constant 4 : u32;
            v435 = hir.bitcast v419 : u32;
            v437 = arith.add v435, v436 : u32 #[overflow = checked];
            v715 = arith.constant 4 : u32;
            v439 = arith.mod v437, v715 : u32;
            hir.assertz v439 #[code = 250];
            v440 = hir.int_to_ptr v437 : ptr<byte, i32>;
            hir.store v440, v421;
            v442 = hir.bitcast v419 : u32;
            v714 = arith.constant 4 : u32;
            v444 = arith.mod v442, v714 : u32;
            hir.assertz v444 #[code = 250];
            v445 = hir.int_to_ptr v442 : ptr<byte, i32>;
            hir.store v445, v713;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v446: i32, v447: i32, v448: i32, v449: i32) {
        ^block56(v446: i32, v447: i32, v448: i32, v449: i32):
            v743 = arith.constant 0 : i32;
            v450 = arith.constant 0 : i32;
            v454 = arith.eq v449, v450 : i1;
            v455 = arith.zext v454 : u32;
            v456 = hir.bitcast v455 : i32;
            v458 = arith.neq v456, v743 : i1;
            v730, v731 = scf.if v458 : i32, i32 {
            ^block95:
                v742 = arith.constant 0 : i32;
                v452 = arith.constant 4 : i32;
                scf.yield v452, v742;
            } else {
            ^block59:
                v459 = hir.bitcast v447 : u32;
                v494 = arith.constant 4 : u32;
                v461 = arith.mod v459, v494 : u32;
                hir.assertz v461 #[code = 250];
                v462 = hir.int_to_ptr v459 : ptr<byte, i32>;
                v463 = hir.load v462 : i32;
                v740 = arith.constant 0 : i32;
                v741 = arith.constant 0 : i32;
                v465 = arith.eq v463, v741 : i1;
                v466 = arith.zext v465 : u32;
                v467 = hir.bitcast v466 : i32;
                v469 = arith.neq v467, v740 : i1;
                v728 = scf.if v469 : i32 {
                ^block94:
                    v739 = arith.constant 0 : i32;
                    scf.yield v739;
                } else {
                ^block60:
                    v738 = arith.constant 4 : u32;
                    v470 = hir.bitcast v446 : u32;
                    v472 = arith.add v470, v738 : u32 #[overflow = checked];
                    v737 = arith.constant 4 : u32;
                    v474 = arith.mod v472, v737 : u32;
                    hir.assertz v474 #[code = 250];
                    v475 = hir.int_to_ptr v472 : ptr<byte, i32>;
                    hir.store v475, v448;
                    v736 = arith.constant 4 : u32;
                    v476 = hir.bitcast v447 : u32;
                    v478 = arith.add v476, v736 : u32 #[overflow = checked];
                    v735 = arith.constant 4 : u32;
                    v480 = arith.mod v478, v735 : u32;
                    hir.assertz v480 #[code = 250];
                    v481 = hir.int_to_ptr v478 : ptr<byte, i32>;
                    v482 = hir.load v481 : i32;
                    v483 = hir.bitcast v446 : u32;
                    v734 = arith.constant 4 : u32;
                    v485 = arith.mod v483, v734 : u32;
                    hir.assertz v485 #[code = 250];
                    v486 = hir.int_to_ptr v483 : ptr<byte, i32>;
                    hir.store v486, v482;
                    v487 = arith.mul v463, v449 : i32 #[overflow = wrapping];
                    scf.yield v487;
                };
                v488 = arith.constant 8 : i32;
                v733 = arith.constant 4 : i32;
                v729 = cf.select v469, v733, v488 : i32;
                scf.yield v729, v728;
            };
            v491 = arith.add v446, v730 : i32 #[overflow = wrapping];
            v493 = hir.bitcast v491 : u32;
            v732 = arith.constant 4 : u32;
            v495 = arith.mod v493, v732 : u32;
            hir.assertz v495 #[code = 250];
            v496 = hir.int_to_ptr v493 : ptr<byte, i32>;
            hir.store v496, v731;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v497: i32, v498: i32, v499: i32) {
        ^block61(v497: i32, v498: i32, v499: i32):
            v745 = arith.constant 0 : i32;
            v500 = arith.constant 0 : i32;
            v501 = arith.eq v499, v500 : i1;
            v502 = arith.zext v501 : u32;
            v503 = hir.bitcast v502 : i32;
            v505 = arith.neq v503, v745 : i1;
            scf.if v505{
            ^block63:
                scf.yield ;
            } else {
            ^block64:
                hir.exec @root_ns:root@1.0.0/vec_alloc_new/__rustc::__rust_dealloc(v497, v499, v498)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v506: i32, v507: i32, v508: i32) {
        ^block65(v506: i32, v507: i32, v508: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v509: i32, v510: i32) -> i32 {
        ^block67(v509: i32, v510: i32):
            v517 = arith.constant 0 : i32;
            v513 = hir.bitcast v510 : u32;
            v512 = hir.bitcast v509 : u32;
            v514 = arith.gt v512, v513 : i1;
            v515 = arith.zext v514 : u32;
            v516 = hir.bitcast v515 : i32;
            v518 = arith.neq v516, v517 : i1;
            v519 = cf.select v518, v509, v510 : i32;
            builtin.ret v519;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.segment readonly @1048576 = 0x00000030000000190000000a00100000000073722e62696c2f637273;
    };
};