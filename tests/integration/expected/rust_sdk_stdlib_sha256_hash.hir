builtin.component root_ns:root@1.0.0 {
    builtin.module public @rust_sdk_stdlib_sha256_hash {
        private builtin.function @<[u8]>::reverse(v0: i32, v1: i32) {
        ^block4(v0: i32, v1: i32):
            v9 = arith.constant -1 : i32;
            v8 = arith.add v1, v0 : i32 #[overflow = wrapping];
            v10 = arith.add v8, v9 : i32 #[overflow = wrapping];
            v484 = arith.constant 1 : u32;
            v4 = hir.bitcast v1 : u32;
            v6 = arith.shr v4, v484 : u32;
            v7 = hir.bitcast v6 : i32;
            v492, v493, v494 = scf.while v7, v0, v10 : i32, i32, i32 {
            ^block7(v11: i32, v18: i32, v24: i32):
                v515 = arith.constant 0 : i32;
                v2 = arith.constant 0 : i32;
                v13 = arith.eq v11, v2 : i1;
                v14 = arith.zext v13 : u32;
                v15 = hir.bitcast v14 : i32;
                v17 = arith.neq v15, v515 : i1;
                v507, v508, v509 = scf.if v17 : i32, i32, i32 {
                ^block39:
                    v485 = ub.poison i32 : i32;
                    scf.yield v485, v485, v485;
                } else {
                ^block9:
                    v19 = hir.bitcast v18 : u32;
                    v20 = hir.int_to_ptr v19 : ptr<byte, u8>;
                    v21 = hir.load v20 : u8;
                    v25 = hir.bitcast v24 : u32;
                    v26 = hir.int_to_ptr v25 : ptr<byte, u8>;
                    v27 = hir.load v26 : u8;
                    v28 = arith.zext v27 : u32;
                    v29 = hir.bitcast v28 : i32;
                    v30 = hir.bitcast v29 : u32;
                    v31 = arith.trunc v30 : u8;
                    v32 = hir.bitcast v18 : u32;
                    v33 = hir.int_to_ptr v32 : ptr<byte, u8>;
                    hir.store v33, v31;
                    v22 = arith.zext v21 : u32;
                    v23 = hir.bitcast v22 : i32;
                    v34 = hir.bitcast v23 : u32;
                    v35 = arith.trunc v34 : u8;
                    v36 = hir.bitcast v24 : u32;
                    v37 = hir.int_to_ptr v36 : ptr<byte, u8>;
                    hir.store v37, v35;
                    v513 = arith.constant -1 : i32;
                    v43 = arith.add v24, v513 : i32 #[overflow = wrapping];
                    v3 = arith.constant 1 : i32;
                    v41 = arith.add v18, v3 : i32 #[overflow = wrapping];
                    v514 = arith.constant -1 : i32;
                    v39 = arith.add v11, v514 : i32 #[overflow = wrapping];
                    scf.yield v39, v41, v43;
                };
                v512 = arith.constant 1 : u32;
                v478 = arith.constant 0 : u32;
                v511 = cf.select v17, v478, v512 : u32;
                v501 = arith.trunc v511 : i1;
                scf.condition v501, v507, v508, v509;
            } do {
            ^block38(v498: i32, v499: i32, v500: i32):
                scf.yield v498, v499, v500;
            };
            builtin.ret ;
        };

        private builtin.function @<core::slice::iter::ChunksExactMut<u8> as core::iter::traits::iterator::Iterator>::next(v44: i32, v45: i32) {
        ^block10(v44: i32, v45: i32):
            v48 = arith.constant 16 : u32;
            v47 = hir.bitcast v45 : u32;
            v49 = arith.add v47, v48 : u32 #[overflow = checked];
            v50 = arith.constant 4 : u32;
            v51 = arith.mod v49, v50 : u32;
            hir.assertz v51 #[code = 250];
            v52 = hir.int_to_ptr v49 : ptr<byte, i32>;
            v53 = hir.load v52 : i32;
            v56 = arith.constant 8 : u32;
            v55 = hir.bitcast v45 : u32;
            v57 = arith.add v55, v56 : u32 #[overflow = checked];
            v540 = arith.constant 4 : u32;
            v59 = arith.mod v57, v540 : u32;
            hir.assertz v59 #[code = 250];
            v60 = hir.int_to_ptr v57 : ptr<byte, i32>;
            v61 = hir.load v60 : i32;
            v539 = arith.constant 0 : i32;
            v46 = arith.constant 0 : i32;
            v63 = arith.eq v61, v46 : i1;
            v64 = arith.zext v63 : u32;
            v65 = hir.bitcast v64 : i32;
            v67 = arith.neq v65, v539 : i1;
            v527 = scf.if v67 : i32 {
            ^block41:
                v538 = arith.constant 0 : i32;
                scf.yield v538;
            } else {
            ^block13:
                v69 = arith.constant 12 : u32;
                v68 = hir.bitcast v45 : u32;
                v70 = arith.add v68, v69 : u32 #[overflow = checked];
                v537 = arith.constant 4 : u32;
                v72 = arith.mod v70, v537 : u32;
                hir.assertz v72 #[code = 250];
                v73 = hir.int_to_ptr v70 : ptr<byte, i32>;
                v74 = hir.load v73 : i32;
                v536 = arith.constant 0 : i32;
                v76 = hir.bitcast v53 : u32;
                v75 = hir.bitcast v74 : u32;
                v77 = arith.lt v75, v76 : i1;
                v78 = arith.zext v77 : u32;
                v79 = hir.bitcast v78 : i32;
                v81 = arith.neq v79, v536 : i1;
                scf.if v81{
                ^block40:
                    scf.yield ;
                } else {
                ^block14:
                    v535 = arith.constant 12 : u32;
                    v83 = hir.bitcast v45 : u32;
                    v85 = arith.add v83, v535 : u32 #[overflow = checked];
                    v534 = arith.constant 4 : u32;
                    v87 = arith.mod v85, v534 : u32;
                    hir.assertz v87 #[code = 250];
                    v82 = arith.sub v74, v53 : i32 #[overflow = wrapping];
                    v88 = hir.int_to_ptr v85 : ptr<byte, i32>;
                    hir.store v88, v82;
                    v533 = arith.constant 8 : u32;
                    v90 = hir.bitcast v45 : u32;
                    v92 = arith.add v90, v533 : u32 #[overflow = checked];
                    v532 = arith.constant 4 : u32;
                    v94 = arith.mod v92, v532 : u32;
                    hir.assertz v94 #[code = 250];
                    v89 = arith.add v61, v53 : i32 #[overflow = wrapping];
                    v95 = hir.int_to_ptr v92 : ptr<byte, i32>;
                    hir.store v95, v89;
                    scf.yield ;
                };
                v531 = arith.constant 0 : i32;
                v526 = cf.select v81, v531, v61 : i32;
                scf.yield v526;
            };
            v530 = arith.constant 4 : u32;
            v98 = hir.bitcast v44 : u32;
            v100 = arith.add v98, v530 : u32 #[overflow = checked];
            v529 = arith.constant 4 : u32;
            v102 = arith.mod v100, v529 : u32;
            hir.assertz v102 #[code = 250];
            v103 = hir.int_to_ptr v100 : ptr<byte, i32>;
            hir.store v103, v53;
            v105 = hir.bitcast v44 : u32;
            v528 = arith.constant 4 : u32;
            v107 = arith.mod v105, v528 : u32;
            hir.assertz v107 #[code = 250];
            v108 = hir.int_to_ptr v105 : ptr<byte, i32>;
            hir.store v108, v527;
            builtin.ret ;
        };

        public builtin.function @entrypoint(v109: i32, v110: i32) {
        ^block15(v109: i32, v110: i32):
            v112 = builtin.global_symbol @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/__stack_pointer : ptr<byte, u8>
            v113 = hir.bitcast v112 : ptr<byte, i32>;
            v114 = hir.load v113 : i32;
            v117 = arith.constant -32 : i32;
            v115 = arith.constant 128 : i32;
            v116 = arith.sub v114, v115 : i32 #[overflow = wrapping];
            v118 = arith.band v116, v117 : i32;
            v119 = builtin.global_symbol @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/__stack_pointer : ptr<byte, u8>
            v120 = hir.bitcast v119 : ptr<byte, i32>;
            hir.store v120, v118;
            v123 = arith.constant 24 : i32;
            v126 = arith.add v110, v123 : i32 #[overflow = wrapping];
            v127 = hir.bitcast v126 : u32;
            v128 = hir.int_to_ptr v127 : ptr<byte, i64>;
            v129 = hir.load v128 : i64;
            v743 = arith.constant 24 : i32;
            v121 = arith.constant 64 : i32;
            v122 = arith.add v118, v121 : i32 #[overflow = wrapping];
            v124 = arith.add v122, v743 : i32 #[overflow = wrapping];
            v130 = hir.bitcast v124 : u32;
            v131 = arith.constant 8 : u32;
            v132 = arith.mod v130, v131 : u32;
            hir.assertz v132 #[code = 250];
            v133 = hir.int_to_ptr v130 : ptr<byte, i64>;
            hir.store v133, v129;
            v136 = arith.constant 16 : i32;
            v139 = arith.add v110, v136 : i32 #[overflow = wrapping];
            v140 = hir.bitcast v139 : u32;
            v141 = hir.int_to_ptr v140 : ptr<byte, i64>;
            v142 = hir.load v141 : i64;
            v741 = arith.constant 16 : i32;
            v742 = arith.constant 64 : i32;
            v135 = arith.add v118, v742 : i32 #[overflow = wrapping];
            v137 = arith.add v135, v741 : i32 #[overflow = wrapping];
            v143 = hir.bitcast v137 : u32;
            v740 = arith.constant 8 : u32;
            v145 = arith.mod v143, v740 : u32;
            hir.assertz v145 #[code = 250];
            v146 = hir.int_to_ptr v143 : ptr<byte, i64>;
            hir.store v146, v142;
            v149 = arith.constant 8 : i32;
            v152 = arith.add v110, v149 : i32 #[overflow = wrapping];
            v153 = hir.bitcast v152 : u32;
            v154 = hir.int_to_ptr v153 : ptr<byte, i64>;
            v155 = hir.load v154 : i64;
            v738 = arith.constant 8 : i32;
            v739 = arith.constant 64 : i32;
            v148 = arith.add v118, v739 : i32 #[overflow = wrapping];
            v150 = arith.add v148, v738 : i32 #[overflow = wrapping];
            v156 = hir.bitcast v150 : u32;
            v737 = arith.constant 8 : u32;
            v158 = arith.mod v156, v737 : u32;
            hir.assertz v158 #[code = 250];
            v159 = hir.int_to_ptr v156 : ptr<byte, i64>;
            hir.store v159, v155;
            v160 = hir.bitcast v110 : u32;
            v161 = hir.int_to_ptr v160 : ptr<byte, i64>;
            v162 = hir.load v161 : i64;
            v164 = arith.constant 64 : u32;
            v163 = hir.bitcast v118 : u32;
            v165 = arith.add v163, v164 : u32 #[overflow = checked];
            v736 = arith.constant 8 : u32;
            v167 = arith.mod v165, v736 : u32;
            hir.assertz v167 #[code = 250];
            v168 = hir.int_to_ptr v165 : ptr<byte, i64>;
            hir.store v168, v162;
            v171 = arith.constant 44 : u32;
            v170 = hir.bitcast v118 : u32;
            v172 = arith.add v170, v171 : u32 #[overflow = checked];
            v173 = arith.constant 4 : u32;
            v174 = arith.mod v172, v173 : u32;
            hir.assertz v174 #[code = 250];
            v169 = arith.constant 17179869216 : i64;
            v175 = hir.int_to_ptr v172 : ptr<byte, i64>;
            hir.store v175, v169;
            v178 = arith.constant 36 : u32;
            v177 = hir.bitcast v118 : u32;
            v179 = arith.add v177, v178 : u32 #[overflow = checked];
            v735 = arith.constant 4 : u32;
            v181 = arith.mod v179, v735 : u32;
            hir.assertz v181 #[code = 250];
            v111 = arith.constant 0 : i32;
            v182 = hir.int_to_ptr v179 : ptr<byte, i32>;
            hir.store v182, v111;
            v186 = arith.constant 32 : u32;
            v185 = hir.bitcast v118 : u32;
            v187 = arith.add v185, v186 : u32 #[overflow = checked];
            v734 = arith.constant 4 : u32;
            v189 = arith.mod v187, v734 : u32;
            hir.assertz v189 #[code = 250];
            v183 = arith.constant 96 : i32;
            v184 = arith.add v118, v183 : i32 #[overflow = wrapping];
            v190 = hir.int_to_ptr v187 : ptr<byte, i32>;
            hir.store v190, v184;
            v194 = arith.constant 40 : u32;
            v193 = hir.bitcast v118 : u32;
            v195 = arith.add v193, v194 : u32 #[overflow = checked];
            v733 = arith.constant 4 : u32;
            v197 = arith.mod v195, v733 : u32;
            hir.assertz v197 #[code = 250];
            v732 = arith.constant 64 : i32;
            v192 = arith.add v118, v732 : i32 #[overflow = wrapping];
            v198 = hir.int_to_ptr v195 : ptr<byte, i32>;
            hir.store v198, v192;
            v657, v658, v659, v660, v661, v662 = scf.while v118, v109, v114 : i32, i32, i32, i32, i32, i32 {
            ^block59(v663: i32, v664: i32, v665: i32):
                v280 = arith.constant 32 : i32;
                v203 = arith.add v663, v280 : i32 #[overflow = wrapping];
                v731 = arith.constant 24 : i32;
                v201 = arith.add v663, v731 : i32 #[overflow = wrapping];
                hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/<core::slice::iter::ChunksExactMut<u8> as core::iter::traits::iterator::Iterator>::next(v201, v203)
                v205 = arith.constant 24 : u32;
                v204 = hir.bitcast v663 : u32;
                v206 = arith.add v204, v205 : u32 #[overflow = checked];
                v730 = arith.constant 4 : u32;
                v208 = arith.mod v206, v730 : u32;
                hir.assertz v208 #[code = 250];
                v209 = hir.int_to_ptr v206 : ptr<byte, i32>;
                v210 = hir.load v209 : i32;
                v728 = arith.constant 0 : i32;
                v729 = arith.constant 0 : i32;
                v212 = arith.eq v210, v729 : i1;
                v213 = arith.zext v212 : u32;
                v214 = hir.bitcast v213 : i32;
                v216 = arith.neq v214, v728 : i1;
                scf.if v216{
                ^block55:
                    scf.yield ;
                } else {
                ^block20:
                    v218 = arith.constant 28 : u32;
                    v217 = hir.bitcast v663 : u32;
                    v219 = arith.add v217, v218 : u32 #[overflow = checked];
                    v727 = arith.constant 4 : u32;
                    v221 = arith.mod v219, v727 : u32;
                    hir.assertz v221 #[code = 250];
                    v222 = hir.int_to_ptr v219 : ptr<byte, i32>;
                    v223 = hir.load v222 : i32;
                    hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/<[u8]>::reverse(v210, v223)
                    scf.yield ;
                };
                v725 = ub.poison i32 : i32;
                v654 = cf.select v216, v725, v665 : i32;
                v726 = ub.poison i32 : i32;
                v653 = cf.select v216, v726, v664 : i32;
                v548 = ub.poison i32 : i32;
                v652 = cf.select v216, v548, v663 : i32;
                v547 = arith.constant 1 : u32;
                v541 = arith.constant 0 : u32;
                v656 = cf.select v216, v541, v547 : u32;
                v621 = arith.trunc v656 : i1;
                scf.condition v621, v652, v653, v654, v663, v664, v665;
            } do {
            ^block60(v666: i32, v667: i32, v668: i32, v669: i32, v670: i32, v671: i32):
                scf.yield v666, v667, v668;
            };
            v724 = arith.constant 64 : u32;
            v224 = hir.bitcast v660 : u32;
            v226 = arith.add v224, v724 : u32 #[overflow = checked];
            v723 = arith.constant 4 : u32;
            v228 = arith.mod v226, v723 : u32;
            hir.assertz v228 #[code = 250];
            v229 = hir.int_to_ptr v226 : ptr<byte, i32>;
            v230 = hir.load v229 : i32;
            v232 = arith.constant 68 : u32;
            v231 = hir.bitcast v660 : u32;
            v233 = arith.add v231, v232 : u32 #[overflow = checked];
            v722 = arith.constant 4 : u32;
            v235 = arith.mod v233, v722 : u32;
            hir.assertz v235 #[code = 250];
            v236 = hir.int_to_ptr v233 : ptr<byte, i32>;
            v237 = hir.load v236 : i32;
            v239 = arith.constant 72 : u32;
            v238 = hir.bitcast v660 : u32;
            v240 = arith.add v238, v239 : u32 #[overflow = checked];
            v721 = arith.constant 4 : u32;
            v242 = arith.mod v240, v721 : u32;
            hir.assertz v242 #[code = 250];
            v243 = hir.int_to_ptr v240 : ptr<byte, i32>;
            v244 = hir.load v243 : i32;
            v246 = arith.constant 76 : u32;
            v245 = hir.bitcast v660 : u32;
            v247 = arith.add v245, v246 : u32 #[overflow = checked];
            v720 = arith.constant 4 : u32;
            v249 = arith.mod v247, v720 : u32;
            hir.assertz v249 #[code = 250];
            v250 = hir.int_to_ptr v247 : ptr<byte, i32>;
            v251 = hir.load v250 : i32;
            v253 = arith.constant 80 : u32;
            v252 = hir.bitcast v660 : u32;
            v254 = arith.add v252, v253 : u32 #[overflow = checked];
            v719 = arith.constant 4 : u32;
            v256 = arith.mod v254, v719 : u32;
            hir.assertz v256 #[code = 250];
            v257 = hir.int_to_ptr v254 : ptr<byte, i32>;
            v258 = hir.load v257 : i32;
            v260 = arith.constant 84 : u32;
            v259 = hir.bitcast v660 : u32;
            v261 = arith.add v259, v260 : u32 #[overflow = checked];
            v718 = arith.constant 4 : u32;
            v263 = arith.mod v261, v718 : u32;
            hir.assertz v263 #[code = 250];
            v264 = hir.int_to_ptr v261 : ptr<byte, i32>;
            v265 = hir.load v264 : i32;
            v267 = arith.constant 88 : u32;
            v266 = hir.bitcast v660 : u32;
            v268 = arith.add v266, v267 : u32 #[overflow = checked];
            v717 = arith.constant 4 : u32;
            v270 = arith.mod v268, v717 : u32;
            hir.assertz v270 #[code = 250];
            v271 = hir.int_to_ptr v268 : ptr<byte, i32>;
            v272 = hir.load v271 : i32;
            v274 = arith.constant 92 : u32;
            v273 = hir.bitcast v660 : u32;
            v275 = arith.add v273, v274 : u32 #[overflow = checked];
            v716 = arith.constant 4 : u32;
            v277 = arith.mod v275, v716 : u32;
            hir.assertz v277 #[code = 250];
            v278 = hir.int_to_ptr v275 : ptr<byte, i32>;
            v279 = hir.load v278 : i32;
            v715 = arith.constant 32 : i32;
            v281 = arith.add v660, v715 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/miden::core::crypto::hashes::sha256::hash(v230, v237, v244, v251, v258, v265, v272, v279, v281)
            v283 = arith.constant 56 : u32;
            v282 = hir.bitcast v660 : u32;
            v284 = arith.add v282, v283 : u32 #[overflow = checked];
            v714 = arith.constant 8 : u32;
            v286 = arith.mod v284, v714 : u32;
            hir.assertz v286 #[code = 250];
            v287 = hir.int_to_ptr v284 : ptr<byte, i64>;
            v288 = hir.load v287 : i64;
            v713 = arith.constant 88 : u32;
            v289 = hir.bitcast v660 : u32;
            v291 = arith.add v289, v713 : u32 #[overflow = checked];
            v712 = arith.constant 8 : u32;
            v293 = arith.mod v291, v712 : u32;
            hir.assertz v293 #[code = 250];
            v294 = hir.int_to_ptr v291 : ptr<byte, i64>;
            hir.store v294, v288;
            v296 = arith.constant 48 : u32;
            v295 = hir.bitcast v660 : u32;
            v297 = arith.add v295, v296 : u32 #[overflow = checked];
            v711 = arith.constant 8 : u32;
            v299 = arith.mod v297, v711 : u32;
            hir.assertz v299 #[code = 250];
            v300 = hir.int_to_ptr v297 : ptr<byte, i64>;
            v301 = hir.load v300 : i64;
            v710 = arith.constant 80 : u32;
            v302 = hir.bitcast v660 : u32;
            v304 = arith.add v302, v710 : u32 #[overflow = checked];
            v709 = arith.constant 8 : u32;
            v306 = arith.mod v304, v709 : u32;
            hir.assertz v306 #[code = 250];
            v307 = hir.int_to_ptr v304 : ptr<byte, i64>;
            hir.store v307, v301;
            v708 = arith.constant 40 : u32;
            v308 = hir.bitcast v660 : u32;
            v310 = arith.add v308, v708 : u32 #[overflow = checked];
            v707 = arith.constant 8 : u32;
            v312 = arith.mod v310, v707 : u32;
            hir.assertz v312 #[code = 250];
            v313 = hir.int_to_ptr v310 : ptr<byte, i64>;
            v314 = hir.load v313 : i64;
            v706 = arith.constant 72 : u32;
            v315 = hir.bitcast v660 : u32;
            v317 = arith.add v315, v706 : u32 #[overflow = checked];
            v705 = arith.constant 8 : u32;
            v319 = arith.mod v317, v705 : u32;
            hir.assertz v319 #[code = 250];
            v320 = hir.int_to_ptr v317 : ptr<byte, i64>;
            hir.store v320, v314;
            v704 = arith.constant 32 : u32;
            v321 = hir.bitcast v660 : u32;
            v323 = arith.add v321, v704 : u32 #[overflow = checked];
            v703 = arith.constant 8 : u32;
            v325 = arith.mod v323, v703 : u32;
            hir.assertz v325 #[code = 250];
            v326 = hir.int_to_ptr v323 : ptr<byte, i64>;
            v327 = hir.load v326 : i64;
            v702 = arith.constant 64 : u32;
            v328 = hir.bitcast v660 : u32;
            v330 = arith.add v328, v702 : u32 #[overflow = checked];
            v701 = arith.constant 8 : u32;
            v332 = arith.mod v330, v701 : u32;
            hir.assertz v332 #[code = 250];
            v333 = hir.int_to_ptr v330 : ptr<byte, i64>;
            hir.store v333, v327;
            v336 = arith.constant 120 : u32;
            v335 = hir.bitcast v660 : u32;
            v337 = arith.add v335, v336 : u32 #[overflow = checked];
            v700 = arith.constant 4 : u32;
            v339 = arith.mod v337, v700 : u32;
            hir.assertz v339 #[code = 250];
            v699 = arith.constant 17179869216 : i64;
            v340 = hir.int_to_ptr v337 : ptr<byte, i64>;
            hir.store v340, v699;
            v343 = arith.constant 112 : u32;
            v342 = hir.bitcast v660 : u32;
            v344 = arith.add v342, v343 : u32 #[overflow = checked];
            v698 = arith.constant 4 : u32;
            v346 = arith.mod v344, v698 : u32;
            hir.assertz v346 #[code = 250];
            v697 = arith.constant 0 : i32;
            v347 = hir.int_to_ptr v344 : ptr<byte, i32>;
            hir.store v347, v697;
            v351 = arith.constant 108 : u32;
            v350 = hir.bitcast v660 : u32;
            v352 = arith.add v350, v351 : u32 #[overflow = checked];
            v696 = arith.constant 4 : u32;
            v354 = arith.mod v352, v696 : u32;
            hir.assertz v354 #[code = 250];
            v695 = arith.constant 96 : i32;
            v349 = arith.add v660, v695 : i32 #[overflow = wrapping];
            v355 = hir.int_to_ptr v352 : ptr<byte, i32>;
            hir.store v355, v349;
            v359 = arith.constant 116 : u32;
            v358 = hir.bitcast v660 : u32;
            v360 = arith.add v358, v359 : u32 #[overflow = checked];
            v694 = arith.constant 4 : u32;
            v362 = arith.mod v360, v694 : u32;
            hir.assertz v362 #[code = 250];
            v693 = arith.constant 64 : i32;
            v357 = arith.add v660, v693 : i32 #[overflow = wrapping];
            v363 = hir.int_to_ptr v360 : ptr<byte, i32>;
            hir.store v363, v357;
            v637, v638, v639, v640, v641, v642 = scf.while v660, v661, v662 : i32, i32, i32, i32, i32, i32 {
            ^block57(v643: i32, v644: i32, v645: i32):
                v367 = arith.constant 108 : i32;
                v368 = arith.add v643, v367 : i32 #[overflow = wrapping];
                v692 = arith.constant 16 : i32;
                v366 = arith.add v643, v692 : i32 #[overflow = wrapping];
                hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/<core::slice::iter::ChunksExactMut<u8> as core::iter::traits::iterator::Iterator>::next(v366, v368)
                v370 = arith.constant 16 : u32;
                v369 = hir.bitcast v643 : u32;
                v371 = arith.add v369, v370 : u32 #[overflow = checked];
                v691 = arith.constant 4 : u32;
                v373 = arith.mod v371, v691 : u32;
                hir.assertz v373 #[code = 250];
                v374 = hir.int_to_ptr v371 : ptr<byte, i32>;
                v375 = hir.load v374 : i32;
                v689 = arith.constant 0 : i32;
                v690 = arith.constant 0 : i32;
                v377 = arith.eq v375, v690 : i1;
                v378 = arith.zext v377 : u32;
                v379 = hir.bitcast v378 : i32;
                v381 = arith.neq v379, v689 : i1;
                scf.if v381{
                ^block56:
                    scf.yield ;
                } else {
                ^block24:
                    v383 = arith.constant 20 : u32;
                    v382 = hir.bitcast v643 : u32;
                    v384 = arith.add v382, v383 : u32 #[overflow = checked];
                    v688 = arith.constant 4 : u32;
                    v386 = arith.mod v384, v688 : u32;
                    hir.assertz v386 #[code = 250];
                    v387 = hir.int_to_ptr v384 : ptr<byte, i32>;
                    v388 = hir.load v387 : i32;
                    hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/<[u8]>::reverse(v375, v388)
                    scf.yield ;
                };
                v683 = ub.poison i32 : i32;
                v634 = cf.select v381, v683, v645 : i32;
                v684 = ub.poison i32 : i32;
                v633 = cf.select v381, v684, v644 : i32;
                v685 = ub.poison i32 : i32;
                v632 = cf.select v381, v685, v643 : i32;
                v686 = arith.constant 1 : u32;
                v687 = arith.constant 0 : u32;
                v636 = cf.select v381, v687, v686 : u32;
                v582 = arith.trunc v636 : i1;
                scf.condition v582, v632, v633, v634, v643, v644, v645;
            } do {
            ^block58(v646: i32, v647: i32, v648: i32, v649: i32, v650: i32, v651: i32):
                scf.yield v646, v647, v648;
            };
            v682 = arith.constant 64 : u32;
            v391 = hir.bitcast v640 : u32;
            v393 = arith.add v391, v682 : u32 #[overflow = checked];
            v681 = arith.constant 8 : u32;
            v395 = arith.mod v393, v681 : u32;
            hir.assertz v395 #[code = 250];
            v396 = hir.int_to_ptr v393 : ptr<byte, i64>;
            v397 = hir.load v396 : i64;
            v398 = hir.bitcast v641 : u32;
            v399 = hir.int_to_ptr v398 : ptr<byte, i64>;
            hir.store v399, v397;
            v680 = arith.constant 88 : u32;
            v402 = hir.bitcast v640 : u32;
            v404 = arith.add v402, v680 : u32 #[overflow = checked];
            v679 = arith.constant 8 : u32;
            v406 = arith.mod v404, v679 : u32;
            hir.assertz v406 #[code = 250];
            v407 = hir.int_to_ptr v404 : ptr<byte, i64>;
            v408 = hir.load v407 : i64;
            v678 = arith.constant 24 : i32;
            v401 = arith.add v641, v678 : i32 #[overflow = wrapping];
            v409 = hir.bitcast v401 : u32;
            v410 = hir.int_to_ptr v409 : ptr<byte, i64>;
            hir.store v410, v408;
            v677 = arith.constant 80 : u32;
            v413 = hir.bitcast v640 : u32;
            v415 = arith.add v413, v677 : u32 #[overflow = checked];
            v676 = arith.constant 8 : u32;
            v417 = arith.mod v415, v676 : u32;
            hir.assertz v417 #[code = 250];
            v418 = hir.int_to_ptr v415 : ptr<byte, i64>;
            v419 = hir.load v418 : i64;
            v675 = arith.constant 16 : i32;
            v412 = arith.add v641, v675 : i32 #[overflow = wrapping];
            v420 = hir.bitcast v412 : u32;
            v421 = hir.int_to_ptr v420 : ptr<byte, i64>;
            hir.store v421, v419;
            v674 = arith.constant 72 : u32;
            v424 = hir.bitcast v640 : u32;
            v426 = arith.add v424, v674 : u32 #[overflow = checked];
            v673 = arith.constant 8 : u32;
            v428 = arith.mod v426, v673 : u32;
            hir.assertz v428 #[code = 250];
            v429 = hir.int_to_ptr v426 : ptr<byte, i64>;
            v430 = hir.load v429 : i64;
            v672 = arith.constant 8 : i32;
            v423 = arith.add v641, v672 : i32 #[overflow = wrapping];
            v431 = hir.bitcast v423 : u32;
            v432 = hir.int_to_ptr v431 : ptr<byte, i64>;
            hir.store v432, v430;
            v435 = builtin.global_symbol @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/__stack_pointer : ptr<byte, u8>
            v436 = hir.bitcast v435 : ptr<byte, i32>;
            hir.store v436, v642;
            builtin.ret ;
        };

        private builtin.function @miden::core::crypto::hashes::sha256::hash(v437: i32, v438: i32, v439: i32, v440: i32, v441: i32, v442: i32, v443: i32, v444: i32, v445: i32) {
        ^block25(v437: i32, v438: i32, v439: i32, v440: i32, v441: i32, v442: i32, v443: i32, v444: i32, v445: i32):
            v446, v447, v448, v449, v450, v451, v452, v453 = hir.exec @miden/core/crypto/hashes/sha256/hash(v437, v438, v439, v440, v441, v442, v443, v444) : i32, i32, i32, i32, i32, i32, i32, i32
            v454 = hir.bitcast v445 : u32;
            v455 = hir.int_to_ptr v454 : ptr<byte, i32>;
            hir.store v455, v446;
            v456 = arith.constant 4 : u32;
            v457 = arith.add v454, v456 : u32 #[overflow = checked];
            v458 = hir.int_to_ptr v457 : ptr<byte, i32>;
            hir.store v458, v447;
            v459 = arith.constant 8 : u32;
            v460 = arith.add v454, v459 : u32 #[overflow = checked];
            v461 = hir.int_to_ptr v460 : ptr<byte, i32>;
            hir.store v461, v448;
            v462 = arith.constant 12 : u32;
            v463 = arith.add v454, v462 : u32 #[overflow = checked];
            v464 = hir.int_to_ptr v463 : ptr<byte, i32>;
            hir.store v464, v449;
            v465 = arith.constant 16 : u32;
            v466 = arith.add v454, v465 : u32 #[overflow = checked];
            v467 = hir.int_to_ptr v466 : ptr<byte, i32>;
            hir.store v467, v450;
            v468 = arith.constant 20 : u32;
            v469 = arith.add v454, v468 : u32 #[overflow = checked];
            v470 = hir.int_to_ptr v469 : ptr<byte, i32>;
            hir.store v470, v451;
            v471 = arith.constant 24 : u32;
            v472 = arith.add v454, v471 : u32 #[overflow = checked];
            v473 = hir.int_to_ptr v472 : ptr<byte, i32>;
            hir.store v473, v452;
            v474 = arith.constant 28 : u32;
            v475 = arith.add v454, v474 : u32 #[overflow = checked];
            v476 = hir.int_to_ptr v475 : ptr<byte, i32>;
            hir.store v476, v453;
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};