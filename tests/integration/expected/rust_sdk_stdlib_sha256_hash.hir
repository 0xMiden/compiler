builtin.component root_ns:root@1.0.0 {
    builtin.module public @rust_sdk_stdlib_sha256_hash {
        private builtin.function @<[u8]>::reverse(v0: i32, v1: i32) {
        ^block4(v0: i32, v1: i32):
            v9 = arith.constant -1 : i32;
            v8 = arith.add v1, v0 : i32 #[overflow = wrapping];
            v10 = arith.add v8, v9 : i32 #[overflow = wrapping];
            v453 = arith.constant 1 : u32;
            v4 = hir.bitcast v1 : u32;
            v6 = arith.shr v4, v453 : u32;
            v7 = hir.bitcast v6 : i32;
            v461, v462, v463 = scf.while v7, v0, v10 : i32, i32, i32 {
            ^block7(v11: i32, v18: i32, v24: i32):
                v484 = arith.constant 0 : i32;
                v2 = arith.constant 0 : i32;
                v13 = arith.eq v11, v2 : i1;
                v14 = arith.zext v13 : u32;
                v15 = hir.bitcast v14 : i32;
                v17 = arith.neq v15, v484 : i1;
                v476, v477, v478 = scf.if v17 : i32, i32, i32 {
                ^block34:
                    v454 = ub.poison i32 : i32;
                    scf.yield v454, v454, v454;
                } else {
                ^block9:
                    v19 = hir.bitcast v18 : u32;
                    v20 = hir.int_to_ptr v19 : ptr<byte, u8>;
                    v21 = hir.load v20 : u8;
                    v25 = hir.bitcast v24 : u32;
                    v26 = hir.int_to_ptr v25 : ptr<byte, u8>;
                    v27 = hir.load v26 : u8;
                    v28 = arith.zext v27 : u32;
                    v29 = hir.bitcast v28 : i32;
                    v30 = hir.bitcast v29 : u32;
                    v31 = arith.trunc v30 : u8;
                    v32 = hir.bitcast v18 : u32;
                    v33 = hir.int_to_ptr v32 : ptr<byte, u8>;
                    hir.store v33, v31;
                    v22 = arith.zext v21 : u32;
                    v23 = hir.bitcast v22 : i32;
                    v34 = hir.bitcast v23 : u32;
                    v35 = arith.trunc v34 : u8;
                    v36 = hir.bitcast v24 : u32;
                    v37 = hir.int_to_ptr v36 : ptr<byte, u8>;
                    hir.store v37, v35;
                    v482 = arith.constant -1 : i32;
                    v43 = arith.add v24, v482 : i32 #[overflow = wrapping];
                    v3 = arith.constant 1 : i32;
                    v41 = arith.add v18, v3 : i32 #[overflow = wrapping];
                    v483 = arith.constant -1 : i32;
                    v39 = arith.add v11, v483 : i32 #[overflow = wrapping];
                    scf.yield v39, v41, v43;
                };
                v481 = arith.constant 1 : u32;
                v447 = arith.constant 0 : u32;
                v480 = cf.select v17, v447, v481 : u32;
                v470 = arith.trunc v480 : i1;
                scf.condition v470, v476, v477, v478;
            } do {
            ^block33(v467: i32, v468: i32, v469: i32):
                scf.yield v467, v468, v469;
            };
            builtin.ret ;
        };

        private builtin.function @<core::slice::iter::ChunksExactMut<u8> as core::iter::traits::iterator::Iterator>::next(v44: i32, v45: i32) {
        ^block10(v44: i32, v45: i32):
            v48 = arith.constant 16 : u32;
            v47 = hir.bitcast v45 : u32;
            v49 = arith.add v47, v48 : u32 #[overflow = checked];
            v50 = arith.constant 4 : u32;
            v51 = arith.mod v49, v50 : u32;
            hir.assertz v51 #[code = 250];
            v52 = hir.int_to_ptr v49 : ptr<byte, i32>;
            v53 = hir.load v52 : i32;
            v56 = arith.constant 8 : u32;
            v55 = hir.bitcast v45 : u32;
            v57 = arith.add v55, v56 : u32 #[overflow = checked];
            v509 = arith.constant 4 : u32;
            v59 = arith.mod v57, v509 : u32;
            hir.assertz v59 #[code = 250];
            v60 = hir.int_to_ptr v57 : ptr<byte, i32>;
            v61 = hir.load v60 : i32;
            v508 = arith.constant 0 : i32;
            v46 = arith.constant 0 : i32;
            v63 = arith.eq v61, v46 : i1;
            v64 = arith.zext v63 : u32;
            v65 = hir.bitcast v64 : i32;
            v67 = arith.neq v65, v508 : i1;
            v496 = scf.if v67 : i32 {
            ^block36:
                v507 = arith.constant 0 : i32;
                scf.yield v507;
            } else {
            ^block13:
                v69 = arith.constant 12 : u32;
                v68 = hir.bitcast v45 : u32;
                v70 = arith.add v68, v69 : u32 #[overflow = checked];
                v506 = arith.constant 4 : u32;
                v72 = arith.mod v70, v506 : u32;
                hir.assertz v72 #[code = 250];
                v73 = hir.int_to_ptr v70 : ptr<byte, i32>;
                v74 = hir.load v73 : i32;
                v505 = arith.constant 0 : i32;
                v76 = hir.bitcast v53 : u32;
                v75 = hir.bitcast v74 : u32;
                v77 = arith.lt v75, v76 : i1;
                v78 = arith.zext v77 : u32;
                v79 = hir.bitcast v78 : i32;
                v81 = arith.neq v79, v505 : i1;
                scf.if v81{
                ^block35:
                    scf.yield ;
                } else {
                ^block14:
                    v504 = arith.constant 12 : u32;
                    v83 = hir.bitcast v45 : u32;
                    v85 = arith.add v83, v504 : u32 #[overflow = checked];
                    v503 = arith.constant 4 : u32;
                    v87 = arith.mod v85, v503 : u32;
                    hir.assertz v87 #[code = 250];
                    v82 = arith.sub v74, v53 : i32 #[overflow = wrapping];
                    v88 = hir.int_to_ptr v85 : ptr<byte, i32>;
                    hir.store v88, v82;
                    v502 = arith.constant 8 : u32;
                    v90 = hir.bitcast v45 : u32;
                    v92 = arith.add v90, v502 : u32 #[overflow = checked];
                    v501 = arith.constant 4 : u32;
                    v94 = arith.mod v92, v501 : u32;
                    hir.assertz v94 #[code = 250];
                    v89 = arith.add v61, v53 : i32 #[overflow = wrapping];
                    v95 = hir.int_to_ptr v92 : ptr<byte, i32>;
                    hir.store v95, v89;
                    scf.yield ;
                };
                v500 = arith.constant 0 : i32;
                v495 = cf.select v81, v500, v61 : i32;
                scf.yield v495;
            };
            v499 = arith.constant 4 : u32;
            v98 = hir.bitcast v44 : u32;
            v100 = arith.add v98, v499 : u32 #[overflow = checked];
            v498 = arith.constant 4 : u32;
            v102 = arith.mod v100, v498 : u32;
            hir.assertz v102 #[code = 250];
            v103 = hir.int_to_ptr v100 : ptr<byte, i32>;
            hir.store v103, v53;
            v105 = hir.bitcast v44 : u32;
            v497 = arith.constant 4 : u32;
            v107 = arith.mod v105, v497 : u32;
            hir.assertz v107 #[code = 250];
            v108 = hir.int_to_ptr v105 : ptr<byte, i32>;
            hir.store v108, v496;
            builtin.ret ;
        };

        public builtin.function @entrypoint(v109: i32, v110: i32) {
        ^block15(v109: i32, v110: i32):
            v112 = builtin.global_symbol @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/__stack_pointer : ptr<byte, u8>
            v113 = hir.bitcast v112 : ptr<byte, i32>;
            v114 = hir.load v113 : i32;
            v117 = arith.constant -32 : i32;
            v115 = arith.constant 128 : i32;
            v116 = arith.sub v114, v115 : i32 #[overflow = wrapping];
            v118 = arith.band v116, v117 : i32;
            v119 = builtin.global_symbol @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/__stack_pointer : ptr<byte, u8>
            v120 = hir.bitcast v119 : ptr<byte, i32>;
            hir.store v120, v118;
            v123 = arith.constant 24 : i32;
            v126 = arith.add v110, v123 : i32 #[overflow = wrapping];
            v127 = hir.bitcast v126 : u32;
            v128 = hir.int_to_ptr v127 : ptr<byte, i64>;
            v129 = hir.load v128 : i64;
            v712 = arith.constant 24 : i32;
            v121 = arith.constant 64 : i32;
            v122 = arith.add v118, v121 : i32 #[overflow = wrapping];
            v124 = arith.add v122, v712 : i32 #[overflow = wrapping];
            v130 = hir.bitcast v124 : u32;
            v131 = arith.constant 8 : u32;
            v132 = arith.mod v130, v131 : u32;
            hir.assertz v132 #[code = 250];
            v133 = hir.int_to_ptr v130 : ptr<byte, i64>;
            hir.store v133, v129;
            v136 = arith.constant 16 : i32;
            v139 = arith.add v110, v136 : i32 #[overflow = wrapping];
            v140 = hir.bitcast v139 : u32;
            v141 = hir.int_to_ptr v140 : ptr<byte, i64>;
            v142 = hir.load v141 : i64;
            v710 = arith.constant 16 : i32;
            v711 = arith.constant 64 : i32;
            v135 = arith.add v118, v711 : i32 #[overflow = wrapping];
            v137 = arith.add v135, v710 : i32 #[overflow = wrapping];
            v143 = hir.bitcast v137 : u32;
            v709 = arith.constant 8 : u32;
            v145 = arith.mod v143, v709 : u32;
            hir.assertz v145 #[code = 250];
            v146 = hir.int_to_ptr v143 : ptr<byte, i64>;
            hir.store v146, v142;
            v149 = arith.constant 8 : i32;
            v152 = arith.add v110, v149 : i32 #[overflow = wrapping];
            v153 = hir.bitcast v152 : u32;
            v154 = hir.int_to_ptr v153 : ptr<byte, i64>;
            v155 = hir.load v154 : i64;
            v707 = arith.constant 8 : i32;
            v708 = arith.constant 64 : i32;
            v148 = arith.add v118, v708 : i32 #[overflow = wrapping];
            v150 = arith.add v148, v707 : i32 #[overflow = wrapping];
            v156 = hir.bitcast v150 : u32;
            v706 = arith.constant 8 : u32;
            v158 = arith.mod v156, v706 : u32;
            hir.assertz v158 #[code = 250];
            v159 = hir.int_to_ptr v156 : ptr<byte, i64>;
            hir.store v159, v155;
            v160 = hir.bitcast v110 : u32;
            v161 = hir.int_to_ptr v160 : ptr<byte, i64>;
            v162 = hir.load v161 : i64;
            v164 = arith.constant 64 : u32;
            v163 = hir.bitcast v118 : u32;
            v165 = arith.add v163, v164 : u32 #[overflow = checked];
            v705 = arith.constant 8 : u32;
            v167 = arith.mod v165, v705 : u32;
            hir.assertz v167 #[code = 250];
            v168 = hir.int_to_ptr v165 : ptr<byte, i64>;
            hir.store v168, v162;
            v171 = arith.constant 44 : u32;
            v170 = hir.bitcast v118 : u32;
            v172 = arith.add v170, v171 : u32 #[overflow = checked];
            v173 = arith.constant 4 : u32;
            v174 = arith.mod v172, v173 : u32;
            hir.assertz v174 #[code = 250];
            v169 = arith.constant 17179869216 : i64;
            v175 = hir.int_to_ptr v172 : ptr<byte, i64>;
            hir.store v175, v169;
            v178 = arith.constant 36 : u32;
            v177 = hir.bitcast v118 : u32;
            v179 = arith.add v177, v178 : u32 #[overflow = checked];
            v704 = arith.constant 4 : u32;
            v181 = arith.mod v179, v704 : u32;
            hir.assertz v181 #[code = 250];
            v111 = arith.constant 0 : i32;
            v182 = hir.int_to_ptr v179 : ptr<byte, i32>;
            hir.store v182, v111;
            v186 = arith.constant 32 : u32;
            v185 = hir.bitcast v118 : u32;
            v187 = arith.add v185, v186 : u32 #[overflow = checked];
            v703 = arith.constant 4 : u32;
            v189 = arith.mod v187, v703 : u32;
            hir.assertz v189 #[code = 250];
            v183 = arith.constant 96 : i32;
            v184 = arith.add v118, v183 : i32 #[overflow = wrapping];
            v190 = hir.int_to_ptr v187 : ptr<byte, i32>;
            hir.store v190, v184;
            v194 = arith.constant 40 : u32;
            v193 = hir.bitcast v118 : u32;
            v195 = arith.add v193, v194 : u32 #[overflow = checked];
            v702 = arith.constant 4 : u32;
            v197 = arith.mod v195, v702 : u32;
            hir.assertz v197 #[code = 250];
            v701 = arith.constant 64 : i32;
            v192 = arith.add v118, v701 : i32 #[overflow = wrapping];
            v198 = hir.int_to_ptr v195 : ptr<byte, i32>;
            hir.store v198, v192;
            v626, v627, v628, v629, v630, v631 = scf.while v118, v109, v114 : i32, i32, i32, i32, i32, i32 {
            ^block54(v632: i32, v633: i32, v634: i32):
                v280 = arith.constant 32 : i32;
                v203 = arith.add v632, v280 : i32 #[overflow = wrapping];
                v700 = arith.constant 24 : i32;
                v201 = arith.add v632, v700 : i32 #[overflow = wrapping];
                hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/<core::slice::iter::ChunksExactMut<u8> as core::iter::traits::iterator::Iterator>::next(v201, v203)
                v205 = arith.constant 24 : u32;
                v204 = hir.bitcast v632 : u32;
                v206 = arith.add v204, v205 : u32 #[overflow = checked];
                v699 = arith.constant 4 : u32;
                v208 = arith.mod v206, v699 : u32;
                hir.assertz v208 #[code = 250];
                v209 = hir.int_to_ptr v206 : ptr<byte, i32>;
                v210 = hir.load v209 : i32;
                v697 = arith.constant 0 : i32;
                v698 = arith.constant 0 : i32;
                v212 = arith.eq v210, v698 : i1;
                v213 = arith.zext v212 : u32;
                v214 = hir.bitcast v213 : i32;
                v216 = arith.neq v214, v697 : i1;
                scf.if v216{
                ^block50:
                    scf.yield ;
                } else {
                ^block20:
                    v218 = arith.constant 28 : u32;
                    v217 = hir.bitcast v632 : u32;
                    v219 = arith.add v217, v218 : u32 #[overflow = checked];
                    v696 = arith.constant 4 : u32;
                    v221 = arith.mod v219, v696 : u32;
                    hir.assertz v221 #[code = 250];
                    v222 = hir.int_to_ptr v219 : ptr<byte, i32>;
                    v223 = hir.load v222 : i32;
                    hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/<[u8]>::reverse(v210, v223)
                    scf.yield ;
                };
                v694 = ub.poison i32 : i32;
                v623 = cf.select v216, v694, v634 : i32;
                v695 = ub.poison i32 : i32;
                v622 = cf.select v216, v695, v633 : i32;
                v517 = ub.poison i32 : i32;
                v621 = cf.select v216, v517, v632 : i32;
                v516 = arith.constant 1 : u32;
                v510 = arith.constant 0 : u32;
                v625 = cf.select v216, v510, v516 : u32;
                v590 = arith.trunc v625 : i1;
                scf.condition v590, v621, v622, v623, v632, v633, v634;
            } do {
            ^block55(v635: i32, v636: i32, v637: i32, v638: i32, v639: i32, v640: i32):
                scf.yield v635, v636, v637;
            };
            v693 = arith.constant 64 : u32;
            v224 = hir.bitcast v629 : u32;
            v226 = arith.add v224, v693 : u32 #[overflow = checked];
            v692 = arith.constant 4 : u32;
            v228 = arith.mod v226, v692 : u32;
            hir.assertz v228 #[code = 250];
            v229 = hir.int_to_ptr v226 : ptr<byte, i32>;
            v230 = hir.load v229 : i32;
            v232 = arith.constant 68 : u32;
            v231 = hir.bitcast v629 : u32;
            v233 = arith.add v231, v232 : u32 #[overflow = checked];
            v691 = arith.constant 4 : u32;
            v235 = arith.mod v233, v691 : u32;
            hir.assertz v235 #[code = 250];
            v236 = hir.int_to_ptr v233 : ptr<byte, i32>;
            v237 = hir.load v236 : i32;
            v239 = arith.constant 72 : u32;
            v238 = hir.bitcast v629 : u32;
            v240 = arith.add v238, v239 : u32 #[overflow = checked];
            v690 = arith.constant 4 : u32;
            v242 = arith.mod v240, v690 : u32;
            hir.assertz v242 #[code = 250];
            v243 = hir.int_to_ptr v240 : ptr<byte, i32>;
            v244 = hir.load v243 : i32;
            v246 = arith.constant 76 : u32;
            v245 = hir.bitcast v629 : u32;
            v247 = arith.add v245, v246 : u32 #[overflow = checked];
            v689 = arith.constant 4 : u32;
            v249 = arith.mod v247, v689 : u32;
            hir.assertz v249 #[code = 250];
            v250 = hir.int_to_ptr v247 : ptr<byte, i32>;
            v251 = hir.load v250 : i32;
            v253 = arith.constant 80 : u32;
            v252 = hir.bitcast v629 : u32;
            v254 = arith.add v252, v253 : u32 #[overflow = checked];
            v688 = arith.constant 4 : u32;
            v256 = arith.mod v254, v688 : u32;
            hir.assertz v256 #[code = 250];
            v257 = hir.int_to_ptr v254 : ptr<byte, i32>;
            v258 = hir.load v257 : i32;
            v260 = arith.constant 84 : u32;
            v259 = hir.bitcast v629 : u32;
            v261 = arith.add v259, v260 : u32 #[overflow = checked];
            v687 = arith.constant 4 : u32;
            v263 = arith.mod v261, v687 : u32;
            hir.assertz v263 #[code = 250];
            v264 = hir.int_to_ptr v261 : ptr<byte, i32>;
            v265 = hir.load v264 : i32;
            v267 = arith.constant 88 : u32;
            v266 = hir.bitcast v629 : u32;
            v268 = arith.add v266, v267 : u32 #[overflow = checked];
            v686 = arith.constant 4 : u32;
            v270 = arith.mod v268, v686 : u32;
            hir.assertz v270 #[code = 250];
            v271 = hir.int_to_ptr v268 : ptr<byte, i32>;
            v272 = hir.load v271 : i32;
            v274 = arith.constant 92 : u32;
            v273 = hir.bitcast v629 : u32;
            v275 = arith.add v273, v274 : u32 #[overflow = checked];
            v685 = arith.constant 4 : u32;
            v277 = arith.mod v275, v685 : u32;
            hir.assertz v277 #[code = 250];
            v278 = hir.int_to_ptr v275 : ptr<byte, i32>;
            v279 = hir.load v278 : i32;
            v684 = arith.constant 32 : i32;
            v281 = arith.add v629, v684 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/miden::core::crypto::hashes::sha256::hash_1to1(v230, v237, v244, v251, v258, v265, v272, v279, v281)
            v283 = arith.constant 56 : u32;
            v282 = hir.bitcast v629 : u32;
            v284 = arith.add v282, v283 : u32 #[overflow = checked];
            v683 = arith.constant 8 : u32;
            v286 = arith.mod v284, v683 : u32;
            hir.assertz v286 #[code = 250];
            v287 = hir.int_to_ptr v284 : ptr<byte, i64>;
            v288 = hir.load v287 : i64;
            v682 = arith.constant 88 : u32;
            v289 = hir.bitcast v629 : u32;
            v291 = arith.add v289, v682 : u32 #[overflow = checked];
            v681 = arith.constant 8 : u32;
            v293 = arith.mod v291, v681 : u32;
            hir.assertz v293 #[code = 250];
            v294 = hir.int_to_ptr v291 : ptr<byte, i64>;
            hir.store v294, v288;
            v296 = arith.constant 48 : u32;
            v295 = hir.bitcast v629 : u32;
            v297 = arith.add v295, v296 : u32 #[overflow = checked];
            v680 = arith.constant 8 : u32;
            v299 = arith.mod v297, v680 : u32;
            hir.assertz v299 #[code = 250];
            v300 = hir.int_to_ptr v297 : ptr<byte, i64>;
            v301 = hir.load v300 : i64;
            v679 = arith.constant 80 : u32;
            v302 = hir.bitcast v629 : u32;
            v304 = arith.add v302, v679 : u32 #[overflow = checked];
            v678 = arith.constant 8 : u32;
            v306 = arith.mod v304, v678 : u32;
            hir.assertz v306 #[code = 250];
            v307 = hir.int_to_ptr v304 : ptr<byte, i64>;
            hir.store v307, v301;
            v677 = arith.constant 40 : u32;
            v308 = hir.bitcast v629 : u32;
            v310 = arith.add v308, v677 : u32 #[overflow = checked];
            v676 = arith.constant 8 : u32;
            v312 = arith.mod v310, v676 : u32;
            hir.assertz v312 #[code = 250];
            v313 = hir.int_to_ptr v310 : ptr<byte, i64>;
            v314 = hir.load v313 : i64;
            v675 = arith.constant 72 : u32;
            v315 = hir.bitcast v629 : u32;
            v317 = arith.add v315, v675 : u32 #[overflow = checked];
            v674 = arith.constant 8 : u32;
            v319 = arith.mod v317, v674 : u32;
            hir.assertz v319 #[code = 250];
            v320 = hir.int_to_ptr v317 : ptr<byte, i64>;
            hir.store v320, v314;
            v673 = arith.constant 32 : u32;
            v321 = hir.bitcast v629 : u32;
            v323 = arith.add v321, v673 : u32 #[overflow = checked];
            v672 = arith.constant 8 : u32;
            v325 = arith.mod v323, v672 : u32;
            hir.assertz v325 #[code = 250];
            v326 = hir.int_to_ptr v323 : ptr<byte, i64>;
            v327 = hir.load v326 : i64;
            v671 = arith.constant 64 : u32;
            v328 = hir.bitcast v629 : u32;
            v330 = arith.add v328, v671 : u32 #[overflow = checked];
            v670 = arith.constant 8 : u32;
            v332 = arith.mod v330, v670 : u32;
            hir.assertz v332 #[code = 250];
            v333 = hir.int_to_ptr v330 : ptr<byte, i64>;
            hir.store v333, v327;
            v336 = arith.constant 120 : u32;
            v335 = hir.bitcast v629 : u32;
            v337 = arith.add v335, v336 : u32 #[overflow = checked];
            v669 = arith.constant 4 : u32;
            v339 = arith.mod v337, v669 : u32;
            hir.assertz v339 #[code = 250];
            v668 = arith.constant 17179869216 : i64;
            v340 = hir.int_to_ptr v337 : ptr<byte, i64>;
            hir.store v340, v668;
            v343 = arith.constant 112 : u32;
            v342 = hir.bitcast v629 : u32;
            v344 = arith.add v342, v343 : u32 #[overflow = checked];
            v667 = arith.constant 4 : u32;
            v346 = arith.mod v344, v667 : u32;
            hir.assertz v346 #[code = 250];
            v666 = arith.constant 0 : i32;
            v347 = hir.int_to_ptr v344 : ptr<byte, i32>;
            hir.store v347, v666;
            v351 = arith.constant 108 : u32;
            v350 = hir.bitcast v629 : u32;
            v352 = arith.add v350, v351 : u32 #[overflow = checked];
            v665 = arith.constant 4 : u32;
            v354 = arith.mod v352, v665 : u32;
            hir.assertz v354 #[code = 250];
            v664 = arith.constant 96 : i32;
            v349 = arith.add v629, v664 : i32 #[overflow = wrapping];
            v355 = hir.int_to_ptr v352 : ptr<byte, i32>;
            hir.store v355, v349;
            v359 = arith.constant 116 : u32;
            v358 = hir.bitcast v629 : u32;
            v360 = arith.add v358, v359 : u32 #[overflow = checked];
            v663 = arith.constant 4 : u32;
            v362 = arith.mod v360, v663 : u32;
            hir.assertz v362 #[code = 250];
            v662 = arith.constant 64 : i32;
            v357 = arith.add v629, v662 : i32 #[overflow = wrapping];
            v363 = hir.int_to_ptr v360 : ptr<byte, i32>;
            hir.store v363, v357;
            v606, v607, v608, v609, v610, v611 = scf.while v629, v630, v631 : i32, i32, i32, i32, i32, i32 {
            ^block52(v612: i32, v613: i32, v614: i32):
                v367 = arith.constant 108 : i32;
                v368 = arith.add v612, v367 : i32 #[overflow = wrapping];
                v661 = arith.constant 16 : i32;
                v366 = arith.add v612, v661 : i32 #[overflow = wrapping];
                hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/<core::slice::iter::ChunksExactMut<u8> as core::iter::traits::iterator::Iterator>::next(v366, v368)
                v370 = arith.constant 16 : u32;
                v369 = hir.bitcast v612 : u32;
                v371 = arith.add v369, v370 : u32 #[overflow = checked];
                v660 = arith.constant 4 : u32;
                v373 = arith.mod v371, v660 : u32;
                hir.assertz v373 #[code = 250];
                v374 = hir.int_to_ptr v371 : ptr<byte, i32>;
                v375 = hir.load v374 : i32;
                v658 = arith.constant 0 : i32;
                v659 = arith.constant 0 : i32;
                v377 = arith.eq v375, v659 : i1;
                v378 = arith.zext v377 : u32;
                v379 = hir.bitcast v378 : i32;
                v381 = arith.neq v379, v658 : i1;
                scf.if v381{
                ^block51:
                    scf.yield ;
                } else {
                ^block24:
                    v383 = arith.constant 20 : u32;
                    v382 = hir.bitcast v612 : u32;
                    v384 = arith.add v382, v383 : u32 #[overflow = checked];
                    v657 = arith.constant 4 : u32;
                    v386 = arith.mod v384, v657 : u32;
                    hir.assertz v386 #[code = 250];
                    v387 = hir.int_to_ptr v384 : ptr<byte, i32>;
                    v388 = hir.load v387 : i32;
                    hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/<[u8]>::reverse(v375, v388)
                    scf.yield ;
                };
                v652 = ub.poison i32 : i32;
                v603 = cf.select v381, v652, v614 : i32;
                v653 = ub.poison i32 : i32;
                v602 = cf.select v381, v653, v613 : i32;
                v654 = ub.poison i32 : i32;
                v601 = cf.select v381, v654, v612 : i32;
                v655 = arith.constant 1 : u32;
                v656 = arith.constant 0 : u32;
                v605 = cf.select v381, v656, v655 : u32;
                v551 = arith.trunc v605 : i1;
                scf.condition v551, v601, v602, v603, v612, v613, v614;
            } do {
            ^block53(v615: i32, v616: i32, v617: i32, v618: i32, v619: i32, v620: i32):
                scf.yield v615, v616, v617;
            };
            v651 = arith.constant 64 : u32;
            v391 = hir.bitcast v609 : u32;
            v393 = arith.add v391, v651 : u32 #[overflow = checked];
            v650 = arith.constant 8 : u32;
            v395 = arith.mod v393, v650 : u32;
            hir.assertz v395 #[code = 250];
            v396 = hir.int_to_ptr v393 : ptr<byte, i64>;
            v397 = hir.load v396 : i64;
            v398 = hir.bitcast v610 : u32;
            v399 = hir.int_to_ptr v398 : ptr<byte, i64>;
            hir.store v399, v397;
            v649 = arith.constant 88 : u32;
            v402 = hir.bitcast v609 : u32;
            v404 = arith.add v402, v649 : u32 #[overflow = checked];
            v648 = arith.constant 8 : u32;
            v406 = arith.mod v404, v648 : u32;
            hir.assertz v406 #[code = 250];
            v407 = hir.int_to_ptr v404 : ptr<byte, i64>;
            v408 = hir.load v407 : i64;
            v647 = arith.constant 24 : i32;
            v401 = arith.add v610, v647 : i32 #[overflow = wrapping];
            v409 = hir.bitcast v401 : u32;
            v410 = hir.int_to_ptr v409 : ptr<byte, i64>;
            hir.store v410, v408;
            v646 = arith.constant 80 : u32;
            v413 = hir.bitcast v609 : u32;
            v415 = arith.add v413, v646 : u32 #[overflow = checked];
            v645 = arith.constant 8 : u32;
            v417 = arith.mod v415, v645 : u32;
            hir.assertz v417 #[code = 250];
            v418 = hir.int_to_ptr v415 : ptr<byte, i64>;
            v419 = hir.load v418 : i64;
            v644 = arith.constant 16 : i32;
            v412 = arith.add v610, v644 : i32 #[overflow = wrapping];
            v420 = hir.bitcast v412 : u32;
            v421 = hir.int_to_ptr v420 : ptr<byte, i64>;
            hir.store v421, v419;
            v643 = arith.constant 72 : u32;
            v424 = hir.bitcast v609 : u32;
            v426 = arith.add v424, v643 : u32 #[overflow = checked];
            v642 = arith.constant 8 : u32;
            v428 = arith.mod v426, v642 : u32;
            hir.assertz v428 #[code = 250];
            v429 = hir.int_to_ptr v426 : ptr<byte, i64>;
            v430 = hir.load v429 : i64;
            v641 = arith.constant 8 : i32;
            v423 = arith.add v610, v641 : i32 #[overflow = wrapping];
            v431 = hir.bitcast v423 : u32;
            v432 = hir.int_to_ptr v431 : ptr<byte, i64>;
            hir.store v432, v430;
            v435 = builtin.global_symbol @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/__stack_pointer : ptr<byte, u8>
            v436 = hir.bitcast v435 : ptr<byte, i32>;
            hir.store v436, v611;
            builtin.ret ;
        };

        private builtin.function @miden::core::crypto::hashes::sha256::hash_1to1(v437: i32, v438: i32, v439: i32, v440: i32, v441: i32, v442: i32, v443: i32, v444: i32, v445: i32) {
        ^block25(v437: i32, v438: i32, v439: i32, v440: i32, v441: i32, v442: i32, v443: i32, v444: i32, v445: i32):
            ub.unreachable ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};