builtin.component root_ns:root@1.0.0 {
    builtin.module public @rust_sdk_stdlib_sha256_hash {
        private builtin.function @<[u8]>::reverse(v0: i32, v1: i32) {
        ^block4(v0: i32, v1: i32):
            hir.store_local v0 #[local = lv0];
            hir.store_local v1 #[local = lv1];
            v2 = hir.load_local  : i32 #[local = lv1];
            v557 = arith.constant 1 : u32;
            v4 = hir.bitcast v2 : u32;
            v6 = arith.shr v4, v557 : u32;
            v7 = hir.bitcast v6 : i32;
            hir.store_local v7 #[local = lv2];
            v8 = hir.load_local  : i32 #[local = lv1];
            v9 = hir.load_local  : i32 #[local = lv0];
            v549 = arith.constant -1 : i32;
            v10 = arith.add v8, v9 : i32 #[overflow = wrapping];
            v12 = arith.add v10, v549 : i32 #[overflow = wrapping];
            hir.store_local v12 #[local = lv1];
            scf.while  {
            ^block7:
                v13 = hir.load_local  : i32 #[local = lv2];
                v566 = arith.constant 0 : i32;
                v553 = arith.constant 0 : i32;
                v15 = arith.eq v13, v553 : i1;
                v16 = arith.zext v15 : u32;
                v17 = hir.bitcast v16 : i32;
                v19 = arith.neq v17, v566 : i1;
                scf.if v19{
                ^block39:
                    scf.yield ;
                } else {
                ^block9:
                    v20 = hir.load_local  : i32 #[local = lv0];
                    v21 = hir.bitcast v20 : u32;
                    v22 = hir.int_to_ptr v21 : ptr<byte, u8>;
                    v23 = hir.load v22 : u8;
                    v26 = hir.load_local  : i32 #[local = lv0];
                    v27 = hir.load_local  : i32 #[local = lv1];
                    v28 = hir.bitcast v27 : u32;
                    v29 = hir.int_to_ptr v28 : ptr<byte, u8>;
                    v30 = hir.load v29 : u8;
                    v31 = arith.zext v30 : u32;
                    v32 = hir.bitcast v31 : i32;
                    v33 = hir.bitcast v32 : u32;
                    v34 = arith.trunc v33 : u8;
                    v35 = hir.bitcast v26 : u32;
                    v36 = hir.int_to_ptr v35 : ptr<byte, u8>;
                    hir.store v36, v34;
                    v37 = hir.load_local  : i32 #[local = lv1];
                    v24 = arith.zext v23 : u32;
                    v25 = hir.bitcast v24 : i32;
                    v39 = hir.bitcast v25 : u32;
                    v40 = arith.trunc v39 : u8;
                    v41 = hir.bitcast v37 : u32;
                    v42 = hir.int_to_ptr v41 : ptr<byte, u8>;
                    hir.store v42, v40;
                    v43 = hir.load_local  : i32 #[local = lv2];
                    v565 = arith.constant -1 : i32;
                    v45 = arith.add v43, v565 : i32 #[overflow = wrapping];
                    hir.store_local v45 #[local = lv2];
                    v46 = hir.load_local  : i32 #[local = lv0];
                    v550 = arith.constant 1 : i32;
                    v48 = arith.add v46, v550 : i32 #[overflow = wrapping];
                    hir.store_local v48 #[local = lv0];
                    v49 = hir.load_local  : i32 #[local = lv1];
                    v564 = arith.constant -1 : i32;
                    v51 = arith.add v49, v564 : i32 #[overflow = wrapping];
                    hir.store_local v51 #[local = lv1];
                    scf.yield ;
                };
                v563 = arith.constant 1 : u32;
                v554 = arith.constant 0 : u32;
                v562 = cf.select v19, v554, v563 : u32;
                v558 = arith.trunc v562 : i1;
                scf.condition v558;
            } do {
            ^block38:
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @<core::slice::iter::ChunksExactMut<u8> as core::iter::traits::iterator::Iterator>::next(v52: i32, v53: i32) {
        ^block10(v52: i32, v53: i32):
            hir.store_local v52 #[local = lv0];
            hir.store_local v53 #[local = lv1];
            v54 = hir.load_local  : i32 #[local = lv1];
            v571 = arith.constant 16 : u32;
            v55 = hir.bitcast v54 : u32;
            v57 = arith.add v55, v571 : u32 #[overflow = checked];
            v570 = arith.constant 4 : u32;
            v59 = arith.mod v57, v570 : u32;
            hir.assertz v59 #[code = 250];
            v60 = hir.int_to_ptr v57 : ptr<byte, i32>;
            v61 = hir.load v60 : i32;
            hir.store_local v61 #[local = lv2];
            v569 = arith.constant 0 : i32;
            hir.store_local v569 #[local = lv3];
            v63 = hir.load_local  : i32 #[local = lv1];
            v568 = arith.constant 8 : u32;
            v64 = hir.bitcast v63 : u32;
            v66 = arith.add v64, v568 : u32 #[overflow = checked];
            v596 = arith.constant 4 : u32;
            v68 = arith.mod v66, v596 : u32;
            hir.assertz v68 #[code = 250];
            v69 = hir.int_to_ptr v66 : ptr<byte, i32>;
            v70 = hir.load v69 : i32;
            hir.store_local v70 #[local = lv4];
            v594 = arith.constant 0 : i32;
            v595 = arith.constant 0 : i32;
            v72 = arith.eq v70, v595 : i1;
            v73 = arith.zext v72 : u32;
            v74 = hir.bitcast v73 : i32;
            v76 = arith.neq v74, v594 : i1;
            scf.if v76{
            ^block41:
                scf.yield ;
            } else {
            ^block13:
                v77 = hir.load_local  : i32 #[local = lv1];
                v567 = arith.constant 12 : u32;
                v78 = hir.bitcast v77 : u32;
                v80 = arith.add v78, v567 : u32 #[overflow = checked];
                v593 = arith.constant 4 : u32;
                v82 = arith.mod v80, v593 : u32;
                hir.assertz v82 #[code = 250];
                v83 = hir.int_to_ptr v80 : ptr<byte, i32>;
                v84 = hir.load v83 : i32;
                hir.store_local v84 #[local = lv5];
                v85 = hir.load_local  : i32 #[local = lv2];
                v592 = arith.constant 0 : i32;
                v87 = hir.bitcast v85 : u32;
                v86 = hir.bitcast v84 : u32;
                v88 = arith.lt v86, v87 : i1;
                v89 = arith.zext v88 : u32;
                v90 = hir.bitcast v89 : i32;
                v92 = arith.neq v90, v592 : i1;
                scf.if v92{
                ^block40:
                    scf.yield ;
                } else {
                ^block14:
                    v93 = hir.load_local  : i32 #[local = lv1];
                    v94 = hir.load_local  : i32 #[local = lv5];
                    v95 = hir.load_local  : i32 #[local = lv2];
                    v591 = arith.constant 12 : u32;
                    v97 = hir.bitcast v93 : u32;
                    v99 = arith.add v97, v591 : u32 #[overflow = checked];
                    v590 = arith.constant 4 : u32;
                    v101 = arith.mod v99, v590 : u32;
                    hir.assertz v101 #[code = 250];
                    v96 = arith.sub v94, v95 : i32 #[overflow = wrapping];
                    v102 = hir.int_to_ptr v99 : ptr<byte, i32>;
                    hir.store v102, v96;
                    v103 = hir.load_local  : i32 #[local = lv1];
                    v104 = hir.load_local  : i32 #[local = lv4];
                    v105 = hir.load_local  : i32 #[local = lv2];
                    v589 = arith.constant 8 : u32;
                    v107 = hir.bitcast v103 : u32;
                    v109 = arith.add v107, v589 : u32 #[overflow = checked];
                    v588 = arith.constant 4 : u32;
                    v111 = arith.mod v109, v588 : u32;
                    hir.assertz v111 #[code = 250];
                    v106 = arith.add v104, v105 : i32 #[overflow = wrapping];
                    v112 = hir.int_to_ptr v109 : ptr<byte, i32>;
                    hir.store v112, v106;
                    v113 = hir.load_local  : i32 #[local = lv4];
                    hir.store_local v113 #[local = lv3];
                    scf.yield ;
                };
                scf.yield ;
            };
            v114 = hir.load_local  : i32 #[local = lv0];
            v115 = hir.load_local  : i32 #[local = lv2];
            v587 = arith.constant 4 : u32;
            v116 = hir.bitcast v114 : u32;
            v118 = arith.add v116, v587 : u32 #[overflow = checked];
            v586 = arith.constant 4 : u32;
            v120 = arith.mod v118, v586 : u32;
            hir.assertz v120 #[code = 250];
            v121 = hir.int_to_ptr v118 : ptr<byte, i32>;
            hir.store v121, v115;
            v122 = hir.load_local  : i32 #[local = lv0];
            v123 = hir.load_local  : i32 #[local = lv3];
            v124 = hir.bitcast v122 : u32;
            v585 = arith.constant 4 : u32;
            v126 = arith.mod v124, v585 : u32;
            hir.assertz v126 #[code = 250];
            v127 = hir.int_to_ptr v124 : ptr<byte, i32>;
            hir.store v127, v123;
            builtin.ret ;
        };

        public builtin.function @entrypoint(v128: i32, v129: i32) {
        ^block15(v128: i32, v129: i32):
            hir.store_local v128 #[local = lv0];
            hir.store_local v129 #[local = lv1];
            v130 = builtin.global_symbol @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/__stack_pointer : ptr<byte, u8>
            v131 = hir.bitcast v130 : ptr<byte, i32>;
            v132 = hir.load v131 : i32;
            hir.store_local v132 #[local = lv2];
            hir.store_local v132 #[local = lv3];
            v133 = hir.load_local  : i32 #[local = lv2];
            v630 = arith.constant -32 : i32;
            v631 = arith.constant 128 : i32;
            v135 = arith.sub v133, v631 : i32 #[overflow = wrapping];
            v137 = arith.band v135, v630 : i32;
            hir.store_local v137 #[local = lv2];
            v138 = builtin.global_symbol @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/__stack_pointer : ptr<byte, u8>
            v139 = hir.bitcast v138 : ptr<byte, i32>;
            hir.store v139, v137;
            v140 = hir.load_local  : i32 #[local = lv2];
            v145 = hir.load_local  : i32 #[local = lv1];
            v628 = arith.constant 24 : i32;
            v147 = arith.add v145, v628 : i32 #[overflow = wrapping];
            v148 = hir.bitcast v147 : u32;
            v149 = hir.int_to_ptr v148 : ptr<byte, i64>;
            v150 = hir.load v149 : i64;
            v779 = arith.constant 24 : i32;
            v629 = arith.constant 64 : i32;
            v142 = arith.add v140, v629 : i32 #[overflow = wrapping];
            v144 = arith.add v142, v779 : i32 #[overflow = wrapping];
            v151 = hir.bitcast v144 : u32;
            v627 = arith.constant 8 : u32;
            v153 = arith.mod v151, v627 : u32;
            hir.assertz v153 #[code = 250];
            v154 = hir.int_to_ptr v151 : ptr<byte, i64>;
            hir.store v154, v150;
            v155 = hir.load_local  : i32 #[local = lv2];
            v160 = hir.load_local  : i32 #[local = lv1];
            v626 = arith.constant 16 : i32;
            v162 = arith.add v160, v626 : i32 #[overflow = wrapping];
            v163 = hir.bitcast v162 : u32;
            v164 = hir.int_to_ptr v163 : ptr<byte, i64>;
            v165 = hir.load v164 : i64;
            v777 = arith.constant 16 : i32;
            v778 = arith.constant 64 : i32;
            v157 = arith.add v155, v778 : i32 #[overflow = wrapping];
            v159 = arith.add v157, v777 : i32 #[overflow = wrapping];
            v166 = hir.bitcast v159 : u32;
            v776 = arith.constant 8 : u32;
            v168 = arith.mod v166, v776 : u32;
            hir.assertz v168 #[code = 250];
            v169 = hir.int_to_ptr v166 : ptr<byte, i64>;
            hir.store v169, v165;
            v170 = hir.load_local  : i32 #[local = lv2];
            v175 = hir.load_local  : i32 #[local = lv1];
            v625 = arith.constant 8 : i32;
            v177 = arith.add v175, v625 : i32 #[overflow = wrapping];
            v178 = hir.bitcast v177 : u32;
            v179 = hir.int_to_ptr v178 : ptr<byte, i64>;
            v180 = hir.load v179 : i64;
            v774 = arith.constant 8 : i32;
            v775 = arith.constant 64 : i32;
            v172 = arith.add v170, v775 : i32 #[overflow = wrapping];
            v174 = arith.add v172, v774 : i32 #[overflow = wrapping];
            v181 = hir.bitcast v174 : u32;
            v773 = arith.constant 8 : u32;
            v183 = arith.mod v181, v773 : u32;
            hir.assertz v183 #[code = 250];
            v184 = hir.int_to_ptr v181 : ptr<byte, i64>;
            hir.store v184, v180;
            v185 = hir.load_local  : i32 #[local = lv2];
            v186 = hir.load_local  : i32 #[local = lv1];
            v187 = hir.bitcast v186 : u32;
            v188 = hir.int_to_ptr v187 : ptr<byte, i64>;
            v189 = hir.load v188 : i64;
            v624 = arith.constant 64 : u32;
            v190 = hir.bitcast v185 : u32;
            v192 = arith.add v190, v624 : u32 #[overflow = checked];
            v772 = arith.constant 8 : u32;
            v194 = arith.mod v192, v772 : u32;
            hir.assertz v194 #[code = 250];
            v195 = hir.int_to_ptr v192 : ptr<byte, i64>;
            hir.store v195, v189;
            v196 = hir.load_local  : i32 #[local = lv2];
            v622 = arith.constant 44 : u32;
            v198 = hir.bitcast v196 : u32;
            v200 = arith.add v198, v622 : u32 #[overflow = checked];
            v621 = arith.constant 4 : u32;
            v202 = arith.mod v200, v621 : u32;
            hir.assertz v202 #[code = 250];
            v623 = arith.constant 17179869216 : i64;
            v203 = hir.int_to_ptr v200 : ptr<byte, i64>;
            hir.store v203, v623;
            v204 = hir.load_local  : i32 #[local = lv2];
            v619 = arith.constant 36 : u32;
            v206 = hir.bitcast v204 : u32;
            v208 = arith.add v206, v619 : u32 #[overflow = checked];
            v771 = arith.constant 4 : u32;
            v210 = arith.mod v208, v771 : u32;
            hir.assertz v210 #[code = 250];
            v620 = arith.constant 0 : i32;
            v211 = hir.int_to_ptr v208 : ptr<byte, i32>;
            hir.store v211, v620;
            v212 = hir.load_local  : i32 #[local = lv2];
            v617 = arith.constant 32 : u32;
            v216 = hir.bitcast v212 : u32;
            v218 = arith.add v216, v617 : u32 #[overflow = checked];
            v770 = arith.constant 4 : u32;
            v220 = arith.mod v218, v770 : u32;
            hir.assertz v220 #[code = 250];
            v618 = arith.constant 96 : i32;
            v215 = arith.add v212, v618 : i32 #[overflow = wrapping];
            v221 = hir.int_to_ptr v218 : ptr<byte, i32>;
            hir.store v221, v215;
            v222 = hir.load_local  : i32 #[local = lv2];
            v616 = arith.constant 40 : u32;
            v226 = hir.bitcast v222 : u32;
            v228 = arith.add v226, v616 : u32 #[overflow = checked];
            v769 = arith.constant 4 : u32;
            v230 = arith.mod v228, v769 : u32;
            hir.assertz v230 #[code = 250];
            v768 = arith.constant 64 : i32;
            v225 = arith.add v222, v768 : i32 #[overflow = wrapping];
            v231 = hir.int_to_ptr v228 : ptr<byte, i32>;
            hir.store v231, v225;
            scf.while  {
            ^block18:
                v232 = hir.load_local  : i32 #[local = lv2];
                v652 = arith.constant 32 : i32;
                v237 = arith.add v232, v652 : i32 #[overflow = wrapping];
                v767 = arith.constant 24 : i32;
                v234 = arith.add v232, v767 : i32 #[overflow = wrapping];
                hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/<core::slice::iter::ChunksExactMut<u8> as core::iter::traits::iterator::Iterator>::next(v234, v237)
                v238 = hir.load_local  : i32 #[local = lv2];
                v601 = arith.constant 24 : u32;
                v239 = hir.bitcast v238 : u32;
                v241 = arith.add v239, v601 : u32 #[overflow = checked];
                v766 = arith.constant 4 : u32;
                v243 = arith.mod v241, v766 : u32;
                hir.assertz v243 #[code = 250];
                v244 = hir.int_to_ptr v241 : ptr<byte, i32>;
                v245 = hir.load v244 : i32;
                hir.store_local v245 #[local = lv1];
                v764 = arith.constant 0 : i32;
                v765 = arith.constant 0 : i32;
                v247 = arith.eq v245, v765 : i1;
                v248 = arith.zext v247 : u32;
                v249 = hir.bitcast v248 : i32;
                v251 = arith.neq v249, v764 : i1;
                scf.if v251{
                ^block55:
                    scf.yield ;
                } else {
                ^block20:
                    v252 = hir.load_local  : i32 #[local = lv1];
                    v253 = hir.load_local  : i32 #[local = lv2];
                    v600 = arith.constant 28 : u32;
                    v254 = hir.bitcast v253 : u32;
                    v256 = arith.add v254, v600 : u32 #[overflow = checked];
                    v763 = arith.constant 4 : u32;
                    v258 = arith.mod v256, v763 : u32;
                    hir.assertz v258 #[code = 250];
                    v259 = hir.int_to_ptr v256 : ptr<byte, i32>;
                    v260 = hir.load v259 : i32;
                    hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/<[u8]>::reverse(v252, v260)
                    scf.yield ;
                };
                v700 = arith.constant 1 : u32;
                v697 = arith.constant 0 : u32;
                v712 = cf.select v251, v697, v700 : u32;
                v704 = arith.trunc v712 : i1;
                scf.condition v704;
            } do {
            ^block54:
                scf.yield ;
            };
            v261 = hir.load_local  : i32 #[local = lv2];
            v762 = arith.constant 64 : u32;
            v262 = hir.bitcast v261 : u32;
            v264 = arith.add v262, v762 : u32 #[overflow = checked];
            v761 = arith.constant 4 : u32;
            v266 = arith.mod v264, v761 : u32;
            hir.assertz v266 #[code = 250];
            v267 = hir.int_to_ptr v264 : ptr<byte, i32>;
            v268 = hir.load v267 : i32;
            v269 = hir.load_local  : i32 #[local = lv2];
            v615 = arith.constant 68 : u32;
            v270 = hir.bitcast v269 : u32;
            v272 = arith.add v270, v615 : u32 #[overflow = checked];
            v760 = arith.constant 4 : u32;
            v274 = arith.mod v272, v760 : u32;
            hir.assertz v274 #[code = 250];
            v275 = hir.int_to_ptr v272 : ptr<byte, i32>;
            v276 = hir.load v275 : i32;
            v277 = hir.load_local  : i32 #[local = lv2];
            v614 = arith.constant 72 : u32;
            v278 = hir.bitcast v277 : u32;
            v280 = arith.add v278, v614 : u32 #[overflow = checked];
            v759 = arith.constant 4 : u32;
            v282 = arith.mod v280, v759 : u32;
            hir.assertz v282 #[code = 250];
            v283 = hir.int_to_ptr v280 : ptr<byte, i32>;
            v284 = hir.load v283 : i32;
            v285 = hir.load_local  : i32 #[local = lv2];
            v613 = arith.constant 76 : u32;
            v286 = hir.bitcast v285 : u32;
            v288 = arith.add v286, v613 : u32 #[overflow = checked];
            v758 = arith.constant 4 : u32;
            v290 = arith.mod v288, v758 : u32;
            hir.assertz v290 #[code = 250];
            v291 = hir.int_to_ptr v288 : ptr<byte, i32>;
            v292 = hir.load v291 : i32;
            v293 = hir.load_local  : i32 #[local = lv2];
            v612 = arith.constant 80 : u32;
            v294 = hir.bitcast v293 : u32;
            v296 = arith.add v294, v612 : u32 #[overflow = checked];
            v757 = arith.constant 4 : u32;
            v298 = arith.mod v296, v757 : u32;
            hir.assertz v298 #[code = 250];
            v299 = hir.int_to_ptr v296 : ptr<byte, i32>;
            v300 = hir.load v299 : i32;
            v301 = hir.load_local  : i32 #[local = lv2];
            v611 = arith.constant 84 : u32;
            v302 = hir.bitcast v301 : u32;
            v304 = arith.add v302, v611 : u32 #[overflow = checked];
            v756 = arith.constant 4 : u32;
            v306 = arith.mod v304, v756 : u32;
            hir.assertz v306 #[code = 250];
            v307 = hir.int_to_ptr v304 : ptr<byte, i32>;
            v308 = hir.load v307 : i32;
            v309 = hir.load_local  : i32 #[local = lv2];
            v610 = arith.constant 88 : u32;
            v310 = hir.bitcast v309 : u32;
            v312 = arith.add v310, v610 : u32 #[overflow = checked];
            v755 = arith.constant 4 : u32;
            v314 = arith.mod v312, v755 : u32;
            hir.assertz v314 #[code = 250];
            v315 = hir.int_to_ptr v312 : ptr<byte, i32>;
            v316 = hir.load v315 : i32;
            v317 = hir.load_local  : i32 #[local = lv2];
            v609 = arith.constant 92 : u32;
            v318 = hir.bitcast v317 : u32;
            v320 = arith.add v318, v609 : u32 #[overflow = checked];
            v754 = arith.constant 4 : u32;
            v322 = arith.mod v320, v754 : u32;
            hir.assertz v322 #[code = 250];
            v323 = hir.int_to_ptr v320 : ptr<byte, i32>;
            v324 = hir.load v323 : i32;
            v325 = hir.load_local  : i32 #[local = lv2];
            v753 = arith.constant 32 : i32;
            v327 = arith.add v325, v753 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/miden::core::crypto::hashes::sha256::hash(v268, v276, v284, v292, v300, v308, v316, v324, v327)
            v328 = hir.load_local  : i32 #[local = lv2];
            v607 = arith.constant 56 : u32;
            v330 = hir.bitcast v328 : u32;
            v332 = arith.add v330, v607 : u32 #[overflow = checked];
            v752 = arith.constant 8 : u32;
            v334 = arith.mod v332, v752 : u32;
            hir.assertz v334 #[code = 250];
            v335 = hir.int_to_ptr v332 : ptr<byte, i64>;
            v336 = hir.load v335 : i64;
            v751 = arith.constant 88 : u32;
            v337 = hir.bitcast v328 : u32;
            v339 = arith.add v337, v751 : u32 #[overflow = checked];
            v750 = arith.constant 8 : u32;
            v341 = arith.mod v339, v750 : u32;
            hir.assertz v341 #[code = 250];
            v342 = hir.int_to_ptr v339 : ptr<byte, i64>;
            hir.store v342, v336;
            v343 = hir.load_local  : i32 #[local = lv2];
            v606 = arith.constant 48 : u32;
            v345 = hir.bitcast v343 : u32;
            v347 = arith.add v345, v606 : u32 #[overflow = checked];
            v749 = arith.constant 8 : u32;
            v349 = arith.mod v347, v749 : u32;
            hir.assertz v349 #[code = 250];
            v350 = hir.int_to_ptr v347 : ptr<byte, i64>;
            v351 = hir.load v350 : i64;
            v748 = arith.constant 80 : u32;
            v352 = hir.bitcast v343 : u32;
            v354 = arith.add v352, v748 : u32 #[overflow = checked];
            v747 = arith.constant 8 : u32;
            v356 = arith.mod v354, v747 : u32;
            hir.assertz v356 #[code = 250];
            v357 = hir.int_to_ptr v354 : ptr<byte, i64>;
            hir.store v357, v351;
            v358 = hir.load_local  : i32 #[local = lv2];
            v746 = arith.constant 40 : u32;
            v360 = hir.bitcast v358 : u32;
            v362 = arith.add v360, v746 : u32 #[overflow = checked];
            v745 = arith.constant 8 : u32;
            v364 = arith.mod v362, v745 : u32;
            hir.assertz v364 #[code = 250];
            v365 = hir.int_to_ptr v362 : ptr<byte, i64>;
            v366 = hir.load v365 : i64;
            v744 = arith.constant 72 : u32;
            v367 = hir.bitcast v358 : u32;
            v369 = arith.add v367, v744 : u32 #[overflow = checked];
            v743 = arith.constant 8 : u32;
            v371 = arith.mod v369, v743 : u32;
            hir.assertz v371 #[code = 250];
            v372 = hir.int_to_ptr v369 : ptr<byte, i64>;
            hir.store v372, v366;
            v373 = hir.load_local  : i32 #[local = lv2];
            v742 = arith.constant 32 : u32;
            v375 = hir.bitcast v373 : u32;
            v377 = arith.add v375, v742 : u32 #[overflow = checked];
            v741 = arith.constant 8 : u32;
            v379 = arith.mod v377, v741 : u32;
            hir.assertz v379 #[code = 250];
            v380 = hir.int_to_ptr v377 : ptr<byte, i64>;
            v381 = hir.load v380 : i64;
            v740 = arith.constant 64 : u32;
            v382 = hir.bitcast v373 : u32;
            v384 = arith.add v382, v740 : u32 #[overflow = checked];
            v739 = arith.constant 8 : u32;
            v386 = arith.mod v384, v739 : u32;
            hir.assertz v386 #[code = 250];
            v387 = hir.int_to_ptr v384 : ptr<byte, i64>;
            hir.store v387, v381;
            v388 = hir.load_local  : i32 #[local = lv2];
            v605 = arith.constant 120 : u32;
            v390 = hir.bitcast v388 : u32;
            v392 = arith.add v390, v605 : u32 #[overflow = checked];
            v738 = arith.constant 4 : u32;
            v394 = arith.mod v392, v738 : u32;
            hir.assertz v394 #[code = 250];
            v737 = arith.constant 17179869216 : i64;
            v395 = hir.int_to_ptr v392 : ptr<byte, i64>;
            hir.store v395, v737;
            v396 = hir.load_local  : i32 #[local = lv2];
            v604 = arith.constant 112 : u32;
            v398 = hir.bitcast v396 : u32;
            v400 = arith.add v398, v604 : u32 #[overflow = checked];
            v736 = arith.constant 4 : u32;
            v402 = arith.mod v400, v736 : u32;
            hir.assertz v402 #[code = 250];
            v735 = arith.constant 0 : i32;
            v403 = hir.int_to_ptr v400 : ptr<byte, i32>;
            hir.store v403, v735;
            v404 = hir.load_local  : i32 #[local = lv2];
            v603 = arith.constant 108 : u32;
            v408 = hir.bitcast v404 : u32;
            v410 = arith.add v408, v603 : u32 #[overflow = checked];
            v734 = arith.constant 4 : u32;
            v412 = arith.mod v410, v734 : u32;
            hir.assertz v412 #[code = 250];
            v733 = arith.constant 96 : i32;
            v407 = arith.add v404, v733 : i32 #[overflow = wrapping];
            v413 = hir.int_to_ptr v410 : ptr<byte, i32>;
            hir.store v413, v407;
            v414 = hir.load_local  : i32 #[local = lv2];
            v602 = arith.constant 116 : u32;
            v418 = hir.bitcast v414 : u32;
            v420 = arith.add v418, v602 : u32 #[overflow = checked];
            v732 = arith.constant 4 : u32;
            v422 = arith.mod v420, v732 : u32;
            hir.assertz v422 #[code = 250];
            v731 = arith.constant 64 : i32;
            v417 = arith.add v414, v731 : i32 #[overflow = wrapping];
            v423 = hir.int_to_ptr v420 : ptr<byte, i32>;
            hir.store v423, v417;
            scf.while  {
            ^block22:
                v424 = hir.load_local  : i32 #[local = lv2];
                v599 = arith.constant 108 : i32;
                v429 = arith.add v424, v599 : i32 #[overflow = wrapping];
                v730 = arith.constant 16 : i32;
                v426 = arith.add v424, v730 : i32 #[overflow = wrapping];
                hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/<core::slice::iter::ChunksExactMut<u8> as core::iter::traits::iterator::Iterator>::next(v426, v429)
                v430 = hir.load_local  : i32 #[local = lv2];
                v598 = arith.constant 16 : u32;
                v431 = hir.bitcast v430 : u32;
                v433 = arith.add v431, v598 : u32 #[overflow = checked];
                v729 = arith.constant 4 : u32;
                v435 = arith.mod v433, v729 : u32;
                hir.assertz v435 #[code = 250];
                v436 = hir.int_to_ptr v433 : ptr<byte, i32>;
                v437 = hir.load v436 : i32;
                hir.store_local v437 #[local = lv1];
                v727 = arith.constant 0 : i32;
                v728 = arith.constant 0 : i32;
                v439 = arith.eq v437, v728 : i1;
                v440 = arith.zext v439 : u32;
                v441 = hir.bitcast v440 : i32;
                v443 = arith.neq v441, v727 : i1;
                scf.if v443{
                ^block56:
                    scf.yield ;
                } else {
                ^block24:
                    v444 = hir.load_local  : i32 #[local = lv1];
                    v445 = hir.load_local  : i32 #[local = lv2];
                    v597 = arith.constant 20 : u32;
                    v446 = hir.bitcast v445 : u32;
                    v448 = arith.add v446, v597 : u32 #[overflow = checked];
                    v726 = arith.constant 4 : u32;
                    v450 = arith.mod v448, v726 : u32;
                    hir.assertz v450 #[code = 250];
                    v451 = hir.int_to_ptr v448 : ptr<byte, i32>;
                    v452 = hir.load v451 : i32;
                    hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/<[u8]>::reverse(v444, v452)
                    scf.yield ;
                };
                v724 = arith.constant 1 : u32;
                v725 = arith.constant 0 : u32;
                v710 = cf.select v443, v725, v724 : u32;
                v701 = arith.trunc v710 : i1;
                scf.condition v701;
            } do {
            ^block49:
                scf.yield ;
            };
            v453 = hir.load_local  : i32 #[local = lv0];
            v454 = hir.load_local  : i32 #[local = lv2];
            v723 = arith.constant 64 : u32;
            v455 = hir.bitcast v454 : u32;
            v457 = arith.add v455, v723 : u32 #[overflow = checked];
            v722 = arith.constant 8 : u32;
            v459 = arith.mod v457, v722 : u32;
            hir.assertz v459 #[code = 250];
            v460 = hir.int_to_ptr v457 : ptr<byte, i64>;
            v461 = hir.load v460 : i64;
            v462 = hir.bitcast v453 : u32;
            v463 = hir.int_to_ptr v462 : ptr<byte, i64>;
            hir.store v463, v461;
            v464 = hir.load_local  : i32 #[local = lv0];
            v467 = hir.load_local  : i32 #[local = lv2];
            v721 = arith.constant 88 : u32;
            v468 = hir.bitcast v467 : u32;
            v470 = arith.add v468, v721 : u32 #[overflow = checked];
            v720 = arith.constant 8 : u32;
            v472 = arith.mod v470, v720 : u32;
            hir.assertz v472 #[code = 250];
            v473 = hir.int_to_ptr v470 : ptr<byte, i64>;
            v474 = hir.load v473 : i64;
            v719 = arith.constant 24 : i32;
            v466 = arith.add v464, v719 : i32 #[overflow = wrapping];
            v475 = hir.bitcast v466 : u32;
            v476 = hir.int_to_ptr v475 : ptr<byte, i64>;
            hir.store v476, v474;
            v477 = hir.load_local  : i32 #[local = lv0];
            v480 = hir.load_local  : i32 #[local = lv2];
            v718 = arith.constant 80 : u32;
            v481 = hir.bitcast v480 : u32;
            v483 = arith.add v481, v718 : u32 #[overflow = checked];
            v717 = arith.constant 8 : u32;
            v485 = arith.mod v483, v717 : u32;
            hir.assertz v485 #[code = 250];
            v486 = hir.int_to_ptr v483 : ptr<byte, i64>;
            v487 = hir.load v486 : i64;
            v716 = arith.constant 16 : i32;
            v479 = arith.add v477, v716 : i32 #[overflow = wrapping];
            v488 = hir.bitcast v479 : u32;
            v489 = hir.int_to_ptr v488 : ptr<byte, i64>;
            hir.store v489, v487;
            v490 = hir.load_local  : i32 #[local = lv0];
            v493 = hir.load_local  : i32 #[local = lv2];
            v715 = arith.constant 72 : u32;
            v494 = hir.bitcast v493 : u32;
            v496 = arith.add v494, v715 : u32 #[overflow = checked];
            v714 = arith.constant 8 : u32;
            v498 = arith.mod v496, v714 : u32;
            hir.assertz v498 #[code = 250];
            v499 = hir.int_to_ptr v496 : ptr<byte, i64>;
            v500 = hir.load v499 : i64;
            v713 = arith.constant 8 : i32;
            v492 = arith.add v490, v713 : i32 #[overflow = wrapping];
            v501 = hir.bitcast v492 : u32;
            v502 = hir.int_to_ptr v501 : ptr<byte, i64>;
            hir.store v502, v500;
            v503 = hir.load_local  : i32 #[local = lv3];
            v504 = builtin.global_symbol @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/__stack_pointer : ptr<byte, u8>
            v505 = hir.bitcast v504 : ptr<byte, i32>;
            hir.store v505, v503;
            builtin.ret ;
        };

        private builtin.function @miden::core::crypto::hashes::sha256::hash(v506: i32, v507: i32, v508: i32, v509: i32, v510: i32, v511: i32, v512: i32, v513: i32, v514: i32) {
        ^block25(v506: i32, v507: i32, v508: i32, v509: i32, v510: i32, v511: i32, v512: i32, v513: i32, v514: i32):
            v515, v516, v517, v518, v519, v520, v521, v522 = hir.exec @miden/core/crypto/hashes/sha256/hash(v506, v507, v508, v509, v510, v511, v512, v513) : i32, i32, i32, i32, i32, i32, i32, i32
            v523 = hir.bitcast v514 : u32;
            v524 = hir.int_to_ptr v523 : ptr<byte, i32>;
            hir.store v524, v515;
            v786 = arith.constant 4 : u32;
            v526 = arith.add v523, v786 : u32 #[overflow = checked];
            v527 = hir.int_to_ptr v526 : ptr<byte, i32>;
            hir.store v527, v516;
            v785 = arith.constant 8 : u32;
            v529 = arith.add v523, v785 : u32 #[overflow = checked];
            v530 = hir.int_to_ptr v529 : ptr<byte, i32>;
            hir.store v530, v517;
            v784 = arith.constant 12 : u32;
            v532 = arith.add v523, v784 : u32 #[overflow = checked];
            v533 = hir.int_to_ptr v532 : ptr<byte, i32>;
            hir.store v533, v518;
            v783 = arith.constant 16 : u32;
            v535 = arith.add v523, v783 : u32 #[overflow = checked];
            v536 = hir.int_to_ptr v535 : ptr<byte, i32>;
            hir.store v536, v519;
            v782 = arith.constant 20 : u32;
            v538 = arith.add v523, v782 : u32 #[overflow = checked];
            v539 = hir.int_to_ptr v538 : ptr<byte, i32>;
            hir.store v539, v520;
            v781 = arith.constant 24 : u32;
            v541 = arith.add v523, v781 : u32 #[overflow = checked];
            v542 = hir.int_to_ptr v541 : ptr<byte, i32>;
            hir.store v542, v521;
            v780 = arith.constant 28 : u32;
            v544 = arith.add v523, v780 : u32 #[overflow = checked];
            v545 = hir.int_to_ptr v544 : ptr<byte, i32>;
            hir.store v545, v522;
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};