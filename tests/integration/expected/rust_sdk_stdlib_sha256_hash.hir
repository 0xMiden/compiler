builtin.component root_ns:root@1.0.0 {
    builtin.module public @rust_sdk_stdlib_sha256_hash {
        private builtin.function @<[u8]>::reverse(v0: i32, v1: i32) {
        ^block4(v0: i32, v1: i32):
            v479 = arith.constant -1 : i32;
            v8 = arith.add v1, v0 : i32 #[overflow = wrapping];
            v10 = arith.add v8, v479 : i32 #[overflow = wrapping];
            v491 = arith.constant 1 : u32;
            v4 = hir.bitcast v1 : u32;
            v6 = arith.shr v4, v491 : u32;
            v7 = hir.bitcast v6 : i32;
            v499, v500, v501 = scf.while v7, v0, v10 : i32, i32, i32 {
            ^block7(v11: i32, v18: i32, v24: i32):
                v522 = arith.constant 0 : i32;
                v484 = arith.constant 0 : i32;
                v13 = arith.eq v11, v484 : i1;
                v14 = arith.zext v13 : u32;
                v15 = hir.bitcast v14 : i32;
                v17 = arith.neq v15, v522 : i1;
                v514, v515, v516 = scf.if v17 : i32, i32, i32 {
                ^block39:
                    v492 = ub.poison i32 : i32;
                    scf.yield v492, v492, v492;
                } else {
                ^block9:
                    v19 = hir.bitcast v18 : u32;
                    v20 = hir.int_to_ptr v19 : ptr<byte, u8>;
                    v21 = hir.load v20 : u8;
                    v25 = hir.bitcast v24 : u32;
                    v26 = hir.int_to_ptr v25 : ptr<byte, u8>;
                    v27 = hir.load v26 : u8;
                    v28 = arith.zext v27 : u32;
                    v29 = hir.bitcast v28 : i32;
                    v30 = hir.bitcast v29 : u32;
                    v31 = arith.trunc v30 : u8;
                    v33 = hir.int_to_ptr v19 : ptr<byte, u8>;
                    hir.store v33, v31;
                    v22 = arith.zext v21 : u32;
                    v23 = hir.bitcast v22 : i32;
                    v34 = hir.bitcast v23 : u32;
                    v35 = arith.trunc v34 : u8;
                    v37 = hir.int_to_ptr v25 : ptr<byte, u8>;
                    hir.store v37, v35;
                    v520 = arith.constant -1 : i32;
                    v43 = arith.add v24, v520 : i32 #[overflow = wrapping];
                    v481 = arith.constant 1 : i32;
                    v41 = arith.add v18, v481 : i32 #[overflow = wrapping];
                    v521 = arith.constant -1 : i32;
                    v39 = arith.add v11, v521 : i32 #[overflow = wrapping];
                    scf.yield v39, v41, v43;
                };
                v519 = arith.constant 1 : u32;
                v485 = arith.constant 0 : u32;
                v518 = cf.select v17, v485, v519 : u32;
                v508 = arith.trunc v518 : i1;
                scf.condition v508, v514, v515, v516;
            } do {
            ^block38(v505: i32, v506: i32, v507: i32):
                scf.yield v505, v506, v507;
            };
            builtin.ret ;
        };

        private builtin.function @<core::slice::iter::ChunksExactMut<u8> as core::iter::traits::iterator::Iterator>::next(v44: i32, v45: i32) {
        ^block10(v44: i32, v45: i32):
            v47 = hir.bitcast v45 : u32;
            v526 = arith.constant 16 : u32;
            v49 = arith.add v47, v526 : u32 #[overflow = checked];
            v525 = arith.constant 4 : u32;
            v51 = arith.mod v49, v525 : u32;
            hir.assertz v51 #[code = 250];
            v52 = hir.int_to_ptr v49 : ptr<byte, i32>;
            v53 = hir.load v52 : i32;
            v524 = arith.constant 8 : u32;
            v57 = arith.add v47, v524 : u32 #[overflow = checked];
            v565 = arith.constant 4 : u32;
            v59 = arith.mod v57, v565 : u32;
            hir.assertz v59 #[code = 250];
            v60 = hir.int_to_ptr v57 : ptr<byte, i32>;
            v61 = hir.load v60 : i32;
            v564 = arith.constant 0 : i32;
            v539 = arith.constant 0 : i32;
            v63 = arith.eq v61, v539 : i1;
            v64 = arith.zext v63 : u32;
            v65 = hir.bitcast v64 : i32;
            v67 = arith.neq v65, v564 : i1;
            v552 = scf.if v67 : i32 {
            ^block41:
                v563 = arith.constant 0 : i32;
                scf.yield v563;
            } else {
            ^block13:
                v523 = arith.constant 12 : u32;
                v70 = arith.add v47, v523 : u32 #[overflow = checked];
                v562 = arith.constant 4 : u32;
                v72 = arith.mod v70, v562 : u32;
                hir.assertz v72 #[code = 250];
                v73 = hir.int_to_ptr v70 : ptr<byte, i32>;
                v74 = hir.load v73 : i32;
                v561 = arith.constant 0 : i32;
                v76 = hir.bitcast v53 : u32;
                v75 = hir.bitcast v74 : u32;
                v77 = arith.lt v75, v76 : i1;
                v78 = arith.zext v77 : u32;
                v79 = hir.bitcast v78 : i32;
                v81 = arith.neq v79, v561 : i1;
                scf.if v81{
                ^block40:
                    scf.yield ;
                } else {
                ^block14:
                    v560 = arith.constant 12 : u32;
                    v85 = arith.add v47, v560 : u32 #[overflow = checked];
                    v559 = arith.constant 4 : u32;
                    v87 = arith.mod v85, v559 : u32;
                    hir.assertz v87 #[code = 250];
                    v82 = arith.sub v74, v53 : i32 #[overflow = wrapping];
                    v88 = hir.int_to_ptr v85 : ptr<byte, i32>;
                    hir.store v88, v82;
                    v558 = arith.constant 8 : u32;
                    v92 = arith.add v47, v558 : u32 #[overflow = checked];
                    v557 = arith.constant 4 : u32;
                    v94 = arith.mod v92, v557 : u32;
                    hir.assertz v94 #[code = 250];
                    v89 = arith.add v61, v53 : i32 #[overflow = wrapping];
                    v95 = hir.int_to_ptr v92 : ptr<byte, i32>;
                    hir.store v95, v89;
                    scf.yield ;
                };
                v556 = arith.constant 0 : i32;
                v551 = cf.select v81, v556, v61 : i32;
                scf.yield v551;
            };
            v98 = hir.bitcast v44 : u32;
            v555 = arith.constant 4 : u32;
            v100 = arith.add v98, v555 : u32 #[overflow = checked];
            v554 = arith.constant 4 : u32;
            v102 = arith.mod v100, v554 : u32;
            hir.assertz v102 #[code = 250];
            v103 = hir.int_to_ptr v100 : ptr<byte, i32>;
            hir.store v103, v53;
            v553 = arith.constant 4 : u32;
            v107 = arith.mod v98, v553 : u32;
            hir.assertz v107 #[code = 250];
            v108 = hir.int_to_ptr v98 : ptr<byte, i32>;
            hir.store v108, v552;
            builtin.ret ;
        };

        public builtin.function @entrypoint(v109: i32, v110: i32) {
        ^block15(v109: i32, v110: i32):
            v112 = builtin.global_symbol @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/__stack_pointer : ptr<byte, u8>
            v113 = hir.bitcast v112 : ptr<byte, i32>;
            v114 = hir.load v113 : i32;
            v598 = arith.constant -32 : i32;
            v599 = arith.constant 128 : i32;
            v116 = arith.sub v114, v599 : i32 #[overflow = wrapping];
            v118 = arith.band v116, v598 : i32;
            v119 = builtin.global_symbol @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/__stack_pointer : ptr<byte, u8>
            v120 = hir.bitcast v119 : ptr<byte, i32>;
            hir.store v120, v118;
            v596 = arith.constant 24 : i32;
            v126 = arith.add v110, v596 : i32 #[overflow = wrapping];
            v127 = hir.bitcast v126 : u32;
            v128 = hir.int_to_ptr v127 : ptr<byte, i64>;
            v129 = hir.load v128 : i64;
            v871 = arith.constant 24 : i32;
            v597 = arith.constant 64 : i32;
            v122 = arith.add v118, v597 : i32 #[overflow = wrapping];
            v124 = arith.add v122, v871 : i32 #[overflow = wrapping];
            v130 = hir.bitcast v124 : u32;
            v595 = arith.constant 8 : u32;
            v132 = arith.mod v130, v595 : u32;
            hir.assertz v132 #[code = 250];
            v133 = hir.int_to_ptr v130 : ptr<byte, i64>;
            hir.store v133, v129;
            v870 = arith.constant 64 : i32;
            v135 = arith.add v118, v870 : i32 #[overflow = wrapping];
            v594 = arith.constant 16 : i32;
            v139 = arith.add v110, v594 : i32 #[overflow = wrapping];
            v140 = hir.bitcast v139 : u32;
            v141 = hir.int_to_ptr v140 : ptr<byte, i64>;
            v142 = hir.load v141 : i64;
            v869 = arith.constant 16 : i32;
            v137 = arith.add v135, v869 : i32 #[overflow = wrapping];
            v143 = hir.bitcast v137 : u32;
            v868 = arith.constant 8 : u32;
            v145 = arith.mod v143, v868 : u32;
            hir.assertz v145 #[code = 250];
            v146 = hir.int_to_ptr v143 : ptr<byte, i64>;
            hir.store v146, v142;
            v593 = arith.constant 8 : i32;
            v152 = arith.add v110, v593 : i32 #[overflow = wrapping];
            v153 = hir.bitcast v152 : u32;
            v154 = hir.int_to_ptr v153 : ptr<byte, i64>;
            v155 = hir.load v154 : i64;
            v867 = arith.constant 8 : i32;
            v150 = arith.add v135, v867 : i32 #[overflow = wrapping];
            v156 = hir.bitcast v150 : u32;
            v866 = arith.constant 8 : u32;
            v158 = arith.mod v156, v866 : u32;
            hir.assertz v158 #[code = 250];
            v159 = hir.int_to_ptr v156 : ptr<byte, i64>;
            hir.store v159, v155;
            v160 = hir.bitcast v110 : u32;
            v161 = hir.int_to_ptr v160 : ptr<byte, i64>;
            v162 = hir.load v161 : i64;
            v163 = hir.bitcast v118 : u32;
            v592 = arith.constant 64 : u32;
            v165 = arith.add v163, v592 : u32 #[overflow = checked];
            v865 = arith.constant 8 : u32;
            v167 = arith.mod v165, v865 : u32;
            hir.assertz v167 #[code = 250];
            v168 = hir.int_to_ptr v165 : ptr<byte, i64>;
            hir.store v168, v162;
            v590 = arith.constant 44 : u32;
            v172 = arith.add v163, v590 : u32 #[overflow = checked];
            v589 = arith.constant 4 : u32;
            v174 = arith.mod v172, v589 : u32;
            hir.assertz v174 #[code = 250];
            v591 = arith.constant 17179869216 : i64;
            v175 = hir.int_to_ptr v172 : ptr<byte, i64>;
            hir.store v175, v591;
            v588 = arith.constant 36 : u32;
            v179 = arith.add v163, v588 : u32 #[overflow = checked];
            v864 = arith.constant 4 : u32;
            v181 = arith.mod v179, v864 : u32;
            hir.assertz v181 #[code = 250];
            v600 = arith.constant 0 : i32;
            v182 = hir.int_to_ptr v179 : ptr<byte, i32>;
            hir.store v182, v600;
            v586 = arith.constant 32 : u32;
            v187 = arith.add v163, v586 : u32 #[overflow = checked];
            v863 = arith.constant 4 : u32;
            v189 = arith.mod v187, v863 : u32;
            hir.assertz v189 #[code = 250];
            v587 = arith.constant 96 : i32;
            v184 = arith.add v118, v587 : i32 #[overflow = wrapping];
            v190 = hir.int_to_ptr v187 : ptr<byte, i32>;
            hir.store v190, v184;
            v585 = arith.constant 40 : u32;
            v195 = arith.add v163, v585 : u32 #[overflow = checked];
            v862 = arith.constant 4 : u32;
            v197 = arith.mod v195, v862 : u32;
            hir.assertz v197 #[code = 250];
            v198 = hir.int_to_ptr v195 : ptr<byte, i32>;
            hir.store v198, v135;
            v786, v787, v788, v789, v790, v791, v792 = scf.while v118, v109, v114 : i32, i32, i32, i32, i32, i32, u32 {
            ^block59(v793: i32, v794: i32, v795: i32):
                v621 = arith.constant 32 : i32;
                v203 = arith.add v793, v621 : i32 #[overflow = wrapping];
                v861 = arith.constant 24 : i32;
                v201 = arith.add v793, v861 : i32 #[overflow = wrapping];
                hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/<core::slice::iter::ChunksExactMut<u8> as core::iter::traits::iterator::Iterator>::next(v201, v203)
                v204 = hir.bitcast v793 : u32;
                v570 = arith.constant 24 : u32;
                v206 = arith.add v204, v570 : u32 #[overflow = checked];
                v860 = arith.constant 4 : u32;
                v208 = arith.mod v206, v860 : u32;
                hir.assertz v208 #[code = 250];
                v209 = hir.int_to_ptr v206 : ptr<byte, i32>;
                v210 = hir.load v209 : i32;
                v858 = arith.constant 0 : i32;
                v859 = arith.constant 0 : i32;
                v212 = arith.eq v210, v859 : i1;
                v213 = arith.zext v212 : u32;
                v214 = hir.bitcast v213 : i32;
                v216 = arith.neq v214, v858 : i1;
                scf.if v216{
                ^block55:
                    scf.yield ;
                } else {
                ^block20:
                    v569 = arith.constant 28 : u32;
                    v219 = arith.add v204, v569 : u32 #[overflow = checked];
                    v857 = arith.constant 4 : u32;
                    v221 = arith.mod v219, v857 : u32;
                    hir.assertz v221 #[code = 250];
                    v222 = hir.int_to_ptr v219 : ptr<byte, i32>;
                    v223 = hir.load v222 : i32;
                    hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/<[u8]>::reverse(v210, v223)
                    scf.yield ;
                };
                v855 = ub.poison i32 : i32;
                v783 = cf.select v216, v855, v795 : i32;
                v856 = ub.poison i32 : i32;
                v782 = cf.select v216, v856, v794 : i32;
                v670 = ub.poison i32 : i32;
                v781 = cf.select v216, v670, v793 : i32;
                v669 = arith.constant 1 : u32;
                v663 = arith.constant 0 : u32;
                v785 = cf.select v216, v663, v669 : u32;
                v750 = arith.trunc v785 : i1;
                scf.condition v750, v781, v782, v783, v793, v794, v795, v204;
            } do {
            ^block60(v796: i32, v797: i32, v798: i32, v799: i32, v800: i32, v801: i32, v802: u32):
                scf.yield v796, v797, v798;
            };
            v854 = arith.constant 64 : u32;
            v226 = arith.add v792, v854 : u32 #[overflow = checked];
            v853 = arith.constant 4 : u32;
            v228 = arith.mod v226, v853 : u32;
            hir.assertz v228 #[code = 250];
            v229 = hir.int_to_ptr v226 : ptr<byte, i32>;
            v230 = hir.load v229 : i32;
            v584 = arith.constant 68 : u32;
            v233 = arith.add v792, v584 : u32 #[overflow = checked];
            v852 = arith.constant 4 : u32;
            v235 = arith.mod v233, v852 : u32;
            hir.assertz v235 #[code = 250];
            v236 = hir.int_to_ptr v233 : ptr<byte, i32>;
            v237 = hir.load v236 : i32;
            v583 = arith.constant 72 : u32;
            v240 = arith.add v792, v583 : u32 #[overflow = checked];
            v851 = arith.constant 4 : u32;
            v242 = arith.mod v240, v851 : u32;
            hir.assertz v242 #[code = 250];
            v243 = hir.int_to_ptr v240 : ptr<byte, i32>;
            v244 = hir.load v243 : i32;
            v582 = arith.constant 76 : u32;
            v247 = arith.add v792, v582 : u32 #[overflow = checked];
            v850 = arith.constant 4 : u32;
            v249 = arith.mod v247, v850 : u32;
            hir.assertz v249 #[code = 250];
            v250 = hir.int_to_ptr v247 : ptr<byte, i32>;
            v251 = hir.load v250 : i32;
            v581 = arith.constant 80 : u32;
            v254 = arith.add v792, v581 : u32 #[overflow = checked];
            v849 = arith.constant 4 : u32;
            v256 = arith.mod v254, v849 : u32;
            hir.assertz v256 #[code = 250];
            v257 = hir.int_to_ptr v254 : ptr<byte, i32>;
            v258 = hir.load v257 : i32;
            v580 = arith.constant 84 : u32;
            v261 = arith.add v792, v580 : u32 #[overflow = checked];
            v848 = arith.constant 4 : u32;
            v263 = arith.mod v261, v848 : u32;
            hir.assertz v263 #[code = 250];
            v264 = hir.int_to_ptr v261 : ptr<byte, i32>;
            v265 = hir.load v264 : i32;
            v579 = arith.constant 88 : u32;
            v268 = arith.add v792, v579 : u32 #[overflow = checked];
            v847 = arith.constant 4 : u32;
            v270 = arith.mod v268, v847 : u32;
            hir.assertz v270 #[code = 250];
            v271 = hir.int_to_ptr v268 : ptr<byte, i32>;
            v272 = hir.load v271 : i32;
            v578 = arith.constant 92 : u32;
            v275 = arith.add v792, v578 : u32 #[overflow = checked];
            v846 = arith.constant 4 : u32;
            v277 = arith.mod v275, v846 : u32;
            hir.assertz v277 #[code = 250];
            v278 = hir.int_to_ptr v275 : ptr<byte, i32>;
            v279 = hir.load v278 : i32;
            v845 = arith.constant 32 : i32;
            v281 = arith.add v789, v845 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/miden::core::crypto::hashes::sha256::hash(v230, v237, v244, v251, v258, v265, v272, v279, v281)
            v576 = arith.constant 56 : u32;
            v284 = arith.add v792, v576 : u32 #[overflow = checked];
            v844 = arith.constant 8 : u32;
            v286 = arith.mod v284, v844 : u32;
            hir.assertz v286 #[code = 250];
            v287 = hir.int_to_ptr v284 : ptr<byte, i64>;
            v288 = hir.load v287 : i64;
            v843 = arith.constant 88 : u32;
            v291 = arith.add v792, v843 : u32 #[overflow = checked];
            v842 = arith.constant 8 : u32;
            v293 = arith.mod v291, v842 : u32;
            hir.assertz v293 #[code = 250];
            v294 = hir.int_to_ptr v291 : ptr<byte, i64>;
            hir.store v294, v288;
            v575 = arith.constant 48 : u32;
            v297 = arith.add v792, v575 : u32 #[overflow = checked];
            v841 = arith.constant 8 : u32;
            v299 = arith.mod v297, v841 : u32;
            hir.assertz v299 #[code = 250];
            v300 = hir.int_to_ptr v297 : ptr<byte, i64>;
            v301 = hir.load v300 : i64;
            v840 = arith.constant 80 : u32;
            v304 = arith.add v792, v840 : u32 #[overflow = checked];
            v839 = arith.constant 8 : u32;
            v306 = arith.mod v304, v839 : u32;
            hir.assertz v306 #[code = 250];
            v307 = hir.int_to_ptr v304 : ptr<byte, i64>;
            hir.store v307, v301;
            v838 = arith.constant 40 : u32;
            v310 = arith.add v792, v838 : u32 #[overflow = checked];
            v837 = arith.constant 8 : u32;
            v312 = arith.mod v310, v837 : u32;
            hir.assertz v312 #[code = 250];
            v313 = hir.int_to_ptr v310 : ptr<byte, i64>;
            v314 = hir.load v313 : i64;
            v836 = arith.constant 72 : u32;
            v317 = arith.add v792, v836 : u32 #[overflow = checked];
            v835 = arith.constant 8 : u32;
            v319 = arith.mod v317, v835 : u32;
            hir.assertz v319 #[code = 250];
            v320 = hir.int_to_ptr v317 : ptr<byte, i64>;
            hir.store v320, v314;
            v834 = arith.constant 32 : u32;
            v323 = arith.add v792, v834 : u32 #[overflow = checked];
            v833 = arith.constant 8 : u32;
            v325 = arith.mod v323, v833 : u32;
            hir.assertz v325 #[code = 250];
            v326 = hir.int_to_ptr v323 : ptr<byte, i64>;
            v327 = hir.load v326 : i64;
            v832 = arith.constant 8 : u32;
            v332 = arith.mod v226, v832 : u32;
            hir.assertz v332 #[code = 250];
            v333 = hir.int_to_ptr v226 : ptr<byte, i64>;
            hir.store v333, v327;
            v574 = arith.constant 120 : u32;
            v337 = arith.add v792, v574 : u32 #[overflow = checked];
            v831 = arith.constant 4 : u32;
            v339 = arith.mod v337, v831 : u32;
            hir.assertz v339 #[code = 250];
            v830 = arith.constant 17179869216 : i64;
            v340 = hir.int_to_ptr v337 : ptr<byte, i64>;
            hir.store v340, v830;
            v573 = arith.constant 112 : u32;
            v344 = arith.add v792, v573 : u32 #[overflow = checked];
            v829 = arith.constant 4 : u32;
            v346 = arith.mod v344, v829 : u32;
            hir.assertz v346 #[code = 250];
            v828 = arith.constant 0 : i32;
            v347 = hir.int_to_ptr v344 : ptr<byte, i32>;
            hir.store v347, v828;
            v572 = arith.constant 108 : u32;
            v352 = arith.add v792, v572 : u32 #[overflow = checked];
            v827 = arith.constant 4 : u32;
            v354 = arith.mod v352, v827 : u32;
            hir.assertz v354 #[code = 250];
            v826 = arith.constant 96 : i32;
            v349 = arith.add v789, v826 : i32 #[overflow = wrapping];
            v355 = hir.int_to_ptr v352 : ptr<byte, i32>;
            hir.store v355, v349;
            v571 = arith.constant 116 : u32;
            v360 = arith.add v792, v571 : u32 #[overflow = checked];
            v825 = arith.constant 4 : u32;
            v362 = arith.mod v360, v825 : u32;
            hir.assertz v362 #[code = 250];
            v824 = arith.constant 64 : i32;
            v357 = arith.add v789, v824 : i32 #[overflow = wrapping];
            v363 = hir.int_to_ptr v360 : ptr<byte, i32>;
            hir.store v363, v357;
            v766, v767, v768, v769, v770, v771 = scf.while v789, v790, v791 : i32, i32, i32, i32, i32, u32 {
            ^block57(v772: i32, v773: i32, v774: i32):
                v568 = arith.constant 108 : i32;
                v368 = arith.add v772, v568 : i32 #[overflow = wrapping];
                v823 = arith.constant 16 : i32;
                v366 = arith.add v772, v823 : i32 #[overflow = wrapping];
                hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/<core::slice::iter::ChunksExactMut<u8> as core::iter::traits::iterator::Iterator>::next(v366, v368)
                v369 = hir.bitcast v772 : u32;
                v567 = arith.constant 16 : u32;
                v371 = arith.add v369, v567 : u32 #[overflow = checked];
                v822 = arith.constant 4 : u32;
                v373 = arith.mod v371, v822 : u32;
                hir.assertz v373 #[code = 250];
                v374 = hir.int_to_ptr v371 : ptr<byte, i32>;
                v375 = hir.load v374 : i32;
                v820 = arith.constant 0 : i32;
                v821 = arith.constant 0 : i32;
                v377 = arith.eq v375, v821 : i1;
                v378 = arith.zext v377 : u32;
                v379 = hir.bitcast v378 : i32;
                v381 = arith.neq v379, v820 : i1;
                scf.if v381{
                ^block56:
                    scf.yield ;
                } else {
                ^block24:
                    v566 = arith.constant 20 : u32;
                    v384 = arith.add v369, v566 : u32 #[overflow = checked];
                    v819 = arith.constant 4 : u32;
                    v386 = arith.mod v384, v819 : u32;
                    hir.assertz v386 #[code = 250];
                    v387 = hir.int_to_ptr v384 : ptr<byte, i32>;
                    v388 = hir.load v387 : i32;
                    hir.exec @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/<[u8]>::reverse(v375, v388)
                    scf.yield ;
                };
                v814 = ub.poison i32 : i32;
                v763 = cf.select v381, v814, v774 : i32;
                v815 = ub.poison i32 : i32;
                v762 = cf.select v381, v815, v773 : i32;
                v816 = ub.poison i32 : i32;
                v761 = cf.select v381, v816, v772 : i32;
                v817 = arith.constant 1 : u32;
                v818 = arith.constant 0 : u32;
                v765 = cf.select v381, v818, v817 : u32;
                v705 = arith.trunc v765 : i1;
                scf.condition v705, v761, v762, v763, v773, v774, v369;
            } do {
            ^block58(v775: i32, v776: i32, v777: i32, v778: i32, v779: i32, v780: u32):
                scf.yield v775, v776, v777;
            };
            v813 = arith.constant 64 : u32;
            v393 = arith.add v771, v813 : u32 #[overflow = checked];
            v812 = arith.constant 8 : u32;
            v395 = arith.mod v393, v812 : u32;
            hir.assertz v395 #[code = 250];
            v396 = hir.int_to_ptr v393 : ptr<byte, i64>;
            v397 = hir.load v396 : i64;
            v398 = hir.bitcast v769 : u32;
            v399 = hir.int_to_ptr v398 : ptr<byte, i64>;
            hir.store v399, v397;
            v811 = arith.constant 88 : u32;
            v404 = arith.add v771, v811 : u32 #[overflow = checked];
            v810 = arith.constant 8 : u32;
            v406 = arith.mod v404, v810 : u32;
            hir.assertz v406 #[code = 250];
            v407 = hir.int_to_ptr v404 : ptr<byte, i64>;
            v408 = hir.load v407 : i64;
            v809 = arith.constant 24 : i32;
            v401 = arith.add v769, v809 : i32 #[overflow = wrapping];
            v409 = hir.bitcast v401 : u32;
            v410 = hir.int_to_ptr v409 : ptr<byte, i64>;
            hir.store v410, v408;
            v808 = arith.constant 80 : u32;
            v415 = arith.add v771, v808 : u32 #[overflow = checked];
            v807 = arith.constant 8 : u32;
            v417 = arith.mod v415, v807 : u32;
            hir.assertz v417 #[code = 250];
            v418 = hir.int_to_ptr v415 : ptr<byte, i64>;
            v419 = hir.load v418 : i64;
            v806 = arith.constant 16 : i32;
            v412 = arith.add v769, v806 : i32 #[overflow = wrapping];
            v420 = hir.bitcast v412 : u32;
            v421 = hir.int_to_ptr v420 : ptr<byte, i64>;
            hir.store v421, v419;
            v805 = arith.constant 72 : u32;
            v426 = arith.add v771, v805 : u32 #[overflow = checked];
            v804 = arith.constant 8 : u32;
            v428 = arith.mod v426, v804 : u32;
            hir.assertz v428 #[code = 250];
            v429 = hir.int_to_ptr v426 : ptr<byte, i64>;
            v430 = hir.load v429 : i64;
            v803 = arith.constant 8 : i32;
            v423 = arith.add v769, v803 : i32 #[overflow = wrapping];
            v431 = hir.bitcast v423 : u32;
            v432 = hir.int_to_ptr v431 : ptr<byte, i64>;
            hir.store v432, v430;
            v435 = builtin.global_symbol @root_ns:root@1.0.0/rust_sdk_stdlib_sha256_hash/__stack_pointer : ptr<byte, u8>
            v436 = hir.bitcast v435 : ptr<byte, i32>;
            hir.store v436, v770;
            builtin.ret ;
        };

        private builtin.function @miden::core::crypto::hashes::sha256::hash(v437: i32, v438: i32, v439: i32, v440: i32, v441: i32, v442: i32, v443: i32, v444: i32, v445: i32) {
        ^block25(v437: i32, v438: i32, v439: i32, v440: i32, v441: i32, v442: i32, v443: i32, v444: i32, v445: i32):
            v446, v447, v448, v449, v450, v451, v452, v453 = hir.exec @miden/core/crypto/hashes/sha256/hash(v437, v438, v439, v440, v441, v442, v443, v444) : i32, i32, i32, i32, i32, i32, i32, i32
            v454 = hir.bitcast v445 : u32;
            v455 = hir.int_to_ptr v454 : ptr<byte, i32>;
            hir.store v455, v446;
            v878 = arith.constant 4 : u32;
            v457 = arith.add v454, v878 : u32 #[overflow = checked];
            v458 = hir.int_to_ptr v457 : ptr<byte, i32>;
            hir.store v458, v447;
            v877 = arith.constant 8 : u32;
            v460 = arith.add v454, v877 : u32 #[overflow = checked];
            v461 = hir.int_to_ptr v460 : ptr<byte, i32>;
            hir.store v461, v448;
            v876 = arith.constant 12 : u32;
            v463 = arith.add v454, v876 : u32 #[overflow = checked];
            v464 = hir.int_to_ptr v463 : ptr<byte, i32>;
            hir.store v464, v449;
            v875 = arith.constant 16 : u32;
            v466 = arith.add v454, v875 : u32 #[overflow = checked];
            v467 = hir.int_to_ptr v466 : ptr<byte, i32>;
            hir.store v467, v450;
            v874 = arith.constant 20 : u32;
            v469 = arith.add v454, v874 : u32 #[overflow = checked];
            v470 = hir.int_to_ptr v469 : ptr<byte, i32>;
            hir.store v470, v451;
            v873 = arith.constant 24 : u32;
            v472 = arith.add v454, v873 : u32 #[overflow = checked];
            v473 = hir.int_to_ptr v472 : ptr<byte, i32>;
            hir.store v473, v452;
            v872 = arith.constant 28 : u32;
            v475 = arith.add v454, v872 : u32 #[overflow = checked];
            v476 = hir.int_to_ptr v475 : ptr<byte, i32>;
            hir.store v476, v453;
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};