builtin.component root_ns:root@1.0.0 {
    builtin.module public @hmerge {
        public builtin.function @entrypoint(v0: i32, v1: i32) {
        ^block6(v0: i32, v1: i32):
            v4 = builtin.global_symbol @root_ns:root@1.0.0/hmerge/__stack_pointer : ptr<byte, u8>
            v5 = hir.bitcast v4 : ptr<byte, i32>;
            v6 = hir.load v5 : i32;
            v7 = arith.constant 16 : i32;
            v8 = arith.sub v6, v7 : i32 #[overflow = wrapping];
            v9 = builtin.global_symbol @root_ns:root@1.0.0/hmerge/__stack_pointer : ptr<byte, u8>
            v10 = hir.bitcast v9 : ptr<byte, i32>;
            hir.store v10, v8;
            v112 = arith.constant 0 : felt;
            v2 = arith.constant 0 : i32;
            v182, v183, v184, v185, v186, v187, v188, v189 = scf.while v2, v8, v112, v1, v0 : i32, i32, felt, i32, i32, i32, i32, i32 {
            ^block19(v190: i32, v191: i32, v192: felt, v193: i32, v194: i32):
                v222 = arith.constant 0 : i32;
                v223 = arith.constant 16 : i32;
                v16 = arith.eq v190, v223 : i1;
                v17 = arith.zext v16 : u32;
                v18 = hir.bitcast v17 : i32;
                v20 = arith.neq v18, v222 : i1;
                v175 = scf.if v20 : i32 {
                ^block18:
                    v122 = ub.poison i32 : i32;
                    scf.yield v122;
                } else {
                ^block11:
                    v22 = arith.add v191, v190 : i32 #[overflow = wrapping];
                    v24 = hir.bitcast v22 : u32;
                    v32 = arith.constant 4 : u32;
                    v26 = arith.mod v24, v32 : u32;
                    hir.assertz v26 #[code = 250];
                    v27 = hir.int_to_ptr v24 : ptr<byte, felt>;
                    hir.store v27, v192;
                    v28 = arith.constant 4 : i32;
                    v29 = arith.add v190, v28 : i32 #[overflow = wrapping];
                    scf.yield v29;
                };
                v219 = ub.poison i32 : i32;
                v179 = cf.select v20, v219, v194 : i32;
                v220 = ub.poison i32 : i32;
                v178 = cf.select v20, v220, v193 : i32;
                v123 = ub.poison felt : felt;
                v177 = cf.select v20, v123, v192 : felt;
                v221 = ub.poison i32 : i32;
                v176 = cf.select v20, v221, v191 : i32;
                v121 = arith.constant 1 : u32;
                v113 = arith.constant 0 : u32;
                v181 = cf.select v20, v113, v121 : u32;
                v167 = arith.trunc v181 : i1;
                scf.condition v167, v175, v176, v177, v178, v179, v191, v193, v194;
            } do {
            ^block20(v195: i32, v196: i32, v197: felt, v198: i32, v199: i32, v200: i32, v201: i32, v202: i32):
                scf.yield v195, v196, v197, v198, v199;
            };
            v31 = hir.bitcast v188 : u32;
            v218 = arith.constant 4 : u32;
            v33 = arith.mod v31, v218 : u32;
            hir.assertz v33 #[code = 250];
            v34 = hir.int_to_ptr v31 : ptr<byte, felt>;
            v35 = hir.load v34 : felt;
            v217 = arith.constant 4 : u32;
            v36 = hir.bitcast v188 : u32;
            v38 = arith.add v36, v217 : u32 #[overflow = checked];
            v216 = arith.constant 4 : u32;
            v40 = arith.mod v38, v216 : u32;
            hir.assertz v40 #[code = 250];
            v41 = hir.int_to_ptr v38 : ptr<byte, felt>;
            v42 = hir.load v41 : felt;
            v44 = arith.constant 8 : u32;
            v43 = hir.bitcast v188 : u32;
            v45 = arith.add v43, v44 : u32 #[overflow = checked];
            v215 = arith.constant 4 : u32;
            v47 = arith.mod v45, v215 : u32;
            hir.assertz v47 #[code = 250];
            v48 = hir.int_to_ptr v45 : ptr<byte, felt>;
            v49 = hir.load v48 : felt;
            v51 = arith.constant 12 : u32;
            v50 = hir.bitcast v188 : u32;
            v52 = arith.add v50, v51 : u32 #[overflow = checked];
            v214 = arith.constant 4 : u32;
            v54 = arith.mod v52, v214 : u32;
            hir.assertz v54 #[code = 250];
            v55 = hir.int_to_ptr v52 : ptr<byte, felt>;
            v56 = hir.load v55 : felt;
            v58 = arith.constant 32 : u32;
            v57 = hir.bitcast v188 : u32;
            v59 = arith.add v57, v58 : u32 #[overflow = checked];
            v213 = arith.constant 4 : u32;
            v61 = arith.mod v59, v213 : u32;
            hir.assertz v61 #[code = 250];
            v62 = hir.int_to_ptr v59 : ptr<byte, felt>;
            v63 = hir.load v62 : felt;
            v65 = arith.constant 36 : u32;
            v64 = hir.bitcast v188 : u32;
            v66 = arith.add v64, v65 : u32 #[overflow = checked];
            v212 = arith.constant 4 : u32;
            v68 = arith.mod v66, v212 : u32;
            hir.assertz v68 #[code = 250];
            v69 = hir.int_to_ptr v66 : ptr<byte, felt>;
            v70 = hir.load v69 : felt;
            v72 = arith.constant 40 : u32;
            v71 = hir.bitcast v188 : u32;
            v73 = arith.add v71, v72 : u32 #[overflow = checked];
            v211 = arith.constant 4 : u32;
            v75 = arith.mod v73, v211 : u32;
            hir.assertz v75 #[code = 250];
            v76 = hir.int_to_ptr v73 : ptr<byte, felt>;
            v77 = hir.load v76 : felt;
            v79 = arith.constant 44 : u32;
            v78 = hir.bitcast v188 : u32;
            v80 = arith.add v78, v79 : u32 #[overflow = checked];
            v210 = arith.constant 4 : u32;
            v82 = arith.mod v80, v210 : u32;
            hir.assertz v82 #[code = 250];
            v83 = hir.int_to_ptr v80 : ptr<byte, felt>;
            v84 = hir.load v83 : felt;
            hir.exec @intrinsics/crypto/hmerge(v35, v42, v49, v56, v63, v70, v77, v84, v187)
            v209 = arith.constant 8 : u32;
            v86 = hir.bitcast v187 : u32;
            v88 = arith.add v86, v209 : u32 #[overflow = checked];
            v208 = arith.constant 4 : u32;
            v90 = arith.mod v88, v208 : u32;
            hir.assertz v90 #[code = 250];
            v91 = hir.int_to_ptr v88 : ptr<byte, i64>;
            v92 = hir.load v91 : i64;
            v207 = arith.constant 8 : u32;
            v93 = hir.bitcast v189 : u32;
            v95 = arith.add v93, v207 : u32 #[overflow = checked];
            v206 = arith.constant 8 : u32;
            v97 = arith.mod v95, v206 : u32;
            hir.assertz v97 #[code = 250];
            v98 = hir.int_to_ptr v95 : ptr<byte, i64>;
            hir.store v98, v92;
            v99 = hir.bitcast v187 : u32;
            v205 = arith.constant 4 : u32;
            v101 = arith.mod v99, v205 : u32;
            hir.assertz v101 #[code = 250];
            v102 = hir.int_to_ptr v99 : ptr<byte, i64>;
            v103 = hir.load v102 : i64;
            v104 = hir.bitcast v189 : u32;
            v204 = arith.constant 8 : u32;
            v106 = arith.mod v104, v204 : u32;
            hir.assertz v106 #[code = 250];
            v107 = hir.int_to_ptr v104 : ptr<byte, i64>;
            hir.store v107, v103;
            v203 = arith.constant 16 : i32;
            v109 = arith.add v187, v203 : i32 #[overflow = wrapping];
            v110 = builtin.global_symbol @root_ns:root@1.0.0/hmerge/__stack_pointer : ptr<byte, u8>
            v111 = hir.bitcast v110 : ptr<byte, i32>;
            hir.store v111, v109;
            builtin.ret ;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};