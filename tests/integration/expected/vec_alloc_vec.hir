builtin.component root_ns:root@1.0.0 {
    builtin.module public @vec_alloc_vec {
        public builtin.function @entrypoint(v0: felt) -> felt {
        ^block6(v0: felt):
            v3 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v4 = hir.bitcast v3 : ptr<byte, i32>;
            v5 = hir.load v4 : i32;
            v6 = arith.constant 16 : i32;
            v7 = arith.sub v5, v6 : i32 #[overflow = wrapping];
            v8 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v9 = hir.bitcast v8 : ptr<byte, i32>;
            hir.store v9, v7;
            v18 = arith.constant 4 : i32;
            v17 = arith.constant 8 : i32;
            v19 = hir.exec @root_ns:root@1.0.0/vec_alloc_vec/__rustc::__rust_alloc(v17, v18) : i32
            v2 = arith.constant 0 : i32;
            v21 = arith.neq v19, v2 : i1;
            cf.cond_br v21 ^block8, ^block9;
        ^block8:
            v25 = arith.constant 4 : u32;
            v24 = hir.bitcast v19 : u32;
            v26 = arith.add v24, v25 : u32 #[overflow = checked];
            v288 = arith.constant 4 : u32;
            v28 = arith.mod v26, v288 : u32;
            hir.assertz v28 #[code = 250];
            v29 = hir.int_to_ptr v26 : ptr<byte, felt>;
            hir.store v29, v0;
            v30 = hir.bitcast v19 : u32;
            v287 = arith.constant 4 : u32;
            v32 = arith.mod v30, v287 : u32;
            hir.assertz v32 #[code = 250];
            v33 = hir.int_to_ptr v30 : ptr<byte, felt>;
            hir.store v33, v0;
            v36 = arith.constant 12 : u32;
            v35 = hir.bitcast v7 : u32;
            v37 = arith.add v35, v36 : u32 #[overflow = checked];
            v286 = arith.constant 4 : u32;
            v39 = arith.mod v37, v286 : u32;
            hir.assertz v39 #[code = 250];
            v34 = arith.constant 2 : i32;
            v40 = hir.int_to_ptr v37 : ptr<byte, i32>;
            hir.store v40, v34;
            v42 = arith.constant 8 : u32;
            v41 = hir.bitcast v7 : u32;
            v43 = arith.add v41, v42 : u32 #[overflow = checked];
            v285 = arith.constant 4 : u32;
            v45 = arith.mod v43, v285 : u32;
            hir.assertz v45 #[code = 250];
            v46 = hir.int_to_ptr v43 : ptr<byte, i32>;
            hir.store v46, v19;
            v284 = arith.constant 4 : u32;
            v48 = hir.bitcast v7 : u32;
            v50 = arith.add v48, v284 : u32 #[overflow = checked];
            v283 = arith.constant 4 : u32;
            v52 = arith.mod v50, v283 : u32;
            hir.assertz v52 #[code = 250];
            v282 = arith.constant 2 : i32;
            v53 = hir.int_to_ptr v50 : ptr<byte, i32>;
            hir.store v53, v282;
            v274 = arith.constant 1048576 : felt;
            v54 = hir.bitcast v19 : felt;
            hir.assert_eq v54, v274;
            v280 = arith.constant 4 : i32;
            v281 = arith.constant 4 : i32;
            v60 = arith.add v7, v281 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/vec_alloc_vec/alloc::raw_vec::RawVecInner<A>::deallocate(v60, v280, v280)
            v279 = arith.constant 16 : i32;
            v64 = arith.add v7, v279 : i32 #[overflow = wrapping];
            v65 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v66 = hir.bitcast v65 : ptr<byte, i32>;
            hir.store v66, v64;
            v273 = arith.constant 0 : felt;
            builtin.ret v273;
        ^block9:
            v277 = arith.constant 8 : i32;
            v278 = arith.constant 4 : i32;
            hir.exec @root_ns:root@1.0.0/vec_alloc_vec/alloc::alloc::handle_alloc_error(v278, v277)
            ub.unreachable ;
        };

        private builtin.function @__rustc::__rust_alloc(v67: i32, v68: i32) -> i32 {
        ^block10(v67: i32, v68: i32):
            v70 = arith.constant 1048576 : i32;
            v71 = hir.exec @root_ns:root@1.0.0/vec_alloc_vec/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v70, v68, v67) : i32
            builtin.ret v71;
        };

        private builtin.function @__rustc::__rust_dealloc(v72: i32, v73: i32, v74: i32) {
        ^block12(v72: i32, v73: i32, v74: i32):
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v75: i32, v76: i32, v77: i32) -> i32 {
        ^block14(v75: i32, v76: i32, v77: i32):
            v80 = arith.constant 16 : i32;
            v79 = arith.constant 0 : i32;
            v290 = arith.constant 16 : u32;
            v82 = hir.bitcast v76 : u32;
            v84 = arith.gt v82, v290 : i1;
            v85 = arith.zext v84 : u32;
            v86 = hir.bitcast v85 : i32;
            v88 = arith.neq v86, v79 : i1;
            v89 = cf.select v88, v76, v80 : i32;
            v329 = arith.constant 0 : i32;
            v90 = arith.constant -1 : i32;
            v91 = arith.add v89, v90 : i32 #[overflow = wrapping];
            v92 = arith.band v89, v91 : i32;
            v94 = arith.neq v92, v329 : i1;
            v299, v300 = scf.if v94 : i32, u32 {
            ^block44:
                v291 = arith.constant 0 : u32;
                v295 = ub.poison i32 : i32;
                scf.yield v295, v291;
            } else {
            ^block17:
                v96 = hir.exec @root_ns:root@1.0.0/vec_alloc_vec/core::ptr::alignment::Alignment::max(v76, v89) : i32
                v328 = arith.constant 0 : i32;
                v95 = arith.constant -2147483648 : i32;
                v97 = arith.sub v95, v96 : i32 #[overflow = wrapping];
                v99 = hir.bitcast v97 : u32;
                v98 = hir.bitcast v77 : u32;
                v100 = arith.gt v98, v99 : i1;
                v101 = arith.zext v100 : u32;
                v102 = hir.bitcast v101 : i32;
                v104 = arith.neq v102, v328 : i1;
                v314 = scf.if v104 : i32 {
                ^block43:
                    v327 = ub.poison i32 : i32;
                    scf.yield v327;
                } else {
                ^block18:
                    v325 = arith.constant 0 : i32;
                    v110 = arith.sub v325, v96 : i32 #[overflow = wrapping];
                    v326 = arith.constant -1 : i32;
                    v106 = arith.add v77, v96 : i32 #[overflow = wrapping];
                    v108 = arith.add v106, v326 : i32 #[overflow = wrapping];
                    v111 = arith.band v108, v110 : i32;
                    v112 = hir.bitcast v75 : u32;
                    v113 = arith.constant 4 : u32;
                    v114 = arith.mod v112, v113 : u32;
                    hir.assertz v114 #[code = 250];
                    v115 = hir.int_to_ptr v112 : ptr<byte, i32>;
                    v116 = hir.load v115 : i32;
                    v324 = arith.constant 0 : i32;
                    v118 = arith.neq v116, v324 : i1;
                    scf.if v118{
                    ^block42:
                        scf.yield ;
                    } else {
                    ^block20:
                        v119 = hir.exec @intrinsics/mem/heap_base() : i32
                        v120 = hir.mem_size  : u32;
                        v126 = hir.bitcast v75 : u32;
                        v323 = arith.constant 4 : u32;
                        v128 = arith.mod v126, v323 : u32;
                        hir.assertz v128 #[code = 250];
                        v322 = arith.constant 16 : u32;
                        v121 = hir.bitcast v120 : i32;
                        v124 = arith.shl v121, v322 : i32;
                        v125 = arith.add v119, v124 : i32 #[overflow = wrapping];
                        v129 = hir.int_to_ptr v126 : ptr<byte, i32>;
                        hir.store v129, v125;
                        scf.yield ;
                    };
                    v132 = hir.bitcast v75 : u32;
                    v321 = arith.constant 4 : u32;
                    v134 = arith.mod v132, v321 : u32;
                    hir.assertz v134 #[code = 250];
                    v135 = hir.int_to_ptr v132 : ptr<byte, i32>;
                    v136 = hir.load v135 : i32;
                    v320 = arith.constant 0 : i32;
                    v140 = hir.bitcast v111 : u32;
                    v130 = arith.constant 268435456 : i32;
                    v137 = arith.sub v130, v136 : i32 #[overflow = wrapping];
                    v139 = hir.bitcast v137 : u32;
                    v141 = arith.lt v139, v140 : i1;
                    v142 = arith.zext v141 : u32;
                    v143 = hir.bitcast v142 : i32;
                    v145 = arith.neq v143, v320 : i1;
                    v313 = scf.if v145 : i32 {
                    ^block21:
                        v319 = arith.constant 0 : i32;
                        scf.yield v319;
                    } else {
                    ^block22:
                        v147 = hir.bitcast v75 : u32;
                        v318 = arith.constant 4 : u32;
                        v149 = arith.mod v147, v318 : u32;
                        hir.assertz v149 #[code = 250];
                        v146 = arith.add v136, v111 : i32 #[overflow = wrapping];
                        v150 = hir.int_to_ptr v147 : ptr<byte, i32>;
                        hir.store v150, v146;
                        v152 = arith.add v136, v96 : i32 #[overflow = wrapping];
                        scf.yield v152;
                    };
                    scf.yield v313;
                };
                v296 = arith.constant 1 : u32;
                v317 = arith.constant 0 : u32;
                v315 = cf.select v104, v317, v296 : u32;
                scf.yield v314, v315;
            };
            v316 = arith.constant 0 : u32;
            v312 = arith.eq v300, v316 : i1;
            cf.cond_br v312 ^block16, ^block46(v299);
        ^block16:
            ub.unreachable ;
        ^block46(v292: i32):
            builtin.ret v292;
        };

        private builtin.function @alloc::alloc::handle_alloc_error(v155: i32, v156: i32) {
        ^block23(v155: i32, v156: i32):
            ub.unreachable ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v157: i32, v158: i32, v159: i32) {
        ^block25(v157: i32, v158: i32, v159: i32):
            v161 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v162 = hir.bitcast v161 : ptr<byte, i32>;
            v163 = hir.load v162 : i32;
            v164 = arith.constant 16 : i32;
            v165 = arith.sub v163, v164 : i32 #[overflow = wrapping];
            v166 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v167 = hir.bitcast v166 : ptr<byte, i32>;
            hir.store v167, v165;
            v168 = arith.constant 4 : i32;
            v169 = arith.add v165, v168 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/vec_alloc_vec/alloc::raw_vec::RawVecInner<A>::current_memory(v169, v157, v158, v159)
            v171 = arith.constant 8 : u32;
            v170 = hir.bitcast v165 : u32;
            v172 = arith.add v170, v171 : u32 #[overflow = checked];
            v173 = arith.constant 4 : u32;
            v174 = arith.mod v172, v173 : u32;
            hir.assertz v174 #[code = 250];
            v175 = hir.int_to_ptr v172 : ptr<byte, i32>;
            v176 = hir.load v175 : i32;
            v336 = arith.constant 0 : i32;
            v160 = arith.constant 0 : i32;
            v178 = arith.eq v176, v160 : i1;
            v179 = arith.zext v178 : u32;
            v180 = hir.bitcast v179 : i32;
            v182 = arith.neq v180, v336 : i1;
            scf.if v182{
            ^block50:
                scf.yield ;
            } else {
            ^block28:
                v335 = arith.constant 4 : u32;
                v183 = hir.bitcast v165 : u32;
                v185 = arith.add v183, v335 : u32 #[overflow = checked];
                v334 = arith.constant 4 : u32;
                v187 = arith.mod v185, v334 : u32;
                hir.assertz v187 #[code = 250];
                v188 = hir.int_to_ptr v185 : ptr<byte, i32>;
                v189 = hir.load v188 : i32;
                v191 = arith.constant 12 : u32;
                v190 = hir.bitcast v165 : u32;
                v192 = arith.add v190, v191 : u32 #[overflow = checked];
                v333 = arith.constant 4 : u32;
                v194 = arith.mod v192, v333 : u32;
                hir.assertz v194 #[code = 250];
                v195 = hir.int_to_ptr v192 : ptr<byte, i32>;
                v196 = hir.load v195 : i32;
                hir.exec @root_ns:root@1.0.0/vec_alloc_vec/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v189, v176, v196)
                scf.yield ;
            };
            v332 = arith.constant 16 : i32;
            v199 = arith.add v165, v332 : i32 #[overflow = wrapping];
            v200 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v201 = hir.bitcast v200 : ptr<byte, i32>;
            hir.store v201, v199;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v202: i32, v203: i32, v204: i32, v205: i32) {
        ^block29(v202: i32, v203: i32, v204: i32, v205: i32):
            v362 = arith.constant 0 : i32;
            v206 = arith.constant 0 : i32;
            v210 = arith.eq v205, v206 : i1;
            v211 = arith.zext v210 : u32;
            v212 = hir.bitcast v211 : i32;
            v214 = arith.neq v212, v362 : i1;
            v349, v350 = scf.if v214 : i32, i32 {
            ^block53:
                v361 = arith.constant 0 : i32;
                v208 = arith.constant 4 : i32;
                scf.yield v208, v361;
            } else {
            ^block32:
                v215 = hir.bitcast v203 : u32;
                v250 = arith.constant 4 : u32;
                v217 = arith.mod v215, v250 : u32;
                hir.assertz v217 #[code = 250];
                v218 = hir.int_to_ptr v215 : ptr<byte, i32>;
                v219 = hir.load v218 : i32;
                v359 = arith.constant 0 : i32;
                v360 = arith.constant 0 : i32;
                v221 = arith.eq v219, v360 : i1;
                v222 = arith.zext v221 : u32;
                v223 = hir.bitcast v222 : i32;
                v225 = arith.neq v223, v359 : i1;
                v347 = scf.if v225 : i32 {
                ^block52:
                    v358 = arith.constant 0 : i32;
                    scf.yield v358;
                } else {
                ^block33:
                    v357 = arith.constant 4 : u32;
                    v226 = hir.bitcast v202 : u32;
                    v228 = arith.add v226, v357 : u32 #[overflow = checked];
                    v356 = arith.constant 4 : u32;
                    v230 = arith.mod v228, v356 : u32;
                    hir.assertz v230 #[code = 250];
                    v231 = hir.int_to_ptr v228 : ptr<byte, i32>;
                    hir.store v231, v204;
                    v355 = arith.constant 4 : u32;
                    v232 = hir.bitcast v203 : u32;
                    v234 = arith.add v232, v355 : u32 #[overflow = checked];
                    v354 = arith.constant 4 : u32;
                    v236 = arith.mod v234, v354 : u32;
                    hir.assertz v236 #[code = 250];
                    v237 = hir.int_to_ptr v234 : ptr<byte, i32>;
                    v238 = hir.load v237 : i32;
                    v239 = hir.bitcast v202 : u32;
                    v353 = arith.constant 4 : u32;
                    v241 = arith.mod v239, v353 : u32;
                    hir.assertz v241 #[code = 250];
                    v242 = hir.int_to_ptr v239 : ptr<byte, i32>;
                    hir.store v242, v238;
                    v243 = arith.mul v219, v205 : i32 #[overflow = wrapping];
                    scf.yield v243;
                };
                v244 = arith.constant 8 : i32;
                v352 = arith.constant 4 : i32;
                v348 = cf.select v225, v352, v244 : i32;
                scf.yield v348, v347;
            };
            v247 = arith.add v202, v349 : i32 #[overflow = wrapping];
            v249 = hir.bitcast v247 : u32;
            v351 = arith.constant 4 : u32;
            v251 = arith.mod v249, v351 : u32;
            hir.assertz v251 #[code = 250];
            v252 = hir.int_to_ptr v249 : ptr<byte, i32>;
            hir.store v252, v350;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v253: i32, v254: i32, v255: i32) {
        ^block34(v253: i32, v254: i32, v255: i32):
            v364 = arith.constant 0 : i32;
            v256 = arith.constant 0 : i32;
            v257 = arith.eq v255, v256 : i1;
            v258 = arith.zext v257 : u32;
            v259 = hir.bitcast v258 : i32;
            v261 = arith.neq v259, v364 : i1;
            scf.if v261{
            ^block36:
                scf.yield ;
            } else {
            ^block37:
                hir.exec @root_ns:root@1.0.0/vec_alloc_vec/__rustc::__rust_dealloc(v253, v255, v254)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v262: i32, v263: i32) -> i32 {
        ^block38(v262: i32, v263: i32):
            v270 = arith.constant 0 : i32;
            v266 = hir.bitcast v263 : u32;
            v265 = hir.bitcast v262 : u32;
            v267 = arith.gt v265, v266 : i1;
            v268 = arith.zext v267 : u32;
            v269 = hir.bitcast v268 : i32;
            v271 = arith.neq v269, v270 : i1;
            v272 = cf.select v271, v262, v263 : i32;
            builtin.ret v272;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};