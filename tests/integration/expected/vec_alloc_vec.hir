builtin.component root_ns:root@1.0.0 {
    builtin.module public @vec_alloc_vec {
        private builtin.function @__rustc::__rust_alloc(v0: i32, v1: i32) -> i32 {
        ^block4(v0: i32, v1: i32):
            v3 = arith.constant 1048576 : i32;
            v4 = hir.exec @root_ns:root@1.0.0/vec_alloc_vec/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v3, v1, v0) : i32
            builtin.ret v4;
        };

        private builtin.function @__rustc::__rust_dealloc(v5: i32, v6: i32, v7: i32) {
        ^block6(v5: i32, v6: i32, v7: i32):
            builtin.ret ;
        };

        public builtin.function @entrypoint(v8: i32) -> felt {
        ^block8(v8: i32):
            v12 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v13 = hir.bitcast v12 : ptr<byte, i32>;
            v14 = hir.load v13 : i32;
            v15 = arith.constant 16 : i32;
            v16 = arith.sub v14, v15 : i32 #[overflow = wrapping];
            v17 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v18 = hir.bitcast v17 : ptr<byte, i32>;
            hir.store v18, v16;
            hir.exec @root_ns:root@1.0.0/vec_alloc_vec/__rustc::__rust_no_alloc_shim_is_unstable_v2()
            v20 = arith.constant 4 : i32;
            v19 = arith.constant 12 : i32;
            v21 = hir.exec @root_ns:root@1.0.0/vec_alloc_vec/__rustc::__rust_alloc(v19, v20) : i32
            v338 = arith.constant 0 : i32;
            v10 = arith.constant 0 : i32;
            v23 = arith.eq v21, v10 : i1;
            v24 = arith.zext v23 : u32;
            v25 = hir.bitcast v24 : i32;
            v27 = arith.neq v25, v338 : i1;
            v310, v311 = scf.if v27 : felt, u32 {
            ^block11:
                v336 = arith.constant 12 : i32;
                v337 = arith.constant 4 : i32;
                hir.exec @root_ns:root@1.0.0/vec_alloc_vec/alloc::alloc::handle_alloc_error(v337, v336)
                v302 = arith.constant 0 : u32;
                v306 = ub.poison felt : felt;
                scf.yield v306, v302;
            } else {
            ^block12:
                v28 = arith.constant 1 : i32;
                v29 = hir.exec @root_ns:root@1.0.0/vec_alloc_vec/intrinsics::felt::from_u32(v28) : felt
                v30 = arith.constant 2 : i32;
                v31 = hir.exec @root_ns:root@1.0.0/vec_alloc_vec/intrinsics::felt::from_u32(v30) : felt
                v32 = arith.constant 3 : i32;
                v33 = hir.exec @root_ns:root@1.0.0/vec_alloc_vec/intrinsics::felt::from_u32(v32) : felt
                v35 = arith.constant 8 : u32;
                v34 = hir.bitcast v21 : u32;
                v36 = arith.add v34, v35 : u32 #[overflow = checked];
                v37 = arith.constant 4 : u32;
                v38 = arith.mod v36, v37 : u32;
                hir.assertz v38 #[code = 250];
                v39 = hir.int_to_ptr v36 : ptr<byte, felt>;
                hir.store v39, v33;
                v335 = arith.constant 4 : u32;
                v40 = hir.bitcast v21 : u32;
                v42 = arith.add v40, v335 : u32 #[overflow = checked];
                v334 = arith.constant 4 : u32;
                v44 = arith.mod v42, v334 : u32;
                hir.assertz v44 #[code = 250];
                v45 = hir.int_to_ptr v42 : ptr<byte, felt>;
                hir.store v45, v31;
                v46 = hir.bitcast v21 : u32;
                v333 = arith.constant 4 : u32;
                v48 = arith.mod v46, v333 : u32;
                hir.assertz v48 #[code = 250];
                v49 = hir.int_to_ptr v46 : ptr<byte, felt>;
                hir.store v49, v29;
                v52 = arith.constant 12 : u32;
                v51 = hir.bitcast v16 : u32;
                v53 = arith.add v51, v52 : u32 #[overflow = checked];
                v332 = arith.constant 4 : u32;
                v55 = arith.mod v53, v332 : u32;
                hir.assertz v55 #[code = 250];
                v331 = arith.constant 3 : i32;
                v56 = hir.int_to_ptr v53 : ptr<byte, i32>;
                hir.store v56, v331;
                v330 = arith.constant 8 : u32;
                v57 = hir.bitcast v16 : u32;
                v59 = arith.add v57, v330 : u32 #[overflow = checked];
                v329 = arith.constant 4 : u32;
                v61 = arith.mod v59, v329 : u32;
                hir.assertz v61 #[code = 250];
                v62 = hir.int_to_ptr v59 : ptr<byte, i32>;
                hir.store v62, v21;
                v328 = arith.constant 4 : u32;
                v64 = hir.bitcast v16 : u32;
                v66 = arith.add v64, v328 : u32 #[overflow = checked];
                v327 = arith.constant 4 : u32;
                v68 = arith.mod v66, v327 : u32;
                hir.assertz v68 #[code = 250];
                v326 = arith.constant 3 : i32;
                v69 = hir.int_to_ptr v66 : ptr<byte, i32>;
                hir.store v69, v326;
                v325 = arith.constant 0 : i32;
                v301 = arith.constant 3 : u32;
                v71 = hir.bitcast v8 : u32;
                v73 = arith.gte v71, v301 : i1;
                v74 = arith.zext v73 : u32;
                v75 = hir.bitcast v74 : i32;
                v77 = arith.neq v75, v325 : i1;
                v316 = scf.if v77 : felt {
                ^block48:
                    v324 = ub.poison felt : felt;
                    scf.yield v324;
                } else {
                ^block13:
                    v300 = arith.constant 2 : u32;
                    v80 = arith.shl v8, v300 : i32;
                    v81 = arith.add v21, v80 : i32 #[overflow = wrapping];
                    v82 = hir.bitcast v81 : u32;
                    v323 = arith.constant 4 : u32;
                    v84 = arith.mod v82, v323 : u32;
                    hir.assertz v84 #[code = 250];
                    v85 = hir.int_to_ptr v82 : ptr<byte, felt>;
                    v86 = hir.load v85 : felt;
                    v321 = arith.constant 4 : i32;
                    v322 = arith.constant 4 : i32;
                    v88 = arith.add v16, v322 : i32 #[overflow = wrapping];
                    hir.exec @root_ns:root@1.0.0/vec_alloc_vec/<alloc::raw_vec::RawVecInner>::deallocate(v88, v321, v321)
                    v320 = arith.constant 16 : i32;
                    v92 = arith.add v16, v320 : i32 #[overflow = wrapping];
                    v93 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
                    v94 = hir.bitcast v93 : ptr<byte, i32>;
                    hir.store v94, v92;
                    scf.yield v86;
                };
                v307 = arith.constant 1 : u32;
                v319 = arith.constant 0 : u32;
                v317 = cf.select v77, v319, v307 : u32;
                scf.yield v316, v317;
            };
            v318 = arith.constant 0 : u32;
            v315 = arith.eq v311, v318 : i1;
            cf.cond_br v315 ^block10, ^block50(v310);
        ^block10:
            ub.unreachable ;
        ^block50(v303: felt):
            builtin.ret v303;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block14:
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v97: i32, v98: i32, v99: i32) -> i32 {
        ^block16(v97: i32, v98: i32, v99: i32):
            v102 = arith.constant 16 : i32;
            v101 = arith.constant 0 : i32;
            v340 = arith.constant 16 : u32;
            v104 = hir.bitcast v98 : u32;
            v106 = arith.gt v104, v340 : i1;
            v107 = arith.zext v106 : u32;
            v108 = hir.bitcast v107 : i32;
            v110 = arith.neq v108, v101 : i1;
            v111 = cf.select v110, v98, v102 : i32;
            v380 = arith.constant 0 : i32;
            v112 = arith.constant -1 : i32;
            v113 = arith.add v111, v112 : i32 #[overflow = wrapping];
            v114 = arith.band v111, v113 : i32;
            v116 = arith.neq v114, v380 : i1;
            v349, v350 = scf.if v116 : i32, u32 {
            ^block55:
                v341 = arith.constant 0 : u32;
                v345 = ub.poison i32 : i32;
                scf.yield v345, v341;
            } else {
            ^block19:
                v118 = hir.exec @root_ns:root@1.0.0/vec_alloc_vec/<core::ptr::alignment::Alignment>::max(v98, v111) : i32
                v379 = arith.constant 0 : i32;
                v117 = arith.constant -2147483648 : i32;
                v119 = arith.sub v117, v118 : i32 #[overflow = wrapping];
                v121 = hir.bitcast v119 : u32;
                v120 = hir.bitcast v99 : u32;
                v122 = arith.gt v120, v121 : i1;
                v123 = arith.zext v122 : u32;
                v124 = hir.bitcast v123 : i32;
                v126 = arith.neq v124, v379 : i1;
                v364 = scf.if v126 : i32 {
                ^block54:
                    v378 = ub.poison i32 : i32;
                    scf.yield v378;
                } else {
                ^block20:
                    v376 = arith.constant 0 : i32;
                    v132 = arith.sub v376, v118 : i32 #[overflow = wrapping];
                    v377 = arith.constant -1 : i32;
                    v128 = arith.add v99, v118 : i32 #[overflow = wrapping];
                    v130 = arith.add v128, v377 : i32 #[overflow = wrapping];
                    v133 = arith.band v130, v132 : i32;
                    v134 = hir.bitcast v97 : u32;
                    v135 = arith.constant 4 : u32;
                    v136 = arith.mod v134, v135 : u32;
                    hir.assertz v136 #[code = 250];
                    v137 = hir.int_to_ptr v134 : ptr<byte, i32>;
                    v138 = hir.load v137 : i32;
                    v375 = arith.constant 0 : i32;
                    v140 = arith.neq v138, v375 : i1;
                    scf.if v140{
                    ^block53:
                        scf.yield ;
                    } else {
                    ^block22:
                        v141 = hir.exec @root_ns:root@1.0.0/vec_alloc_vec/intrinsics::mem::heap_base() : i32
                        v142 = hir.mem_size  : u32;
                        v148 = hir.bitcast v97 : u32;
                        v374 = arith.constant 4 : u32;
                        v150 = arith.mod v148, v374 : u32;
                        hir.assertz v150 #[code = 250];
                        v373 = arith.constant 16 : u32;
                        v143 = hir.bitcast v142 : i32;
                        v146 = arith.shl v143, v373 : i32;
                        v147 = arith.add v141, v146 : i32 #[overflow = wrapping];
                        v151 = hir.int_to_ptr v148 : ptr<byte, i32>;
                        hir.store v151, v147;
                        scf.yield ;
                    };
                    v154 = hir.bitcast v97 : u32;
                    v372 = arith.constant 4 : u32;
                    v156 = arith.mod v154, v372 : u32;
                    hir.assertz v156 #[code = 250];
                    v157 = hir.int_to_ptr v154 : ptr<byte, i32>;
                    v158 = hir.load v157 : i32;
                    v370 = arith.constant 0 : i32;
                    v371 = arith.constant -1 : i32;
                    v160 = arith.bxor v158, v371 : i32;
                    v162 = hir.bitcast v160 : u32;
                    v161 = hir.bitcast v133 : u32;
                    v163 = arith.gt v161, v162 : i1;
                    v164 = arith.zext v163 : u32;
                    v165 = hir.bitcast v164 : i32;
                    v167 = arith.neq v165, v370 : i1;
                    v363 = scf.if v167 : i32 {
                    ^block23:
                        v369 = arith.constant 0 : i32;
                        scf.yield v369;
                    } else {
                    ^block24:
                        v169 = hir.bitcast v97 : u32;
                        v368 = arith.constant 4 : u32;
                        v171 = arith.mod v169, v368 : u32;
                        hir.assertz v171 #[code = 250];
                        v168 = arith.add v158, v133 : i32 #[overflow = wrapping];
                        v172 = hir.int_to_ptr v169 : ptr<byte, i32>;
                        hir.store v172, v168;
                        v174 = arith.add v158, v118 : i32 #[overflow = wrapping];
                        scf.yield v174;
                    };
                    scf.yield v363;
                };
                v346 = arith.constant 1 : u32;
                v367 = arith.constant 0 : u32;
                v365 = cf.select v126, v367, v346 : u32;
                scf.yield v364, v365;
            };
            v366 = arith.constant 0 : u32;
            v362 = arith.eq v350, v366 : i1;
            cf.cond_br v362 ^block18, ^block57(v349);
        ^block18:
            ub.unreachable ;
        ^block57(v342: i32):
            builtin.ret v342;
        };

        private builtin.function @intrinsics::mem::heap_base() -> i32 {
        ^block25:
            v177 = hir.exec @intrinsics/mem/heap_base() : i32
            builtin.ret v177;
        };

        private builtin.function @intrinsics::felt::from_u32(v179: i32) -> felt {
        ^block29(v179: i32):
            v180 = hir.bitcast v179 : felt;
            builtin.ret v180;
        };

        private builtin.function @alloc::alloc::handle_alloc_error(v182: i32, v183: i32) {
        ^block31(v182: i32, v183: i32):
            ub.unreachable ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::deallocate(v184: i32, v185: i32, v186: i32) {
        ^block33(v184: i32, v185: i32, v186: i32):
            v188 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v189 = hir.bitcast v188 : ptr<byte, i32>;
            v190 = hir.load v189 : i32;
            v191 = arith.constant 16 : i32;
            v192 = arith.sub v190, v191 : i32 #[overflow = wrapping];
            v193 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v194 = hir.bitcast v193 : ptr<byte, i32>;
            hir.store v194, v192;
            v195 = arith.constant 4 : i32;
            v196 = arith.add v192, v195 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/vec_alloc_vec/<alloc::raw_vec::RawVecInner>::current_memory(v196, v184, v185, v186)
            v198 = arith.constant 8 : u32;
            v197 = hir.bitcast v192 : u32;
            v199 = arith.add v197, v198 : u32 #[overflow = checked];
            v200 = arith.constant 4 : u32;
            v201 = arith.mod v199, v200 : u32;
            hir.assertz v201 #[code = 250];
            v202 = hir.int_to_ptr v199 : ptr<byte, i32>;
            v203 = hir.load v202 : i32;
            v387 = arith.constant 0 : i32;
            v187 = arith.constant 0 : i32;
            v205 = arith.eq v203, v187 : i1;
            v206 = arith.zext v205 : u32;
            v207 = hir.bitcast v206 : i32;
            v209 = arith.neq v207, v387 : i1;
            scf.if v209{
            ^block61:
                scf.yield ;
            } else {
            ^block36:
                v386 = arith.constant 4 : u32;
                v210 = hir.bitcast v192 : u32;
                v212 = arith.add v210, v386 : u32 #[overflow = checked];
                v385 = arith.constant 4 : u32;
                v214 = arith.mod v212, v385 : u32;
                hir.assertz v214 #[code = 250];
                v215 = hir.int_to_ptr v212 : ptr<byte, i32>;
                v216 = hir.load v215 : i32;
                v218 = arith.constant 12 : u32;
                v217 = hir.bitcast v192 : u32;
                v219 = arith.add v217, v218 : u32 #[overflow = checked];
                v384 = arith.constant 4 : u32;
                v221 = arith.mod v219, v384 : u32;
                hir.assertz v221 #[code = 250];
                v222 = hir.int_to_ptr v219 : ptr<byte, i32>;
                v223 = hir.load v222 : i32;
                hir.exec @root_ns:root@1.0.0/vec_alloc_vec/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v216, v203, v223)
                scf.yield ;
            };
            v383 = arith.constant 16 : i32;
            v226 = arith.add v192, v383 : i32 #[overflow = wrapping];
            v227 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v228 = hir.bitcast v227 : ptr<byte, i32>;
            hir.store v228, v226;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::current_memory(v229: i32, v230: i32, v231: i32, v232: i32) {
        ^block37(v229: i32, v230: i32, v231: i32, v232: i32):
            v413 = arith.constant 0 : i32;
            v233 = arith.constant 0 : i32;
            v237 = arith.eq v232, v233 : i1;
            v238 = arith.zext v237 : u32;
            v239 = hir.bitcast v238 : i32;
            v241 = arith.neq v239, v413 : i1;
            v400, v401 = scf.if v241 : i32, i32 {
            ^block64:
                v412 = arith.constant 0 : i32;
                v235 = arith.constant 4 : i32;
                scf.yield v235, v412;
            } else {
            ^block40:
                v242 = hir.bitcast v230 : u32;
                v277 = arith.constant 4 : u32;
                v244 = arith.mod v242, v277 : u32;
                hir.assertz v244 #[code = 250];
                v245 = hir.int_to_ptr v242 : ptr<byte, i32>;
                v246 = hir.load v245 : i32;
                v410 = arith.constant 0 : i32;
                v411 = arith.constant 0 : i32;
                v248 = arith.eq v246, v411 : i1;
                v249 = arith.zext v248 : u32;
                v250 = hir.bitcast v249 : i32;
                v252 = arith.neq v250, v410 : i1;
                v398 = scf.if v252 : i32 {
                ^block63:
                    v409 = arith.constant 0 : i32;
                    scf.yield v409;
                } else {
                ^block41:
                    v408 = arith.constant 4 : u32;
                    v253 = hir.bitcast v229 : u32;
                    v255 = arith.add v253, v408 : u32 #[overflow = checked];
                    v407 = arith.constant 4 : u32;
                    v257 = arith.mod v255, v407 : u32;
                    hir.assertz v257 #[code = 250];
                    v258 = hir.int_to_ptr v255 : ptr<byte, i32>;
                    hir.store v258, v231;
                    v406 = arith.constant 4 : u32;
                    v259 = hir.bitcast v230 : u32;
                    v261 = arith.add v259, v406 : u32 #[overflow = checked];
                    v405 = arith.constant 4 : u32;
                    v263 = arith.mod v261, v405 : u32;
                    hir.assertz v263 #[code = 250];
                    v264 = hir.int_to_ptr v261 : ptr<byte, i32>;
                    v265 = hir.load v264 : i32;
                    v266 = hir.bitcast v229 : u32;
                    v404 = arith.constant 4 : u32;
                    v268 = arith.mod v266, v404 : u32;
                    hir.assertz v268 #[code = 250];
                    v269 = hir.int_to_ptr v266 : ptr<byte, i32>;
                    hir.store v269, v265;
                    v270 = arith.mul v246, v232 : i32 #[overflow = wrapping];
                    scf.yield v270;
                };
                v271 = arith.constant 8 : i32;
                v403 = arith.constant 4 : i32;
                v399 = cf.select v252, v403, v271 : i32;
                scf.yield v399, v398;
            };
            v274 = arith.add v229, v400 : i32 #[overflow = wrapping];
            v276 = hir.bitcast v274 : u32;
            v402 = arith.constant 4 : u32;
            v278 = arith.mod v276, v402 : u32;
            hir.assertz v278 #[code = 250];
            v279 = hir.int_to_ptr v276 : ptr<byte, i32>;
            hir.store v279, v401;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v280: i32, v281: i32, v282: i32) {
        ^block42(v280: i32, v281: i32, v282: i32):
            v415 = arith.constant 0 : i32;
            v283 = arith.constant 0 : i32;
            v284 = arith.eq v282, v283 : i1;
            v285 = arith.zext v284 : u32;
            v286 = hir.bitcast v285 : i32;
            v288 = arith.neq v286, v415 : i1;
            scf.if v288{
            ^block44:
                scf.yield ;
            } else {
            ^block45:
                hir.exec @root_ns:root@1.0.0/vec_alloc_vec/__rustc::__rust_dealloc(v280, v282, v281)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @<core::ptr::alignment::Alignment>::max(v289: i32, v290: i32) -> i32 {
        ^block46(v289: i32, v290: i32):
            v297 = arith.constant 0 : i32;
            v293 = hir.bitcast v290 : u32;
            v292 = hir.bitcast v289 : u32;
            v294 = arith.gt v292, v293 : i1;
            v295 = arith.zext v294 : u32;
            v296 = hir.bitcast v295 : i32;
            v298 = arith.neq v296, v297 : i1;
            v299 = cf.select v298, v289, v290 : i32;
            builtin.ret v299;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};