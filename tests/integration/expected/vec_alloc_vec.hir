builtin.component root_ns:root@1.0.0 {
    builtin.module public @vec_alloc_vec {
        private builtin.function @__rustc::__rust_alloc(v0: i32, v1: i32) -> i32 {
        ^block6(v0: i32, v1: i32):
            v3 = arith.constant 1048576 : i32;
            v4 = hir.exec @root_ns:root@1.0.0/vec_alloc_vec/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v3, v1, v0) : i32
            builtin.ret v4;
        };

        private builtin.function @__rustc::__rust_dealloc(v5: i32, v6: i32, v7: i32) {
        ^block8(v5: i32, v6: i32, v7: i32):
            builtin.ret ;
        };

        public builtin.function @entrypoint(v8: i32) -> felt {
        ^block10(v8: i32):
            v12 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v13 = hir.bitcast v12 : ptr<byte, i32>;
            v14 = hir.load v13 : i32;
            v15 = arith.constant 16 : i32;
            v16 = arith.sub v14, v15 : i32 #[overflow = wrapping];
            v17 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v18 = hir.bitcast v17 : ptr<byte, i32>;
            hir.store v18, v16;
            hir.exec @root_ns:root@1.0.0/vec_alloc_vec/__rustc::__rust_no_alloc_shim_is_unstable_v2()
            v20 = arith.constant 4 : i32;
            v19 = arith.constant 12 : i32;
            v21 = hir.exec @root_ns:root@1.0.0/vec_alloc_vec/__rustc::__rust_alloc(v19, v20) : i32
            v337 = arith.constant 0 : i32;
            v10 = arith.constant 0 : i32;
            v23 = arith.eq v21, v10 : i1;
            v24 = arith.zext v23 : u32;
            v25 = hir.bitcast v24 : i32;
            v27 = arith.neq v25, v337 : i1;
            v310, v311 = scf.if v27 : felt, u32 {
            ^block13:
                v335 = arith.constant 12 : i32;
                v336 = arith.constant 4 : i32;
                hir.exec @root_ns:root@1.0.0/vec_alloc_vec/alloc::alloc::handle_alloc_error(v336, v335)
                v302 = arith.constant 0 : u32;
                v306 = ub.poison felt : felt;
                scf.yield v306, v302;
            } else {
            ^block14:
                v35 = arith.constant 8 : u32;
                v34 = hir.bitcast v21 : u32;
                v36 = arith.add v34, v35 : u32 #[overflow = checked];
                v37 = arith.constant 4 : u32;
                v38 = arith.mod v36, v37 : u32;
                hir.assertz v38 #[code = 250];
                v299 = arith.constant 3 : felt;
                v39 = hir.int_to_ptr v36 : ptr<byte, felt>;
                hir.store v39, v299;
                v334 = arith.constant 4 : u32;
                v40 = hir.bitcast v21 : u32;
                v42 = arith.add v40, v334 : u32 #[overflow = checked];
                v333 = arith.constant 4 : u32;
                v44 = arith.mod v42, v333 : u32;
                hir.assertz v44 #[code = 250];
                v300 = arith.constant 2 : felt;
                v45 = hir.int_to_ptr v42 : ptr<byte, felt>;
                hir.store v45, v300;
                v46 = hir.bitcast v21 : u32;
                v332 = arith.constant 4 : u32;
                v48 = arith.mod v46, v332 : u32;
                hir.assertz v48 #[code = 250];
                v301 = arith.constant 1 : felt;
                v49 = hir.int_to_ptr v46 : ptr<byte, felt>;
                hir.store v49, v301;
                v52 = arith.constant 12 : u32;
                v51 = hir.bitcast v16 : u32;
                v53 = arith.add v51, v52 : u32 #[overflow = checked];
                v331 = arith.constant 4 : u32;
                v55 = arith.mod v53, v331 : u32;
                hir.assertz v55 #[code = 250];
                v32 = arith.constant 3 : i32;
                v56 = hir.int_to_ptr v53 : ptr<byte, i32>;
                hir.store v56, v32;
                v330 = arith.constant 8 : u32;
                v57 = hir.bitcast v16 : u32;
                v59 = arith.add v57, v330 : u32 #[overflow = checked];
                v329 = arith.constant 4 : u32;
                v61 = arith.mod v59, v329 : u32;
                hir.assertz v61 #[code = 250];
                v62 = hir.int_to_ptr v59 : ptr<byte, i32>;
                hir.store v62, v21;
                v328 = arith.constant 4 : u32;
                v64 = hir.bitcast v16 : u32;
                v66 = arith.add v64, v328 : u32 #[overflow = checked];
                v327 = arith.constant 4 : u32;
                v68 = arith.mod v66, v327 : u32;
                hir.assertz v68 #[code = 250];
                v326 = arith.constant 3 : i32;
                v69 = hir.int_to_ptr v66 : ptr<byte, i32>;
                hir.store v69, v326;
                v325 = arith.constant 0 : i32;
                v298 = arith.constant 3 : u32;
                v71 = hir.bitcast v8 : u32;
                v73 = arith.gte v71, v298 : i1;
                v74 = arith.zext v73 : u32;
                v75 = hir.bitcast v74 : i32;
                v77 = arith.neq v75, v325 : i1;
                v316 = scf.if v77 : felt {
                ^block44:
                    v324 = ub.poison felt : felt;
                    scf.yield v324;
                } else {
                ^block15:
                    v297 = arith.constant 2 : u32;
                    v80 = arith.shl v8, v297 : i32;
                    v81 = arith.add v21, v80 : i32 #[overflow = wrapping];
                    v82 = hir.bitcast v81 : u32;
                    v323 = arith.constant 4 : u32;
                    v84 = arith.mod v82, v323 : u32;
                    hir.assertz v84 #[code = 250];
                    v85 = hir.int_to_ptr v82 : ptr<byte, felt>;
                    v86 = hir.load v85 : felt;
                    v321 = arith.constant 4 : i32;
                    v322 = arith.constant 4 : i32;
                    v88 = arith.add v16, v322 : i32 #[overflow = wrapping];
                    hir.exec @root_ns:root@1.0.0/vec_alloc_vec/<alloc::raw_vec::RawVecInner>::deallocate(v88, v321, v321)
                    v320 = arith.constant 16 : i32;
                    v92 = arith.add v16, v320 : i32 #[overflow = wrapping];
                    v93 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
                    v94 = hir.bitcast v93 : ptr<byte, i32>;
                    hir.store v94, v92;
                    scf.yield v86;
                };
                v307 = arith.constant 1 : u32;
                v319 = arith.constant 0 : u32;
                v317 = cf.select v77, v319, v307 : u32;
                scf.yield v316, v317;
            };
            v318 = arith.constant 0 : u32;
            v315 = arith.eq v311, v318 : i1;
            cf.cond_br v315 ^block12, ^block46(v310);
        ^block12:
            ub.unreachable ;
        ^block46(v303: felt):
            builtin.ret v303;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block16:
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v97: i32, v98: i32, v99: i32) -> i32 {
        ^block18(v97: i32, v98: i32, v99: i32):
            v102 = arith.constant 16 : i32;
            v101 = arith.constant 0 : i32;
            v339 = arith.constant 16 : u32;
            v104 = hir.bitcast v98 : u32;
            v106 = arith.gt v104, v339 : i1;
            v107 = arith.zext v106 : u32;
            v108 = hir.bitcast v107 : i32;
            v110 = arith.neq v108, v101 : i1;
            v111 = cf.select v110, v98, v102 : i32;
            v379 = arith.constant 0 : i32;
            v112 = arith.constant -1 : i32;
            v113 = arith.add v111, v112 : i32 #[overflow = wrapping];
            v114 = arith.band v111, v113 : i32;
            v116 = arith.neq v114, v379 : i1;
            v348, v349 = scf.if v116 : i32, u32 {
            ^block51:
                v340 = arith.constant 0 : u32;
                v344 = ub.poison i32 : i32;
                scf.yield v344, v340;
            } else {
            ^block21:
                v118 = hir.exec @root_ns:root@1.0.0/vec_alloc_vec/<core::ptr::alignment::Alignment>::max(v98, v111) : i32
                v378 = arith.constant 0 : i32;
                v117 = arith.constant -2147483648 : i32;
                v119 = arith.sub v117, v118 : i32 #[overflow = wrapping];
                v121 = hir.bitcast v119 : u32;
                v120 = hir.bitcast v99 : u32;
                v122 = arith.gt v120, v121 : i1;
                v123 = arith.zext v122 : u32;
                v124 = hir.bitcast v123 : i32;
                v126 = arith.neq v124, v378 : i1;
                v363 = scf.if v126 : i32 {
                ^block50:
                    v377 = ub.poison i32 : i32;
                    scf.yield v377;
                } else {
                ^block22:
                    v375 = arith.constant 0 : i32;
                    v132 = arith.sub v375, v118 : i32 #[overflow = wrapping];
                    v376 = arith.constant -1 : i32;
                    v128 = arith.add v99, v118 : i32 #[overflow = wrapping];
                    v130 = arith.add v128, v376 : i32 #[overflow = wrapping];
                    v133 = arith.band v130, v132 : i32;
                    v134 = hir.bitcast v97 : u32;
                    v135 = arith.constant 4 : u32;
                    v136 = arith.mod v134, v135 : u32;
                    hir.assertz v136 #[code = 250];
                    v137 = hir.int_to_ptr v134 : ptr<byte, i32>;
                    v138 = hir.load v137 : i32;
                    v374 = arith.constant 0 : i32;
                    v140 = arith.neq v138, v374 : i1;
                    scf.if v140{
                    ^block49:
                        scf.yield ;
                    } else {
                    ^block24:
                        v141 = hir.exec @intrinsics/mem/heap_base() : u32
                        v142 = hir.mem_size  : u32;
                        v150 = hir.bitcast v97 : u32;
                        v373 = arith.constant 4 : u32;
                        v152 = arith.mod v150, v373 : u32;
                        hir.assertz v152 #[code = 250];
                        v372 = arith.constant 16 : u32;
                        v143 = hir.bitcast v142 : i32;
                        v146 = arith.shl v143, v372 : i32;
                        v147 = hir.bitcast v146 : u32;
                        v148 = arith.add v141, v147 : u32 #[overflow = wrapping];
                        v149 = hir.bitcast v148 : i32;
                        v153 = hir.int_to_ptr v150 : ptr<byte, i32>;
                        hir.store v153, v149;
                        scf.yield ;
                    };
                    v156 = hir.bitcast v97 : u32;
                    v371 = arith.constant 4 : u32;
                    v158 = arith.mod v156, v371 : u32;
                    hir.assertz v158 #[code = 250];
                    v159 = hir.int_to_ptr v156 : ptr<byte, i32>;
                    v160 = hir.load v159 : i32;
                    v369 = arith.constant 0 : i32;
                    v370 = arith.constant -1 : i32;
                    v162 = arith.bxor v160, v370 : i32;
                    v164 = hir.bitcast v162 : u32;
                    v163 = hir.bitcast v133 : u32;
                    v165 = arith.gt v163, v164 : i1;
                    v166 = arith.zext v165 : u32;
                    v167 = hir.bitcast v166 : i32;
                    v169 = arith.neq v167, v369 : i1;
                    v362 = scf.if v169 : i32 {
                    ^block25:
                        v368 = arith.constant 0 : i32;
                        scf.yield v368;
                    } else {
                    ^block26:
                        v171 = hir.bitcast v97 : u32;
                        v367 = arith.constant 4 : u32;
                        v173 = arith.mod v171, v367 : u32;
                        hir.assertz v173 #[code = 250];
                        v170 = arith.add v160, v133 : i32 #[overflow = wrapping];
                        v174 = hir.int_to_ptr v171 : ptr<byte, i32>;
                        hir.store v174, v170;
                        v176 = arith.add v160, v118 : i32 #[overflow = wrapping];
                        scf.yield v176;
                    };
                    scf.yield v362;
                };
                v345 = arith.constant 1 : u32;
                v366 = arith.constant 0 : u32;
                v364 = cf.select v126, v366, v345 : u32;
                scf.yield v363, v364;
            };
            v365 = arith.constant 0 : u32;
            v361 = arith.eq v349, v365 : i1;
            cf.cond_br v361 ^block20, ^block53(v348);
        ^block20:
            ub.unreachable ;
        ^block53(v341: i32):
            builtin.ret v341;
        };

        private builtin.function @alloc::alloc::handle_alloc_error(v179: i32, v180: i32) {
        ^block27(v179: i32, v180: i32):
            ub.unreachable ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::deallocate(v181: i32, v182: i32, v183: i32) {
        ^block29(v181: i32, v182: i32, v183: i32):
            v185 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v186 = hir.bitcast v185 : ptr<byte, i32>;
            v187 = hir.load v186 : i32;
            v188 = arith.constant 16 : i32;
            v189 = arith.sub v187, v188 : i32 #[overflow = wrapping];
            v190 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v191 = hir.bitcast v190 : ptr<byte, i32>;
            hir.store v191, v189;
            v192 = arith.constant 4 : i32;
            v193 = arith.add v189, v192 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/vec_alloc_vec/<alloc::raw_vec::RawVecInner>::current_memory(v193, v181, v182, v183)
            v195 = arith.constant 8 : u32;
            v194 = hir.bitcast v189 : u32;
            v196 = arith.add v194, v195 : u32 #[overflow = checked];
            v197 = arith.constant 4 : u32;
            v198 = arith.mod v196, v197 : u32;
            hir.assertz v198 #[code = 250];
            v199 = hir.int_to_ptr v196 : ptr<byte, i32>;
            v200 = hir.load v199 : i32;
            v386 = arith.constant 0 : i32;
            v184 = arith.constant 0 : i32;
            v202 = arith.eq v200, v184 : i1;
            v203 = arith.zext v202 : u32;
            v204 = hir.bitcast v203 : i32;
            v206 = arith.neq v204, v386 : i1;
            scf.if v206{
            ^block57:
                scf.yield ;
            } else {
            ^block32:
                v385 = arith.constant 4 : u32;
                v207 = hir.bitcast v189 : u32;
                v209 = arith.add v207, v385 : u32 #[overflow = checked];
                v384 = arith.constant 4 : u32;
                v211 = arith.mod v209, v384 : u32;
                hir.assertz v211 #[code = 250];
                v212 = hir.int_to_ptr v209 : ptr<byte, i32>;
                v213 = hir.load v212 : i32;
                v215 = arith.constant 12 : u32;
                v214 = hir.bitcast v189 : u32;
                v216 = arith.add v214, v215 : u32 #[overflow = checked];
                v383 = arith.constant 4 : u32;
                v218 = arith.mod v216, v383 : u32;
                hir.assertz v218 #[code = 250];
                v219 = hir.int_to_ptr v216 : ptr<byte, i32>;
                v220 = hir.load v219 : i32;
                hir.exec @root_ns:root@1.0.0/vec_alloc_vec/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v213, v200, v220)
                scf.yield ;
            };
            v382 = arith.constant 16 : i32;
            v223 = arith.add v189, v382 : i32 #[overflow = wrapping];
            v224 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v225 = hir.bitcast v224 : ptr<byte, i32>;
            hir.store v225, v223;
            builtin.ret ;
        };

        private builtin.function @<alloc::raw_vec::RawVecInner>::current_memory(v226: i32, v227: i32, v228: i32, v229: i32) {
        ^block33(v226: i32, v227: i32, v228: i32, v229: i32):
            v412 = arith.constant 0 : i32;
            v230 = arith.constant 0 : i32;
            v234 = arith.eq v229, v230 : i1;
            v235 = arith.zext v234 : u32;
            v236 = hir.bitcast v235 : i32;
            v238 = arith.neq v236, v412 : i1;
            v399, v400 = scf.if v238 : i32, i32 {
            ^block60:
                v411 = arith.constant 0 : i32;
                v232 = arith.constant 4 : i32;
                scf.yield v232, v411;
            } else {
            ^block36:
                v239 = hir.bitcast v227 : u32;
                v274 = arith.constant 4 : u32;
                v241 = arith.mod v239, v274 : u32;
                hir.assertz v241 #[code = 250];
                v242 = hir.int_to_ptr v239 : ptr<byte, i32>;
                v243 = hir.load v242 : i32;
                v409 = arith.constant 0 : i32;
                v410 = arith.constant 0 : i32;
                v245 = arith.eq v243, v410 : i1;
                v246 = arith.zext v245 : u32;
                v247 = hir.bitcast v246 : i32;
                v249 = arith.neq v247, v409 : i1;
                v397 = scf.if v249 : i32 {
                ^block59:
                    v408 = arith.constant 0 : i32;
                    scf.yield v408;
                } else {
                ^block37:
                    v407 = arith.constant 4 : u32;
                    v250 = hir.bitcast v226 : u32;
                    v252 = arith.add v250, v407 : u32 #[overflow = checked];
                    v406 = arith.constant 4 : u32;
                    v254 = arith.mod v252, v406 : u32;
                    hir.assertz v254 #[code = 250];
                    v255 = hir.int_to_ptr v252 : ptr<byte, i32>;
                    hir.store v255, v228;
                    v405 = arith.constant 4 : u32;
                    v256 = hir.bitcast v227 : u32;
                    v258 = arith.add v256, v405 : u32 #[overflow = checked];
                    v404 = arith.constant 4 : u32;
                    v260 = arith.mod v258, v404 : u32;
                    hir.assertz v260 #[code = 250];
                    v261 = hir.int_to_ptr v258 : ptr<byte, i32>;
                    v262 = hir.load v261 : i32;
                    v263 = hir.bitcast v226 : u32;
                    v403 = arith.constant 4 : u32;
                    v265 = arith.mod v263, v403 : u32;
                    hir.assertz v265 #[code = 250];
                    v266 = hir.int_to_ptr v263 : ptr<byte, i32>;
                    hir.store v266, v262;
                    v267 = arith.mul v243, v229 : i32 #[overflow = wrapping];
                    scf.yield v267;
                };
                v268 = arith.constant 8 : i32;
                v402 = arith.constant 4 : i32;
                v398 = cf.select v249, v402, v268 : i32;
                scf.yield v398, v397;
            };
            v271 = arith.add v226, v399 : i32 #[overflow = wrapping];
            v273 = hir.bitcast v271 : u32;
            v401 = arith.constant 4 : u32;
            v275 = arith.mod v273, v401 : u32;
            hir.assertz v275 #[code = 250];
            v276 = hir.int_to_ptr v273 : ptr<byte, i32>;
            hir.store v276, v400;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v277: i32, v278: i32, v279: i32) {
        ^block38(v277: i32, v278: i32, v279: i32):
            v414 = arith.constant 0 : i32;
            v280 = arith.constant 0 : i32;
            v281 = arith.eq v279, v280 : i1;
            v282 = arith.zext v281 : u32;
            v283 = hir.bitcast v282 : i32;
            v285 = arith.neq v283, v414 : i1;
            scf.if v285{
            ^block40:
                scf.yield ;
            } else {
            ^block41:
                hir.exec @root_ns:root@1.0.0/vec_alloc_vec/__rustc::__rust_dealloc(v277, v279, v278)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @<core::ptr::alignment::Alignment>::max(v286: i32, v287: i32) -> i32 {
        ^block42(v286: i32, v287: i32):
            v294 = arith.constant 0 : i32;
            v290 = hir.bitcast v287 : u32;
            v289 = hir.bitcast v286 : u32;
            v291 = arith.gt v289, v290 : i1;
            v292 = arith.zext v291 : u32;
            v293 = hir.bitcast v292 : i32;
            v295 = arith.neq v293, v294 : i1;
            v296 = cf.select v295, v286, v287 : i32;
            builtin.ret v296;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};