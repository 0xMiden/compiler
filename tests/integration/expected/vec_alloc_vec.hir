builtin.component root_ns:root@1.0.0 {
    builtin.module public @vec_alloc_vec {
        public builtin.function @entrypoint(v0: felt) -> felt {
        ^block6(v0: felt):
            v3 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v4 = hir.bitcast v3 : ptr<byte, i32>;
            v5 = hir.load v4 : i32;
            v6 = arith.constant 16 : i32;
            v7 = arith.sub v5, v6 : i32 #[overflow = wrapping];
            v8 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v9 = hir.bitcast v8 : ptr<byte, i32>;
            hir.store v9, v7;
            hir.exec @root_ns:root@1.0.0/vec_alloc_vec/__rustc::__rust_no_alloc_shim_is_unstable_v2()
            v11 = arith.constant 4 : i32;
            v10 = arith.constant 8 : i32;
            v12 = hir.exec @root_ns:root@1.0.0/vec_alloc_vec/__rustc::__rust_alloc(v10, v11) : i32
            v2 = arith.constant 0 : i32;
            v14 = arith.neq v12, v2 : i1;
            cf.cond_br v14 ^block8, ^block9;
        ^block8:
            v18 = arith.constant 4 : u32;
            v17 = hir.bitcast v12 : u32;
            v19 = arith.add v17, v18 : u32 #[overflow = checked];
            v281 = arith.constant 4 : u32;
            v21 = arith.mod v19, v281 : u32;
            hir.assertz v21 #[code = 250];
            v22 = hir.int_to_ptr v19 : ptr<byte, felt>;
            hir.store v22, v0;
            v23 = hir.bitcast v12 : u32;
            v280 = arith.constant 4 : u32;
            v25 = arith.mod v23, v280 : u32;
            hir.assertz v25 #[code = 250];
            v26 = hir.int_to_ptr v23 : ptr<byte, felt>;
            hir.store v26, v0;
            v29 = arith.constant 12 : u32;
            v28 = hir.bitcast v7 : u32;
            v30 = arith.add v28, v29 : u32 #[overflow = checked];
            v279 = arith.constant 4 : u32;
            v32 = arith.mod v30, v279 : u32;
            hir.assertz v32 #[code = 250];
            v27 = arith.constant 2 : i32;
            v33 = hir.int_to_ptr v30 : ptr<byte, i32>;
            hir.store v33, v27;
            v35 = arith.constant 8 : u32;
            v34 = hir.bitcast v7 : u32;
            v36 = arith.add v34, v35 : u32 #[overflow = checked];
            v278 = arith.constant 4 : u32;
            v38 = arith.mod v36, v278 : u32;
            hir.assertz v38 #[code = 250];
            v39 = hir.int_to_ptr v36 : ptr<byte, i32>;
            hir.store v39, v12;
            v277 = arith.constant 4 : u32;
            v41 = hir.bitcast v7 : u32;
            v43 = arith.add v41, v277 : u32 #[overflow = checked];
            v276 = arith.constant 4 : u32;
            v45 = arith.mod v43, v276 : u32;
            hir.assertz v45 #[code = 250];
            v275 = arith.constant 2 : i32;
            v46 = hir.int_to_ptr v43 : ptr<byte, i32>;
            hir.store v46, v275;
            v267 = arith.constant 1048576 : felt;
            v47 = hir.bitcast v12 : felt;
            hir.assert_eq v47, v267;
            v273 = arith.constant 4 : i32;
            v274 = arith.constant 4 : i32;
            v53 = arith.add v7, v274 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/vec_alloc_vec/alloc::raw_vec::RawVecInner<A>::deallocate(v53, v273, v273)
            v272 = arith.constant 16 : i32;
            v57 = arith.add v7, v272 : i32 #[overflow = wrapping];
            v58 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v59 = hir.bitcast v58 : ptr<byte, i32>;
            hir.store v59, v57;
            v266 = arith.constant 0 : felt;
            builtin.ret v266;
        ^block9:
            v270 = arith.constant 8 : i32;
            v271 = arith.constant 4 : i32;
            hir.exec @root_ns:root@1.0.0/vec_alloc_vec/alloc::alloc::handle_alloc_error(v271, v270)
            ub.unreachable ;
        };

        private builtin.function @__rustc::__rust_alloc(v60: i32, v61: i32) -> i32 {
        ^block10(v60: i32, v61: i32):
            v63 = arith.constant 1048576 : i32;
            v64 = hir.exec @root_ns:root@1.0.0/vec_alloc_vec/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v63, v61, v60) : i32
            builtin.ret v64;
        };

        private builtin.function @__rustc::__rust_dealloc(v65: i32, v66: i32, v67: i32) {
        ^block12(v65: i32, v66: i32, v67: i32):
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block14:
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v68: i32, v69: i32, v70: i32) -> i32 {
        ^block16(v68: i32, v69: i32, v70: i32):
            v73 = arith.constant 16 : i32;
            v72 = arith.constant 0 : i32;
            v283 = arith.constant 16 : u32;
            v75 = hir.bitcast v69 : u32;
            v77 = arith.gt v75, v283 : i1;
            v78 = arith.zext v77 : u32;
            v79 = hir.bitcast v78 : i32;
            v81 = arith.neq v79, v72 : i1;
            v82 = cf.select v81, v69, v73 : i32;
            v322 = arith.constant 0 : i32;
            v83 = arith.constant -1 : i32;
            v84 = arith.add v82, v83 : i32 #[overflow = wrapping];
            v85 = arith.band v82, v84 : i32;
            v87 = arith.neq v85, v322 : i1;
            v292, v293 = scf.if v87 : i32, u32 {
            ^block46:
                v284 = arith.constant 0 : u32;
                v288 = ub.poison i32 : i32;
                scf.yield v288, v284;
            } else {
            ^block19:
                v89 = hir.exec @root_ns:root@1.0.0/vec_alloc_vec/core::ptr::alignment::Alignment::max(v69, v82) : i32
                v321 = arith.constant 0 : i32;
                v88 = arith.constant -2147483648 : i32;
                v90 = arith.sub v88, v89 : i32 #[overflow = wrapping];
                v92 = hir.bitcast v90 : u32;
                v91 = hir.bitcast v70 : u32;
                v93 = arith.gt v91, v92 : i1;
                v94 = arith.zext v93 : u32;
                v95 = hir.bitcast v94 : i32;
                v97 = arith.neq v95, v321 : i1;
                v307 = scf.if v97 : i32 {
                ^block45:
                    v320 = ub.poison i32 : i32;
                    scf.yield v320;
                } else {
                ^block20:
                    v318 = arith.constant 0 : i32;
                    v103 = arith.sub v318, v89 : i32 #[overflow = wrapping];
                    v319 = arith.constant -1 : i32;
                    v99 = arith.add v70, v89 : i32 #[overflow = wrapping];
                    v101 = arith.add v99, v319 : i32 #[overflow = wrapping];
                    v104 = arith.band v101, v103 : i32;
                    v105 = hir.bitcast v68 : u32;
                    v106 = arith.constant 4 : u32;
                    v107 = arith.mod v105, v106 : u32;
                    hir.assertz v107 #[code = 250];
                    v108 = hir.int_to_ptr v105 : ptr<byte, i32>;
                    v109 = hir.load v108 : i32;
                    v317 = arith.constant 0 : i32;
                    v111 = arith.neq v109, v317 : i1;
                    scf.if v111{
                    ^block44:
                        scf.yield ;
                    } else {
                    ^block22:
                        v112 = hir.exec @intrinsics/mem/heap_base() : i32
                        v113 = hir.mem_size  : u32;
                        v119 = hir.bitcast v68 : u32;
                        v316 = arith.constant 4 : u32;
                        v121 = arith.mod v119, v316 : u32;
                        hir.assertz v121 #[code = 250];
                        v315 = arith.constant 16 : u32;
                        v114 = hir.bitcast v113 : i32;
                        v117 = arith.shl v114, v315 : i32;
                        v118 = arith.add v112, v117 : i32 #[overflow = wrapping];
                        v122 = hir.int_to_ptr v119 : ptr<byte, i32>;
                        hir.store v122, v118;
                        scf.yield ;
                    };
                    v125 = hir.bitcast v68 : u32;
                    v314 = arith.constant 4 : u32;
                    v127 = arith.mod v125, v314 : u32;
                    hir.assertz v127 #[code = 250];
                    v128 = hir.int_to_ptr v125 : ptr<byte, i32>;
                    v129 = hir.load v128 : i32;
                    v313 = arith.constant 0 : i32;
                    v133 = hir.bitcast v104 : u32;
                    v123 = arith.constant 268435456 : i32;
                    v130 = arith.sub v123, v129 : i32 #[overflow = wrapping];
                    v132 = hir.bitcast v130 : u32;
                    v134 = arith.lt v132, v133 : i1;
                    v135 = arith.zext v134 : u32;
                    v136 = hir.bitcast v135 : i32;
                    v138 = arith.neq v136, v313 : i1;
                    v306 = scf.if v138 : i32 {
                    ^block23:
                        v312 = arith.constant 0 : i32;
                        scf.yield v312;
                    } else {
                    ^block24:
                        v140 = hir.bitcast v68 : u32;
                        v311 = arith.constant 4 : u32;
                        v142 = arith.mod v140, v311 : u32;
                        hir.assertz v142 #[code = 250];
                        v139 = arith.add v129, v104 : i32 #[overflow = wrapping];
                        v143 = hir.int_to_ptr v140 : ptr<byte, i32>;
                        hir.store v143, v139;
                        v145 = arith.add v129, v89 : i32 #[overflow = wrapping];
                        scf.yield v145;
                    };
                    scf.yield v306;
                };
                v289 = arith.constant 1 : u32;
                v310 = arith.constant 0 : u32;
                v308 = cf.select v97, v310, v289 : u32;
                scf.yield v307, v308;
            };
            v309 = arith.constant 0 : u32;
            v305 = arith.eq v293, v309 : i1;
            cf.cond_br v305 ^block18, ^block48(v292);
        ^block18:
            ub.unreachable ;
        ^block48(v285: i32):
            builtin.ret v285;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v148: i32, v149: i32, v150: i32) {
        ^block25(v148: i32, v149: i32, v150: i32):
            v152 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v153 = hir.bitcast v152 : ptr<byte, i32>;
            v154 = hir.load v153 : i32;
            v155 = arith.constant 16 : i32;
            v156 = arith.sub v154, v155 : i32 #[overflow = wrapping];
            v157 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v158 = hir.bitcast v157 : ptr<byte, i32>;
            hir.store v158, v156;
            v159 = arith.constant 4 : i32;
            v160 = arith.add v156, v159 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/vec_alloc_vec/alloc::raw_vec::RawVecInner<A>::current_memory(v160, v148, v149, v150)
            v162 = arith.constant 8 : u32;
            v161 = hir.bitcast v156 : u32;
            v163 = arith.add v161, v162 : u32 #[overflow = checked];
            v164 = arith.constant 4 : u32;
            v165 = arith.mod v163, v164 : u32;
            hir.assertz v165 #[code = 250];
            v166 = hir.int_to_ptr v163 : ptr<byte, i32>;
            v167 = hir.load v166 : i32;
            v329 = arith.constant 0 : i32;
            v151 = arith.constant 0 : i32;
            v169 = arith.eq v167, v151 : i1;
            v170 = arith.zext v169 : u32;
            v171 = hir.bitcast v170 : i32;
            v173 = arith.neq v171, v329 : i1;
            scf.if v173{
            ^block52:
                scf.yield ;
            } else {
            ^block28:
                v328 = arith.constant 4 : u32;
                v174 = hir.bitcast v156 : u32;
                v176 = arith.add v174, v328 : u32 #[overflow = checked];
                v327 = arith.constant 4 : u32;
                v178 = arith.mod v176, v327 : u32;
                hir.assertz v178 #[code = 250];
                v179 = hir.int_to_ptr v176 : ptr<byte, i32>;
                v180 = hir.load v179 : i32;
                v182 = arith.constant 12 : u32;
                v181 = hir.bitcast v156 : u32;
                v183 = arith.add v181, v182 : u32 #[overflow = checked];
                v326 = arith.constant 4 : u32;
                v185 = arith.mod v183, v326 : u32;
                hir.assertz v185 #[code = 250];
                v186 = hir.int_to_ptr v183 : ptr<byte, i32>;
                v187 = hir.load v186 : i32;
                hir.exec @root_ns:root@1.0.0/vec_alloc_vec/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v180, v167, v187)
                scf.yield ;
            };
            v325 = arith.constant 16 : i32;
            v190 = arith.add v156, v325 : i32 #[overflow = wrapping];
            v191 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v192 = hir.bitcast v191 : ptr<byte, i32>;
            hir.store v192, v190;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v193: i32, v194: i32, v195: i32, v196: i32) {
        ^block29(v193: i32, v194: i32, v195: i32, v196: i32):
            v355 = arith.constant 0 : i32;
            v197 = arith.constant 0 : i32;
            v201 = arith.eq v196, v197 : i1;
            v202 = arith.zext v201 : u32;
            v203 = hir.bitcast v202 : i32;
            v205 = arith.neq v203, v355 : i1;
            v342, v343 = scf.if v205 : i32, i32 {
            ^block55:
                v354 = arith.constant 0 : i32;
                v199 = arith.constant 4 : i32;
                scf.yield v199, v354;
            } else {
            ^block32:
                v206 = hir.bitcast v194 : u32;
                v241 = arith.constant 4 : u32;
                v208 = arith.mod v206, v241 : u32;
                hir.assertz v208 #[code = 250];
                v209 = hir.int_to_ptr v206 : ptr<byte, i32>;
                v210 = hir.load v209 : i32;
                v352 = arith.constant 0 : i32;
                v353 = arith.constant 0 : i32;
                v212 = arith.eq v210, v353 : i1;
                v213 = arith.zext v212 : u32;
                v214 = hir.bitcast v213 : i32;
                v216 = arith.neq v214, v352 : i1;
                v340 = scf.if v216 : i32 {
                ^block54:
                    v351 = arith.constant 0 : i32;
                    scf.yield v351;
                } else {
                ^block33:
                    v350 = arith.constant 4 : u32;
                    v217 = hir.bitcast v193 : u32;
                    v219 = arith.add v217, v350 : u32 #[overflow = checked];
                    v349 = arith.constant 4 : u32;
                    v221 = arith.mod v219, v349 : u32;
                    hir.assertz v221 #[code = 250];
                    v222 = hir.int_to_ptr v219 : ptr<byte, i32>;
                    hir.store v222, v195;
                    v348 = arith.constant 4 : u32;
                    v223 = hir.bitcast v194 : u32;
                    v225 = arith.add v223, v348 : u32 #[overflow = checked];
                    v347 = arith.constant 4 : u32;
                    v227 = arith.mod v225, v347 : u32;
                    hir.assertz v227 #[code = 250];
                    v228 = hir.int_to_ptr v225 : ptr<byte, i32>;
                    v229 = hir.load v228 : i32;
                    v230 = hir.bitcast v193 : u32;
                    v346 = arith.constant 4 : u32;
                    v232 = arith.mod v230, v346 : u32;
                    hir.assertz v232 #[code = 250];
                    v233 = hir.int_to_ptr v230 : ptr<byte, i32>;
                    hir.store v233, v229;
                    v234 = arith.mul v210, v196 : i32 #[overflow = wrapping];
                    scf.yield v234;
                };
                v235 = arith.constant 8 : i32;
                v345 = arith.constant 4 : i32;
                v341 = cf.select v216, v345, v235 : i32;
                scf.yield v341, v340;
            };
            v238 = arith.add v193, v342 : i32 #[overflow = wrapping];
            v240 = hir.bitcast v238 : u32;
            v344 = arith.constant 4 : u32;
            v242 = arith.mod v240, v344 : u32;
            hir.assertz v242 #[code = 250];
            v243 = hir.int_to_ptr v240 : ptr<byte, i32>;
            hir.store v243, v343;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v244: i32, v245: i32, v246: i32) {
        ^block34(v244: i32, v245: i32, v246: i32):
            v357 = arith.constant 0 : i32;
            v247 = arith.constant 0 : i32;
            v248 = arith.eq v246, v247 : i1;
            v249 = arith.zext v248 : u32;
            v250 = hir.bitcast v249 : i32;
            v252 = arith.neq v250, v357 : i1;
            scf.if v252{
            ^block36:
                scf.yield ;
            } else {
            ^block37:
                hir.exec @root_ns:root@1.0.0/vec_alloc_vec/__rustc::__rust_dealloc(v244, v246, v245)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::handle_alloc_error(v253: i32, v254: i32) {
        ^block38(v253: i32, v254: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v255: i32, v256: i32) -> i32 {
        ^block40(v255: i32, v256: i32):
            v263 = arith.constant 0 : i32;
            v259 = hir.bitcast v256 : u32;
            v258 = hir.bitcast v255 : u32;
            v260 = arith.gt v258, v259 : i1;
            v261 = arith.zext v260 : u32;
            v262 = hir.bitcast v261 : i32;
            v264 = arith.neq v262, v263 : i1;
            v265 = cf.select v264, v255, v256 : i32;
            builtin.ret v265;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};