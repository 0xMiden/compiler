builtin.component root_ns:root@1.0.0 {
    builtin.module public @vec_alloc_vec {
        public builtin.function @entrypoint(v0: i32) -> felt {
        ^block6(v0: i32):
            v4 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v5 = hir.bitcast v4 : ptr<byte, i32>;
            v6 = hir.load v5 : i32;
            v7 = arith.constant 16 : i32;
            v8 = arith.sub v6, v7 : i32 #[overflow = wrapping];
            v9 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v10 = hir.bitcast v9 : ptr<byte, i32>;
            hir.store v10, v8;
            hir.exec @root_ns:root@1.0.0/vec_alloc_vec/__rustc::__rust_no_alloc_shim_is_unstable_v2()
            v12 = arith.constant 4 : i32;
            v11 = arith.constant 12 : i32;
            v13 = hir.exec @root_ns:root@1.0.0/vec_alloc_vec/__rustc::__rust_alloc(v11, v12) : i32
            v335 = arith.constant 0 : i32;
            v2 = arith.constant 0 : i32;
            v15 = arith.eq v13, v2 : i1;
            v16 = arith.zext v15 : u32;
            v17 = hir.bitcast v16 : i32;
            v19 = arith.neq v17, v335 : i1;
            v308, v309 = scf.if v19 : felt, u32 {
            ^block9:
                v333 = arith.constant 12 : i32;
                v334 = arith.constant 4 : i32;
                hir.exec @root_ns:root@1.0.0/vec_alloc_vec/alloc::alloc::handle_alloc_error(v334, v333)
                v300 = arith.constant 0 : u32;
                v304 = ub.poison felt : felt;
                scf.yield v304, v300;
            } else {
            ^block10:
                v27 = arith.constant 8 : u32;
                v26 = hir.bitcast v13 : u32;
                v28 = arith.add v26, v27 : u32 #[overflow = checked];
                v29 = arith.constant 4 : u32;
                v30 = arith.mod v28, v29 : u32;
                hir.assertz v30 #[code = 250];
                v297 = arith.constant 3 : felt;
                v31 = hir.int_to_ptr v28 : ptr<byte, felt>;
                hir.store v31, v297;
                v332 = arith.constant 4 : u32;
                v32 = hir.bitcast v13 : u32;
                v34 = arith.add v32, v332 : u32 #[overflow = checked];
                v331 = arith.constant 4 : u32;
                v36 = arith.mod v34, v331 : u32;
                hir.assertz v36 #[code = 250];
                v298 = arith.constant 2 : felt;
                v37 = hir.int_to_ptr v34 : ptr<byte, felt>;
                hir.store v37, v298;
                v38 = hir.bitcast v13 : u32;
                v330 = arith.constant 4 : u32;
                v40 = arith.mod v38, v330 : u32;
                hir.assertz v40 #[code = 250];
                v299 = arith.constant 1 : felt;
                v41 = hir.int_to_ptr v38 : ptr<byte, felt>;
                hir.store v41, v299;
                v44 = arith.constant 12 : u32;
                v43 = hir.bitcast v8 : u32;
                v45 = arith.add v43, v44 : u32 #[overflow = checked];
                v329 = arith.constant 4 : u32;
                v47 = arith.mod v45, v329 : u32;
                hir.assertz v47 #[code = 250];
                v24 = arith.constant 3 : i32;
                v48 = hir.int_to_ptr v45 : ptr<byte, i32>;
                hir.store v48, v24;
                v328 = arith.constant 8 : u32;
                v49 = hir.bitcast v8 : u32;
                v51 = arith.add v49, v328 : u32 #[overflow = checked];
                v327 = arith.constant 4 : u32;
                v53 = arith.mod v51, v327 : u32;
                hir.assertz v53 #[code = 250];
                v54 = hir.int_to_ptr v51 : ptr<byte, i32>;
                hir.store v54, v13;
                v326 = arith.constant 4 : u32;
                v56 = hir.bitcast v8 : u32;
                v58 = arith.add v56, v326 : u32 #[overflow = checked];
                v325 = arith.constant 4 : u32;
                v60 = arith.mod v58, v325 : u32;
                hir.assertz v60 #[code = 250];
                v324 = arith.constant 3 : i32;
                v61 = hir.int_to_ptr v58 : ptr<byte, i32>;
                hir.store v61, v324;
                v323 = arith.constant 0 : i32;
                v296 = arith.constant 3 : u32;
                v63 = hir.bitcast v0 : u32;
                v65 = arith.gte v63, v296 : i1;
                v66 = arith.zext v65 : u32;
                v67 = hir.bitcast v66 : i32;
                v69 = arith.neq v67, v323 : i1;
                v314 = scf.if v69 : felt {
                ^block44:
                    v322 = ub.poison felt : felt;
                    scf.yield v322;
                } else {
                ^block11:
                    v295 = arith.constant 2 : u32;
                    v72 = arith.shl v0, v295 : i32;
                    v73 = arith.add v13, v72 : i32 #[overflow = wrapping];
                    v74 = hir.bitcast v73 : u32;
                    v321 = arith.constant 4 : u32;
                    v76 = arith.mod v74, v321 : u32;
                    hir.assertz v76 #[code = 250];
                    v77 = hir.int_to_ptr v74 : ptr<byte, felt>;
                    v78 = hir.load v77 : felt;
                    v319 = arith.constant 4 : i32;
                    v320 = arith.constant 4 : i32;
                    v80 = arith.add v8, v320 : i32 #[overflow = wrapping];
                    hir.exec @root_ns:root@1.0.0/vec_alloc_vec/alloc::raw_vec::RawVecInner<A>::deallocate(v80, v319, v319)
                    v318 = arith.constant 16 : i32;
                    v84 = arith.add v8, v318 : i32 #[overflow = wrapping];
                    v85 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
                    v86 = hir.bitcast v85 : ptr<byte, i32>;
                    hir.store v86, v84;
                    scf.yield v78;
                };
                v305 = arith.constant 1 : u32;
                v317 = arith.constant 0 : u32;
                v315 = cf.select v69, v317, v305 : u32;
                scf.yield v314, v315;
            };
            v316 = arith.constant 0 : u32;
            v313 = arith.eq v309, v316 : i1;
            cf.cond_br v313 ^block8, ^block46(v308);
        ^block8:
            ub.unreachable ;
        ^block46(v301: felt):
            builtin.ret v301;
        };

        private builtin.function @__rustc::__rust_alloc(v89: i32, v90: i32) -> i32 {
        ^block12(v89: i32, v90: i32):
            v92 = arith.constant 1048576 : i32;
            v93 = hir.exec @root_ns:root@1.0.0/vec_alloc_vec/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v92, v90, v89) : i32
            builtin.ret v93;
        };

        private builtin.function @__rustc::__rust_dealloc(v94: i32, v95: i32, v96: i32) {
        ^block14(v94: i32, v95: i32, v96: i32):
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block16:
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v97: i32, v98: i32, v99: i32) -> i32 {
        ^block18(v97: i32, v98: i32, v99: i32):
            v102 = arith.constant 16 : i32;
            v101 = arith.constant 0 : i32;
            v337 = arith.constant 16 : u32;
            v104 = hir.bitcast v98 : u32;
            v106 = arith.gt v104, v337 : i1;
            v107 = arith.zext v106 : u32;
            v108 = hir.bitcast v107 : i32;
            v110 = arith.neq v108, v101 : i1;
            v111 = cf.select v110, v98, v102 : i32;
            v376 = arith.constant 0 : i32;
            v112 = arith.constant -1 : i32;
            v113 = arith.add v111, v112 : i32 #[overflow = wrapping];
            v114 = arith.band v111, v113 : i32;
            v116 = arith.neq v114, v376 : i1;
            v346, v347 = scf.if v116 : i32, u32 {
            ^block51:
                v338 = arith.constant 0 : u32;
                v342 = ub.poison i32 : i32;
                scf.yield v342, v338;
            } else {
            ^block21:
                v118 = hir.exec @root_ns:root@1.0.0/vec_alloc_vec/core::ptr::alignment::Alignment::max(v98, v111) : i32
                v375 = arith.constant 0 : i32;
                v117 = arith.constant -2147483648 : i32;
                v119 = arith.sub v117, v118 : i32 #[overflow = wrapping];
                v121 = hir.bitcast v119 : u32;
                v120 = hir.bitcast v99 : u32;
                v122 = arith.gt v120, v121 : i1;
                v123 = arith.zext v122 : u32;
                v124 = hir.bitcast v123 : i32;
                v126 = arith.neq v124, v375 : i1;
                v361 = scf.if v126 : i32 {
                ^block50:
                    v374 = ub.poison i32 : i32;
                    scf.yield v374;
                } else {
                ^block22:
                    v372 = arith.constant 0 : i32;
                    v132 = arith.sub v372, v118 : i32 #[overflow = wrapping];
                    v373 = arith.constant -1 : i32;
                    v128 = arith.add v99, v118 : i32 #[overflow = wrapping];
                    v130 = arith.add v128, v373 : i32 #[overflow = wrapping];
                    v133 = arith.band v130, v132 : i32;
                    v134 = hir.bitcast v97 : u32;
                    v135 = arith.constant 4 : u32;
                    v136 = arith.mod v134, v135 : u32;
                    hir.assertz v136 #[code = 250];
                    v137 = hir.int_to_ptr v134 : ptr<byte, i32>;
                    v138 = hir.load v137 : i32;
                    v371 = arith.constant 0 : i32;
                    v140 = arith.neq v138, v371 : i1;
                    scf.if v140{
                    ^block49:
                        scf.yield ;
                    } else {
                    ^block24:
                        v141 = hir.exec @intrinsics/mem/heap_base() : i32
                        v142 = hir.mem_size  : u32;
                        v148 = hir.bitcast v97 : u32;
                        v370 = arith.constant 4 : u32;
                        v150 = arith.mod v148, v370 : u32;
                        hir.assertz v150 #[code = 250];
                        v369 = arith.constant 16 : u32;
                        v143 = hir.bitcast v142 : i32;
                        v146 = arith.shl v143, v369 : i32;
                        v147 = arith.add v141, v146 : i32 #[overflow = wrapping];
                        v151 = hir.int_to_ptr v148 : ptr<byte, i32>;
                        hir.store v151, v147;
                        scf.yield ;
                    };
                    v154 = hir.bitcast v97 : u32;
                    v368 = arith.constant 4 : u32;
                    v156 = arith.mod v154, v368 : u32;
                    hir.assertz v156 #[code = 250];
                    v157 = hir.int_to_ptr v154 : ptr<byte, i32>;
                    v158 = hir.load v157 : i32;
                    v367 = arith.constant 0 : i32;
                    v162 = hir.bitcast v133 : u32;
                    v152 = arith.constant -2 : i32;
                    v159 = arith.sub v152, v158 : i32 #[overflow = wrapping];
                    v161 = hir.bitcast v159 : u32;
                    v163 = arith.lt v161, v162 : i1;
                    v164 = arith.zext v163 : u32;
                    v165 = hir.bitcast v164 : i32;
                    v167 = arith.neq v165, v367 : i1;
                    v360 = scf.if v167 : i32 {
                    ^block25:
                        v366 = arith.constant 0 : i32;
                        scf.yield v366;
                    } else {
                    ^block26:
                        v169 = hir.bitcast v97 : u32;
                        v365 = arith.constant 4 : u32;
                        v171 = arith.mod v169, v365 : u32;
                        hir.assertz v171 #[code = 250];
                        v168 = arith.add v158, v133 : i32 #[overflow = wrapping];
                        v172 = hir.int_to_ptr v169 : ptr<byte, i32>;
                        hir.store v172, v168;
                        v174 = arith.add v158, v118 : i32 #[overflow = wrapping];
                        scf.yield v174;
                    };
                    scf.yield v360;
                };
                v343 = arith.constant 1 : u32;
                v364 = arith.constant 0 : u32;
                v362 = cf.select v126, v364, v343 : u32;
                scf.yield v361, v362;
            };
            v363 = arith.constant 0 : u32;
            v359 = arith.eq v347, v363 : i1;
            cf.cond_br v359 ^block20, ^block53(v346);
        ^block20:
            ub.unreachable ;
        ^block53(v339: i32):
            builtin.ret v339;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v177: i32, v178: i32, v179: i32) {
        ^block27(v177: i32, v178: i32, v179: i32):
            v181 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v182 = hir.bitcast v181 : ptr<byte, i32>;
            v183 = hir.load v182 : i32;
            v184 = arith.constant 16 : i32;
            v185 = arith.sub v183, v184 : i32 #[overflow = wrapping];
            v186 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v187 = hir.bitcast v186 : ptr<byte, i32>;
            hir.store v187, v185;
            v188 = arith.constant 4 : i32;
            v189 = arith.add v185, v188 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/vec_alloc_vec/alloc::raw_vec::RawVecInner<A>::current_memory(v189, v177, v178, v179)
            v191 = arith.constant 8 : u32;
            v190 = hir.bitcast v185 : u32;
            v192 = arith.add v190, v191 : u32 #[overflow = checked];
            v193 = arith.constant 4 : u32;
            v194 = arith.mod v192, v193 : u32;
            hir.assertz v194 #[code = 250];
            v195 = hir.int_to_ptr v192 : ptr<byte, i32>;
            v196 = hir.load v195 : i32;
            v383 = arith.constant 0 : i32;
            v180 = arith.constant 0 : i32;
            v198 = arith.eq v196, v180 : i1;
            v199 = arith.zext v198 : u32;
            v200 = hir.bitcast v199 : i32;
            v202 = arith.neq v200, v383 : i1;
            scf.if v202{
            ^block57:
                scf.yield ;
            } else {
            ^block30:
                v382 = arith.constant 4 : u32;
                v203 = hir.bitcast v185 : u32;
                v205 = arith.add v203, v382 : u32 #[overflow = checked];
                v381 = arith.constant 4 : u32;
                v207 = arith.mod v205, v381 : u32;
                hir.assertz v207 #[code = 250];
                v208 = hir.int_to_ptr v205 : ptr<byte, i32>;
                v209 = hir.load v208 : i32;
                v211 = arith.constant 12 : u32;
                v210 = hir.bitcast v185 : u32;
                v212 = arith.add v210, v211 : u32 #[overflow = checked];
                v380 = arith.constant 4 : u32;
                v214 = arith.mod v212, v380 : u32;
                hir.assertz v214 #[code = 250];
                v215 = hir.int_to_ptr v212 : ptr<byte, i32>;
                v216 = hir.load v215 : i32;
                hir.exec @root_ns:root@1.0.0/vec_alloc_vec/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v209, v196, v216)
                scf.yield ;
            };
            v379 = arith.constant 16 : i32;
            v219 = arith.add v185, v379 : i32 #[overflow = wrapping];
            v220 = builtin.global_symbol @root_ns:root@1.0.0/vec_alloc_vec/__stack_pointer : ptr<byte, u8>
            v221 = hir.bitcast v220 : ptr<byte, i32>;
            hir.store v221, v219;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v222: i32, v223: i32, v224: i32, v225: i32) {
        ^block31(v222: i32, v223: i32, v224: i32, v225: i32):
            v409 = arith.constant 0 : i32;
            v226 = arith.constant 0 : i32;
            v230 = arith.eq v225, v226 : i1;
            v231 = arith.zext v230 : u32;
            v232 = hir.bitcast v231 : i32;
            v234 = arith.neq v232, v409 : i1;
            v396, v397 = scf.if v234 : i32, i32 {
            ^block60:
                v408 = arith.constant 0 : i32;
                v228 = arith.constant 4 : i32;
                scf.yield v228, v408;
            } else {
            ^block34:
                v235 = hir.bitcast v223 : u32;
                v270 = arith.constant 4 : u32;
                v237 = arith.mod v235, v270 : u32;
                hir.assertz v237 #[code = 250];
                v238 = hir.int_to_ptr v235 : ptr<byte, i32>;
                v239 = hir.load v238 : i32;
                v406 = arith.constant 0 : i32;
                v407 = arith.constant 0 : i32;
                v241 = arith.eq v239, v407 : i1;
                v242 = arith.zext v241 : u32;
                v243 = hir.bitcast v242 : i32;
                v245 = arith.neq v243, v406 : i1;
                v394 = scf.if v245 : i32 {
                ^block59:
                    v405 = arith.constant 0 : i32;
                    scf.yield v405;
                } else {
                ^block35:
                    v404 = arith.constant 4 : u32;
                    v246 = hir.bitcast v222 : u32;
                    v248 = arith.add v246, v404 : u32 #[overflow = checked];
                    v403 = arith.constant 4 : u32;
                    v250 = arith.mod v248, v403 : u32;
                    hir.assertz v250 #[code = 250];
                    v251 = hir.int_to_ptr v248 : ptr<byte, i32>;
                    hir.store v251, v224;
                    v402 = arith.constant 4 : u32;
                    v252 = hir.bitcast v223 : u32;
                    v254 = arith.add v252, v402 : u32 #[overflow = checked];
                    v401 = arith.constant 4 : u32;
                    v256 = arith.mod v254, v401 : u32;
                    hir.assertz v256 #[code = 250];
                    v257 = hir.int_to_ptr v254 : ptr<byte, i32>;
                    v258 = hir.load v257 : i32;
                    v259 = hir.bitcast v222 : u32;
                    v400 = arith.constant 4 : u32;
                    v261 = arith.mod v259, v400 : u32;
                    hir.assertz v261 #[code = 250];
                    v262 = hir.int_to_ptr v259 : ptr<byte, i32>;
                    hir.store v262, v258;
                    v263 = arith.mul v239, v225 : i32 #[overflow = wrapping];
                    scf.yield v263;
                };
                v264 = arith.constant 8 : i32;
                v399 = arith.constant 4 : i32;
                v395 = cf.select v245, v399, v264 : i32;
                scf.yield v395, v394;
            };
            v267 = arith.add v222, v396 : i32 #[overflow = wrapping];
            v269 = hir.bitcast v267 : u32;
            v398 = arith.constant 4 : u32;
            v271 = arith.mod v269, v398 : u32;
            hir.assertz v271 #[code = 250];
            v272 = hir.int_to_ptr v269 : ptr<byte, i32>;
            hir.store v272, v397;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v273: i32, v274: i32, v275: i32) {
        ^block36(v273: i32, v274: i32, v275: i32):
            v411 = arith.constant 0 : i32;
            v276 = arith.constant 0 : i32;
            v277 = arith.eq v275, v276 : i1;
            v278 = arith.zext v277 : u32;
            v279 = hir.bitcast v278 : i32;
            v281 = arith.neq v279, v411 : i1;
            scf.if v281{
            ^block38:
                scf.yield ;
            } else {
            ^block39:
                hir.exec @root_ns:root@1.0.0/vec_alloc_vec/__rustc::__rust_dealloc(v273, v275, v274)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::handle_alloc_error(v282: i32, v283: i32) {
        ^block40(v282: i32, v283: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v284: i32, v285: i32) -> i32 {
        ^block42(v284: i32, v285: i32):
            v292 = arith.constant 0 : i32;
            v288 = hir.bitcast v285 : u32;
            v287 = hir.bitcast v284 : u32;
            v289 = arith.gt v287, v288 : i1;
            v290 = arith.zext v289 : u32;
            v291 = hir.bitcast v290 : i32;
            v293 = arith.neq v291, v292 : i1;
            v294 = cf.select v293, v284, v285 : i32;
            builtin.ret v294;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};