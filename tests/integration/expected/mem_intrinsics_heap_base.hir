builtin.component root_ns:root@1.0.0 {
    builtin.module public @mem_intrinsics_heap_base {
        public builtin.function @entrypoint(v0: i32, v1: i32) {
        ^block6(v0: i32, v1: i32):
            hir.exec @root_ns:root@1.0.0/mem_intrinsics_heap_base/__rustc::__rust_no_alloc_shim_is_unstable_v2()
            v3 = arith.constant 4 : i32;
            v5 = hir.exec @root_ns:root@1.0.0/mem_intrinsics_heap_base/__rustc::__rust_alloc(v3, v3) : i32
            v2 = arith.constant 0 : i32;
            v7 = arith.neq v5, v2 : i1;
            cf.cond_br v7 ^block8, ^block9;
        ^block8:
            v12 = arith.constant 8 : u32;
            v11 = hir.bitcast v0 : u32;
            v13 = arith.add v11, v12 : u32 #[overflow = checked];
            v14 = arith.constant 4 : u32;
            v15 = arith.mod v13, v14 : u32;
            hir.assertz v15 #[code = 250];
            v10 = arith.constant 1 : i32;
            v16 = hir.int_to_ptr v13 : ptr<byte, i32>;
            hir.store v16, v10;
            v140 = arith.constant 4 : u32;
            v17 = hir.bitcast v0 : u32;
            v19 = arith.add v17, v140 : u32 #[overflow = checked];
            v139 = arith.constant 4 : u32;
            v21 = arith.mod v19, v139 : u32;
            hir.assertz v21 #[code = 250];
            v22 = hir.int_to_ptr v19 : ptr<byte, i32>;
            hir.store v22, v5;
            v24 = hir.bitcast v0 : u32;
            v138 = arith.constant 4 : u32;
            v26 = arith.mod v24, v138 : u32;
            hir.assertz v26 #[code = 250];
            v137 = arith.constant 1 : i32;
            v27 = hir.int_to_ptr v24 : ptr<byte, i32>;
            hir.store v27, v137;
            v31 = hir.bitcast v5 : u32;
            v136 = arith.constant 4 : u32;
            v33 = arith.mod v31, v136 : u32;
            hir.assertz v33 #[code = 250];
            v133 = arith.constant 1 : u32;
            v30 = arith.shl v1, v133 : i32;
            v34 = hir.int_to_ptr v31 : ptr<byte, i32>;
            hir.store v34, v30;
            builtin.ret ;
        ^block9:
            v135 = arith.constant 4 : i32;
            hir.exec @root_ns:root@1.0.0/mem_intrinsics_heap_base/alloc::alloc::handle_alloc_error(v135, v135)
            ub.unreachable ;
        };

        private builtin.function @__rustc::__rust_alloc(v35: i32, v36: i32) -> i32 {
        ^block10(v35: i32, v36: i32):
            v38 = arith.constant 1048576 : i32;
            v39 = hir.exec @root_ns:root@1.0.0/mem_intrinsics_heap_base/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v38, v36, v35) : i32
            builtin.ret v39;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block12:
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v40: i32, v41: i32, v42: i32) -> i32 {
        ^block14(v40: i32, v41: i32, v42: i32):
            v45 = arith.constant 16 : i32;
            v44 = arith.constant 0 : i32;
            v142 = arith.constant 16 : u32;
            v47 = hir.bitcast v41 : u32;
            v49 = arith.gt v47, v142 : i1;
            v50 = arith.zext v49 : u32;
            v51 = hir.bitcast v50 : i32;
            v53 = arith.neq v51, v44 : i1;
            v54 = cf.select v53, v41, v45 : i32;
            v181 = arith.constant 0 : i32;
            v55 = arith.constant -1 : i32;
            v56 = arith.add v54, v55 : i32 #[overflow = wrapping];
            v57 = arith.band v54, v56 : i32;
            v59 = arith.neq v57, v181 : i1;
            v151, v152 = scf.if v59 : i32, u32 {
            ^block31:
                v143 = arith.constant 0 : u32;
                v147 = ub.poison i32 : i32;
                scf.yield v147, v143;
            } else {
            ^block17:
                v61 = hir.exec @root_ns:root@1.0.0/mem_intrinsics_heap_base/core::ptr::alignment::Alignment::max(v41, v54) : i32
                v180 = arith.constant 0 : i32;
                v60 = arith.constant -2147483648 : i32;
                v62 = arith.sub v60, v61 : i32 #[overflow = wrapping];
                v64 = hir.bitcast v62 : u32;
                v63 = hir.bitcast v42 : u32;
                v65 = arith.gt v63, v64 : i1;
                v66 = arith.zext v65 : u32;
                v67 = hir.bitcast v66 : i32;
                v69 = arith.neq v67, v180 : i1;
                v166 = scf.if v69 : i32 {
                ^block30:
                    v179 = ub.poison i32 : i32;
                    scf.yield v179;
                } else {
                ^block18:
                    v177 = arith.constant 0 : i32;
                    v75 = arith.sub v177, v61 : i32 #[overflow = wrapping];
                    v178 = arith.constant -1 : i32;
                    v71 = arith.add v42, v61 : i32 #[overflow = wrapping];
                    v73 = arith.add v71, v178 : i32 #[overflow = wrapping];
                    v76 = arith.band v73, v75 : i32;
                    v77 = hir.bitcast v40 : u32;
                    v78 = arith.constant 4 : u32;
                    v79 = arith.mod v77, v78 : u32;
                    hir.assertz v79 #[code = 250];
                    v80 = hir.int_to_ptr v77 : ptr<byte, i32>;
                    v81 = hir.load v80 : i32;
                    v176 = arith.constant 0 : i32;
                    v83 = arith.neq v81, v176 : i1;
                    scf.if v83{
                    ^block29:
                        scf.yield ;
                    } else {
                    ^block20:
                        v84 = hir.exec @intrinsics/mem/heap_base() : i32
                        v85 = hir.mem_size  : u32;
                        v91 = hir.bitcast v40 : u32;
                        v175 = arith.constant 4 : u32;
                        v93 = arith.mod v91, v175 : u32;
                        hir.assertz v93 #[code = 250];
                        v174 = arith.constant 16 : u32;
                        v86 = hir.bitcast v85 : i32;
                        v89 = arith.shl v86, v174 : i32;
                        v90 = arith.add v84, v89 : i32 #[overflow = wrapping];
                        v94 = hir.int_to_ptr v91 : ptr<byte, i32>;
                        hir.store v94, v90;
                        scf.yield ;
                    };
                    v97 = hir.bitcast v40 : u32;
                    v173 = arith.constant 4 : u32;
                    v99 = arith.mod v97, v173 : u32;
                    hir.assertz v99 #[code = 250];
                    v100 = hir.int_to_ptr v97 : ptr<byte, i32>;
                    v101 = hir.load v100 : i32;
                    v172 = arith.constant 0 : i32;
                    v105 = hir.bitcast v76 : u32;
                    v95 = arith.constant 268435456 : i32;
                    v102 = arith.sub v95, v101 : i32 #[overflow = wrapping];
                    v104 = hir.bitcast v102 : u32;
                    v106 = arith.lt v104, v105 : i1;
                    v107 = arith.zext v106 : u32;
                    v108 = hir.bitcast v107 : i32;
                    v110 = arith.neq v108, v172 : i1;
                    v165 = scf.if v110 : i32 {
                    ^block21:
                        v171 = arith.constant 0 : i32;
                        scf.yield v171;
                    } else {
                    ^block22:
                        v112 = hir.bitcast v40 : u32;
                        v170 = arith.constant 4 : u32;
                        v114 = arith.mod v112, v170 : u32;
                        hir.assertz v114 #[code = 250];
                        v111 = arith.add v101, v76 : i32 #[overflow = wrapping];
                        v115 = hir.int_to_ptr v112 : ptr<byte, i32>;
                        hir.store v115, v111;
                        v117 = arith.add v101, v61 : i32 #[overflow = wrapping];
                        scf.yield v117;
                    };
                    scf.yield v165;
                };
                v148 = arith.constant 1 : u32;
                v169 = arith.constant 0 : u32;
                v167 = cf.select v69, v169, v148 : u32;
                scf.yield v166, v167;
            };
            v168 = arith.constant 0 : u32;
            v164 = arith.eq v152, v168 : i1;
            cf.cond_br v164 ^block16, ^block33(v151);
        ^block16:
            ub.unreachable ;
        ^block33(v144: i32):
            builtin.ret v144;
        };

        private builtin.function @alloc::alloc::handle_alloc_error(v120: i32, v121: i32) {
        ^block23(v120: i32, v121: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v122: i32, v123: i32) -> i32 {
        ^block25(v122: i32, v123: i32):
            v130 = arith.constant 0 : i32;
            v126 = hir.bitcast v123 : u32;
            v125 = hir.bitcast v122 : u32;
            v127 = arith.gt v125, v126 : i1;
            v128 = arith.zext v127 : u32;
            v129 = hir.bitcast v128 : i32;
            v131 = arith.neq v129, v130 : i1;
            v132 = cf.select v131, v122, v123 : i32;
            builtin.ret v132;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};