builtin.component root_ns:root@1.0.0 {
    builtin.module public @abi_transform_tx_kernel_get_inputs_4 {
        private builtin.function @miden_base_sys::bindings::note::extern_note_get_inputs(v0: i32) -> i32 {
        ^block5(v0: i32):
            v1, v2 = hir.exec @miden/note/get_inputs(v0) : i32, i32
            builtin.ret v1;
        };

        public builtin.function @entrypoint() {
        ^block10:
            v5 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v6 = hir.bitcast v5 : ptr<byte, i32>;
            v7 = hir.load v6 : i32;
            v8 = arith.constant 16 : i32;
            v9 = arith.sub v7, v8 : i32 #[overflow = wrapping];
            v10 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v11 = hir.bitcast v10 : ptr<byte, i32>;
            hir.store v11, v9;
            v12 = arith.constant 4 : i32;
            v13 = arith.add v9, v12 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/miden_base_sys::bindings::note::get_inputs(v13)
            v15 = arith.constant 12 : u32;
            v14 = hir.bitcast v9 : u32;
            v16 = arith.add v14, v15 : u32 #[overflow = checked];
            v17 = arith.constant 4 : u32;
            v18 = arith.mod v16, v17 : u32;
            hir.assertz v18 #[code = 250];
            v19 = hir.int_to_ptr v16 : ptr<byte, i32>;
            v20 = hir.load v19 : i32;
            v664 = arith.constant 4 : felt;
            v21 = hir.bitcast v20 : felt;
            hir.assert_eq v21, v664;
            v696 = arith.constant 0 : i32;
            v4 = arith.constant 0 : i32;
            v25 = arith.eq v20, v4 : i1;
            v26 = arith.zext v25 : u32;
            v27 = hir.bitcast v26 : i32;
            v29 = arith.neq v27, v696 : i1;
            v669 = scf.if v29 : u32 {
            ^block83:
                v665 = arith.constant 0 : u32;
                scf.yield v665;
            } else {
            ^block13:
                v31 = arith.constant 8 : u32;
                v30 = hir.bitcast v9 : u32;
                v32 = arith.add v30, v31 : u32 #[overflow = checked];
                v695 = arith.constant 4 : u32;
                v34 = arith.mod v32, v695 : u32;
                hir.assertz v34 #[code = 250];
                v35 = hir.int_to_ptr v32 : ptr<byte, i32>;
                v36 = hir.load v35 : i32;
                v37 = hir.bitcast v36 : u32;
                v694 = arith.constant 4 : u32;
                v39 = arith.mod v37, v694 : u32;
                hir.assertz v39 #[code = 250];
                v40 = hir.int_to_ptr v37 : ptr<byte, felt>;
                v41 = hir.load v40 : felt;
                v42 = arith.constant -1 : i32;
                v43 = hir.bitcast v42 : felt;
                hir.assert_eq v41, v43;
                v693 = arith.constant 0 : i32;
                v44 = arith.constant 1 : i32;
                v45 = arith.eq v20, v44 : i1;
                v46 = arith.zext v45 : u32;
                v47 = hir.bitcast v46 : i32;
                v49 = arith.neq v47, v693 : i1;
                v671 = scf.if v49 : u32 {
                ^block82:
                    v692 = arith.constant 0 : u32;
                    scf.yield v692;
                } else {
                ^block14:
                    v691 = arith.constant 4 : u32;
                    v50 = hir.bitcast v36 : u32;
                    v52 = arith.add v50, v691 : u32 #[overflow = checked];
                    v690 = arith.constant 4 : u32;
                    v54 = arith.mod v52, v690 : u32;
                    hir.assertz v54 #[code = 250];
                    v55 = hir.int_to_ptr v52 : ptr<byte, felt>;
                    v56 = hir.load v55 : felt;
                    v663 = arith.constant 1 : felt;
                    hir.assert_eq v56, v663;
                    v689 = arith.constant 0 : i32;
                    v662 = arith.constant 2 : u32;
                    v60 = hir.bitcast v20 : u32;
                    v62 = arith.lte v60, v662 : i1;
                    v63 = arith.zext v62 : u32;
                    v64 = hir.bitcast v63 : i32;
                    v66 = arith.neq v64, v689 : i1;
                    v673 = scf.if v66 : u32 {
                    ^block81:
                        v688 = arith.constant 0 : u32;
                        scf.yield v688;
                    } else {
                    ^block15:
                        v687 = arith.constant 8 : u32;
                        v67 = hir.bitcast v36 : u32;
                        v69 = arith.add v67, v687 : u32 #[overflow = checked];
                        v686 = arith.constant 4 : u32;
                        v71 = arith.mod v69, v686 : u32;
                        hir.assertz v71 #[code = 250];
                        v72 = hir.int_to_ptr v69 : ptr<byte, felt>;
                        v73 = hir.load v72 : felt;
                        v661 = arith.constant 2 : felt;
                        hir.assert_eq v73, v661;
                        v685 = arith.constant 0 : i32;
                        v76 = arith.constant 3 : i32;
                        v77 = arith.eq v20, v76 : i1;
                        v78 = arith.zext v77 : u32;
                        v79 = hir.bitcast v78 : i32;
                        v81 = arith.neq v79, v685 : i1;
                        scf.if v81{
                        ^block80:
                            scf.yield ;
                        } else {
                        ^block16:
                            v684 = arith.constant 12 : u32;
                            v82 = hir.bitcast v36 : u32;
                            v84 = arith.add v82, v684 : u32 #[overflow = checked];
                            v683 = arith.constant 4 : u32;
                            v86 = arith.mod v84, v683 : u32;
                            hir.assertz v86 #[code = 250];
                            v87 = hir.int_to_ptr v84 : ptr<byte, felt>;
                            v88 = hir.load v87 : felt;
                            v660 = arith.constant 3 : felt;
                            hir.assert_eq v88, v660;
                            v681 = arith.constant 4 : i32;
                            v682 = arith.constant 4 : i32;
                            v92 = arith.add v9, v682 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/alloc::raw_vec::RawVecInner<A>::deallocate(v92, v681, v681)
                            v680 = arith.constant 16 : i32;
                            v96 = arith.add v9, v680 : i32 #[overflow = wrapping];
                            v97 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
                            v98 = hir.bitcast v97 : ptr<byte, i32>;
                            hir.store v98, v96;
                            scf.yield ;
                        };
                        v667 = arith.constant 1 : u32;
                        v679 = arith.constant 0 : u32;
                        v677 = cf.select v81, v679, v667 : u32;
                        scf.yield v677;
                    };
                    scf.yield v673;
                };
                scf.yield v671;
            };
            v678 = arith.constant 0 : u32;
            v676 = arith.eq v669, v678 : i1;
            cf.cond_br v676 ^block12, ^block85;
        ^block12:
            ub.unreachable ;
        ^block85:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc(v99: i32, v100: i32) -> i32 {
        ^block17(v99: i32, v100: i32):
            v102 = arith.constant 1048636 : i32;
            v103 = hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v102, v100, v99) : i32
            builtin.ret v103;
        };

        private builtin.function @__rustc::__rust_dealloc(v104: i32, v105: i32, v106: i32) {
        ^block19(v104: i32, v105: i32, v106: i32):
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v107: i32, v108: i32) -> i32 {
        ^block21(v107: i32, v108: i32):
            v110 = arith.constant 1048636 : i32;
            v111 = hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v110, v108, v107) : i32
            v705 = arith.constant 0 : i32;
            v112 = arith.constant 0 : i32;
            v113 = arith.eq v111, v112 : i1;
            v114 = arith.zext v113 : u32;
            v115 = hir.bitcast v114 : i32;
            v117 = arith.neq v115, v705 : i1;
            scf.if v117{
            ^block23:
                scf.yield ;
            } else {
            ^block24:
                v703 = arith.constant 0 : i32;
                v704 = arith.constant 0 : i32;
                v119 = arith.eq v107, v704 : i1;
                v120 = arith.zext v119 : u32;
                v121 = hir.bitcast v120 : i32;
                v123 = arith.neq v121, v703 : i1;
                scf.if v123{
                ^block90:
                    scf.yield ;
                } else {
                ^block25:
                    v697 = arith.constant 0 : u8;
                    v126 = hir.bitcast v107 : u32;
                    v127 = hir.bitcast v111 : u32;
                    v128 = hir.int_to_ptr v127 : ptr<byte, u8>;
                    hir.mem_set v128, v126, v697;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v111;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v130: i32, v131: i32, v132: i32) -> i32 {
        ^block26(v130: i32, v131: i32, v132: i32):
            v135 = arith.constant 16 : i32;
            v134 = arith.constant 0 : i32;
            v707 = arith.constant 16 : u32;
            v137 = hir.bitcast v131 : u32;
            v139 = arith.gt v137, v707 : i1;
            v140 = arith.zext v139 : u32;
            v141 = hir.bitcast v140 : i32;
            v143 = arith.neq v141, v134 : i1;
            v144 = cf.select v143, v131, v135 : i32;
            v746 = arith.constant 0 : i32;
            v145 = arith.constant -1 : i32;
            v146 = arith.add v144, v145 : i32 #[overflow = wrapping];
            v147 = arith.band v144, v146 : i32;
            v149 = arith.neq v147, v746 : i1;
            v716, v717 = scf.if v149 : i32, u32 {
            ^block95:
                v708 = arith.constant 0 : u32;
                v712 = ub.poison i32 : i32;
                scf.yield v712, v708;
            } else {
            ^block29:
                v151 = hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/core::ptr::alignment::Alignment::max(v131, v144) : i32
                v745 = arith.constant 0 : i32;
                v150 = arith.constant -2147483648 : i32;
                v152 = arith.sub v150, v151 : i32 #[overflow = wrapping];
                v154 = hir.bitcast v152 : u32;
                v153 = hir.bitcast v132 : u32;
                v155 = arith.gt v153, v154 : i1;
                v156 = arith.zext v155 : u32;
                v157 = hir.bitcast v156 : i32;
                v159 = arith.neq v157, v745 : i1;
                v731 = scf.if v159 : i32 {
                ^block94:
                    v744 = ub.poison i32 : i32;
                    scf.yield v744;
                } else {
                ^block30:
                    v742 = arith.constant 0 : i32;
                    v165 = arith.sub v742, v151 : i32 #[overflow = wrapping];
                    v743 = arith.constant -1 : i32;
                    v161 = arith.add v132, v151 : i32 #[overflow = wrapping];
                    v163 = arith.add v161, v743 : i32 #[overflow = wrapping];
                    v166 = arith.band v163, v165 : i32;
                    v167 = hir.bitcast v130 : u32;
                    v168 = arith.constant 4 : u32;
                    v169 = arith.mod v167, v168 : u32;
                    hir.assertz v169 #[code = 250];
                    v170 = hir.int_to_ptr v167 : ptr<byte, i32>;
                    v171 = hir.load v170 : i32;
                    v741 = arith.constant 0 : i32;
                    v173 = arith.neq v171, v741 : i1;
                    scf.if v173{
                    ^block93:
                        scf.yield ;
                    } else {
                    ^block32:
                        v174 = hir.exec @intrinsics/mem/heap_base() : i32
                        v175 = hir.mem_size  : u32;
                        v181 = hir.bitcast v130 : u32;
                        v740 = arith.constant 4 : u32;
                        v183 = arith.mod v181, v740 : u32;
                        hir.assertz v183 #[code = 250];
                        v739 = arith.constant 16 : u32;
                        v176 = hir.bitcast v175 : i32;
                        v179 = arith.shl v176, v739 : i32;
                        v180 = arith.add v174, v179 : i32 #[overflow = wrapping];
                        v184 = hir.int_to_ptr v181 : ptr<byte, i32>;
                        hir.store v184, v180;
                        scf.yield ;
                    };
                    v187 = hir.bitcast v130 : u32;
                    v738 = arith.constant 4 : u32;
                    v189 = arith.mod v187, v738 : u32;
                    hir.assertz v189 #[code = 250];
                    v190 = hir.int_to_ptr v187 : ptr<byte, i32>;
                    v191 = hir.load v190 : i32;
                    v737 = arith.constant 0 : i32;
                    v195 = hir.bitcast v166 : u32;
                    v185 = arith.constant 268435456 : i32;
                    v192 = arith.sub v185, v191 : i32 #[overflow = wrapping];
                    v194 = hir.bitcast v192 : u32;
                    v196 = arith.lt v194, v195 : i1;
                    v197 = arith.zext v196 : u32;
                    v198 = hir.bitcast v197 : i32;
                    v200 = arith.neq v198, v737 : i1;
                    v730 = scf.if v200 : i32 {
                    ^block33:
                        v736 = arith.constant 0 : i32;
                        scf.yield v736;
                    } else {
                    ^block34:
                        v202 = hir.bitcast v130 : u32;
                        v735 = arith.constant 4 : u32;
                        v204 = arith.mod v202, v735 : u32;
                        hir.assertz v204 #[code = 250];
                        v201 = arith.add v191, v166 : i32 #[overflow = wrapping];
                        v205 = hir.int_to_ptr v202 : ptr<byte, i32>;
                        hir.store v205, v201;
                        v207 = arith.add v191, v151 : i32 #[overflow = wrapping];
                        scf.yield v207;
                    };
                    scf.yield v730;
                };
                v713 = arith.constant 1 : u32;
                v734 = arith.constant 0 : u32;
                v732 = cf.select v159, v734, v713 : u32;
                scf.yield v731, v732;
            };
            v733 = arith.constant 0 : u32;
            v729 = arith.eq v717, v733 : i1;
            cf.cond_br v729 ^block28, ^block97(v716);
        ^block28:
            ub.unreachable ;
        ^block97(v709: i32):
            builtin.ret v709;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::with_capacity_in(v210: i32, v211: i32, v212: i32, v213: i32) {
        ^block35(v210: i32, v211: i32, v212: i32, v213: i32):
            v215 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v216 = hir.bitcast v215 : ptr<byte, i32>;
            v217 = hir.load v216 : i32;
            v218 = arith.constant 16 : i32;
            v219 = arith.sub v217, v218 : i32 #[overflow = wrapping];
            v220 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v221 = hir.bitcast v220 : ptr<byte, i32>;
            hir.store v221, v219;
            v214 = arith.constant 0 : i32;
            v224 = arith.constant 256 : i32;
            v222 = arith.constant 4 : i32;
            v223 = arith.add v219, v222 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/alloc::raw_vec::RawVecInner<A>::try_allocate_in(v223, v224, v214, v211, v212)
            v227 = arith.constant 8 : u32;
            v226 = hir.bitcast v219 : u32;
            v228 = arith.add v226, v227 : u32 #[overflow = checked];
            v229 = arith.constant 4 : u32;
            v230 = arith.mod v228, v229 : u32;
            hir.assertz v230 #[code = 250];
            v231 = hir.int_to_ptr v228 : ptr<byte, i32>;
            v232 = hir.load v231 : i32;
            v757 = arith.constant 4 : u32;
            v233 = hir.bitcast v219 : u32;
            v235 = arith.add v233, v757 : u32 #[overflow = checked];
            v756 = arith.constant 4 : u32;
            v237 = arith.mod v235, v756 : u32;
            hir.assertz v237 #[code = 250];
            v238 = hir.int_to_ptr v235 : ptr<byte, i32>;
            v239 = hir.load v238 : i32;
            v755 = arith.constant 0 : i32;
            v240 = arith.constant 1 : i32;
            v241 = arith.neq v239, v240 : i1;
            v242 = arith.zext v241 : u32;
            v243 = hir.bitcast v242 : i32;
            v245 = arith.neq v243, v755 : i1;
            cf.cond_br v245 ^block37, ^block38;
        ^block37:
            v254 = arith.constant 12 : u32;
            v253 = hir.bitcast v219 : u32;
            v255 = arith.add v253, v254 : u32 #[overflow = checked];
            v754 = arith.constant 4 : u32;
            v257 = arith.mod v255, v754 : u32;
            hir.assertz v257 #[code = 250];
            v258 = hir.int_to_ptr v255 : ptr<byte, i32>;
            v259 = hir.load v258 : i32;
            v753 = arith.constant 4 : u32;
            v260 = hir.bitcast v210 : u32;
            v262 = arith.add v260, v753 : u32 #[overflow = checked];
            v752 = arith.constant 4 : u32;
            v264 = arith.mod v262, v752 : u32;
            hir.assertz v264 #[code = 250];
            v265 = hir.int_to_ptr v262 : ptr<byte, i32>;
            hir.store v265, v259;
            v266 = hir.bitcast v210 : u32;
            v751 = arith.constant 4 : u32;
            v268 = arith.mod v266, v751 : u32;
            hir.assertz v268 #[code = 250];
            v269 = hir.int_to_ptr v266 : ptr<byte, i32>;
            hir.store v269, v232;
            v750 = arith.constant 16 : i32;
            v271 = arith.add v219, v750 : i32 #[overflow = wrapping];
            v272 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v273 = hir.bitcast v272 : ptr<byte, i32>;
            hir.store v273, v271;
            builtin.ret ;
        ^block38:
            v749 = arith.constant 12 : u32;
            v246 = hir.bitcast v219 : u32;
            v248 = arith.add v246, v749 : u32 #[overflow = checked];
            v748 = arith.constant 4 : u32;
            v250 = arith.mod v248, v748 : u32;
            hir.assertz v250 #[code = 250];
            v251 = hir.int_to_ptr v248 : ptr<byte, i32>;
            v252 = hir.load v251 : i32;
            hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/alloc::raw_vec::handle_error(v232, v252, v213)
            ub.unreachable ;
        };

        private builtin.function @miden_base_sys::bindings::note::get_inputs(v274: i32) {
        ^block39(v274: i32):
            v276 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v277 = hir.bitcast v276 : ptr<byte, i32>;
            v278 = hir.load v277 : i32;
            v279 = arith.constant 16 : i32;
            v280 = arith.sub v278, v279 : i32 #[overflow = wrapping];
            v281 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v282 = hir.bitcast v281 : ptr<byte, i32>;
            hir.store v282, v280;
            v287 = arith.constant 1048620 : i32;
            v285 = arith.constant 4 : i32;
            v283 = arith.constant 8 : i32;
            v284 = arith.add v280, v283 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/alloc::raw_vec::RawVecInner<A>::with_capacity_in(v284, v285, v285, v287)
            v289 = arith.constant 8 : u32;
            v288 = hir.bitcast v280 : u32;
            v290 = arith.add v288, v289 : u32 #[overflow = checked];
            v291 = arith.constant 4 : u32;
            v292 = arith.mod v290, v291 : u32;
            hir.assertz v292 #[code = 250];
            v293 = hir.int_to_ptr v290 : ptr<byte, i32>;
            v294 = hir.load v293 : i32;
            v296 = arith.constant 12 : u32;
            v295 = hir.bitcast v280 : u32;
            v297 = arith.add v295, v296 : u32 #[overflow = checked];
            v765 = arith.constant 4 : u32;
            v299 = arith.mod v297, v765 : u32;
            hir.assertz v299 #[code = 250];
            v300 = hir.int_to_ptr v297 : ptr<byte, i32>;
            v301 = hir.load v300 : i32;
            v758 = arith.constant 2 : u32;
            v303 = hir.bitcast v301 : u32;
            v305 = arith.shr v303, v758 : u32;
            v306 = hir.bitcast v305 : i32;
            v307 = hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/miden_base_sys::bindings::note::extern_note_get_inputs(v306) : i32
            v764 = arith.constant 8 : u32;
            v308 = hir.bitcast v274 : u32;
            v310 = arith.add v308, v764 : u32 #[overflow = checked];
            v763 = arith.constant 4 : u32;
            v312 = arith.mod v310, v763 : u32;
            hir.assertz v312 #[code = 250];
            v313 = hir.int_to_ptr v310 : ptr<byte, i32>;
            hir.store v313, v307;
            v762 = arith.constant 4 : u32;
            v314 = hir.bitcast v274 : u32;
            v316 = arith.add v314, v762 : u32 #[overflow = checked];
            v761 = arith.constant 4 : u32;
            v318 = arith.mod v316, v761 : u32;
            hir.assertz v318 #[code = 250];
            v319 = hir.int_to_ptr v316 : ptr<byte, i32>;
            hir.store v319, v301;
            v320 = hir.bitcast v274 : u32;
            v760 = arith.constant 4 : u32;
            v322 = arith.mod v320, v760 : u32;
            hir.assertz v322 #[code = 250];
            v323 = hir.int_to_ptr v320 : ptr<byte, i32>;
            hir.store v323, v294;
            v759 = arith.constant 16 : i32;
            v325 = arith.add v280, v759 : i32 #[overflow = wrapping];
            v326 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v327 = hir.bitcast v326 : ptr<byte, i32>;
            hir.store v327, v325;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v328: i32, v329: i32, v330: i32) {
        ^block41(v328: i32, v329: i32, v330: i32):
            v332 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v333 = hir.bitcast v332 : ptr<byte, i32>;
            v334 = hir.load v333 : i32;
            v335 = arith.constant 16 : i32;
            v336 = arith.sub v334, v335 : i32 #[overflow = wrapping];
            v337 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v338 = hir.bitcast v337 : ptr<byte, i32>;
            hir.store v338, v336;
            v339 = arith.constant 4 : i32;
            v340 = arith.add v336, v339 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/alloc::raw_vec::RawVecInner<A>::current_memory(v340, v328, v329, v330)
            v342 = arith.constant 8 : u32;
            v341 = hir.bitcast v336 : u32;
            v343 = arith.add v341, v342 : u32 #[overflow = checked];
            v344 = arith.constant 4 : u32;
            v345 = arith.mod v343, v344 : u32;
            hir.assertz v345 #[code = 250];
            v346 = hir.int_to_ptr v343 : ptr<byte, i32>;
            v347 = hir.load v346 : i32;
            v772 = arith.constant 0 : i32;
            v331 = arith.constant 0 : i32;
            v349 = arith.eq v347, v331 : i1;
            v350 = arith.zext v349 : u32;
            v351 = hir.bitcast v350 : i32;
            v353 = arith.neq v351, v772 : i1;
            scf.if v353{
            ^block103:
                scf.yield ;
            } else {
            ^block44:
                v771 = arith.constant 4 : u32;
                v354 = hir.bitcast v336 : u32;
                v356 = arith.add v354, v771 : u32 #[overflow = checked];
                v770 = arith.constant 4 : u32;
                v358 = arith.mod v356, v770 : u32;
                hir.assertz v358 #[code = 250];
                v359 = hir.int_to_ptr v356 : ptr<byte, i32>;
                v360 = hir.load v359 : i32;
                v362 = arith.constant 12 : u32;
                v361 = hir.bitcast v336 : u32;
                v363 = arith.add v361, v362 : u32 #[overflow = checked];
                v769 = arith.constant 4 : u32;
                v365 = arith.mod v363, v769 : u32;
                hir.assertz v365 #[code = 250];
                v366 = hir.int_to_ptr v363 : ptr<byte, i32>;
                v367 = hir.load v366 : i32;
                hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v360, v347, v367)
                scf.yield ;
            };
            v768 = arith.constant 16 : i32;
            v370 = arith.add v336, v768 : i32 #[overflow = wrapping];
            v371 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v372 = hir.bitcast v371 : ptr<byte, i32>;
            hir.store v372, v370;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::try_allocate_in(v373: i32, v374: i32, v375: i32, v376: i32, v377: i32) {
        ^block45(v373: i32, v374: i32, v375: i32, v376: i32, v377: i32):
            v380 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v381 = hir.bitcast v380 : ptr<byte, i32>;
            v382 = hir.load v381 : i32;
            v383 = arith.constant 16 : i32;
            v384 = arith.sub v382, v383 : i32 #[overflow = wrapping];
            v385 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v386 = hir.bitcast v385 : ptr<byte, i32>;
            hir.store v386, v384;
            v396 = hir.bitcast v374 : u32;
            v397 = arith.zext v396 : u64;
            v398 = hir.bitcast v397 : i64;
            v378 = arith.constant 0 : i32;
            v391 = arith.sub v378, v376 : i32 #[overflow = wrapping];
            v388 = arith.constant -1 : i32;
            v387 = arith.add v376, v377 : i32 #[overflow = wrapping];
            v389 = arith.add v387, v388 : i32 #[overflow = wrapping];
            v392 = arith.band v389, v391 : i32;
            v393 = hir.bitcast v392 : u32;
            v394 = arith.zext v393 : u64;
            v395 = hir.bitcast v394 : i64;
            v399 = arith.mul v395, v398 : i64 #[overflow = wrapping];
            v876 = arith.constant 0 : i32;
            v400 = arith.constant 32 : i64;
            v402 = hir.cast v400 : u32;
            v401 = hir.bitcast v399 : u64;
            v403 = arith.shr v401, v402 : u64;
            v404 = hir.bitcast v403 : i64;
            v405 = arith.trunc v404 : i32;
            v407 = arith.neq v405, v876 : i1;
            v788, v789, v790, v791, v792, v793 = scf.if v407 : i32, i32, i32, i32, i32, u32 {
            ^block105:
                v773 = arith.constant 0 : u32;
                v780 = ub.poison i32 : i32;
                scf.yield v373, v384, v780, v780, v780, v773;
            } else {
            ^block50:
                v408 = arith.trunc v399 : i32;
                v875 = arith.constant 0 : i32;
                v409 = arith.constant -2147483648 : i32;
                v410 = arith.sub v409, v376 : i32 #[overflow = wrapping];
                v412 = hir.bitcast v410 : u32;
                v411 = hir.bitcast v408 : u32;
                v413 = arith.lte v411, v412 : i1;
                v414 = arith.zext v413 : u32;
                v415 = hir.bitcast v414 : i32;
                v417 = arith.neq v415, v875 : i1;
                v836 = scf.if v417 : i32 {
                ^block48:
                    v874 = arith.constant 0 : i32;
                    v428 = arith.neq v408, v874 : i1;
                    v835 = scf.if v428 : i32 {
                    ^block52:
                        v873 = arith.constant 0 : i32;
                        v444 = arith.neq v375, v873 : i1;
                        v834 = scf.if v444 : i32 {
                        ^block55:
                            v426 = arith.constant 1 : i32;
                            hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/alloc::alloc::Global::alloc_impl(v384, v376, v408, v426)
                            v455 = hir.bitcast v384 : u32;
                            v500 = arith.constant 4 : u32;
                            v457 = arith.mod v455, v500 : u32;
                            hir.assertz v457 #[code = 250];
                            v458 = hir.int_to_ptr v455 : ptr<byte, i32>;
                            v459 = hir.load v458 : i32;
                            scf.yield v459;
                        } else {
                        ^block56:
                            v445 = arith.constant 8 : i32;
                            v446 = arith.add v384, v445 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v446, v376, v408)
                            v430 = arith.constant 8 : u32;
                            v447 = hir.bitcast v384 : u32;
                            v449 = arith.add v447, v430 : u32 #[overflow = checked];
                            v872 = arith.constant 4 : u32;
                            v451 = arith.mod v449, v872 : u32;
                            hir.assertz v451 #[code = 250];
                            v452 = hir.int_to_ptr v449 : ptr<byte, i32>;
                            v453 = hir.load v452 : i32;
                            scf.yield v453;
                        };
                        v870 = arith.constant 0 : i32;
                        v871 = arith.constant 0 : i32;
                        v462 = arith.eq v834, v871 : i1;
                        v463 = arith.zext v462 : u32;
                        v464 = hir.bitcast v463 : i32;
                        v466 = arith.neq v464, v870 : i1;
                        scf.if v466{
                        ^block57:
                            v869 = arith.constant 8 : u32;
                            v483 = hir.bitcast v373 : u32;
                            v485 = arith.add v483, v869 : u32 #[overflow = checked];
                            v868 = arith.constant 4 : u32;
                            v487 = arith.mod v485, v868 : u32;
                            hir.assertz v487 #[code = 250];
                            v488 = hir.int_to_ptr v485 : ptr<byte, i32>;
                            hir.store v488, v408;
                            v867 = arith.constant 4 : u32;
                            v490 = hir.bitcast v373 : u32;
                            v492 = arith.add v490, v867 : u32 #[overflow = checked];
                            v866 = arith.constant 4 : u32;
                            v494 = arith.mod v492, v866 : u32;
                            hir.assertz v494 #[code = 250];
                            v495 = hir.int_to_ptr v492 : ptr<byte, i32>;
                            hir.store v495, v376;
                            scf.yield ;
                        } else {
                        ^block58:
                            v865 = arith.constant 8 : u32;
                            v468 = hir.bitcast v373 : u32;
                            v470 = arith.add v468, v865 : u32 #[overflow = checked];
                            v864 = arith.constant 4 : u32;
                            v472 = arith.mod v470, v864 : u32;
                            hir.assertz v472 #[code = 250];
                            v473 = hir.int_to_ptr v470 : ptr<byte, i32>;
                            hir.store v473, v834;
                            v863 = arith.constant 4 : u32;
                            v475 = hir.bitcast v373 : u32;
                            v477 = arith.add v475, v863 : u32 #[overflow = checked];
                            v862 = arith.constant 4 : u32;
                            v479 = arith.mod v477, v862 : u32;
                            hir.assertz v479 #[code = 250];
                            v480 = hir.int_to_ptr v477 : ptr<byte, i32>;
                            hir.store v480, v374;
                            scf.yield ;
                        };
                        v860 = arith.constant 0 : i32;
                        v861 = arith.constant 1 : i32;
                        v833 = cf.select v466, v861, v860 : i32;
                        scf.yield v833;
                    } else {
                    ^block53:
                        v859 = arith.constant 8 : u32;
                        v429 = hir.bitcast v373 : u32;
                        v431 = arith.add v429, v859 : u32 #[overflow = checked];
                        v858 = arith.constant 4 : u32;
                        v433 = arith.mod v431, v858 : u32;
                        hir.assertz v433 #[code = 250];
                        v434 = hir.int_to_ptr v431 : ptr<byte, i32>;
                        hir.store v434, v376;
                        v857 = arith.constant 4 : u32;
                        v437 = hir.bitcast v373 : u32;
                        v439 = arith.add v437, v857 : u32 #[overflow = checked];
                        v856 = arith.constant 4 : u32;
                        v441 = arith.mod v439, v856 : u32;
                        hir.assertz v441 #[code = 250];
                        v855 = arith.constant 0 : i32;
                        v442 = hir.int_to_ptr v439 : ptr<byte, i32>;
                        hir.store v442, v855;
                        v854 = arith.constant 0 : i32;
                        scf.yield v854;
                    };
                    scf.yield v835;
                } else {
                ^block51:
                    v853 = ub.poison i32 : i32;
                    scf.yield v853;
                };
                v848 = arith.constant 0 : u32;
                v781 = arith.constant 1 : u32;
                v841 = cf.select v417, v781, v848 : u32;
                v849 = ub.poison i32 : i32;
                v840 = cf.select v417, v384, v849 : i32;
                v850 = ub.poison i32 : i32;
                v839 = cf.select v417, v373, v850 : i32;
                v851 = ub.poison i32 : i32;
                v838 = cf.select v417, v851, v384 : i32;
                v852 = ub.poison i32 : i32;
                v837 = cf.select v417, v852, v373 : i32;
                scf.yield v837, v838, v839, v836, v840, v841;
            };
            v794, v795, v796 = scf.index_switch v793 : i32, i32, i32 
            case 0 {
            ^block49:
                v847 = arith.constant 4 : u32;
                v420 = hir.bitcast v788 : u32;
                v422 = arith.add v420, v847 : u32 #[overflow = checked];
                v846 = arith.constant 4 : u32;
                v424 = arith.mod v422, v846 : u32;
                hir.assertz v424 #[code = 250];
                v845 = arith.constant 0 : i32;
                v425 = hir.int_to_ptr v422 : ptr<byte, i32>;
                hir.store v425, v845;
                v844 = arith.constant 1 : i32;
                scf.yield v788, v844, v789;
            }
            default {
            ^block109:
                scf.yield v790, v791, v792;
            };
            v499 = hir.bitcast v794 : u32;
            v843 = arith.constant 4 : u32;
            v501 = arith.mod v499, v843 : u32;
            hir.assertz v501 #[code = 250];
            v502 = hir.int_to_ptr v499 : ptr<byte, i32>;
            hir.store v502, v795;
            v842 = arith.constant 16 : i32;
            v507 = arith.add v796, v842 : i32 #[overflow = wrapping];
            v508 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v509 = hir.bitcast v508 : ptr<byte, i32>;
            hir.store v509, v507;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v510: i32, v511: i32, v512: i32) {
        ^block59(v510: i32, v511: i32, v512: i32):
            v514 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v515 = hir.bitcast v514 : ptr<byte, i32>;
            v516 = hir.load v515 : i32;
            v517 = arith.constant 16 : i32;
            v518 = arith.sub v516, v517 : i32 #[overflow = wrapping];
            v519 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v520 = hir.bitcast v519 : ptr<byte, i32>;
            hir.store v520, v518;
            v513 = arith.constant 0 : i32;
            v521 = arith.constant 8 : i32;
            v522 = arith.add v518, v521 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/alloc::alloc::Global::alloc_impl(v522, v511, v512, v513)
            v525 = arith.constant 12 : u32;
            v524 = hir.bitcast v518 : u32;
            v526 = arith.add v524, v525 : u32 #[overflow = checked];
            v527 = arith.constant 4 : u32;
            v528 = arith.mod v526, v527 : u32;
            hir.assertz v528 #[code = 250];
            v529 = hir.int_to_ptr v526 : ptr<byte, i32>;
            v530 = hir.load v529 : i32;
            v532 = arith.constant 8 : u32;
            v531 = hir.bitcast v518 : u32;
            v533 = arith.add v531, v532 : u32 #[overflow = checked];
            v881 = arith.constant 4 : u32;
            v535 = arith.mod v533, v881 : u32;
            hir.assertz v535 #[code = 250];
            v536 = hir.int_to_ptr v533 : ptr<byte, i32>;
            v537 = hir.load v536 : i32;
            v538 = hir.bitcast v510 : u32;
            v880 = arith.constant 4 : u32;
            v540 = arith.mod v538, v880 : u32;
            hir.assertz v540 #[code = 250];
            v541 = hir.int_to_ptr v538 : ptr<byte, i32>;
            hir.store v541, v537;
            v879 = arith.constant 4 : u32;
            v542 = hir.bitcast v510 : u32;
            v544 = arith.add v542, v879 : u32 #[overflow = checked];
            v878 = arith.constant 4 : u32;
            v546 = arith.mod v544, v878 : u32;
            hir.assertz v546 #[code = 250];
            v547 = hir.int_to_ptr v544 : ptr<byte, i32>;
            hir.store v547, v530;
            v877 = arith.constant 16 : i32;
            v549 = arith.add v518, v877 : i32 #[overflow = wrapping];
            v550 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v551 = hir.bitcast v550 : ptr<byte, i32>;
            hir.store v551, v549;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v552: i32, v553: i32, v554: i32, v555: i32) {
        ^block61(v552: i32, v553: i32, v554: i32, v555: i32):
            v897 = arith.constant 0 : i32;
            v556 = arith.constant 0 : i32;
            v557 = arith.eq v554, v556 : i1;
            v558 = arith.zext v557 : u32;
            v559 = hir.bitcast v558 : i32;
            v561 = arith.neq v559, v897 : i1;
            v893 = scf.if v561 : i32 {
            ^block112:
                scf.yield v553;
            } else {
            ^block64:
                v896 = arith.constant 0 : i32;
                v570 = arith.neq v555, v896 : i1;
                v892 = scf.if v570 : i32 {
                ^block65:
                    v572 = hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__rustc::__rust_alloc_zeroed(v554, v553) : i32
                    scf.yield v572;
                } else {
                ^block66:
                    v571 = hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__rustc::__rust_alloc(v554, v553) : i32
                    scf.yield v571;
                };
                scf.yield v892;
            };
            v576 = arith.constant 4 : u32;
            v575 = hir.bitcast v552 : u32;
            v577 = arith.add v575, v576 : u32 #[overflow = checked];
            v895 = arith.constant 4 : u32;
            v579 = arith.mod v577, v895 : u32;
            hir.assertz v579 #[code = 250];
            v580 = hir.int_to_ptr v577 : ptr<byte, i32>;
            hir.store v580, v554;
            v582 = hir.bitcast v552 : u32;
            v894 = arith.constant 4 : u32;
            v584 = arith.mod v582, v894 : u32;
            hir.assertz v584 #[code = 250];
            v585 = hir.int_to_ptr v582 : ptr<byte, i32>;
            hir.store v585, v893;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v586: i32, v587: i32, v588: i32, v589: i32) {
        ^block67(v586: i32, v587: i32, v588: i32, v589: i32):
            v923 = arith.constant 0 : i32;
            v590 = arith.constant 0 : i32;
            v594 = arith.eq v589, v590 : i1;
            v595 = arith.zext v594 : u32;
            v596 = hir.bitcast v595 : i32;
            v598 = arith.neq v596, v923 : i1;
            v910, v911 = scf.if v598 : i32, i32 {
            ^block116:
                v922 = arith.constant 0 : i32;
                v592 = arith.constant 4 : i32;
                scf.yield v592, v922;
            } else {
            ^block70:
                v599 = hir.bitcast v587 : u32;
                v634 = arith.constant 4 : u32;
                v601 = arith.mod v599, v634 : u32;
                hir.assertz v601 #[code = 250];
                v602 = hir.int_to_ptr v599 : ptr<byte, i32>;
                v603 = hir.load v602 : i32;
                v920 = arith.constant 0 : i32;
                v921 = arith.constant 0 : i32;
                v605 = arith.eq v603, v921 : i1;
                v606 = arith.zext v605 : u32;
                v607 = hir.bitcast v606 : i32;
                v609 = arith.neq v607, v920 : i1;
                v908 = scf.if v609 : i32 {
                ^block115:
                    v919 = arith.constant 0 : i32;
                    scf.yield v919;
                } else {
                ^block71:
                    v918 = arith.constant 4 : u32;
                    v610 = hir.bitcast v586 : u32;
                    v612 = arith.add v610, v918 : u32 #[overflow = checked];
                    v917 = arith.constant 4 : u32;
                    v614 = arith.mod v612, v917 : u32;
                    hir.assertz v614 #[code = 250];
                    v615 = hir.int_to_ptr v612 : ptr<byte, i32>;
                    hir.store v615, v588;
                    v916 = arith.constant 4 : u32;
                    v616 = hir.bitcast v587 : u32;
                    v618 = arith.add v616, v916 : u32 #[overflow = checked];
                    v915 = arith.constant 4 : u32;
                    v620 = arith.mod v618, v915 : u32;
                    hir.assertz v620 #[code = 250];
                    v621 = hir.int_to_ptr v618 : ptr<byte, i32>;
                    v622 = hir.load v621 : i32;
                    v623 = hir.bitcast v586 : u32;
                    v914 = arith.constant 4 : u32;
                    v625 = arith.mod v623, v914 : u32;
                    hir.assertz v625 #[code = 250];
                    v626 = hir.int_to_ptr v623 : ptr<byte, i32>;
                    hir.store v626, v622;
                    v627 = arith.mul v603, v589 : i32 #[overflow = wrapping];
                    scf.yield v627;
                };
                v628 = arith.constant 8 : i32;
                v913 = arith.constant 4 : i32;
                v909 = cf.select v609, v913, v628 : i32;
                scf.yield v909, v908;
            };
            v631 = arith.add v586, v910 : i32 #[overflow = wrapping];
            v633 = hir.bitcast v631 : u32;
            v912 = arith.constant 4 : u32;
            v635 = arith.mod v633, v912 : u32;
            hir.assertz v635 #[code = 250];
            v636 = hir.int_to_ptr v633 : ptr<byte, i32>;
            hir.store v636, v911;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v637: i32, v638: i32, v639: i32) {
        ^block72(v637: i32, v638: i32, v639: i32):
            v925 = arith.constant 0 : i32;
            v640 = arith.constant 0 : i32;
            v641 = arith.eq v639, v640 : i1;
            v642 = arith.zext v641 : u32;
            v643 = hir.bitcast v642 : i32;
            v645 = arith.neq v643, v925 : i1;
            scf.if v645{
            ^block74:
                scf.yield ;
            } else {
            ^block75:
                hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__rustc::__rust_dealloc(v637, v639, v638)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v646: i32, v647: i32, v648: i32) {
        ^block76(v646: i32, v647: i32, v648: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v649: i32, v650: i32) -> i32 {
        ^block78(v649: i32, v650: i32):
            v657 = arith.constant 0 : i32;
            v653 = hir.bitcast v650 : u32;
            v652 = hir.bitcast v649 : u32;
            v654 = arith.gt v652, v653 : i1;
            v655 = arith.zext v654 : u32;
            v656 = hir.bitcast v655 : i32;
            v658 = arith.neq v656, v657 : i1;
            v659 = cf.select v658, v649, v650 : i32;
            builtin.ret v659;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.segment readonly @1048576 = 0x0000002100000013000000290010000000000073722e65746f6e2f73676e69646e69622f6372732f352e312e302d7379732d657361622d6e6564696d;
    };
};