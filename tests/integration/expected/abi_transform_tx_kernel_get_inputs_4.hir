builtin.component root_ns:root@1.0.0 {
    builtin.module public @abi_transform_tx_kernel_get_inputs_4 {
        private builtin.function @miden_base_sys::bindings::note::extern_note_get_inputs(v0: i32) -> i32 {
        ^block5(v0: i32):
            v1, v2 = hir.exec @miden/note/get_inputs(v0) : i32, i32
            builtin.ret v1;
        };

        public builtin.function @entrypoint() {
        ^block10:
            v5 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v6 = hir.bitcast v5 : ptr<byte, i32>;
            v7 = hir.load v6 : i32;
            v8 = arith.constant 16 : i32;
            v9 = arith.sub v7, v8 : i32 #[overflow = wrapping];
            v10 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v11 = hir.bitcast v10 : ptr<byte, i32>;
            hir.store v11, v9;
            v12 = arith.constant 4 : i32;
            v13 = arith.add v9, v12 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/miden_base_sys::bindings::note::get_inputs(v13)
            v15 = arith.constant 12 : u32;
            v14 = hir.bitcast v9 : u32;
            v16 = arith.add v14, v15 : u32 #[overflow = checked];
            v17 = arith.constant 4 : u32;
            v18 = arith.mod v16, v17 : u32;
            hir.assertz v18 #[code = 250];
            v19 = hir.int_to_ptr v16 : ptr<byte, i32>;
            v20 = hir.load v19 : i32;
            v21 = hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/<miden_stdlib_sys::intrinsics::felt::Felt as core::convert::From<u32>>::from(v20) : felt
            v660 = arith.constant 4 : felt;
            hir.assert_eq v21, v660;
            v692 = arith.constant 0 : i32;
            v4 = arith.constant 0 : i32;
            v25 = arith.eq v20, v4 : i1;
            v26 = arith.zext v25 : u32;
            v27 = hir.bitcast v26 : i32;
            v29 = arith.neq v27, v692 : i1;
            v665 = scf.if v29 : u32 {
            ^block87:
                v661 = arith.constant 0 : u32;
                scf.yield v661;
            } else {
            ^block13:
                v31 = arith.constant 8 : u32;
                v30 = hir.bitcast v9 : u32;
                v32 = arith.add v30, v31 : u32 #[overflow = checked];
                v691 = arith.constant 4 : u32;
                v34 = arith.mod v32, v691 : u32;
                hir.assertz v34 #[code = 250];
                v35 = hir.int_to_ptr v32 : ptr<byte, i32>;
                v36 = hir.load v35 : i32;
                v37 = hir.bitcast v36 : u32;
                v690 = arith.constant 4 : u32;
                v39 = arith.mod v37, v690 : u32;
                hir.assertz v39 #[code = 250];
                v40 = hir.int_to_ptr v37 : ptr<byte, felt>;
                v41 = hir.load v40 : felt;
                v42 = arith.constant -1 : i32;
                v43 = hir.bitcast v42 : felt;
                hir.assert_eq v41, v43;
                v689 = arith.constant 0 : i32;
                v44 = arith.constant 1 : i32;
                v45 = arith.eq v20, v44 : i1;
                v46 = arith.zext v45 : u32;
                v47 = hir.bitcast v46 : i32;
                v49 = arith.neq v47, v689 : i1;
                v667 = scf.if v49 : u32 {
                ^block86:
                    v688 = arith.constant 0 : u32;
                    scf.yield v688;
                } else {
                ^block14:
                    v687 = arith.constant 4 : u32;
                    v50 = hir.bitcast v36 : u32;
                    v52 = arith.add v50, v687 : u32 #[overflow = checked];
                    v686 = arith.constant 4 : u32;
                    v54 = arith.mod v52, v686 : u32;
                    hir.assertz v54 #[code = 250];
                    v55 = hir.int_to_ptr v52 : ptr<byte, felt>;
                    v56 = hir.load v55 : felt;
                    v659 = arith.constant 1 : felt;
                    hir.assert_eq v56, v659;
                    v685 = arith.constant 0 : i32;
                    v658 = arith.constant 2 : u32;
                    v60 = hir.bitcast v20 : u32;
                    v62 = arith.lte v60, v658 : i1;
                    v63 = arith.zext v62 : u32;
                    v64 = hir.bitcast v63 : i32;
                    v66 = arith.neq v64, v685 : i1;
                    v669 = scf.if v66 : u32 {
                    ^block85:
                        v684 = arith.constant 0 : u32;
                        scf.yield v684;
                    } else {
                    ^block15:
                        v683 = arith.constant 8 : u32;
                        v67 = hir.bitcast v36 : u32;
                        v69 = arith.add v67, v683 : u32 #[overflow = checked];
                        v682 = arith.constant 4 : u32;
                        v71 = arith.mod v69, v682 : u32;
                        hir.assertz v71 #[code = 250];
                        v72 = hir.int_to_ptr v69 : ptr<byte, felt>;
                        v73 = hir.load v72 : felt;
                        v657 = arith.constant 2 : felt;
                        hir.assert_eq v73, v657;
                        v681 = arith.constant 0 : i32;
                        v76 = arith.constant 3 : i32;
                        v77 = arith.eq v20, v76 : i1;
                        v78 = arith.zext v77 : u32;
                        v79 = hir.bitcast v78 : i32;
                        v81 = arith.neq v79, v681 : i1;
                        scf.if v81{
                        ^block84:
                            scf.yield ;
                        } else {
                        ^block16:
                            v680 = arith.constant 12 : u32;
                            v82 = hir.bitcast v36 : u32;
                            v84 = arith.add v82, v680 : u32 #[overflow = checked];
                            v679 = arith.constant 4 : u32;
                            v86 = arith.mod v84, v679 : u32;
                            hir.assertz v86 #[code = 250];
                            v87 = hir.int_to_ptr v84 : ptr<byte, felt>;
                            v88 = hir.load v87 : felt;
                            v656 = arith.constant 3 : felt;
                            hir.assert_eq v88, v656;
                            v677 = arith.constant 4 : i32;
                            v678 = arith.constant 4 : i32;
                            v92 = arith.add v9, v678 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/alloc::raw_vec::RawVecInner<A>::deallocate(v92, v677, v677)
                            v676 = arith.constant 16 : i32;
                            v96 = arith.add v9, v676 : i32 #[overflow = wrapping];
                            v97 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
                            v98 = hir.bitcast v97 : ptr<byte, i32>;
                            hir.store v98, v96;
                            scf.yield ;
                        };
                        v663 = arith.constant 1 : u32;
                        v675 = arith.constant 0 : u32;
                        v673 = cf.select v81, v675, v663 : u32;
                        scf.yield v673;
                    };
                    scf.yield v669;
                };
                scf.yield v667;
            };
            v674 = arith.constant 0 : u32;
            v672 = arith.eq v665, v674 : i1;
            cf.cond_br v672 ^block12, ^block89;
        ^block12:
            ub.unreachable ;
        ^block89:
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc(v99: i32, v100: i32) -> i32 {
        ^block17(v99: i32, v100: i32):
            v102 = arith.constant 1048636 : i32;
            v103 = hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v102, v100, v99) : i32
            builtin.ret v103;
        };

        private builtin.function @__rustc::__rust_dealloc(v104: i32, v105: i32, v106: i32) {
        ^block19(v104: i32, v105: i32, v106: i32):
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v107: i32, v108: i32) -> i32 {
        ^block21(v107: i32, v108: i32):
            v110 = arith.constant 1048636 : i32;
            v111 = hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v110, v108, v107) : i32
            v701 = arith.constant 0 : i32;
            v112 = arith.constant 0 : i32;
            v113 = arith.eq v111, v112 : i1;
            v114 = arith.zext v113 : u32;
            v115 = hir.bitcast v114 : i32;
            v117 = arith.neq v115, v701 : i1;
            scf.if v117{
            ^block23:
                scf.yield ;
            } else {
            ^block24:
                v699 = arith.constant 0 : i32;
                v700 = arith.constant 0 : i32;
                v119 = arith.eq v107, v700 : i1;
                v120 = arith.zext v119 : u32;
                v121 = hir.bitcast v120 : i32;
                v123 = arith.neq v121, v699 : i1;
                scf.if v123{
                ^block94:
                    scf.yield ;
                } else {
                ^block25:
                    v693 = arith.constant 0 : u8;
                    v126 = hir.bitcast v107 : u32;
                    v127 = hir.bitcast v111 : u32;
                    v128 = hir.int_to_ptr v127 : ptr<byte, u8>;
                    hir.mem_set v128, v126, v693;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v111;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block26:
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v130: i32, v131: i32, v132: i32) -> i32 {
        ^block28(v130: i32, v131: i32, v132: i32):
            v135 = arith.constant 16 : i32;
            v134 = arith.constant 0 : i32;
            v703 = arith.constant 16 : u32;
            v137 = hir.bitcast v131 : u32;
            v139 = arith.gt v137, v703 : i1;
            v140 = arith.zext v139 : u32;
            v141 = hir.bitcast v140 : i32;
            v143 = arith.neq v141, v134 : i1;
            v144 = cf.select v143, v131, v135 : i32;
            v743 = arith.constant 0 : i32;
            v145 = arith.constant -1 : i32;
            v146 = arith.add v144, v145 : i32 #[overflow = wrapping];
            v147 = arith.band v144, v146 : i32;
            v149 = arith.neq v147, v743 : i1;
            v712, v713 = scf.if v149 : i32, u32 {
            ^block99:
                v704 = arith.constant 0 : u32;
                v708 = ub.poison i32 : i32;
                scf.yield v708, v704;
            } else {
            ^block31:
                v151 = hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/core::ptr::alignment::Alignment::max(v131, v144) : i32
                v742 = arith.constant 0 : i32;
                v150 = arith.constant -2147483648 : i32;
                v152 = arith.sub v150, v151 : i32 #[overflow = wrapping];
                v154 = hir.bitcast v152 : u32;
                v153 = hir.bitcast v132 : u32;
                v155 = arith.gt v153, v154 : i1;
                v156 = arith.zext v155 : u32;
                v157 = hir.bitcast v156 : i32;
                v159 = arith.neq v157, v742 : i1;
                v727 = scf.if v159 : i32 {
                ^block98:
                    v741 = ub.poison i32 : i32;
                    scf.yield v741;
                } else {
                ^block32:
                    v739 = arith.constant 0 : i32;
                    v165 = arith.sub v739, v151 : i32 #[overflow = wrapping];
                    v740 = arith.constant -1 : i32;
                    v161 = arith.add v132, v151 : i32 #[overflow = wrapping];
                    v163 = arith.add v161, v740 : i32 #[overflow = wrapping];
                    v166 = arith.band v163, v165 : i32;
                    v167 = hir.bitcast v130 : u32;
                    v168 = arith.constant 4 : u32;
                    v169 = arith.mod v167, v168 : u32;
                    hir.assertz v169 #[code = 250];
                    v170 = hir.int_to_ptr v167 : ptr<byte, i32>;
                    v171 = hir.load v170 : i32;
                    v738 = arith.constant 0 : i32;
                    v173 = arith.neq v171, v738 : i1;
                    scf.if v173{
                    ^block97:
                        scf.yield ;
                    } else {
                    ^block34:
                        v174 = hir.exec @intrinsics/mem/heap_base() : i32
                        v175 = hir.mem_size  : u32;
                        v181 = hir.bitcast v130 : u32;
                        v737 = arith.constant 4 : u32;
                        v183 = arith.mod v181, v737 : u32;
                        hir.assertz v183 #[code = 250];
                        v736 = arith.constant 16 : u32;
                        v176 = hir.bitcast v175 : i32;
                        v179 = arith.shl v176, v736 : i32;
                        v180 = arith.add v174, v179 : i32 #[overflow = wrapping];
                        v184 = hir.int_to_ptr v181 : ptr<byte, i32>;
                        hir.store v184, v180;
                        scf.yield ;
                    };
                    v187 = hir.bitcast v130 : u32;
                    v735 = arith.constant 4 : u32;
                    v189 = arith.mod v187, v735 : u32;
                    hir.assertz v189 #[code = 250];
                    v190 = hir.int_to_ptr v187 : ptr<byte, i32>;
                    v191 = hir.load v190 : i32;
                    v733 = arith.constant 0 : i32;
                    v734 = arith.constant -1 : i32;
                    v193 = arith.bxor v191, v734 : i32;
                    v195 = hir.bitcast v193 : u32;
                    v194 = hir.bitcast v166 : u32;
                    v196 = arith.gt v194, v195 : i1;
                    v197 = arith.zext v196 : u32;
                    v198 = hir.bitcast v197 : i32;
                    v200 = arith.neq v198, v733 : i1;
                    v726 = scf.if v200 : i32 {
                    ^block35:
                        v732 = arith.constant 0 : i32;
                        scf.yield v732;
                    } else {
                    ^block36:
                        v202 = hir.bitcast v130 : u32;
                        v731 = arith.constant 4 : u32;
                        v204 = arith.mod v202, v731 : u32;
                        hir.assertz v204 #[code = 250];
                        v201 = arith.add v191, v166 : i32 #[overflow = wrapping];
                        v205 = hir.int_to_ptr v202 : ptr<byte, i32>;
                        hir.store v205, v201;
                        v207 = arith.add v191, v151 : i32 #[overflow = wrapping];
                        scf.yield v207;
                    };
                    scf.yield v726;
                };
                v709 = arith.constant 1 : u32;
                v730 = arith.constant 0 : u32;
                v728 = cf.select v159, v730, v709 : u32;
                scf.yield v727, v728;
            };
            v729 = arith.constant 0 : u32;
            v725 = arith.eq v713, v729 : i1;
            cf.cond_br v725 ^block30, ^block101(v712);
        ^block30:
            ub.unreachable ;
        ^block101(v705: i32):
            builtin.ret v705;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::with_capacity_in(v210: i32, v211: i32, v212: i32, v213: i32) {
        ^block37(v210: i32, v211: i32, v212: i32, v213: i32):
            v215 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v216 = hir.bitcast v215 : ptr<byte, i32>;
            v217 = hir.load v216 : i32;
            v218 = arith.constant 16 : i32;
            v219 = arith.sub v217, v218 : i32 #[overflow = wrapping];
            v220 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v221 = hir.bitcast v220 : ptr<byte, i32>;
            hir.store v221, v219;
            v214 = arith.constant 0 : i32;
            v224 = arith.constant 256 : i32;
            v222 = arith.constant 4 : i32;
            v223 = arith.add v219, v222 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/alloc::raw_vec::RawVecInner<A>::try_allocate_in(v223, v224, v214, v211, v212)
            v227 = arith.constant 8 : u32;
            v226 = hir.bitcast v219 : u32;
            v228 = arith.add v226, v227 : u32 #[overflow = checked];
            v229 = arith.constant 4 : u32;
            v230 = arith.mod v228, v229 : u32;
            hir.assertz v230 #[code = 250];
            v231 = hir.int_to_ptr v228 : ptr<byte, i32>;
            v232 = hir.load v231 : i32;
            v754 = arith.constant 4 : u32;
            v233 = hir.bitcast v219 : u32;
            v235 = arith.add v233, v754 : u32 #[overflow = checked];
            v753 = arith.constant 4 : u32;
            v237 = arith.mod v235, v753 : u32;
            hir.assertz v237 #[code = 250];
            v238 = hir.int_to_ptr v235 : ptr<byte, i32>;
            v239 = hir.load v238 : i32;
            v752 = arith.constant 0 : i32;
            v240 = arith.constant 1 : i32;
            v241 = arith.neq v239, v240 : i1;
            v242 = arith.zext v241 : u32;
            v243 = hir.bitcast v242 : i32;
            v245 = arith.neq v243, v752 : i1;
            cf.cond_br v245 ^block39, ^block40;
        ^block39:
            v254 = arith.constant 12 : u32;
            v253 = hir.bitcast v219 : u32;
            v255 = arith.add v253, v254 : u32 #[overflow = checked];
            v751 = arith.constant 4 : u32;
            v257 = arith.mod v255, v751 : u32;
            hir.assertz v257 #[code = 250];
            v258 = hir.int_to_ptr v255 : ptr<byte, i32>;
            v259 = hir.load v258 : i32;
            v750 = arith.constant 4 : u32;
            v260 = hir.bitcast v210 : u32;
            v262 = arith.add v260, v750 : u32 #[overflow = checked];
            v749 = arith.constant 4 : u32;
            v264 = arith.mod v262, v749 : u32;
            hir.assertz v264 #[code = 250];
            v265 = hir.int_to_ptr v262 : ptr<byte, i32>;
            hir.store v265, v259;
            v266 = hir.bitcast v210 : u32;
            v748 = arith.constant 4 : u32;
            v268 = arith.mod v266, v748 : u32;
            hir.assertz v268 #[code = 250];
            v269 = hir.int_to_ptr v266 : ptr<byte, i32>;
            hir.store v269, v232;
            v747 = arith.constant 16 : i32;
            v271 = arith.add v219, v747 : i32 #[overflow = wrapping];
            v272 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v273 = hir.bitcast v272 : ptr<byte, i32>;
            hir.store v273, v271;
            builtin.ret ;
        ^block40:
            v746 = arith.constant 12 : u32;
            v246 = hir.bitcast v219 : u32;
            v248 = arith.add v246, v746 : u32 #[overflow = checked];
            v745 = arith.constant 4 : u32;
            v250 = arith.mod v248, v745 : u32;
            hir.assertz v250 #[code = 250];
            v251 = hir.int_to_ptr v248 : ptr<byte, i32>;
            v252 = hir.load v251 : i32;
            hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/alloc::raw_vec::handle_error(v232, v252, v213)
            ub.unreachable ;
        };

        private builtin.function @miden_base_sys::bindings::note::get_inputs(v274: i32) {
        ^block41(v274: i32):
            v276 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v277 = hir.bitcast v276 : ptr<byte, i32>;
            v278 = hir.load v277 : i32;
            v279 = arith.constant 16 : i32;
            v280 = arith.sub v278, v279 : i32 #[overflow = wrapping];
            v281 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v282 = hir.bitcast v281 : ptr<byte, i32>;
            hir.store v282, v280;
            v287 = arith.constant 1048620 : i32;
            v285 = arith.constant 4 : i32;
            v283 = arith.constant 8 : i32;
            v284 = arith.add v280, v283 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/alloc::raw_vec::RawVecInner<A>::with_capacity_in(v284, v285, v285, v287)
            v289 = arith.constant 8 : u32;
            v288 = hir.bitcast v280 : u32;
            v290 = arith.add v288, v289 : u32 #[overflow = checked];
            v291 = arith.constant 4 : u32;
            v292 = arith.mod v290, v291 : u32;
            hir.assertz v292 #[code = 250];
            v293 = hir.int_to_ptr v290 : ptr<byte, i32>;
            v294 = hir.load v293 : i32;
            v296 = arith.constant 12 : u32;
            v295 = hir.bitcast v280 : u32;
            v297 = arith.add v295, v296 : u32 #[overflow = checked];
            v762 = arith.constant 4 : u32;
            v299 = arith.mod v297, v762 : u32;
            hir.assertz v299 #[code = 250];
            v300 = hir.int_to_ptr v297 : ptr<byte, i32>;
            v301 = hir.load v300 : i32;
            v755 = arith.constant 2 : u32;
            v303 = hir.bitcast v301 : u32;
            v305 = arith.shr v303, v755 : u32;
            v306 = hir.bitcast v305 : i32;
            v307 = hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/miden_base_sys::bindings::note::extern_note_get_inputs(v306) : i32
            v761 = arith.constant 8 : u32;
            v308 = hir.bitcast v274 : u32;
            v310 = arith.add v308, v761 : u32 #[overflow = checked];
            v760 = arith.constant 4 : u32;
            v312 = arith.mod v310, v760 : u32;
            hir.assertz v312 #[code = 250];
            v313 = hir.int_to_ptr v310 : ptr<byte, i32>;
            hir.store v313, v307;
            v759 = arith.constant 4 : u32;
            v314 = hir.bitcast v274 : u32;
            v316 = arith.add v314, v759 : u32 #[overflow = checked];
            v758 = arith.constant 4 : u32;
            v318 = arith.mod v316, v758 : u32;
            hir.assertz v318 #[code = 250];
            v319 = hir.int_to_ptr v316 : ptr<byte, i32>;
            hir.store v319, v301;
            v320 = hir.bitcast v274 : u32;
            v757 = arith.constant 4 : u32;
            v322 = arith.mod v320, v757 : u32;
            hir.assertz v322 #[code = 250];
            v323 = hir.int_to_ptr v320 : ptr<byte, i32>;
            hir.store v323, v294;
            v756 = arith.constant 16 : i32;
            v325 = arith.add v280, v756 : i32 #[overflow = wrapping];
            v326 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v327 = hir.bitcast v326 : ptr<byte, i32>;
            hir.store v327, v325;
            builtin.ret ;
        };

        private builtin.function @<miden_stdlib_sys::intrinsics::felt::Felt as core::convert::From<u32>>::from(v328: i32) -> felt {
        ^block43(v328: i32):
            v330 = hir.bitcast v328 : felt;
            builtin.ret v330;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v331: i32, v332: i32, v333: i32) {
        ^block45(v331: i32, v332: i32, v333: i32):
            v335 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v336 = hir.bitcast v335 : ptr<byte, i32>;
            v337 = hir.load v336 : i32;
            v338 = arith.constant 16 : i32;
            v339 = arith.sub v337, v338 : i32 #[overflow = wrapping];
            v340 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v341 = hir.bitcast v340 : ptr<byte, i32>;
            hir.store v341, v339;
            v342 = arith.constant 4 : i32;
            v343 = arith.add v339, v342 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/alloc::raw_vec::RawVecInner<A>::current_memory(v343, v331, v332, v333)
            v345 = arith.constant 8 : u32;
            v344 = hir.bitcast v339 : u32;
            v346 = arith.add v344, v345 : u32 #[overflow = checked];
            v347 = arith.constant 4 : u32;
            v348 = arith.mod v346, v347 : u32;
            hir.assertz v348 #[code = 250];
            v349 = hir.int_to_ptr v346 : ptr<byte, i32>;
            v350 = hir.load v349 : i32;
            v769 = arith.constant 0 : i32;
            v334 = arith.constant 0 : i32;
            v352 = arith.eq v350, v334 : i1;
            v353 = arith.zext v352 : u32;
            v354 = hir.bitcast v353 : i32;
            v356 = arith.neq v354, v769 : i1;
            scf.if v356{
            ^block107:
                scf.yield ;
            } else {
            ^block48:
                v768 = arith.constant 4 : u32;
                v357 = hir.bitcast v339 : u32;
                v359 = arith.add v357, v768 : u32 #[overflow = checked];
                v767 = arith.constant 4 : u32;
                v361 = arith.mod v359, v767 : u32;
                hir.assertz v361 #[code = 250];
                v362 = hir.int_to_ptr v359 : ptr<byte, i32>;
                v363 = hir.load v362 : i32;
                v365 = arith.constant 12 : u32;
                v364 = hir.bitcast v339 : u32;
                v366 = arith.add v364, v365 : u32 #[overflow = checked];
                v766 = arith.constant 4 : u32;
                v368 = arith.mod v366, v766 : u32;
                hir.assertz v368 #[code = 250];
                v369 = hir.int_to_ptr v366 : ptr<byte, i32>;
                v370 = hir.load v369 : i32;
                hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v363, v350, v370)
                scf.yield ;
            };
            v765 = arith.constant 16 : i32;
            v373 = arith.add v339, v765 : i32 #[overflow = wrapping];
            v374 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v375 = hir.bitcast v374 : ptr<byte, i32>;
            hir.store v375, v373;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::try_allocate_in(v376: i32, v377: i32, v378: i32, v379: i32, v380: i32) {
        ^block49(v376: i32, v377: i32, v378: i32, v379: i32, v380: i32):
            v383 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v384 = hir.bitcast v383 : ptr<byte, i32>;
            v385 = hir.load v384 : i32;
            v386 = arith.constant 16 : i32;
            v387 = arith.sub v385, v386 : i32 #[overflow = wrapping];
            v388 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v389 = hir.bitcast v388 : ptr<byte, i32>;
            hir.store v389, v387;
            v399 = hir.bitcast v377 : u32;
            v400 = arith.zext v399 : u64;
            v401 = hir.bitcast v400 : i64;
            v381 = arith.constant 0 : i32;
            v394 = arith.sub v381, v379 : i32 #[overflow = wrapping];
            v391 = arith.constant -1 : i32;
            v390 = arith.add v379, v380 : i32 #[overflow = wrapping];
            v392 = arith.add v390, v391 : i32 #[overflow = wrapping];
            v395 = arith.band v392, v394 : i32;
            v396 = hir.bitcast v395 : u32;
            v397 = arith.zext v396 : u64;
            v398 = hir.bitcast v397 : i64;
            v402 = arith.mul v398, v401 : i64 #[overflow = wrapping];
            v873 = arith.constant 0 : i32;
            v403 = arith.constant 32 : i64;
            v405 = hir.cast v403 : u32;
            v404 = hir.bitcast v402 : u64;
            v406 = arith.shr v404, v405 : u64;
            v407 = hir.bitcast v406 : i64;
            v408 = arith.trunc v407 : i32;
            v410 = arith.neq v408, v873 : i1;
            v785, v786, v787, v788, v789, v790 = scf.if v410 : i32, i32, i32, i32, i32, u32 {
            ^block109:
                v770 = arith.constant 0 : u32;
                v777 = ub.poison i32 : i32;
                scf.yield v376, v387, v777, v777, v777, v770;
            } else {
            ^block54:
                v411 = arith.trunc v402 : i32;
                v872 = arith.constant 0 : i32;
                v412 = arith.constant -2147483648 : i32;
                v413 = arith.sub v412, v379 : i32 #[overflow = wrapping];
                v415 = hir.bitcast v413 : u32;
                v414 = hir.bitcast v411 : u32;
                v416 = arith.lte v414, v415 : i1;
                v417 = arith.zext v416 : u32;
                v418 = hir.bitcast v417 : i32;
                v420 = arith.neq v418, v872 : i1;
                v833 = scf.if v420 : i32 {
                ^block52:
                    v871 = arith.constant 0 : i32;
                    v431 = arith.neq v411, v871 : i1;
                    v832 = scf.if v431 : i32 {
                    ^block56:
                        v870 = arith.constant 0 : i32;
                        v447 = arith.neq v378, v870 : i1;
                        v831 = scf.if v447 : i32 {
                        ^block59:
                            v429 = arith.constant 1 : i32;
                            hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/alloc::alloc::Global::alloc_impl(v387, v379, v411, v429)
                            v458 = hir.bitcast v387 : u32;
                            v503 = arith.constant 4 : u32;
                            v460 = arith.mod v458, v503 : u32;
                            hir.assertz v460 #[code = 250];
                            v461 = hir.int_to_ptr v458 : ptr<byte, i32>;
                            v462 = hir.load v461 : i32;
                            scf.yield v462;
                        } else {
                        ^block60:
                            v448 = arith.constant 8 : i32;
                            v449 = arith.add v387, v448 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v449, v379, v411)
                            v433 = arith.constant 8 : u32;
                            v450 = hir.bitcast v387 : u32;
                            v452 = arith.add v450, v433 : u32 #[overflow = checked];
                            v869 = arith.constant 4 : u32;
                            v454 = arith.mod v452, v869 : u32;
                            hir.assertz v454 #[code = 250];
                            v455 = hir.int_to_ptr v452 : ptr<byte, i32>;
                            v456 = hir.load v455 : i32;
                            scf.yield v456;
                        };
                        v867 = arith.constant 0 : i32;
                        v868 = arith.constant 0 : i32;
                        v465 = arith.eq v831, v868 : i1;
                        v466 = arith.zext v465 : u32;
                        v467 = hir.bitcast v466 : i32;
                        v469 = arith.neq v467, v867 : i1;
                        scf.if v469{
                        ^block61:
                            v866 = arith.constant 8 : u32;
                            v486 = hir.bitcast v376 : u32;
                            v488 = arith.add v486, v866 : u32 #[overflow = checked];
                            v865 = arith.constant 4 : u32;
                            v490 = arith.mod v488, v865 : u32;
                            hir.assertz v490 #[code = 250];
                            v491 = hir.int_to_ptr v488 : ptr<byte, i32>;
                            hir.store v491, v411;
                            v864 = arith.constant 4 : u32;
                            v493 = hir.bitcast v376 : u32;
                            v495 = arith.add v493, v864 : u32 #[overflow = checked];
                            v863 = arith.constant 4 : u32;
                            v497 = arith.mod v495, v863 : u32;
                            hir.assertz v497 #[code = 250];
                            v498 = hir.int_to_ptr v495 : ptr<byte, i32>;
                            hir.store v498, v379;
                            scf.yield ;
                        } else {
                        ^block62:
                            v862 = arith.constant 8 : u32;
                            v471 = hir.bitcast v376 : u32;
                            v473 = arith.add v471, v862 : u32 #[overflow = checked];
                            v861 = arith.constant 4 : u32;
                            v475 = arith.mod v473, v861 : u32;
                            hir.assertz v475 #[code = 250];
                            v476 = hir.int_to_ptr v473 : ptr<byte, i32>;
                            hir.store v476, v831;
                            v860 = arith.constant 4 : u32;
                            v478 = hir.bitcast v376 : u32;
                            v480 = arith.add v478, v860 : u32 #[overflow = checked];
                            v859 = arith.constant 4 : u32;
                            v482 = arith.mod v480, v859 : u32;
                            hir.assertz v482 #[code = 250];
                            v483 = hir.int_to_ptr v480 : ptr<byte, i32>;
                            hir.store v483, v377;
                            scf.yield ;
                        };
                        v857 = arith.constant 0 : i32;
                        v858 = arith.constant 1 : i32;
                        v830 = cf.select v469, v858, v857 : i32;
                        scf.yield v830;
                    } else {
                    ^block57:
                        v856 = arith.constant 8 : u32;
                        v432 = hir.bitcast v376 : u32;
                        v434 = arith.add v432, v856 : u32 #[overflow = checked];
                        v855 = arith.constant 4 : u32;
                        v436 = arith.mod v434, v855 : u32;
                        hir.assertz v436 #[code = 250];
                        v437 = hir.int_to_ptr v434 : ptr<byte, i32>;
                        hir.store v437, v379;
                        v854 = arith.constant 4 : u32;
                        v440 = hir.bitcast v376 : u32;
                        v442 = arith.add v440, v854 : u32 #[overflow = checked];
                        v853 = arith.constant 4 : u32;
                        v444 = arith.mod v442, v853 : u32;
                        hir.assertz v444 #[code = 250];
                        v852 = arith.constant 0 : i32;
                        v445 = hir.int_to_ptr v442 : ptr<byte, i32>;
                        hir.store v445, v852;
                        v851 = arith.constant 0 : i32;
                        scf.yield v851;
                    };
                    scf.yield v832;
                } else {
                ^block55:
                    v850 = ub.poison i32 : i32;
                    scf.yield v850;
                };
                v845 = arith.constant 0 : u32;
                v778 = arith.constant 1 : u32;
                v838 = cf.select v420, v778, v845 : u32;
                v846 = ub.poison i32 : i32;
                v837 = cf.select v420, v387, v846 : i32;
                v847 = ub.poison i32 : i32;
                v836 = cf.select v420, v376, v847 : i32;
                v848 = ub.poison i32 : i32;
                v835 = cf.select v420, v848, v387 : i32;
                v849 = ub.poison i32 : i32;
                v834 = cf.select v420, v849, v376 : i32;
                scf.yield v834, v835, v836, v833, v837, v838;
            };
            v791, v792, v793 = scf.index_switch v790 : i32, i32, i32 
            case 0 {
            ^block53:
                v844 = arith.constant 4 : u32;
                v423 = hir.bitcast v785 : u32;
                v425 = arith.add v423, v844 : u32 #[overflow = checked];
                v843 = arith.constant 4 : u32;
                v427 = arith.mod v425, v843 : u32;
                hir.assertz v427 #[code = 250];
                v842 = arith.constant 0 : i32;
                v428 = hir.int_to_ptr v425 : ptr<byte, i32>;
                hir.store v428, v842;
                v841 = arith.constant 1 : i32;
                scf.yield v785, v841, v786;
            }
            default {
            ^block113:
                scf.yield v787, v788, v789;
            };
            v502 = hir.bitcast v791 : u32;
            v840 = arith.constant 4 : u32;
            v504 = arith.mod v502, v840 : u32;
            hir.assertz v504 #[code = 250];
            v505 = hir.int_to_ptr v502 : ptr<byte, i32>;
            hir.store v505, v792;
            v839 = arith.constant 16 : i32;
            v510 = arith.add v793, v839 : i32 #[overflow = wrapping];
            v511 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v512 = hir.bitcast v511 : ptr<byte, i32>;
            hir.store v512, v510;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v513: i32, v514: i32, v515: i32) {
        ^block63(v513: i32, v514: i32, v515: i32):
            v517 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v518 = hir.bitcast v517 : ptr<byte, i32>;
            v519 = hir.load v518 : i32;
            v520 = arith.constant 16 : i32;
            v521 = arith.sub v519, v520 : i32 #[overflow = wrapping];
            v522 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v523 = hir.bitcast v522 : ptr<byte, i32>;
            hir.store v523, v521;
            v516 = arith.constant 0 : i32;
            v524 = arith.constant 8 : i32;
            v525 = arith.add v521, v524 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/alloc::alloc::Global::alloc_impl(v525, v514, v515, v516)
            v528 = arith.constant 12 : u32;
            v527 = hir.bitcast v521 : u32;
            v529 = arith.add v527, v528 : u32 #[overflow = checked];
            v530 = arith.constant 4 : u32;
            v531 = arith.mod v529, v530 : u32;
            hir.assertz v531 #[code = 250];
            v532 = hir.int_to_ptr v529 : ptr<byte, i32>;
            v533 = hir.load v532 : i32;
            v535 = arith.constant 8 : u32;
            v534 = hir.bitcast v521 : u32;
            v536 = arith.add v534, v535 : u32 #[overflow = checked];
            v878 = arith.constant 4 : u32;
            v538 = arith.mod v536, v878 : u32;
            hir.assertz v538 #[code = 250];
            v539 = hir.int_to_ptr v536 : ptr<byte, i32>;
            v540 = hir.load v539 : i32;
            v541 = hir.bitcast v513 : u32;
            v877 = arith.constant 4 : u32;
            v543 = arith.mod v541, v877 : u32;
            hir.assertz v543 #[code = 250];
            v544 = hir.int_to_ptr v541 : ptr<byte, i32>;
            hir.store v544, v540;
            v876 = arith.constant 4 : u32;
            v545 = hir.bitcast v513 : u32;
            v547 = arith.add v545, v876 : u32 #[overflow = checked];
            v875 = arith.constant 4 : u32;
            v549 = arith.mod v547, v875 : u32;
            hir.assertz v549 #[code = 250];
            v550 = hir.int_to_ptr v547 : ptr<byte, i32>;
            hir.store v550, v533;
            v874 = arith.constant 16 : i32;
            v552 = arith.add v521, v874 : i32 #[overflow = wrapping];
            v553 = builtin.global_symbol @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__stack_pointer : ptr<byte, u8>
            v554 = hir.bitcast v553 : ptr<byte, i32>;
            hir.store v554, v552;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v555: i32, v556: i32, v557: i32, v558: i32) {
        ^block65(v555: i32, v556: i32, v557: i32, v558: i32):
            v894 = arith.constant 0 : i32;
            v559 = arith.constant 0 : i32;
            v560 = arith.eq v557, v559 : i1;
            v561 = arith.zext v560 : u32;
            v562 = hir.bitcast v561 : i32;
            v564 = arith.neq v562, v894 : i1;
            v890 = scf.if v564 : i32 {
            ^block116:
                scf.yield v556;
            } else {
            ^block68:
                hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__rustc::__rust_no_alloc_shim_is_unstable_v2()
                v893 = arith.constant 0 : i32;
                v566 = arith.neq v558, v893 : i1;
                v889 = scf.if v566 : i32 {
                ^block69:
                    v568 = hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__rustc::__rust_alloc_zeroed(v557, v556) : i32
                    scf.yield v568;
                } else {
                ^block70:
                    v567 = hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__rustc::__rust_alloc(v557, v556) : i32
                    scf.yield v567;
                };
                scf.yield v889;
            };
            v572 = arith.constant 4 : u32;
            v571 = hir.bitcast v555 : u32;
            v573 = arith.add v571, v572 : u32 #[overflow = checked];
            v892 = arith.constant 4 : u32;
            v575 = arith.mod v573, v892 : u32;
            hir.assertz v575 #[code = 250];
            v576 = hir.int_to_ptr v573 : ptr<byte, i32>;
            hir.store v576, v557;
            v578 = hir.bitcast v555 : u32;
            v891 = arith.constant 4 : u32;
            v580 = arith.mod v578, v891 : u32;
            hir.assertz v580 #[code = 250];
            v581 = hir.int_to_ptr v578 : ptr<byte, i32>;
            hir.store v581, v890;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v582: i32, v583: i32, v584: i32, v585: i32) {
        ^block71(v582: i32, v583: i32, v584: i32, v585: i32):
            v920 = arith.constant 0 : i32;
            v586 = arith.constant 0 : i32;
            v590 = arith.eq v585, v586 : i1;
            v591 = arith.zext v590 : u32;
            v592 = hir.bitcast v591 : i32;
            v594 = arith.neq v592, v920 : i1;
            v907, v908 = scf.if v594 : i32, i32 {
            ^block120:
                v919 = arith.constant 0 : i32;
                v588 = arith.constant 4 : i32;
                scf.yield v588, v919;
            } else {
            ^block74:
                v595 = hir.bitcast v583 : u32;
                v630 = arith.constant 4 : u32;
                v597 = arith.mod v595, v630 : u32;
                hir.assertz v597 #[code = 250];
                v598 = hir.int_to_ptr v595 : ptr<byte, i32>;
                v599 = hir.load v598 : i32;
                v917 = arith.constant 0 : i32;
                v918 = arith.constant 0 : i32;
                v601 = arith.eq v599, v918 : i1;
                v602 = arith.zext v601 : u32;
                v603 = hir.bitcast v602 : i32;
                v605 = arith.neq v603, v917 : i1;
                v905 = scf.if v605 : i32 {
                ^block119:
                    v916 = arith.constant 0 : i32;
                    scf.yield v916;
                } else {
                ^block75:
                    v915 = arith.constant 4 : u32;
                    v606 = hir.bitcast v582 : u32;
                    v608 = arith.add v606, v915 : u32 #[overflow = checked];
                    v914 = arith.constant 4 : u32;
                    v610 = arith.mod v608, v914 : u32;
                    hir.assertz v610 #[code = 250];
                    v611 = hir.int_to_ptr v608 : ptr<byte, i32>;
                    hir.store v611, v584;
                    v913 = arith.constant 4 : u32;
                    v612 = hir.bitcast v583 : u32;
                    v614 = arith.add v612, v913 : u32 #[overflow = checked];
                    v912 = arith.constant 4 : u32;
                    v616 = arith.mod v614, v912 : u32;
                    hir.assertz v616 #[code = 250];
                    v617 = hir.int_to_ptr v614 : ptr<byte, i32>;
                    v618 = hir.load v617 : i32;
                    v619 = hir.bitcast v582 : u32;
                    v911 = arith.constant 4 : u32;
                    v621 = arith.mod v619, v911 : u32;
                    hir.assertz v621 #[code = 250];
                    v622 = hir.int_to_ptr v619 : ptr<byte, i32>;
                    hir.store v622, v618;
                    v623 = arith.mul v599, v585 : i32 #[overflow = wrapping];
                    scf.yield v623;
                };
                v624 = arith.constant 8 : i32;
                v910 = arith.constant 4 : i32;
                v906 = cf.select v605, v910, v624 : i32;
                scf.yield v906, v905;
            };
            v627 = arith.add v582, v907 : i32 #[overflow = wrapping];
            v629 = hir.bitcast v627 : u32;
            v909 = arith.constant 4 : u32;
            v631 = arith.mod v629, v909 : u32;
            hir.assertz v631 #[code = 250];
            v632 = hir.int_to_ptr v629 : ptr<byte, i32>;
            hir.store v632, v908;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v633: i32, v634: i32, v635: i32) {
        ^block76(v633: i32, v634: i32, v635: i32):
            v922 = arith.constant 0 : i32;
            v636 = arith.constant 0 : i32;
            v637 = arith.eq v635, v636 : i1;
            v638 = arith.zext v637 : u32;
            v639 = hir.bitcast v638 : i32;
            v641 = arith.neq v639, v922 : i1;
            scf.if v641{
            ^block78:
                scf.yield ;
            } else {
            ^block79:
                hir.exec @root_ns:root@1.0.0/abi_transform_tx_kernel_get_inputs_4/__rustc::__rust_dealloc(v633, v635, v634)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v642: i32, v643: i32, v644: i32) {
        ^block80(v642: i32, v643: i32, v644: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v645: i32, v646: i32) -> i32 {
        ^block82(v645: i32, v646: i32):
            v653 = arith.constant 0 : i32;
            v649 = hir.bitcast v646 : u32;
            v648 = hir.bitcast v645 : u32;
            v650 = arith.gt v648, v649 : i1;
            v651 = arith.zext v650 : u32;
            v652 = hir.bitcast v651 : i32;
            v654 = arith.neq v652, v653 : i1;
            v655 = cf.select v654, v645, v646 : i32;
            builtin.ret v655;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.segment readonly @1048576 = 0x0000002100000013000000290010000000000073722e65746f6e2f73676e69646e69622f6372732f352e312e302d7379732d657361622d6e6564696d;
    };
};