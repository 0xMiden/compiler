builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_elements_smoke {
        private builtin.function @miden_stdlib_sys::stdlib::crypto::hashes::extern_hash_memory(v0: i32, v1: i32, v2: i32) {
        ^block3(v0: i32, v1: i32, v2: i32):
            v3, v4, v5, v6 = hir.exec @std/crypto/hashes/rpo/hash_memory(v0, v1) : felt, felt, felt, felt
            v7 = hir.bitcast v2 : u32;
            v8 = hir.int_to_ptr v7 : ptr<byte, felt>;
            hir.store v8, v3;
            v9 = arith.constant 4 : u32;
            v10 = arith.add v7, v9 : u32 #[overflow = checked];
            v11 = hir.int_to_ptr v10 : ptr<byte, felt>;
            hir.store v11, v4;
            v12 = arith.constant 8 : u32;
            v13 = arith.add v7, v12 : u32 #[overflow = checked];
            v14 = hir.int_to_ptr v13 : ptr<byte, felt>;
            hir.store v14, v5;
            v15 = arith.constant 12 : u32;
            v16 = arith.add v7, v15 : u32 #[overflow = checked];
            v17 = hir.int_to_ptr v16 : ptr<byte, felt>;
            hir.store v17, v6;
            builtin.ret ;
        };

        public builtin.function @entrypoint(v18: felt, v19: felt, v20: felt, v21: felt, v22: felt, v23: felt, v24: felt, v25: felt) -> felt {
        ^block12(v18: felt, v19: felt, v20: felt, v21: felt, v22: felt, v23: felt, v24: felt, v25: felt):
            v28 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements_smoke/__stack_pointer : ptr<byte, u8>
            v29 = hir.bitcast v28 : ptr<byte, i32>;
            v30 = hir.load v29 : i32;
            v33 = arith.constant -32 : i32;
            v31 = arith.constant 64 : i32;
            v32 = arith.sub v30, v31 : i32 #[overflow = wrapping];
            v34 = arith.band v32, v33 : i32;
            v35 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements_smoke/__stack_pointer : ptr<byte, u8>
            v36 = hir.bitcast v35 : ptr<byte, i32>;
            hir.store v36, v34;
            v501 = arith.constant 0 : felt;
            hir.assert_eq v18, v501;
            v500 = arith.constant 1 : felt;
            hir.assert_eq v19, v500;
            v499 = arith.constant 2 : felt;
            hir.assert_eq v20, v499;
            v498 = arith.constant 3 : felt;
            hir.assert_eq v21, v498;
            v497 = arith.constant 4 : felt;
            hir.assert_eq v22, v497;
            v496 = arith.constant 5 : felt;
            hir.assert_eq v23, v496;
            v495 = arith.constant 6 : felt;
            hir.assert_eq v24, v495;
            v494 = arith.constant 7 : felt;
            hir.assert_eq v25, v494;
            v45 = arith.constant 4 : i32;
            v60 = arith.constant 32 : i32;
            v62 = hir.exec @root_ns:root@1.0.0/hash_elements_smoke/__rustc::__rust_alloc(v60, v45) : i32
            v27 = arith.constant 0 : i32;
            v64 = arith.neq v62, v27 : i1;
            cf.cond_br v64 ^block14, ^block15;
        ^block14:
            v68 = arith.constant 28 : u32;
            v67 = hir.bitcast v62 : u32;
            v69 = arith.add v67, v68 : u32 #[overflow = checked];
            v70 = arith.constant 4 : u32;
            v71 = arith.mod v69, v70 : u32;
            hir.assertz v71 #[code = 250];
            v72 = hir.int_to_ptr v69 : ptr<byte, felt>;
            hir.store v72, v25;
            v74 = arith.constant 24 : u32;
            v73 = hir.bitcast v62 : u32;
            v75 = arith.add v73, v74 : u32 #[overflow = checked];
            v561 = arith.constant 4 : u32;
            v77 = arith.mod v75, v561 : u32;
            hir.assertz v77 #[code = 250];
            v78 = hir.int_to_ptr v75 : ptr<byte, felt>;
            hir.store v78, v24;
            v80 = arith.constant 20 : u32;
            v79 = hir.bitcast v62 : u32;
            v81 = arith.add v79, v80 : u32 #[overflow = checked];
            v560 = arith.constant 4 : u32;
            v83 = arith.mod v81, v560 : u32;
            hir.assertz v83 #[code = 250];
            v84 = hir.int_to_ptr v81 : ptr<byte, felt>;
            hir.store v84, v23;
            v86 = arith.constant 16 : u32;
            v85 = hir.bitcast v62 : u32;
            v87 = arith.add v85, v86 : u32 #[overflow = checked];
            v559 = arith.constant 4 : u32;
            v89 = arith.mod v87, v559 : u32;
            hir.assertz v89 #[code = 250];
            v90 = hir.int_to_ptr v87 : ptr<byte, felt>;
            hir.store v90, v22;
            v92 = arith.constant 12 : u32;
            v91 = hir.bitcast v62 : u32;
            v93 = arith.add v91, v92 : u32 #[overflow = checked];
            v558 = arith.constant 4 : u32;
            v95 = arith.mod v93, v558 : u32;
            hir.assertz v95 #[code = 250];
            v96 = hir.int_to_ptr v93 : ptr<byte, felt>;
            hir.store v96, v21;
            v98 = arith.constant 8 : u32;
            v97 = hir.bitcast v62 : u32;
            v99 = arith.add v97, v98 : u32 #[overflow = checked];
            v557 = arith.constant 4 : u32;
            v101 = arith.mod v99, v557 : u32;
            hir.assertz v101 #[code = 250];
            v102 = hir.int_to_ptr v99 : ptr<byte, felt>;
            hir.store v102, v20;
            v556 = arith.constant 4 : u32;
            v103 = hir.bitcast v62 : u32;
            v105 = arith.add v103, v556 : u32 #[overflow = checked];
            v555 = arith.constant 4 : u32;
            v107 = arith.mod v105, v555 : u32;
            hir.assertz v107 #[code = 250];
            v108 = hir.int_to_ptr v105 : ptr<byte, felt>;
            hir.store v108, v19;
            v109 = hir.bitcast v62 : u32;
            v554 = arith.constant 4 : u32;
            v111 = arith.mod v109, v554 : u32;
            hir.assertz v111 #[code = 250];
            v112 = hir.int_to_ptr v109 : ptr<byte, felt>;
            hir.store v112, v18;
            v553 = arith.constant 0 : felt;
            hir.assert_eq v18, v553;
            v552 = arith.constant 4 : u32;
            v115 = hir.bitcast v62 : u32;
            v117 = arith.add v115, v552 : u32 #[overflow = checked];
            v551 = arith.constant 4 : u32;
            v119 = arith.mod v117, v551 : u32;
            hir.assertz v119 #[code = 250];
            v120 = hir.int_to_ptr v117 : ptr<byte, felt>;
            v121 = hir.load v120 : felt;
            v550 = arith.constant 1 : felt;
            hir.assert_eq v121, v550;
            v549 = arith.constant 8 : u32;
            v124 = hir.bitcast v62 : u32;
            v126 = arith.add v124, v549 : u32 #[overflow = checked];
            v548 = arith.constant 4 : u32;
            v128 = arith.mod v126, v548 : u32;
            hir.assertz v128 #[code = 250];
            v129 = hir.int_to_ptr v126 : ptr<byte, felt>;
            v130 = hir.load v129 : felt;
            v547 = arith.constant 2 : felt;
            hir.assert_eq v130, v547;
            v546 = arith.constant 12 : u32;
            v133 = hir.bitcast v62 : u32;
            v135 = arith.add v133, v546 : u32 #[overflow = checked];
            v545 = arith.constant 4 : u32;
            v137 = arith.mod v135, v545 : u32;
            hir.assertz v137 #[code = 250];
            v138 = hir.int_to_ptr v135 : ptr<byte, felt>;
            v139 = hir.load v138 : felt;
            v544 = arith.constant 3 : felt;
            hir.assert_eq v139, v544;
            v543 = arith.constant 16 : u32;
            v142 = hir.bitcast v62 : u32;
            v144 = arith.add v142, v543 : u32 #[overflow = checked];
            v542 = arith.constant 4 : u32;
            v146 = arith.mod v144, v542 : u32;
            hir.assertz v146 #[code = 250];
            v147 = hir.int_to_ptr v144 : ptr<byte, felt>;
            v148 = hir.load v147 : felt;
            v541 = arith.constant 4 : felt;
            hir.assert_eq v148, v541;
            v540 = arith.constant 20 : u32;
            v151 = hir.bitcast v62 : u32;
            v153 = arith.add v151, v540 : u32 #[overflow = checked];
            v539 = arith.constant 4 : u32;
            v155 = arith.mod v153, v539 : u32;
            hir.assertz v155 #[code = 250];
            v156 = hir.int_to_ptr v153 : ptr<byte, felt>;
            v157 = hir.load v156 : felt;
            v538 = arith.constant 5 : felt;
            hir.assert_eq v157, v538;
            v537 = arith.constant 24 : u32;
            v160 = hir.bitcast v62 : u32;
            v162 = arith.add v160, v537 : u32 #[overflow = checked];
            v536 = arith.constant 4 : u32;
            v164 = arith.mod v162, v536 : u32;
            hir.assertz v164 #[code = 250];
            v165 = hir.int_to_ptr v162 : ptr<byte, felt>;
            v166 = hir.load v165 : felt;
            v535 = arith.constant 6 : felt;
            hir.assert_eq v166, v535;
            v534 = arith.constant 28 : u32;
            v169 = hir.bitcast v62 : u32;
            v171 = arith.add v169, v534 : u32 #[overflow = checked];
            v533 = arith.constant 4 : u32;
            v173 = arith.mod v171, v533 : u32;
            hir.assertz v173 #[code = 250];
            v174 = hir.int_to_ptr v171 : ptr<byte, felt>;
            v175 = hir.load v174 : felt;
            v532 = arith.constant 7 : felt;
            hir.assert_eq v175, v532;
            v531 = arith.constant 28 : u32;
            v179 = hir.bitcast v34 : u32;
            v181 = arith.add v179, v531 : u32 #[overflow = checked];
            v530 = arith.constant 4 : u32;
            v183 = arith.mod v181, v530 : u32;
            hir.assertz v183 #[code = 250];
            v178 = arith.constant 8 : i32;
            v184 = hir.int_to_ptr v181 : ptr<byte, i32>;
            hir.store v184, v178;
            v529 = arith.constant 24 : u32;
            v185 = hir.bitcast v34 : u32;
            v187 = arith.add v185, v529 : u32 #[overflow = checked];
            v528 = arith.constant 4 : u32;
            v189 = arith.mod v187, v528 : u32;
            hir.assertz v189 #[code = 250];
            v190 = hir.int_to_ptr v187 : ptr<byte, i32>;
            hir.store v190, v62;
            v527 = arith.constant 20 : u32;
            v192 = hir.bitcast v34 : u32;
            v194 = arith.add v192, v527 : u32 #[overflow = checked];
            v526 = arith.constant 4 : u32;
            v196 = arith.mod v194, v526 : u32;
            hir.assertz v196 #[code = 250];
            v525 = arith.constant 8 : i32;
            v197 = hir.int_to_ptr v194 : ptr<byte, i32>;
            hir.store v197, v525;
            v198 = hir.bitcast v62 : u32;
            v524 = arith.constant 4 : u32;
            v200 = arith.mod v198, v524 : u32;
            hir.assertz v200 #[code = 250];
            v201 = hir.int_to_ptr v198 : ptr<byte, felt>;
            v202 = hir.load v201 : felt;
            v523 = arith.constant 0 : felt;
            hir.assert_eq v202, v523;
            v522 = arith.constant 16 : u32;
            v205 = hir.bitcast v62 : u32;
            v207 = arith.add v205, v522 : u32 #[overflow = checked];
            v521 = arith.constant 4 : u32;
            v209 = arith.mod v207, v521 : u32;
            hir.assertz v209 #[code = 250];
            v210 = hir.int_to_ptr v207 : ptr<byte, felt>;
            v211 = hir.load v210 : felt;
            v520 = arith.constant 4 : felt;
            hir.assert_eq v211, v520;
            v519 = arith.constant 20 : u32;
            v214 = hir.bitcast v62 : u32;
            v216 = arith.add v214, v519 : u32 #[overflow = checked];
            v518 = arith.constant 4 : u32;
            v218 = arith.mod v216, v518 : u32;
            hir.assertz v218 #[code = 250];
            v219 = hir.int_to_ptr v216 : ptr<byte, felt>;
            v220 = hir.load v219 : felt;
            v517 = arith.constant 5 : felt;
            hir.assert_eq v220, v517;
            v516 = arith.constant 24 : u32;
            v223 = hir.bitcast v62 : u32;
            v225 = arith.add v223, v516 : u32 #[overflow = checked];
            v515 = arith.constant 4 : u32;
            v227 = arith.mod v225, v515 : u32;
            hir.assertz v227 #[code = 250];
            v228 = hir.int_to_ptr v225 : ptr<byte, felt>;
            v229 = hir.load v228 : felt;
            v514 = arith.constant 6 : felt;
            hir.assert_eq v229, v514;
            v513 = arith.constant 28 : u32;
            v232 = hir.bitcast v62 : u32;
            v234 = arith.add v232, v513 : u32 #[overflow = checked];
            v512 = arith.constant 4 : u32;
            v236 = arith.mod v234, v512 : u32;
            hir.assertz v236 #[code = 250];
            v237 = hir.int_to_ptr v234 : ptr<byte, felt>;
            v238 = hir.load v237 : felt;
            v511 = arith.constant 7 : felt;
            hir.assert_eq v238, v511;
            v480 = arith.constant 8 : felt;
            hir.assert_eq v480, v480;
            v478 = arith.constant 2 : u32;
            v246 = hir.bitcast v62 : u32;
            v248 = arith.shr v246, v478 : u32;
            v249 = hir.bitcast v248 : i32;
            v510 = arith.constant 0 : felt;
            v43 = arith.constant 3 : i32;
            v251 = arith.band v249, v43 : i32;
            v252 = hir.bitcast v251 : felt;
            hir.assert_eq v252, v510;
            v508 = arith.constant 32 : i32;
            v257 = arith.add v34, v508 : i32 #[overflow = wrapping];
            v509 = arith.constant 8 : i32;
            hir.exec @root_ns:root@1.0.0/hash_elements_smoke/miden_stdlib_sys::stdlib::crypto::hashes::extern_hash_memory(v249, v509, v257)
            v259 = arith.constant 44 : u32;
            v258 = hir.bitcast v34 : u32;
            v260 = arith.add v258, v259 : u32 #[overflow = checked];
            v507 = arith.constant 4 : u32;
            v262 = arith.mod v260, v507 : u32;
            hir.assertz v262 #[code = 250];
            v263 = hir.int_to_ptr v260 : ptr<byte, felt>;
            v264 = hir.load v263 : felt;
            v506 = arith.constant 4 : i32;
            v265 = arith.constant 20 : i32;
            v266 = arith.add v34, v265 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements_smoke/alloc::raw_vec::RawVecInner<A>::deallocate(v266, v506, v506)
            v269 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements_smoke/__stack_pointer : ptr<byte, u8>
            v270 = hir.bitcast v269 : ptr<byte, i32>;
            hir.store v270, v30;
            builtin.ret v264;
        ^block15:
            v504 = arith.constant 32 : i32;
            v505 = arith.constant 4 : i32;
            hir.exec @root_ns:root@1.0.0/hash_elements_smoke/alloc::alloc::handle_alloc_error(v505, v504)
            ub.unreachable ;
        };

        private builtin.function @__rustc::__rust_alloc(v271: i32, v272: i32) -> i32 {
        ^block16(v271: i32, v272: i32):
            v274 = arith.constant 1048576 : i32;
            v275 = hir.exec @root_ns:root@1.0.0/hash_elements_smoke/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v274, v272, v271) : i32
            builtin.ret v275;
        };

        private builtin.function @__rustc::__rust_dealloc(v276: i32, v277: i32, v278: i32) {
        ^block18(v276: i32, v277: i32, v278: i32):
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v279: i32, v280: i32, v281: i32) -> i32 {
        ^block20(v279: i32, v280: i32, v281: i32):
            v284 = arith.constant 16 : i32;
            v283 = arith.constant 0 : i32;
            v563 = arith.constant 16 : u32;
            v286 = hir.bitcast v280 : u32;
            v288 = arith.gt v286, v563 : i1;
            v289 = arith.zext v288 : u32;
            v290 = hir.bitcast v289 : i32;
            v292 = arith.neq v290, v283 : i1;
            v293 = cf.select v292, v280, v284 : i32;
            v602 = arith.constant 0 : i32;
            v294 = arith.constant -1 : i32;
            v295 = arith.add v293, v294 : i32 #[overflow = wrapping];
            v296 = arith.band v293, v295 : i32;
            v298 = arith.neq v296, v602 : i1;
            v572, v573 = scf.if v298 : i32, u32 {
            ^block50:
                v564 = arith.constant 0 : u32;
                v568 = ub.poison i32 : i32;
                scf.yield v568, v564;
            } else {
            ^block23:
                v300 = hir.exec @root_ns:root@1.0.0/hash_elements_smoke/core::ptr::alignment::Alignment::max(v280, v293) : i32
                v601 = arith.constant 0 : i32;
                v299 = arith.constant -2147483648 : i32;
                v301 = arith.sub v299, v300 : i32 #[overflow = wrapping];
                v303 = hir.bitcast v301 : u32;
                v302 = hir.bitcast v281 : u32;
                v304 = arith.gt v302, v303 : i1;
                v305 = arith.zext v304 : u32;
                v306 = hir.bitcast v305 : i32;
                v308 = arith.neq v306, v601 : i1;
                v587 = scf.if v308 : i32 {
                ^block49:
                    v600 = ub.poison i32 : i32;
                    scf.yield v600;
                } else {
                ^block24:
                    v598 = arith.constant 0 : i32;
                    v314 = arith.sub v598, v300 : i32 #[overflow = wrapping];
                    v599 = arith.constant -1 : i32;
                    v310 = arith.add v281, v300 : i32 #[overflow = wrapping];
                    v312 = arith.add v310, v599 : i32 #[overflow = wrapping];
                    v315 = arith.band v312, v314 : i32;
                    v316 = hir.bitcast v279 : u32;
                    v317 = arith.constant 4 : u32;
                    v318 = arith.mod v316, v317 : u32;
                    hir.assertz v318 #[code = 250];
                    v319 = hir.int_to_ptr v316 : ptr<byte, i32>;
                    v320 = hir.load v319 : i32;
                    v597 = arith.constant 0 : i32;
                    v322 = arith.neq v320, v597 : i1;
                    scf.if v322{
                    ^block48:
                        scf.yield ;
                    } else {
                    ^block26:
                        v323 = hir.exec @intrinsics/mem/heap_base() : i32
                        v324 = hir.mem_size  : u32;
                        v330 = hir.bitcast v279 : u32;
                        v596 = arith.constant 4 : u32;
                        v332 = arith.mod v330, v596 : u32;
                        hir.assertz v332 #[code = 250];
                        v595 = arith.constant 16 : u32;
                        v325 = hir.bitcast v324 : i32;
                        v328 = arith.shl v325, v595 : i32;
                        v329 = arith.add v323, v328 : i32 #[overflow = wrapping];
                        v333 = hir.int_to_ptr v330 : ptr<byte, i32>;
                        hir.store v333, v329;
                        scf.yield ;
                    };
                    v336 = hir.bitcast v279 : u32;
                    v594 = arith.constant 4 : u32;
                    v338 = arith.mod v336, v594 : u32;
                    hir.assertz v338 #[code = 250];
                    v339 = hir.int_to_ptr v336 : ptr<byte, i32>;
                    v340 = hir.load v339 : i32;
                    v593 = arith.constant 0 : i32;
                    v344 = hir.bitcast v315 : u32;
                    v334 = arith.constant 268435456 : i32;
                    v341 = arith.sub v334, v340 : i32 #[overflow = wrapping];
                    v343 = hir.bitcast v341 : u32;
                    v345 = arith.lt v343, v344 : i1;
                    v346 = arith.zext v345 : u32;
                    v347 = hir.bitcast v346 : i32;
                    v349 = arith.neq v347, v593 : i1;
                    v586 = scf.if v349 : i32 {
                    ^block27:
                        v592 = arith.constant 0 : i32;
                        scf.yield v592;
                    } else {
                    ^block28:
                        v351 = hir.bitcast v279 : u32;
                        v591 = arith.constant 4 : u32;
                        v353 = arith.mod v351, v591 : u32;
                        hir.assertz v353 #[code = 250];
                        v350 = arith.add v340, v315 : i32 #[overflow = wrapping];
                        v354 = hir.int_to_ptr v351 : ptr<byte, i32>;
                        hir.store v354, v350;
                        v356 = arith.add v340, v300 : i32 #[overflow = wrapping];
                        scf.yield v356;
                    };
                    scf.yield v586;
                };
                v569 = arith.constant 1 : u32;
                v590 = arith.constant 0 : u32;
                v588 = cf.select v308, v590, v569 : u32;
                scf.yield v587, v588;
            };
            v589 = arith.constant 0 : u32;
            v585 = arith.eq v573, v589 : i1;
            cf.cond_br v585 ^block22, ^block52(v572);
        ^block22:
            ub.unreachable ;
        ^block52(v565: i32):
            builtin.ret v565;
        };

        private builtin.function @alloc::alloc::handle_alloc_error(v359: i32, v360: i32) {
        ^block29(v359: i32, v360: i32):
            ub.unreachable ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v361: i32, v362: i32, v363: i32) {
        ^block31(v361: i32, v362: i32, v363: i32):
            v365 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements_smoke/__stack_pointer : ptr<byte, u8>
            v366 = hir.bitcast v365 : ptr<byte, i32>;
            v367 = hir.load v366 : i32;
            v368 = arith.constant 16 : i32;
            v369 = arith.sub v367, v368 : i32 #[overflow = wrapping];
            v370 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements_smoke/__stack_pointer : ptr<byte, u8>
            v371 = hir.bitcast v370 : ptr<byte, i32>;
            hir.store v371, v369;
            v372 = arith.constant 4 : i32;
            v373 = arith.add v369, v372 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements_smoke/alloc::raw_vec::RawVecInner<A>::current_memory(v373, v361, v362, v363)
            v375 = arith.constant 8 : u32;
            v374 = hir.bitcast v369 : u32;
            v376 = arith.add v374, v375 : u32 #[overflow = checked];
            v377 = arith.constant 4 : u32;
            v378 = arith.mod v376, v377 : u32;
            hir.assertz v378 #[code = 250];
            v379 = hir.int_to_ptr v376 : ptr<byte, i32>;
            v380 = hir.load v379 : i32;
            v609 = arith.constant 0 : i32;
            v364 = arith.constant 0 : i32;
            v382 = arith.eq v380, v364 : i1;
            v383 = arith.zext v382 : u32;
            v384 = hir.bitcast v383 : i32;
            v386 = arith.neq v384, v609 : i1;
            scf.if v386{
            ^block56:
                scf.yield ;
            } else {
            ^block34:
                v608 = arith.constant 4 : u32;
                v387 = hir.bitcast v369 : u32;
                v389 = arith.add v387, v608 : u32 #[overflow = checked];
                v607 = arith.constant 4 : u32;
                v391 = arith.mod v389, v607 : u32;
                hir.assertz v391 #[code = 250];
                v392 = hir.int_to_ptr v389 : ptr<byte, i32>;
                v393 = hir.load v392 : i32;
                v395 = arith.constant 12 : u32;
                v394 = hir.bitcast v369 : u32;
                v396 = arith.add v394, v395 : u32 #[overflow = checked];
                v606 = arith.constant 4 : u32;
                v398 = arith.mod v396, v606 : u32;
                hir.assertz v398 #[code = 250];
                v399 = hir.int_to_ptr v396 : ptr<byte, i32>;
                v400 = hir.load v399 : i32;
                hir.exec @root_ns:root@1.0.0/hash_elements_smoke/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v393, v380, v400)
                scf.yield ;
            };
            v605 = arith.constant 16 : i32;
            v403 = arith.add v369, v605 : i32 #[overflow = wrapping];
            v404 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements_smoke/__stack_pointer : ptr<byte, u8>
            v405 = hir.bitcast v404 : ptr<byte, i32>;
            hir.store v405, v403;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v406: i32, v407: i32, v408: i32, v409: i32) {
        ^block35(v406: i32, v407: i32, v408: i32, v409: i32):
            v635 = arith.constant 0 : i32;
            v410 = arith.constant 0 : i32;
            v414 = arith.eq v409, v410 : i1;
            v415 = arith.zext v414 : u32;
            v416 = hir.bitcast v415 : i32;
            v418 = arith.neq v416, v635 : i1;
            v622, v623 = scf.if v418 : i32, i32 {
            ^block59:
                v634 = arith.constant 0 : i32;
                v412 = arith.constant 4 : i32;
                scf.yield v412, v634;
            } else {
            ^block38:
                v419 = hir.bitcast v407 : u32;
                v454 = arith.constant 4 : u32;
                v421 = arith.mod v419, v454 : u32;
                hir.assertz v421 #[code = 250];
                v422 = hir.int_to_ptr v419 : ptr<byte, i32>;
                v423 = hir.load v422 : i32;
                v632 = arith.constant 0 : i32;
                v633 = arith.constant 0 : i32;
                v425 = arith.eq v423, v633 : i1;
                v426 = arith.zext v425 : u32;
                v427 = hir.bitcast v426 : i32;
                v429 = arith.neq v427, v632 : i1;
                v620 = scf.if v429 : i32 {
                ^block58:
                    v631 = arith.constant 0 : i32;
                    scf.yield v631;
                } else {
                ^block39:
                    v630 = arith.constant 4 : u32;
                    v430 = hir.bitcast v406 : u32;
                    v432 = arith.add v430, v630 : u32 #[overflow = checked];
                    v629 = arith.constant 4 : u32;
                    v434 = arith.mod v432, v629 : u32;
                    hir.assertz v434 #[code = 250];
                    v435 = hir.int_to_ptr v432 : ptr<byte, i32>;
                    hir.store v435, v408;
                    v628 = arith.constant 4 : u32;
                    v436 = hir.bitcast v407 : u32;
                    v438 = arith.add v436, v628 : u32 #[overflow = checked];
                    v627 = arith.constant 4 : u32;
                    v440 = arith.mod v438, v627 : u32;
                    hir.assertz v440 #[code = 250];
                    v441 = hir.int_to_ptr v438 : ptr<byte, i32>;
                    v442 = hir.load v441 : i32;
                    v443 = hir.bitcast v406 : u32;
                    v626 = arith.constant 4 : u32;
                    v445 = arith.mod v443, v626 : u32;
                    hir.assertz v445 #[code = 250];
                    v446 = hir.int_to_ptr v443 : ptr<byte, i32>;
                    hir.store v446, v442;
                    v447 = arith.mul v423, v409 : i32 #[overflow = wrapping];
                    scf.yield v447;
                };
                v448 = arith.constant 8 : i32;
                v625 = arith.constant 4 : i32;
                v621 = cf.select v429, v625, v448 : i32;
                scf.yield v621, v620;
            };
            v451 = arith.add v406, v622 : i32 #[overflow = wrapping];
            v453 = hir.bitcast v451 : u32;
            v624 = arith.constant 4 : u32;
            v455 = arith.mod v453, v624 : u32;
            hir.assertz v455 #[code = 250];
            v456 = hir.int_to_ptr v453 : ptr<byte, i32>;
            hir.store v456, v623;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v457: i32, v458: i32, v459: i32) {
        ^block40(v457: i32, v458: i32, v459: i32):
            v637 = arith.constant 0 : i32;
            v460 = arith.constant 0 : i32;
            v461 = arith.eq v459, v460 : i1;
            v462 = arith.zext v461 : u32;
            v463 = hir.bitcast v462 : i32;
            v465 = arith.neq v463, v637 : i1;
            scf.if v465{
            ^block42:
                scf.yield ;
            } else {
            ^block43:
                hir.exec @root_ns:root@1.0.0/hash_elements_smoke/__rustc::__rust_dealloc(v457, v459, v458)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v466: i32, v467: i32) -> i32 {
        ^block44(v466: i32, v467: i32):
            v474 = arith.constant 0 : i32;
            v470 = hir.bitcast v467 : u32;
            v469 = hir.bitcast v466 : u32;
            v471 = arith.gt v469, v470 : i1;
            v472 = arith.zext v471 : u32;
            v473 = hir.bitcast v472 : i32;
            v475 = arith.neq v473, v474 : i1;
            v476 = cf.select v475, v466, v467 : i32;
            builtin.ret v476;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };
    };
};