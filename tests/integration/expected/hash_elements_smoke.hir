builtin.component root_ns:root@1.0.0 {
    builtin.module public @hash_elements_smoke {
        private builtin.function @miden_stdlib_sys::stdlib::crypto::hashes::extern_hash_memory(v0: i32, v1: i32, v2: i32) {
        ^block3(v0: i32, v1: i32, v2: i32):
            v3, v4, v5, v6 = hir.exec @std/crypto/hashes/rpo/hash_memory(v0, v1) : felt, felt, felt, felt
            v7 = hir.bitcast v2 : u32;
            v8 = hir.int_to_ptr v7 : ptr<byte, felt>;
            hir.store v8, v3;
            v9 = arith.constant 4 : u32;
            v10 = arith.add v7, v9 : u32 #[overflow = checked];
            v11 = hir.int_to_ptr v10 : ptr<byte, felt>;
            hir.store v11, v4;
            v12 = arith.constant 8 : u32;
            v13 = arith.add v7, v12 : u32 #[overflow = checked];
            v14 = hir.int_to_ptr v13 : ptr<byte, felt>;
            hir.store v14, v5;
            v15 = arith.constant 12 : u32;
            v16 = arith.add v7, v15 : u32 #[overflow = checked];
            v17 = hir.int_to_ptr v16 : ptr<byte, felt>;
            hir.store v17, v6;
            builtin.ret ;
        };

        public builtin.function @entrypoint(v18: felt, v19: felt, v20: felt, v21: felt, v22: felt, v23: felt, v24: felt, v25: felt) -> felt {
        ^block12(v18: felt, v19: felt, v20: felt, v21: felt, v22: felt, v23: felt, v24: felt, v25: felt):
            v28 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements_smoke/__stack_pointer : ptr<byte, u8>
            v29 = hir.bitcast v28 : ptr<byte, i32>;
            v30 = hir.load v29 : i32;
            v33 = arith.constant -32 : i32;
            v31 = arith.constant 96 : i32;
            v32 = arith.sub v30, v31 : i32 #[overflow = wrapping];
            v34 = arith.band v32, v33 : i32;
            v35 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements_smoke/__stack_pointer : ptr<byte, u8>
            v36 = hir.bitcast v35 : ptr<byte, i32>;
            hir.store v36, v34;
            v38 = arith.constant 28 : u32;
            v37 = hir.bitcast v34 : u32;
            v39 = arith.add v37, v38 : u32 #[overflow = checked];
            v40 = arith.constant 4 : u32;
            v41 = arith.mod v39, v40 : u32;
            hir.assertz v41 #[code = 250];
            v42 = hir.int_to_ptr v39 : ptr<byte, felt>;
            hir.store v42, v25;
            v44 = arith.constant 24 : u32;
            v43 = hir.bitcast v34 : u32;
            v45 = arith.add v43, v44 : u32 #[overflow = checked];
            v738 = arith.constant 4 : u32;
            v47 = arith.mod v45, v738 : u32;
            hir.assertz v47 #[code = 250];
            v48 = hir.int_to_ptr v45 : ptr<byte, felt>;
            hir.store v48, v24;
            v50 = arith.constant 20 : u32;
            v49 = hir.bitcast v34 : u32;
            v51 = arith.add v49, v50 : u32 #[overflow = checked];
            v737 = arith.constant 4 : u32;
            v53 = arith.mod v51, v737 : u32;
            hir.assertz v53 #[code = 250];
            v54 = hir.int_to_ptr v51 : ptr<byte, felt>;
            hir.store v54, v23;
            v56 = arith.constant 16 : u32;
            v55 = hir.bitcast v34 : u32;
            v57 = arith.add v55, v56 : u32 #[overflow = checked];
            v736 = arith.constant 4 : u32;
            v59 = arith.mod v57, v736 : u32;
            hir.assertz v59 #[code = 250];
            v60 = hir.int_to_ptr v57 : ptr<byte, felt>;
            hir.store v60, v22;
            v62 = arith.constant 12 : u32;
            v61 = hir.bitcast v34 : u32;
            v63 = arith.add v61, v62 : u32 #[overflow = checked];
            v735 = arith.constant 4 : u32;
            v65 = arith.mod v63, v735 : u32;
            hir.assertz v65 #[code = 250];
            v66 = hir.int_to_ptr v63 : ptr<byte, felt>;
            hir.store v66, v21;
            v68 = arith.constant 8 : u32;
            v67 = hir.bitcast v34 : u32;
            v69 = arith.add v67, v68 : u32 #[overflow = checked];
            v734 = arith.constant 4 : u32;
            v71 = arith.mod v69, v734 : u32;
            hir.assertz v71 #[code = 250];
            v72 = hir.int_to_ptr v69 : ptr<byte, felt>;
            hir.store v72, v20;
            v733 = arith.constant 4 : u32;
            v73 = hir.bitcast v34 : u32;
            v75 = arith.add v73, v733 : u32 #[overflow = checked];
            v732 = arith.constant 4 : u32;
            v77 = arith.mod v75, v732 : u32;
            hir.assertz v77 #[code = 250];
            v78 = hir.int_to_ptr v75 : ptr<byte, felt>;
            hir.store v78, v19;
            v79 = hir.bitcast v34 : u32;
            v731 = arith.constant 4 : u32;
            v81 = arith.mod v79, v731 : u32;
            hir.assertz v81 #[code = 250];
            v82 = hir.int_to_ptr v79 : ptr<byte, felt>;
            hir.store v82, v18;
            v27 = arith.constant 0 : i32;
            v83 = arith.constant 12 : i32;
            v84 = arith.band v34, v83 : i32;
            v86 = arith.neq v84, v27 : i1;
            v687, v688, v689 = scf.if v86 : i32, i32, u32 {
            ^block16:
                v99 = arith.constant 4 : i32;
                v730 = arith.constant 0 : i32;
                v97 = arith.constant 8 : i32;
                v95 = arith.constant 32 : i32;
                v96 = arith.add v34, v95 : i32 #[overflow = wrapping];
                hir.exec @root_ns:root@1.0.0/hash_elements_smoke/alloc::raw_vec::RawVecInner<A>::try_allocate_in(v96, v97, v730, v99, v99)
                v102 = arith.constant 36 : u32;
                v101 = hir.bitcast v34 : u32;
                v103 = arith.add v101, v102 : u32 #[overflow = checked];
                v729 = arith.constant 4 : u32;
                v105 = arith.mod v103, v729 : u32;
                hir.assertz v105 #[code = 250];
                v106 = hir.int_to_ptr v103 : ptr<byte, i32>;
                v107 = hir.load v106 : i32;
                v109 = arith.constant 32 : u32;
                v108 = hir.bitcast v34 : u32;
                v110 = arith.add v108, v109 : u32 #[overflow = checked];
                v728 = arith.constant 4 : u32;
                v112 = arith.mod v110, v728 : u32;
                hir.assertz v112 #[code = 250];
                v113 = hir.int_to_ptr v110 : ptr<byte, i32>;
                v114 = hir.load v113 : i32;
                v727 = arith.constant 0 : i32;
                v115 = arith.constant 1 : i32;
                v116 = arith.eq v114, v115 : i1;
                v117 = arith.zext v116 : u32;
                v118 = hir.bitcast v117 : i32;
                v120 = arith.neq v118, v727 : i1;
                scf.if v120{
                ^block14:
                    v224 = arith.constant 40 : u32;
                    v223 = hir.bitcast v34 : u32;
                    v225 = arith.add v223, v224 : u32 #[overflow = checked];
                    v726 = arith.constant 4 : u32;
                    v227 = arith.mod v225, v726 : u32;
                    hir.assertz v227 #[code = 250];
                    v228 = hir.int_to_ptr v225 : ptr<byte, i32>;
                    v229 = hir.load v228 : i32;
                    v230 = arith.constant 1048628 : i32;
                    hir.exec @root_ns:root@1.0.0/hash_elements_smoke/alloc::raw_vec::handle_error(v107, v229, v230)
                    scf.yield ;
                } else {
                ^block18:
                    v725 = arith.constant 40 : u32;
                    v121 = hir.bitcast v34 : u32;
                    v123 = arith.add v121, v725 : u32 #[overflow = checked];
                    v724 = arith.constant 4 : u32;
                    v125 = arith.mod v123, v724 : u32;
                    hir.assertz v125 #[code = 250];
                    v126 = hir.int_to_ptr v123 : ptr<byte, i32>;
                    v127 = hir.load v126 : i32;
                    v129 = arith.constant 88 : u32;
                    v128 = hir.bitcast v34 : u32;
                    v130 = arith.add v128, v129 : u32 #[overflow = checked];
                    v723 = arith.constant 4 : u32;
                    v132 = arith.mod v130, v723 : u32;
                    hir.assertz v132 #[code = 250];
                    v133 = hir.int_to_ptr v130 : ptr<byte, i32>;
                    hir.store v133, v127;
                    v135 = arith.constant 84 : u32;
                    v134 = hir.bitcast v34 : u32;
                    v136 = arith.add v134, v135 : u32 #[overflow = checked];
                    v722 = arith.constant 4 : u32;
                    v138 = arith.mod v136, v722 : u32;
                    hir.assertz v138 #[code = 250];
                    v139 = hir.int_to_ptr v136 : ptr<byte, i32>;
                    hir.store v139, v107;
                    v140 = hir.bitcast v34 : u32;
                    v721 = arith.constant 4 : u32;
                    v142 = arith.mod v140, v721 : u32;
                    hir.assertz v142 #[code = 250];
                    v143 = hir.int_to_ptr v140 : ptr<byte, i64>;
                    v144 = hir.load v143 : i64;
                    v145 = hir.bitcast v127 : u32;
                    v720 = arith.constant 4 : u32;
                    v147 = arith.mod v145, v720 : u32;
                    hir.assertz v147 #[code = 250];
                    v148 = hir.int_to_ptr v145 : ptr<byte, i64>;
                    hir.store v148, v144;
                    v719 = arith.constant 8 : i32;
                    v152 = arith.add v34, v719 : i32 #[overflow = wrapping];
                    v153 = hir.bitcast v152 : u32;
                    v718 = arith.constant 4 : u32;
                    v155 = arith.mod v153, v718 : u32;
                    hir.assertz v155 #[code = 250];
                    v156 = hir.int_to_ptr v153 : ptr<byte, i64>;
                    v157 = hir.load v156 : i64;
                    v717 = arith.constant 8 : i32;
                    v150 = arith.add v127, v717 : i32 #[overflow = wrapping];
                    v158 = hir.bitcast v150 : u32;
                    v716 = arith.constant 4 : u32;
                    v160 = arith.mod v158, v716 : u32;
                    hir.assertz v160 #[code = 250];
                    v161 = hir.int_to_ptr v158 : ptr<byte, i64>;
                    hir.store v161, v157;
                    v162 = arith.constant 16 : i32;
                    v165 = arith.add v34, v162 : i32 #[overflow = wrapping];
                    v166 = hir.bitcast v165 : u32;
                    v715 = arith.constant 4 : u32;
                    v168 = arith.mod v166, v715 : u32;
                    hir.assertz v168 #[code = 250];
                    v169 = hir.int_to_ptr v166 : ptr<byte, i64>;
                    v170 = hir.load v169 : i64;
                    v714 = arith.constant 16 : i32;
                    v163 = arith.add v127, v714 : i32 #[overflow = wrapping];
                    v171 = hir.bitcast v163 : u32;
                    v713 = arith.constant 4 : u32;
                    v173 = arith.mod v171, v713 : u32;
                    hir.assertz v173 #[code = 250];
                    v174 = hir.int_to_ptr v171 : ptr<byte, i64>;
                    hir.store v174, v170;
                    v175 = arith.constant 24 : i32;
                    v178 = arith.add v34, v175 : i32 #[overflow = wrapping];
                    v179 = hir.bitcast v178 : u32;
                    v712 = arith.constant 4 : u32;
                    v181 = arith.mod v179, v712 : u32;
                    hir.assertz v181 #[code = 250];
                    v182 = hir.int_to_ptr v179 : ptr<byte, i64>;
                    v183 = hir.load v182 : i64;
                    v711 = arith.constant 24 : i32;
                    v176 = arith.add v127, v711 : i32 #[overflow = wrapping];
                    v184 = hir.bitcast v176 : u32;
                    v710 = arith.constant 4 : u32;
                    v186 = arith.mod v184, v710 : u32;
                    hir.assertz v186 #[code = 250];
                    v187 = hir.int_to_ptr v184 : ptr<byte, i64>;
                    hir.store v187, v183;
                    v190 = arith.constant 92 : u32;
                    v189 = hir.bitcast v34 : u32;
                    v191 = arith.add v189, v190 : u32 #[overflow = checked];
                    v709 = arith.constant 4 : u32;
                    v193 = arith.mod v191, v709 : u32;
                    hir.assertz v193 #[code = 250];
                    v708 = arith.constant 8 : i32;
                    v194 = hir.int_to_ptr v191 : ptr<byte, i32>;
                    hir.store v194, v708;
                    v676 = arith.constant 2 : u32;
                    v196 = hir.bitcast v127 : u32;
                    v198 = arith.shr v196, v676 : u32;
                    v199 = hir.bitcast v198 : i32;
                    v674 = arith.constant 0 : felt;
                    v200 = arith.constant 3 : i32;
                    v201 = arith.band v199, v200 : i32;
                    v202 = hir.bitcast v201 : felt;
                    hir.assert_eq v202, v674;
                    v706 = arith.constant 32 : i32;
                    v207 = arith.add v34, v706 : i32 #[overflow = wrapping];
                    v707 = arith.constant 8 : i32;
                    hir.exec @root_ns:root@1.0.0/hash_elements_smoke/miden_stdlib_sys::stdlib::crypto::hashes::extern_hash_memory(v199, v707, v207)
                    v705 = arith.constant 4 : i32;
                    v208 = arith.constant 84 : i32;
                    v209 = arith.add v34, v208 : i32 #[overflow = wrapping];
                    hir.exec @root_ns:root@1.0.0/hash_elements_smoke/alloc::raw_vec::RawVecInner<A>::deallocate(v209, v705, v705)
                    scf.yield ;
                };
                v677 = arith.constant 0 : u32;
                v683 = arith.constant 1 : u32;
                v697 = cf.select v120, v683, v677 : u32;
                v704 = ub.poison i32 : i32;
                v696 = cf.select v120, v704, v30 : i32;
                v682 = ub.poison i32 : i32;
                v695 = cf.select v120, v682, v34 : i32;
                scf.yield v695, v696, v697;
            } else {
            ^block17:
                v701 = arith.constant 32 : i32;
                v94 = arith.add v34, v701 : i32 #[overflow = wrapping];
                v702 = arith.constant 8 : i32;
                v703 = arith.constant 2 : u32;
                v88 = hir.bitcast v34 : u32;
                v90 = arith.shr v88, v703 : u32;
                v91 = hir.bitcast v90 : i32;
                hir.exec @root_ns:root@1.0.0/hash_elements_smoke/miden_stdlib_sys::stdlib::crypto::hashes::extern_hash_memory(v91, v702, v94)
                v700 = arith.constant 0 : u32;
                scf.yield v34, v30, v700;
            };
            v699 = arith.constant 0 : u32;
            v694 = arith.eq v689, v699 : i1;
            cf.cond_br v694 ^block15, ^block76;
        ^block15:
            v214 = arith.constant 44 : u32;
            v213 = hir.bitcast v687 : u32;
            v215 = arith.add v213, v214 : u32 #[overflow = checked];
            v698 = arith.constant 4 : u32;
            v217 = arith.mod v215, v698 : u32;
            hir.assertz v217 #[code = 250];
            v218 = hir.int_to_ptr v215 : ptr<byte, felt>;
            v219 = hir.load v218 : felt;
            v221 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements_smoke/__stack_pointer : ptr<byte, u8>
            v222 = hir.bitcast v221 : ptr<byte, i32>;
            hir.store v222, v688;
            builtin.ret v219;
        ^block76:
            ub.unreachable ;
        };

        private builtin.function @__rustc::__rust_alloc(v231: i32, v232: i32) -> i32 {
        ^block19(v231: i32, v232: i32):
            v234 = arith.constant 1048644 : i32;
            v235 = hir.exec @root_ns:root@1.0.0/hash_elements_smoke/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v234, v232, v231) : i32
            builtin.ret v235;
        };

        private builtin.function @__rustc::__rust_dealloc(v236: i32, v237: i32, v238: i32) {
        ^block21(v236: i32, v237: i32, v238: i32):
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v239: i32, v240: i32) -> i32 {
        ^block23(v239: i32, v240: i32):
            v242 = arith.constant 1048644 : i32;
            v243 = hir.exec @root_ns:root@1.0.0/hash_elements_smoke/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v242, v240, v239) : i32
            v747 = arith.constant 0 : i32;
            v244 = arith.constant 0 : i32;
            v245 = arith.eq v243, v244 : i1;
            v246 = arith.zext v245 : u32;
            v247 = hir.bitcast v246 : i32;
            v249 = arith.neq v247, v747 : i1;
            scf.if v249{
            ^block25:
                scf.yield ;
            } else {
            ^block26:
                v745 = arith.constant 0 : i32;
                v746 = arith.constant 0 : i32;
                v251 = arith.eq v239, v746 : i1;
                v252 = arith.zext v251 : u32;
                v253 = hir.bitcast v252 : i32;
                v255 = arith.neq v253, v745 : i1;
                scf.if v255{
                ^block80:
                    scf.yield ;
                } else {
                ^block27:
                    v739 = arith.constant 0 : u8;
                    v258 = hir.bitcast v239 : u32;
                    v259 = hir.bitcast v243 : u32;
                    v260 = hir.int_to_ptr v259 : ptr<byte, u8>;
                    hir.mem_set v260, v258, v739;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v243;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v262: i32, v263: i32, v264: i32) -> i32 {
        ^block28(v262: i32, v263: i32, v264: i32):
            v267 = arith.constant 16 : i32;
            v266 = arith.constant 0 : i32;
            v749 = arith.constant 16 : u32;
            v269 = hir.bitcast v263 : u32;
            v271 = arith.gt v269, v749 : i1;
            v272 = arith.zext v271 : u32;
            v273 = hir.bitcast v272 : i32;
            v275 = arith.neq v273, v266 : i1;
            v276 = cf.select v275, v263, v267 : i32;
            v788 = arith.constant 0 : i32;
            v277 = arith.constant -1 : i32;
            v278 = arith.add v276, v277 : i32 #[overflow = wrapping];
            v279 = arith.band v276, v278 : i32;
            v281 = arith.neq v279, v788 : i1;
            v758, v759 = scf.if v281 : i32, u32 {
            ^block85:
                v750 = arith.constant 0 : u32;
                v754 = ub.poison i32 : i32;
                scf.yield v754, v750;
            } else {
            ^block31:
                v283 = hir.exec @root_ns:root@1.0.0/hash_elements_smoke/core::ptr::alignment::Alignment::max(v263, v276) : i32
                v787 = arith.constant 0 : i32;
                v282 = arith.constant -2147483648 : i32;
                v284 = arith.sub v282, v283 : i32 #[overflow = wrapping];
                v286 = hir.bitcast v284 : u32;
                v285 = hir.bitcast v264 : u32;
                v287 = arith.gt v285, v286 : i1;
                v288 = arith.zext v287 : u32;
                v289 = hir.bitcast v288 : i32;
                v291 = arith.neq v289, v787 : i1;
                v773 = scf.if v291 : i32 {
                ^block84:
                    v786 = ub.poison i32 : i32;
                    scf.yield v786;
                } else {
                ^block32:
                    v784 = arith.constant 0 : i32;
                    v297 = arith.sub v784, v283 : i32 #[overflow = wrapping];
                    v785 = arith.constant -1 : i32;
                    v293 = arith.add v264, v283 : i32 #[overflow = wrapping];
                    v295 = arith.add v293, v785 : i32 #[overflow = wrapping];
                    v298 = arith.band v295, v297 : i32;
                    v299 = hir.bitcast v262 : u32;
                    v300 = arith.constant 4 : u32;
                    v301 = arith.mod v299, v300 : u32;
                    hir.assertz v301 #[code = 250];
                    v302 = hir.int_to_ptr v299 : ptr<byte, i32>;
                    v303 = hir.load v302 : i32;
                    v783 = arith.constant 0 : i32;
                    v305 = arith.neq v303, v783 : i1;
                    scf.if v305{
                    ^block83:
                        scf.yield ;
                    } else {
                    ^block34:
                        v306 = hir.exec @intrinsics/mem/heap_base() : i32
                        v307 = hir.mem_size  : u32;
                        v313 = hir.bitcast v262 : u32;
                        v782 = arith.constant 4 : u32;
                        v315 = arith.mod v313, v782 : u32;
                        hir.assertz v315 #[code = 250];
                        v781 = arith.constant 16 : u32;
                        v308 = hir.bitcast v307 : i32;
                        v311 = arith.shl v308, v781 : i32;
                        v312 = arith.add v306, v311 : i32 #[overflow = wrapping];
                        v316 = hir.int_to_ptr v313 : ptr<byte, i32>;
                        hir.store v316, v312;
                        scf.yield ;
                    };
                    v319 = hir.bitcast v262 : u32;
                    v780 = arith.constant 4 : u32;
                    v321 = arith.mod v319, v780 : u32;
                    hir.assertz v321 #[code = 250];
                    v322 = hir.int_to_ptr v319 : ptr<byte, i32>;
                    v323 = hir.load v322 : i32;
                    v779 = arith.constant 0 : i32;
                    v327 = hir.bitcast v298 : u32;
                    v317 = arith.constant 268435456 : i32;
                    v324 = arith.sub v317, v323 : i32 #[overflow = wrapping];
                    v326 = hir.bitcast v324 : u32;
                    v328 = arith.lt v326, v327 : i1;
                    v329 = arith.zext v328 : u32;
                    v330 = hir.bitcast v329 : i32;
                    v332 = arith.neq v330, v779 : i1;
                    v772 = scf.if v332 : i32 {
                    ^block35:
                        v778 = arith.constant 0 : i32;
                        scf.yield v778;
                    } else {
                    ^block36:
                        v334 = hir.bitcast v262 : u32;
                        v777 = arith.constant 4 : u32;
                        v336 = arith.mod v334, v777 : u32;
                        hir.assertz v336 #[code = 250];
                        v333 = arith.add v323, v298 : i32 #[overflow = wrapping];
                        v337 = hir.int_to_ptr v334 : ptr<byte, i32>;
                        hir.store v337, v333;
                        v339 = arith.add v323, v283 : i32 #[overflow = wrapping];
                        scf.yield v339;
                    };
                    scf.yield v772;
                };
                v755 = arith.constant 1 : u32;
                v776 = arith.constant 0 : u32;
                v774 = cf.select v291, v776, v755 : u32;
                scf.yield v773, v774;
            };
            v775 = arith.constant 0 : u32;
            v771 = arith.eq v759, v775 : i1;
            cf.cond_br v771 ^block30, ^block87(v758);
        ^block30:
            ub.unreachable ;
        ^block87(v751: i32):
            builtin.ret v751;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v342: i32, v343: i32, v344: i32) {
        ^block37(v342: i32, v343: i32, v344: i32):
            v346 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements_smoke/__stack_pointer : ptr<byte, u8>
            v347 = hir.bitcast v346 : ptr<byte, i32>;
            v348 = hir.load v347 : i32;
            v349 = arith.constant 16 : i32;
            v350 = arith.sub v348, v349 : i32 #[overflow = wrapping];
            v351 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements_smoke/__stack_pointer : ptr<byte, u8>
            v352 = hir.bitcast v351 : ptr<byte, i32>;
            hir.store v352, v350;
            v353 = arith.constant 4 : i32;
            v354 = arith.add v350, v353 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements_smoke/alloc::raw_vec::RawVecInner<A>::current_memory(v354, v342, v343, v344)
            v356 = arith.constant 8 : u32;
            v355 = hir.bitcast v350 : u32;
            v357 = arith.add v355, v356 : u32 #[overflow = checked];
            v358 = arith.constant 4 : u32;
            v359 = arith.mod v357, v358 : u32;
            hir.assertz v359 #[code = 250];
            v360 = hir.int_to_ptr v357 : ptr<byte, i32>;
            v361 = hir.load v360 : i32;
            v795 = arith.constant 0 : i32;
            v345 = arith.constant 0 : i32;
            v363 = arith.eq v361, v345 : i1;
            v364 = arith.zext v363 : u32;
            v365 = hir.bitcast v364 : i32;
            v367 = arith.neq v365, v795 : i1;
            scf.if v367{
            ^block91:
                scf.yield ;
            } else {
            ^block40:
                v794 = arith.constant 4 : u32;
                v368 = hir.bitcast v350 : u32;
                v370 = arith.add v368, v794 : u32 #[overflow = checked];
                v793 = arith.constant 4 : u32;
                v372 = arith.mod v370, v793 : u32;
                hir.assertz v372 #[code = 250];
                v373 = hir.int_to_ptr v370 : ptr<byte, i32>;
                v374 = hir.load v373 : i32;
                v376 = arith.constant 12 : u32;
                v375 = hir.bitcast v350 : u32;
                v377 = arith.add v375, v376 : u32 #[overflow = checked];
                v792 = arith.constant 4 : u32;
                v379 = arith.mod v377, v792 : u32;
                hir.assertz v379 #[code = 250];
                v380 = hir.int_to_ptr v377 : ptr<byte, i32>;
                v381 = hir.load v380 : i32;
                hir.exec @root_ns:root@1.0.0/hash_elements_smoke/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v374, v361, v381)
                scf.yield ;
            };
            v791 = arith.constant 16 : i32;
            v384 = arith.add v350, v791 : i32 #[overflow = wrapping];
            v385 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements_smoke/__stack_pointer : ptr<byte, u8>
            v386 = hir.bitcast v385 : ptr<byte, i32>;
            hir.store v386, v384;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::try_allocate_in(v387: i32, v388: i32, v389: i32, v390: i32, v391: i32) {
        ^block41(v387: i32, v388: i32, v389: i32, v390: i32, v391: i32):
            v394 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements_smoke/__stack_pointer : ptr<byte, u8>
            v395 = hir.bitcast v394 : ptr<byte, i32>;
            v396 = hir.load v395 : i32;
            v397 = arith.constant 16 : i32;
            v398 = arith.sub v396, v397 : i32 #[overflow = wrapping];
            v399 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements_smoke/__stack_pointer : ptr<byte, u8>
            v400 = hir.bitcast v399 : ptr<byte, i32>;
            hir.store v400, v398;
            v410 = hir.bitcast v388 : u32;
            v411 = arith.zext v410 : u64;
            v412 = hir.bitcast v411 : i64;
            v392 = arith.constant 0 : i32;
            v405 = arith.sub v392, v390 : i32 #[overflow = wrapping];
            v402 = arith.constant -1 : i32;
            v401 = arith.add v390, v391 : i32 #[overflow = wrapping];
            v403 = arith.add v401, v402 : i32 #[overflow = wrapping];
            v406 = arith.band v403, v405 : i32;
            v407 = hir.bitcast v406 : u32;
            v408 = arith.zext v407 : u64;
            v409 = hir.bitcast v408 : i64;
            v413 = arith.mul v409, v412 : i64 #[overflow = wrapping];
            v899 = arith.constant 0 : i32;
            v414 = arith.constant 32 : i64;
            v416 = hir.cast v414 : u32;
            v415 = hir.bitcast v413 : u64;
            v417 = arith.shr v415, v416 : u64;
            v418 = hir.bitcast v417 : i64;
            v419 = arith.trunc v418 : i32;
            v421 = arith.neq v419, v899 : i1;
            v811, v812, v813, v814, v815, v816 = scf.if v421 : i32, i32, i32, i32, i32, u32 {
            ^block93:
                v796 = arith.constant 0 : u32;
                v803 = ub.poison i32 : i32;
                scf.yield v387, v398, v803, v803, v803, v796;
            } else {
            ^block46:
                v422 = arith.trunc v413 : i32;
                v898 = arith.constant 0 : i32;
                v423 = arith.constant -2147483648 : i32;
                v424 = arith.sub v423, v390 : i32 #[overflow = wrapping];
                v426 = hir.bitcast v424 : u32;
                v425 = hir.bitcast v422 : u32;
                v427 = arith.lte v425, v426 : i1;
                v428 = arith.zext v427 : u32;
                v429 = hir.bitcast v428 : i32;
                v431 = arith.neq v429, v898 : i1;
                v859 = scf.if v431 : i32 {
                ^block44:
                    v897 = arith.constant 0 : i32;
                    v442 = arith.neq v422, v897 : i1;
                    v858 = scf.if v442 : i32 {
                    ^block48:
                        v896 = arith.constant 0 : i32;
                        v458 = arith.neq v389, v896 : i1;
                        v857 = scf.if v458 : i32 {
                        ^block51:
                            v440 = arith.constant 1 : i32;
                            hir.exec @root_ns:root@1.0.0/hash_elements_smoke/alloc::alloc::Global::alloc_impl(v398, v390, v422, v440)
                            v469 = hir.bitcast v398 : u32;
                            v514 = arith.constant 4 : u32;
                            v471 = arith.mod v469, v514 : u32;
                            hir.assertz v471 #[code = 250];
                            v472 = hir.int_to_ptr v469 : ptr<byte, i32>;
                            v473 = hir.load v472 : i32;
                            scf.yield v473;
                        } else {
                        ^block52:
                            v459 = arith.constant 8 : i32;
                            v460 = arith.add v398, v459 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/hash_elements_smoke/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v460, v390, v422)
                            v444 = arith.constant 8 : u32;
                            v461 = hir.bitcast v398 : u32;
                            v463 = arith.add v461, v444 : u32 #[overflow = checked];
                            v895 = arith.constant 4 : u32;
                            v465 = arith.mod v463, v895 : u32;
                            hir.assertz v465 #[code = 250];
                            v466 = hir.int_to_ptr v463 : ptr<byte, i32>;
                            v467 = hir.load v466 : i32;
                            scf.yield v467;
                        };
                        v893 = arith.constant 0 : i32;
                        v894 = arith.constant 0 : i32;
                        v476 = arith.eq v857, v894 : i1;
                        v477 = arith.zext v476 : u32;
                        v478 = hir.bitcast v477 : i32;
                        v480 = arith.neq v478, v893 : i1;
                        scf.if v480{
                        ^block53:
                            v892 = arith.constant 8 : u32;
                            v497 = hir.bitcast v387 : u32;
                            v499 = arith.add v497, v892 : u32 #[overflow = checked];
                            v891 = arith.constant 4 : u32;
                            v501 = arith.mod v499, v891 : u32;
                            hir.assertz v501 #[code = 250];
                            v502 = hir.int_to_ptr v499 : ptr<byte, i32>;
                            hir.store v502, v422;
                            v890 = arith.constant 4 : u32;
                            v504 = hir.bitcast v387 : u32;
                            v506 = arith.add v504, v890 : u32 #[overflow = checked];
                            v889 = arith.constant 4 : u32;
                            v508 = arith.mod v506, v889 : u32;
                            hir.assertz v508 #[code = 250];
                            v509 = hir.int_to_ptr v506 : ptr<byte, i32>;
                            hir.store v509, v390;
                            scf.yield ;
                        } else {
                        ^block54:
                            v888 = arith.constant 8 : u32;
                            v482 = hir.bitcast v387 : u32;
                            v484 = arith.add v482, v888 : u32 #[overflow = checked];
                            v887 = arith.constant 4 : u32;
                            v486 = arith.mod v484, v887 : u32;
                            hir.assertz v486 #[code = 250];
                            v487 = hir.int_to_ptr v484 : ptr<byte, i32>;
                            hir.store v487, v857;
                            v886 = arith.constant 4 : u32;
                            v489 = hir.bitcast v387 : u32;
                            v491 = arith.add v489, v886 : u32 #[overflow = checked];
                            v885 = arith.constant 4 : u32;
                            v493 = arith.mod v491, v885 : u32;
                            hir.assertz v493 #[code = 250];
                            v494 = hir.int_to_ptr v491 : ptr<byte, i32>;
                            hir.store v494, v388;
                            scf.yield ;
                        };
                        v883 = arith.constant 0 : i32;
                        v884 = arith.constant 1 : i32;
                        v856 = cf.select v480, v884, v883 : i32;
                        scf.yield v856;
                    } else {
                    ^block49:
                        v882 = arith.constant 8 : u32;
                        v443 = hir.bitcast v387 : u32;
                        v445 = arith.add v443, v882 : u32 #[overflow = checked];
                        v881 = arith.constant 4 : u32;
                        v447 = arith.mod v445, v881 : u32;
                        hir.assertz v447 #[code = 250];
                        v448 = hir.int_to_ptr v445 : ptr<byte, i32>;
                        hir.store v448, v390;
                        v880 = arith.constant 4 : u32;
                        v451 = hir.bitcast v387 : u32;
                        v453 = arith.add v451, v880 : u32 #[overflow = checked];
                        v879 = arith.constant 4 : u32;
                        v455 = arith.mod v453, v879 : u32;
                        hir.assertz v455 #[code = 250];
                        v878 = arith.constant 0 : i32;
                        v456 = hir.int_to_ptr v453 : ptr<byte, i32>;
                        hir.store v456, v878;
                        v877 = arith.constant 0 : i32;
                        scf.yield v877;
                    };
                    scf.yield v858;
                } else {
                ^block47:
                    v876 = ub.poison i32 : i32;
                    scf.yield v876;
                };
                v871 = arith.constant 0 : u32;
                v804 = arith.constant 1 : u32;
                v864 = cf.select v431, v804, v871 : u32;
                v872 = ub.poison i32 : i32;
                v863 = cf.select v431, v398, v872 : i32;
                v873 = ub.poison i32 : i32;
                v862 = cf.select v431, v387, v873 : i32;
                v874 = ub.poison i32 : i32;
                v861 = cf.select v431, v874, v398 : i32;
                v875 = ub.poison i32 : i32;
                v860 = cf.select v431, v875, v387 : i32;
                scf.yield v860, v861, v862, v859, v863, v864;
            };
            v817, v818, v819 = scf.index_switch v816 : i32, i32, i32 
            case 0 {
            ^block45:
                v870 = arith.constant 4 : u32;
                v434 = hir.bitcast v811 : u32;
                v436 = arith.add v434, v870 : u32 #[overflow = checked];
                v869 = arith.constant 4 : u32;
                v438 = arith.mod v436, v869 : u32;
                hir.assertz v438 #[code = 250];
                v868 = arith.constant 0 : i32;
                v439 = hir.int_to_ptr v436 : ptr<byte, i32>;
                hir.store v439, v868;
                v867 = arith.constant 1 : i32;
                scf.yield v811, v867, v812;
            }
            default {
            ^block97:
                scf.yield v813, v814, v815;
            };
            v513 = hir.bitcast v817 : u32;
            v866 = arith.constant 4 : u32;
            v515 = arith.mod v513, v866 : u32;
            hir.assertz v515 #[code = 250];
            v516 = hir.int_to_ptr v513 : ptr<byte, i32>;
            hir.store v516, v818;
            v865 = arith.constant 16 : i32;
            v521 = arith.add v819, v865 : i32 #[overflow = wrapping];
            v522 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements_smoke/__stack_pointer : ptr<byte, u8>
            v523 = hir.bitcast v522 : ptr<byte, i32>;
            hir.store v523, v521;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v524: i32, v525: i32, v526: i32) {
        ^block55(v524: i32, v525: i32, v526: i32):
            v528 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements_smoke/__stack_pointer : ptr<byte, u8>
            v529 = hir.bitcast v528 : ptr<byte, i32>;
            v530 = hir.load v529 : i32;
            v531 = arith.constant 16 : i32;
            v532 = arith.sub v530, v531 : i32 #[overflow = wrapping];
            v533 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements_smoke/__stack_pointer : ptr<byte, u8>
            v534 = hir.bitcast v533 : ptr<byte, i32>;
            hir.store v534, v532;
            v527 = arith.constant 0 : i32;
            v535 = arith.constant 8 : i32;
            v536 = arith.add v532, v535 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/hash_elements_smoke/alloc::alloc::Global::alloc_impl(v536, v525, v526, v527)
            v539 = arith.constant 12 : u32;
            v538 = hir.bitcast v532 : u32;
            v540 = arith.add v538, v539 : u32 #[overflow = checked];
            v541 = arith.constant 4 : u32;
            v542 = arith.mod v540, v541 : u32;
            hir.assertz v542 #[code = 250];
            v543 = hir.int_to_ptr v540 : ptr<byte, i32>;
            v544 = hir.load v543 : i32;
            v546 = arith.constant 8 : u32;
            v545 = hir.bitcast v532 : u32;
            v547 = arith.add v545, v546 : u32 #[overflow = checked];
            v904 = arith.constant 4 : u32;
            v549 = arith.mod v547, v904 : u32;
            hir.assertz v549 #[code = 250];
            v550 = hir.int_to_ptr v547 : ptr<byte, i32>;
            v551 = hir.load v550 : i32;
            v552 = hir.bitcast v524 : u32;
            v903 = arith.constant 4 : u32;
            v554 = arith.mod v552, v903 : u32;
            hir.assertz v554 #[code = 250];
            v555 = hir.int_to_ptr v552 : ptr<byte, i32>;
            hir.store v555, v551;
            v902 = arith.constant 4 : u32;
            v556 = hir.bitcast v524 : u32;
            v558 = arith.add v556, v902 : u32 #[overflow = checked];
            v901 = arith.constant 4 : u32;
            v560 = arith.mod v558, v901 : u32;
            hir.assertz v560 #[code = 250];
            v561 = hir.int_to_ptr v558 : ptr<byte, i32>;
            hir.store v561, v544;
            v900 = arith.constant 16 : i32;
            v563 = arith.add v532, v900 : i32 #[overflow = wrapping];
            v564 = builtin.global_symbol @root_ns:root@1.0.0/hash_elements_smoke/__stack_pointer : ptr<byte, u8>
            v565 = hir.bitcast v564 : ptr<byte, i32>;
            hir.store v565, v563;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v566: i32, v567: i32, v568: i32, v569: i32) {
        ^block57(v566: i32, v567: i32, v568: i32, v569: i32):
            v920 = arith.constant 0 : i32;
            v570 = arith.constant 0 : i32;
            v571 = arith.eq v568, v570 : i1;
            v572 = arith.zext v571 : u32;
            v573 = hir.bitcast v572 : i32;
            v575 = arith.neq v573, v920 : i1;
            v916 = scf.if v575 : i32 {
            ^block100:
                scf.yield v567;
            } else {
            ^block60:
                v919 = arith.constant 0 : i32;
                v584 = arith.neq v569, v919 : i1;
                v915 = scf.if v584 : i32 {
                ^block61:
                    v586 = hir.exec @root_ns:root@1.0.0/hash_elements_smoke/__rustc::__rust_alloc_zeroed(v568, v567) : i32
                    scf.yield v586;
                } else {
                ^block62:
                    v585 = hir.exec @root_ns:root@1.0.0/hash_elements_smoke/__rustc::__rust_alloc(v568, v567) : i32
                    scf.yield v585;
                };
                scf.yield v915;
            };
            v590 = arith.constant 4 : u32;
            v589 = hir.bitcast v566 : u32;
            v591 = arith.add v589, v590 : u32 #[overflow = checked];
            v918 = arith.constant 4 : u32;
            v593 = arith.mod v591, v918 : u32;
            hir.assertz v593 #[code = 250];
            v594 = hir.int_to_ptr v591 : ptr<byte, i32>;
            hir.store v594, v568;
            v596 = hir.bitcast v566 : u32;
            v917 = arith.constant 4 : u32;
            v598 = arith.mod v596, v917 : u32;
            hir.assertz v598 #[code = 250];
            v599 = hir.int_to_ptr v596 : ptr<byte, i32>;
            hir.store v599, v916;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v600: i32, v601: i32, v602: i32, v603: i32) {
        ^block63(v600: i32, v601: i32, v602: i32, v603: i32):
            v946 = arith.constant 0 : i32;
            v604 = arith.constant 0 : i32;
            v608 = arith.eq v603, v604 : i1;
            v609 = arith.zext v608 : u32;
            v610 = hir.bitcast v609 : i32;
            v612 = arith.neq v610, v946 : i1;
            v933, v934 = scf.if v612 : i32, i32 {
            ^block104:
                v945 = arith.constant 0 : i32;
                v606 = arith.constant 4 : i32;
                scf.yield v606, v945;
            } else {
            ^block66:
                v613 = hir.bitcast v601 : u32;
                v648 = arith.constant 4 : u32;
                v615 = arith.mod v613, v648 : u32;
                hir.assertz v615 #[code = 250];
                v616 = hir.int_to_ptr v613 : ptr<byte, i32>;
                v617 = hir.load v616 : i32;
                v943 = arith.constant 0 : i32;
                v944 = arith.constant 0 : i32;
                v619 = arith.eq v617, v944 : i1;
                v620 = arith.zext v619 : u32;
                v621 = hir.bitcast v620 : i32;
                v623 = arith.neq v621, v943 : i1;
                v931 = scf.if v623 : i32 {
                ^block103:
                    v942 = arith.constant 0 : i32;
                    scf.yield v942;
                } else {
                ^block67:
                    v941 = arith.constant 4 : u32;
                    v624 = hir.bitcast v600 : u32;
                    v626 = arith.add v624, v941 : u32 #[overflow = checked];
                    v940 = arith.constant 4 : u32;
                    v628 = arith.mod v626, v940 : u32;
                    hir.assertz v628 #[code = 250];
                    v629 = hir.int_to_ptr v626 : ptr<byte, i32>;
                    hir.store v629, v602;
                    v939 = arith.constant 4 : u32;
                    v630 = hir.bitcast v601 : u32;
                    v632 = arith.add v630, v939 : u32 #[overflow = checked];
                    v938 = arith.constant 4 : u32;
                    v634 = arith.mod v632, v938 : u32;
                    hir.assertz v634 #[code = 250];
                    v635 = hir.int_to_ptr v632 : ptr<byte, i32>;
                    v636 = hir.load v635 : i32;
                    v637 = hir.bitcast v600 : u32;
                    v937 = arith.constant 4 : u32;
                    v639 = arith.mod v637, v937 : u32;
                    hir.assertz v639 #[code = 250];
                    v640 = hir.int_to_ptr v637 : ptr<byte, i32>;
                    hir.store v640, v636;
                    v641 = arith.mul v617, v603 : i32 #[overflow = wrapping];
                    scf.yield v641;
                };
                v642 = arith.constant 8 : i32;
                v936 = arith.constant 4 : i32;
                v932 = cf.select v623, v936, v642 : i32;
                scf.yield v932, v931;
            };
            v645 = arith.add v600, v933 : i32 #[overflow = wrapping];
            v647 = hir.bitcast v645 : u32;
            v935 = arith.constant 4 : u32;
            v649 = arith.mod v647, v935 : u32;
            hir.assertz v649 #[code = 250];
            v650 = hir.int_to_ptr v647 : ptr<byte, i32>;
            hir.store v650, v934;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v651: i32, v652: i32, v653: i32) {
        ^block68(v651: i32, v652: i32, v653: i32):
            v948 = arith.constant 0 : i32;
            v654 = arith.constant 0 : i32;
            v655 = arith.eq v653, v654 : i1;
            v656 = arith.zext v655 : u32;
            v657 = hir.bitcast v656 : i32;
            v659 = arith.neq v657, v948 : i1;
            scf.if v659{
            ^block70:
                scf.yield ;
            } else {
            ^block71:
                hir.exec @root_ns:root@1.0.0/hash_elements_smoke/__rustc::__rust_dealloc(v651, v653, v652)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v660: i32, v661: i32, v662: i32) {
        ^block72(v660: i32, v661: i32, v662: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v663: i32, v664: i32) -> i32 {
        ^block74(v663: i32, v664: i32):
            v671 = arith.constant 0 : i32;
            v667 = hir.bitcast v664 : u32;
            v666 = hir.bitcast v663 : u32;
            v668 = arith.gt v666, v667 : i1;
            v669 = arith.zext v668 : u32;
            v670 = hir.bitcast v669 : i32;
            v672 = arith.neq v670, v671 : i1;
            v673 = cf.select v672, v663, v664 : i32;
            builtin.ret v673;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.segment readonly @1048576 = 0x0000002a000000d70000003200100000000073722e7365687361682f6f74707972632f62696c6474732f6372732f352e312e302d7379732d62696c6474732d6e6564696d;
    };
};