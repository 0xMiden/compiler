#![no_std]

extern crate alloc;
use alloc::vec::Vec;

// Global allocator for no-std environment
#[global_allocator]
static ALLOC: miden::BumpAlloc = miden::BumpAlloc::new();

// Required for no-std crates
#[cfg(not(test))]
#[panic_handler]
fn my_panic(_info: &core::panic::PanicInfo) -> ! {
    loop {}
}

// TODO: The bindings module is auto-generated by wit-bindgen during build
// For now, we'll use the SDK directly without the WIT bindings

use miden::*;

// Stubbed functions that would normally come from bindings
fn receive_asset(asset: Asset) {
    // In real implementation, this would call the wallet's receive_asset
    // For now, we use the account::add_asset function
    miden::account::add_asset(asset);
}

fn send_asset(asset: Asset, _note_idx: Felt) {
    // In real implementation, this would move the asset to a note
    // For now, this is stubbed
    let _ = asset;
}

// Type aliases for clarity
type NoteIdx = Felt;

// ================================================================================================
// CONSTANTS
// ================================================================================================

const PUBLIC_NOTE: u8 = 1;
const EXECUTION_HINT_ALWAYS: u8 = 1;

// P2ID script root as a constant digest
// Since we can't use const with non-const functions, we'll create this as a function
fn get_p2id_script_root() -> Word {
    Word::from([miden::felt!(0), miden::felt!(0), miden::felt!(0), miden::felt!(0)])
}

// ================================================================================================
// SWAPP INPUT STRUCTURE
// ================================================================================================

/// Structure representing the SWAPP note inputs
/// Total of 8 u64 values (compact format)
struct SwappInputs {
    // Requested asset (token B) - first 3 felts
    token_b_id_prefix: Felt,
    token_b_id_suffix: Felt,
    token_b_amount: Felt,

    // Tags and metadata - next 3 felts
    swapp_tag: Felt,
    p2id_tag: Felt,
    swapp_count: Felt,

    // Creator account ID - last 2 felts
    creator_id_prefix: Felt,
    creator_id_suffix: Felt,
}

impl SwappInputs {
    /// Parse inputs from the note
    fn from_note_inputs(inputs: Vec<Felt>) -> Self {
        assert!(inputs.len() >= 8, "SWAPP wrong number of inputs");

        Self {
            token_b_id_prefix: inputs[0],
            token_b_id_suffix: inputs[1],
            token_b_amount: inputs[2],
            swapp_tag: inputs[3],
            p2id_tag: inputs[4],
            swapp_count: inputs[5],
            creator_id_prefix: inputs[6],
            creator_id_suffix: inputs[7],
        }
    }

    /// Get the requested asset
    fn get_requested_asset(&self) -> Asset {
        // Create asset from the token B details
        // Asset format: [amount, 0, id_suffix, id_prefix]
        Asset {
            inner: Word::from([
                self.token_b_amount,
                Felt::from(0u32),
                self.token_b_id_suffix,
                self.token_b_id_prefix,
            ]),
        }
    }

    /// Get the creator account ID
    fn get_creator_id(&self) -> AccountId {
        AccountId {
            prefix: self.creator_id_prefix,
            suffix: self.creator_id_suffix,
        }
    }

    /// Increment the swap count
    fn increment_count(&mut self) {
        let count = self.swapp_count.as_u64();
        // Convert u64 to u32 for Felt::from
        self.swapp_count = Felt::from((count.wrapping_add(1)) as u32);
    }

    /// Update the requested amount for partial fills
    fn update_requested_amount(&mut self, new_amount: u64) {
        // Convert u64 to u32 for Felt::from
        self.token_b_amount = Felt::from(new_amount as u32);
    }

    /// Convert back to an array for hashing
    fn to_array(&self) -> [Felt; 8] {
        [
            self.token_b_id_prefix,
            self.token_b_id_suffix,
            self.token_b_amount,
            self.swapp_tag,
            self.p2id_tag,
            self.swapp_count,
            self.creator_id_prefix,
            self.creator_id_suffix,
        ]
    }
}

// ================================================================================================
// PRICE CALCULATION
// ================================================================================================

/// Computes how many of the offered asset go out given `requested_asset_filled`,
/// then returns both the partial-fill amounts and the new remaining amounts.
///
/// Formulas:
///   amount_out = (offered_swapp_asset_amount * requested_asset_filled)
///                / requested_swapp_asset_amount
///
///   new_offered_asset_amount = offered_swapp_asset_amount - amount_out
///
///   new_requested_asset_amount = requested_swapp_asset_amount - requested_asset_filled
///
/// Returns a tuple of:
/// (amount_out, new_offered_asset_amount, new_requested_asset_amount)
/// where:
///   - `amount_out` is how many of the offered asset will be sent out,
///   - `new_offered_asset_amount` is how many of the offered asset remain unfilled,
///   - `new_requested_asset_amount` is how many of the requested asset remain unfilled.
pub fn compute_partial_swapp(
    offered_swapp_asset_amount: u64,
    requested_swapp_asset_amount: u64,
    requested_asset_filled: u64,
) -> (u64, u64, u64) {
    // amount of "offered" tokens (A) to send out
    let mut amount_out_offered = offered_swapp_asset_amount
        .saturating_mul(requested_asset_filled)
        .saturating_div(requested_swapp_asset_amount);

    // Ensure we don't exceed the offered amount
    if amount_out_offered > offered_swapp_asset_amount {
        amount_out_offered = offered_swapp_asset_amount;
    }

    // update leftover offered amount
    let new_offered_asset_amount = offered_swapp_asset_amount.saturating_sub(amount_out_offered);

    // update leftover requested amount
    let new_requested_asset_amount =
        requested_swapp_asset_amount.saturating_sub(requested_asset_filled);

    // Return partial fill info and updated amounts
    (amount_out_offered, new_offered_asset_amount, new_requested_asset_amount)
}

// ================================================================================================
// HELPER FUNCTIONS
// ================================================================================================

/// Check if the consuming account is the creator of the note
fn is_consumer_creator(creator: AccountId) -> bool {
    let consumer = miden::account::get_id();
    consumer.prefix == creator.prefix && consumer.suffix == creator.suffix
}

/// Handle reclaiming all assets when creator consumes their own note
fn handle_reclaim() {
    let assets = miden::note::get_assets();
    for asset in assets {
        receive_asset(asset);
    }
}

/// Build a P2ID recipient hash
fn build_p2id_recipient(
    serial_num: Felt,
    script_root: Word,
    creator: AccountId,
    inputs: &[Felt; 8],
) -> Recipient {
    // Hash the serial number with padding
    let serial_word =
        Word::from([serial_num, Felt::from(0u32), Felt::from(0u32), Felt::from(0u32)]);
    let serial_hash: Word = miden::hash_words(&[serial_word]).into();

    // Merge serial hash with script root
    let serial_script_hash: Word = miden::hash_words(&[serial_hash, script_root]).into();

    // Hash the inputs (split into two words since we have 8 Felts)
    let inputs_word1 = Word::from([inputs[0], inputs[1], inputs[2], inputs[3]]);
    let inputs_word2 = Word::from([inputs[4], inputs[5], inputs[6], inputs[7]]);
    let inputs_hash: Word = miden::hash_words(&[inputs_word1, inputs_word2]).into();

    // Create account hash from creator ID
    let account_word =
        Word::from([creator.prefix, creator.suffix, Felt::from(0u32), Felt::from(0u32)]);
    let account_hash: Word = miden::hash_words(&[account_word]).into();

    // Merge account hash with inputs hash
    let account_inputs_hash: Word = miden::hash_words(&[account_hash, inputs_hash]).into();

    // Final merge to create recipient
    let recipient_hash: Word = miden::hash_words(&[serial_script_hash, account_inputs_hash]).into();

    Recipient {
        inner: recipient_hash,
    }
}

/// Build a SWAPP recipient hash for partial fills
fn build_swapp_recipient(serial_num: Felt, script_root: Word, inputs: &[Felt; 8]) -> Recipient {
    // Hash the serial number with padding
    let serial_word =
        Word::from([serial_num, Felt::from(0u32), Felt::from(0u32), Felt::from(0u32)]);
    let serial_hash: Word = miden::hash_words(&[serial_word]).into();

    // Merge serial hash with script root
    let serial_script_hash: Word = miden::hash_words(&[serial_hash, script_root]).into();

    // Hash the inputs (split into two words since we have 8 Felts)
    let inputs_word1 = Word::from([inputs[0], inputs[1], inputs[2], inputs[3]]);
    let inputs_word2 = Word::from([inputs[4], inputs[5], inputs[6], inputs[7]]);
    let inputs_hash: Word = miden::hash_words(&[inputs_word1, inputs_word2]).into();

    // Final merge to create recipient
    let recipient_hash: Word = miden::hash_words(&[serial_script_hash, inputs_hash]).into();

    Recipient {
        inner: recipient_hash,
    }
}

/// Get P2ID serial number by hashing swap serial with count
fn get_p2id_serial_num(swap_serial: Felt, swap_count: Felt) -> Felt {
    // Create a word with swap serial and count, padded with zeros
    let serial_count_word =
        Word::from([swap_serial, swap_count, Felt::from(0u32), Felt::from(0u32)]);

    // Hash the word and return the first element as the serial number
    let hash: Word = miden::hash_words(&[serial_count_word]).into();
    hash[0]
}

// ================================================================================================
// MAIN SWAPP NOTE IMPLEMENTATION
// ================================================================================================

pub struct SwappNote;

impl SwappNote {
    pub fn note_script(_arg: Word) {
        // Step 1: Read note arguments (amount of requested asset the consumer wants to fill)
        let note_args = miden::note::get_args();
        // Note args is a Word (4 Felts), we use the first element as the fill amount
        let requested_fill_amount = note_args[0].as_u64();

        // Read note inputs
        let inputs = miden::note::get_inputs();
        let mut swapp_inputs = SwappInputs::from_note_inputs(inputs);

        // Step 2: Check if consuming account is the creator
        let creator_id = swapp_inputs.get_creator_id();
        if is_consumer_creator(creator_id) {
            // Creator is reclaiming - send back all assets
            handle_reclaim();
            return;
        }

        // Step 3: SWAP logic begins

        // Step 4: Assert that the note has only 1 asset stored
        let assets = miden::note::get_assets();
        assert!(assets.len() == 1, "SWAPP wrong number of assets");
        let offered_asset = assets[0].clone();

        // Extract offered asset details (token A)
        // Asset structure: [amount, 0, id_suffix, id_prefix]
        let token_a_amount = offered_asset.inner[0].as_u64();
        let token_a_id = offered_asset.clone();

        // Extract requested asset details (token B)
        let requested_asset = swapp_inputs.get_requested_asset();
        let token_b_amount = requested_asset.inner[0].as_u64();
        let token_b_id = requested_asset.clone();

        // Step 5: Assert correct number of inputs (already done in from_note_inputs)

        // Step 6: Determine how much token B the consumer will provide
        let token_b_in = if requested_fill_amount == 0 {
            // No amount specified - use consumer's full balance of token B
            let balance = miden::account::get_balance(token_b_id.clone());
            assert!(balance > 0, "SWAPP zero SWAP amount");
            balance
        } else {
            // Use the specified amount from note args
            assert!(requested_fill_amount > 0, "SWAPP zero SWAP amount");
            requested_fill_amount
        };

        // Step 7: Calculate swap amounts using the correct formula
        let (token_a_out, remaining_token_a, remaining_token_b) =
            compute_partial_swapp(token_a_amount, token_b_amount, token_b_in);

        // Determine if this is a complete or partial fill
        let is_partial_fill = remaining_token_a > 0;

        // Step 8/9: Create notes based on fill type

        // Always create P2ID note for the creator with token B
        swapp_inputs.increment_count();

        // TODO: These functions are stubbed and need proper implementation
        let swap_serial = miden::note::get_serial_number();
        let p2id_serial = get_p2id_serial_num(swap_serial, swapp_inputs.swapp_count);

        let p2id_recipient = build_p2id_recipient(
            p2id_serial,
            get_p2id_script_root(),
            creator_id,
            &swapp_inputs.to_array(),
        );

        // Create P2ID note
        // create_note signature: (tag, aux, note_type, execution_hint, recipient)
        let p2id_note_idx = miden::tx::create_note(
            swapp_inputs.p2id_tag.into(), // tag
            Felt::from(0u32),             // aux
            Felt::from(1u32).into(),      // NoteType::Public
            Felt::from(1u32),             // EXECUTION_HINT_ALWAYS
            p2id_recipient,
        );

        // Send token B to the P2ID note for the creator
        let token_b_to_send = Asset::new(Word::from([
            Felt::from(token_b_in as u32),
            Felt::from(0u32),
            token_b_id.inner[2],
            token_b_id.inner[3],
        ]));
        send_asset(token_b_to_send, p2id_note_idx.inner);

        // Give token A to the consumer
        let token_a_to_receive = Asset::new(Word::from([
            Felt::from(token_a_out as u32),
            Felt::from(0u32),
            token_a_id.inner[2],
            token_a_id.inner[3],
        ]));
        receive_asset(token_a_to_receive);

        // Step 9: If partial fill, create new SWAPP note with remainder
        if is_partial_fill {
            // Update the inputs with new requested amount
            swapp_inputs.update_requested_amount(remaining_token_b);

            // Get script root for creating new SWAPP note
            let script_root = miden::note::get_script_root();
            let new_serial = Felt::from((swap_serial.as_u64() + 1) as u32);

            let swapp_recipient =
                build_swapp_recipient(new_serial, script_root, &swapp_inputs.to_array());

            // Create new SWAPP note
            // create_note signature: (tag, aux, note_type, execution_hint, recipient)
            let swapp_note_idx = miden::tx::create_note(
                swapp_inputs.swapp_tag.into(), // tag
                Felt::from(0u32),              // aux
                Felt::from(1u32).into(),       // NoteType::Public
                Felt::from(1u32),              // EXECUTION_HINT_ALWAYS
                swapp_recipient,
            );

            // Add remaining token A to the new SWAPP note
            let remaining_asset = Asset::new(Word::from([
                Felt::from(remaining_token_a as u32),
                Felt::from(0u32),
                token_a_id.inner[2],
                token_a_id.inner[3],
            ]));

            // First receive it into the account (required for moving to note)
            receive_asset(remaining_asset.clone());

            // Then move it to the new SWAPP note
            send_asset(remaining_asset, swapp_note_idx.inner);
        }
    }
}
