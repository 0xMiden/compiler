// Do not link against libstd (i.e. anything defined in `std::`)
#![no_std]

// However, we could still use some standard library types while
// remaining no-std compatible, if we uncommented the following lines:
//
// extern crate alloc;

use miden::{component, Asset, Felt, StorageMap, StorageMapAccess, Value, ValueAccess, Word};

use crate::bindings::exports::miden::storage_example::*;

miden::generate!();
bindings::export!(MyAccount);

#[component]
struct MyAccount {
    #[storage(
        slot(0),
        description = "test value",
        type = "auth::rpo_falcon512::pub_key"
    )]
    owner_public_key: Value,

    #[storage(slot(1), description = "test map")]
    asset_qty_map: StorageMap,
}

// // generated by the `component` and `storage` attribute macros
// impl Default for MyAccount {
//     fn default() -> Self {
//         Self {
//             owner_public_key: Value { slot: 0 },
//             asset_qty_map: StorageMap { slot: 1 },
//         }
//     }
// }

impl foo::Guest for MyAccount {
    fn set_asset_qty(pub_key: Word, asset: Asset, qty: Felt) {
        let mut my_account = MyAccount::default();
        let owner_key: Word = my_account.owner_public_key.read();
        if pub_key == owner_key {
            my_account.asset_qty_map.set(asset, qty);
        }
    }

    fn get_asset_qty(asset: Asset) -> Felt {
        let my_account = MyAccount::default();
        my_account.asset_qty_map.get(&asset)
    }
}
