// Do not link against libstd (i.e. anything defined in `std::`)
#![no_std]

// However, we could still use some standard library types while
// remaining no-std compatible, if we uncommented the following lines:
//
extern crate alloc;

// Global allocator to use heap memory in no-std environment
#[global_allocator]
static ALLOC: miden::BumpAlloc = miden::BumpAlloc::new();

// Required for no-std crates
#[cfg(not(test))]
#[panic_handler]
fn my_panic(_info: &core::panic::PanicInfo) -> ! {
    loop {}
}

use bindings::exports::miden::storage_example::*;

bindings::export!(MyAccount with_types_in bindings);

mod bindings;

use miden::{
    component, storage, CoreAsset, Felt, StorageMap, StorageMapAccess, Value, ValueAccess, Word,
};

#[component]
struct MyAccount {
    #[storage(
        slot(0),
        description = "test value",
        type = "auth::rpo_falcon512::pub_key"
    )]
    owner_public_key: Value,

    #[storage(slot(1), description = "test map")]
    foo_map: StorageMap,
    // #[storage(slot(2, 3), description = "test multi-slot")]
    // multi_slot: Values,
}

// // generated by the `component` and `storage` attribute macros
// impl Default for MyAccount {
//     fn default() -> Self {
//         Self {
//             owner_public_key: Value { slot: 0 },
//             foo_map: StorageMap { slot: 1 },
//         }
//     }
// }

impl foo::Guest for MyAccount {
    fn test_storage_item_low(value: Word) -> Felt {
        let (_new_root, _old_value) = storage::set_item(0, value.clone());
        let retrieved_value = storage::get_item(0);
        retrieved_value[0]
    }

    fn test_storage_map_item_low(key: Word, value: Word) -> Felt {
        let (_old_map_root, _old_map_value) = storage::set_map_item(1, key.clone(), value.clone());
        let retrieved_map_value = storage::get_map_item(1, &key);
        retrieved_map_value[0]
    }

    fn test_storage_item_high(value: Word) -> Felt {
        let my_account = MyAccount::default();
        let (_new_root, _old_value) = my_account.owner_public_key.write(value.clone());
        let high_retrieved: Word = my_account.owner_public_key.read();
        high_retrieved[0]
    }

    fn test_storage_map_item_high(key: Word, value: Word) -> Felt {
        let my_account = MyAccount::default();
        let (_old_map_root, _old_map_value) = my_account.foo_map.write(key.clone(), value.clone());
        let retrieved_map_value: Word = my_account.foo_map.read(&key);
        retrieved_map_value[0]
    }
}

impl MyAccount {
    fn test_asset(asset: CoreAsset) -> CoreAsset {
        let my_account = MyAccount::default();
        let (_new_root, _old_value) = my_account.owner_public_key.write(asset);
        my_account.owner_public_key.read()
    }
}
