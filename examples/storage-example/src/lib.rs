// Do not link against libstd (i.e. anything defined in `std::`)
#![no_std]

// However, we could still use some standard library types while
// remaining no-std compatible, if we uncommented the following lines:
//
extern crate alloc;

// Global allocator to use heap memory in no-std environment
#[global_allocator]
static ALLOC: miden::BumpAlloc = miden::BumpAlloc::new();

// Required for no-std crates
#[cfg(not(test))]
#[panic_handler]
fn my_panic(_info: &core::panic::PanicInfo) -> ! {
    loop {}
}

use bindings::exports::miden::storage_example::*;

bindings::export!(MyAccount with_types_in bindings);

mod bindings;

use miden::{component, storage, Felt, StorageMap, StorageMapAccess, Value, ValueAccess, Word};

#[component]
struct MyAccount {
    #[storage(
        slot(1),
        description = "test value",
        type = "auth::rpo_falcon512::pub_key"
    )]
    owner_public_key: Value,

    #[storage(slot(2), description = "test map")]
    foo_map: StorageMap,
    // #[storage(slot(2, 3), description = "test multi-slot")]
    // multi_slot: Values,
}

// // generated by the `component` and `storage` attribute macros
// #[allow(non_upper_case_globals)]
// const MyAccount: MyAccount = MyAccount {
//     owner_public_key: Value { slot: 1 },
//     foo_map: StorageMap { slot: 2 },
// };

impl foo::Guest for MyAccount {
    fn test_storage_item_low(value: Word) -> Felt {
        let (_new_root, _old_value) = storage::set_item(1, value.clone());
        let retrieved_value = storage::get_item(1);
        assert_eq!(value, retrieved_value);
        retrieved_value[0]
    }

    fn test_storage_map_item_low(key: Word, value: Word) -> Felt {
        let (_old_map_root, _old_map_value) = storage::set_map_item(2, key.clone(), value.clone());
        let retrieved_map_value = storage::get_map_item(2, &key);
        assert_eq!(value, retrieved_map_value);
        retrieved_map_value[0]
    }

    fn test_storage_item_high(value: Word) -> Felt {
        let (_new_root, _old_value) = MyAccount.owner_public_key.write(value);
        let high_retrieved = MyAccount.owner_public_key.read();
        high_retrieved[0]
    }

    fn test_storage_map_item_high(key: Word, value: Word) -> Felt {
        let (_old_map_root, _old_map_value) = MyAccount.foo_map.write(key.clone(), value.clone());
        let retrieved_map_value = MyAccount.foo_map.read(&key);
        assert_eq!(value, retrieved_map_value);
        retrieved_map_value[0]
    }
}
