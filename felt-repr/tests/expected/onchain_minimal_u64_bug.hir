builtin.component root_ns:root@1.0.0 {
    builtin.module public @onchain_minimal_u64_bug {
        private builtin.function @alloc::vec::Vec<T,A>::push(v0: i32, v1: felt) {
        ^block4(v0: i32, v1: felt):
            v4 = arith.constant 8 : u32;
            v3 = hir.bitcast v0 : u32;
            v5 = arith.add v3, v4 : u32 #[overflow = checked];
            v6 = arith.constant 4 : u32;
            v7 = arith.mod v5, v6 : u32;
            hir.assertz v7 #[code = 250];
            v8 = hir.int_to_ptr v5 : ptr<byte, i32>;
            v9 = hir.load v8 : i32;
            v10 = hir.bitcast v0 : u32;
            v981 = arith.constant 4 : u32;
            v12 = arith.mod v10, v981 : u32;
            hir.assertz v12 #[code = 250];
            v13 = hir.int_to_ptr v10 : ptr<byte, i32>;
            v14 = hir.load v13 : i32;
            v2 = arith.constant 0 : i32;
            v15 = arith.neq v9, v14 : i1;
            v16 = arith.zext v15 : u32;
            v17 = hir.bitcast v16 : i32;
            v19 = arith.neq v17, v2 : i1;
            scf.if v19{
            ^block104:
                scf.yield ;
            } else {
            ^block7:
                hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/alloc::raw_vec::RawVec<T,A>::grow_one(v0)
                scf.yield ;
            };
            v980 = arith.constant 4 : u32;
            v21 = hir.bitcast v0 : u32;
            v23 = arith.add v21, v980 : u32 #[overflow = checked];
            v979 = arith.constant 4 : u32;
            v25 = arith.mod v23, v979 : u32;
            hir.assertz v25 #[code = 250];
            v26 = hir.int_to_ptr v23 : ptr<byte, i32>;
            v27 = hir.load v26 : i32;
            v971 = arith.constant 2 : u32;
            v31 = arith.shl v9, v971 : i32;
            v32 = arith.add v27, v31 : i32 #[overflow = wrapping];
            v34 = hir.bitcast v32 : u32;
            v978 = arith.constant 4 : u32;
            v36 = arith.mod v34, v978 : u32;
            hir.assertz v36 #[code = 250];
            v37 = hir.int_to_ptr v34 : ptr<byte, felt>;
            hir.store v37, v1;
            v977 = arith.constant 8 : u32;
            v40 = hir.bitcast v0 : u32;
            v42 = arith.add v40, v977 : u32 #[overflow = checked];
            v976 = arith.constant 4 : u32;
            v44 = arith.mod v42, v976 : u32;
            hir.assertz v44 #[code = 250];
            v38 = arith.constant 1 : i32;
            v39 = arith.add v9, v38 : i32 #[overflow = wrapping];
            v45 = hir.int_to_ptr v42 : ptr<byte, i32>;
            hir.store v45, v39;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVec<T,A>::grow_one(v46: i32) {
        ^block8(v46: i32):
            v48 = builtin.global_symbol @root_ns:root@1.0.0/onchain_minimal_u64_bug/__stack_pointer : ptr<byte, u8>
            v49 = hir.bitcast v48 : ptr<byte, i32>;
            v50 = hir.load v49 : i32;
            v51 = arith.constant 16 : i32;
            v52 = arith.sub v50, v51 : i32 #[overflow = wrapping];
            v53 = builtin.global_symbol @root_ns:root@1.0.0/onchain_minimal_u64_bug/__stack_pointer : ptr<byte, u8>
            v54 = hir.bitcast v53 : ptr<byte, i32>;
            hir.store v54, v52;
            v57 = hir.bitcast v46 : u32;
            v58 = arith.constant 4 : u32;
            v59 = arith.mod v57, v58 : u32;
            hir.assertz v59 #[code = 250];
            v60 = hir.int_to_ptr v57 : ptr<byte, i32>;
            v61 = hir.load v60 : i32;
            v63 = arith.constant 4 : i32;
            v62 = arith.constant 1 : i32;
            v55 = arith.constant 8 : i32;
            v56 = arith.add v52, v55 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/alloc::raw_vec::RawVecInner<A>::grow_amortized(v56, v46, v61, v62, v63, v63)
            v66 = arith.constant 8 : u32;
            v65 = hir.bitcast v52 : u32;
            v67 = arith.add v65, v66 : u32 #[overflow = checked];
            v985 = arith.constant 4 : u32;
            v69 = arith.mod v67, v985 : u32;
            hir.assertz v69 #[code = 250];
            v70 = hir.int_to_ptr v67 : ptr<byte, i32>;
            v71 = hir.load v70 : i32;
            v47 = arith.constant 0 : i32;
            v72 = arith.constant -2147483647 : i32;
            v73 = arith.eq v71, v72 : i1;
            v74 = arith.zext v73 : u32;
            v75 = hir.bitcast v74 : i32;
            v77 = arith.neq v75, v47 : i1;
            cf.cond_br v77 ^block10, ^block11;
        ^block10:
            v984 = arith.constant 16 : i32;
            v87 = arith.add v52, v984 : i32 #[overflow = wrapping];
            v88 = builtin.global_symbol @root_ns:root@1.0.0/onchain_minimal_u64_bug/__stack_pointer : ptr<byte, u8>
            v89 = hir.bitcast v88 : ptr<byte, i32>;
            hir.store v89, v87;
            builtin.ret ;
        ^block11:
            v79 = arith.constant 12 : u32;
            v78 = hir.bitcast v52 : u32;
            v80 = arith.add v78, v79 : u32 #[overflow = checked];
            v983 = arith.constant 4 : u32;
            v82 = arith.mod v80, v983 : u32;
            hir.assertz v82 #[code = 250];
            v83 = hir.int_to_ptr v80 : ptr<byte, i32>;
            v84 = hir.load v83 : i32;
            v85 = arith.constant 1048588 : i32;
            hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/alloc::raw_vec::handle_error(v71, v84, v85)
            ub.unreachable ;
        };

        public builtin.function @entrypoint(v90: i32, v91: i32) {
        ^block12(v90: i32, v91: i32):
            v96 = builtin.global_symbol @root_ns:root@1.0.0/onchain_minimal_u64_bug/__stack_pointer : ptr<byte, u8>
            v97 = hir.bitcast v96 : ptr<byte, i32>;
            v98 = hir.load v97 : i32;
            v99 = arith.constant 32 : i32;
            v100 = arith.sub v98, v99 : i32 #[overflow = wrapping];
            v101 = builtin.global_symbol @root_ns:root@1.0.0/onchain_minimal_u64_bug/__stack_pointer : ptr<byte, u8>
            v102 = hir.bitcast v101 : ptr<byte, i32>;
            hir.store v102, v100;
            v103 = hir.bitcast v91 : u32;
            v104 = arith.constant 4 : u32;
            v105 = arith.mod v103, v104 : u32;
            hir.assertz v105 #[code = 250];
            v106 = hir.int_to_ptr v103 : ptr<byte, felt>;
            v107 = hir.load v106 : felt;
            v108 = arith.constant 111111 : i32;
            v109 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/intrinsics::felt::from_u32(v108) : felt
            hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/intrinsics::felt::assert_eq(v107, v109)
            v111 = arith.constant 16 : u32;
            v110 = hir.bitcast v91 : u32;
            v112 = arith.add v110, v111 : u32 #[overflow = checked];
            v1016 = arith.constant 4 : u32;
            v114 = arith.mod v112, v1016 : u32;
            hir.assertz v114 #[code = 250];
            v115 = hir.int_to_ptr v112 : ptr<byte, felt>;
            v116 = hir.load v115 : felt;
            v117 = arith.constant 55 : i32;
            v118 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/intrinsics::felt::from_u32(v117) : felt
            hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/intrinsics::felt::assert_eq(v116, v118)
            v119 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/intrinsics::felt::as_u64(v107) : i64
            v1015 = arith.constant 4 : u32;
            v120 = hir.bitcast v91 : u32;
            v122 = arith.add v120, v1015 : u32 #[overflow = checked];
            v1014 = arith.constant 4 : u32;
            v124 = arith.mod v122, v1014 : u32;
            hir.assertz v124 #[code = 250];
            v125 = hir.int_to_ptr v122 : ptr<byte, felt>;
            v126 = hir.load v125 : felt;
            v127 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/intrinsics::felt::as_u64(v126) : i64
            v129 = arith.constant 8 : u32;
            v128 = hir.bitcast v91 : u32;
            v130 = arith.add v128, v129 : u32 #[overflow = checked];
            v1013 = arith.constant 4 : u32;
            v132 = arith.mod v130, v1013 : u32;
            hir.assertz v132 #[code = 250];
            v133 = hir.int_to_ptr v130 : ptr<byte, felt>;
            v134 = hir.load v133 : felt;
            v135 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/intrinsics::felt::as_u64(v134) : i64
            v137 = arith.constant 12 : u32;
            v136 = hir.bitcast v91 : u32;
            v138 = arith.add v136, v137 : u32 #[overflow = checked];
            v1012 = arith.constant 4 : u32;
            v140 = arith.mod v138, v1012 : u32;
            hir.assertz v140 #[code = 250];
            v141 = hir.int_to_ptr v138 : ptr<byte, felt>;
            v142 = hir.load v141 : felt;
            v143 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/intrinsics::felt::as_u64(v142) : i64
            v144 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/intrinsics::felt::as_u64(v116) : i64
            v149 = arith.constant 4 : i32;
            v92 = arith.constant 0 : i32;
            v147 = arith.constant 256 : i32;
            v145 = arith.constant 20 : i32;
            v146 = arith.add v100, v145 : i32 #[overflow = wrapping];
            hir.store_local v90 #[local = lv0];
            hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/alloc::raw_vec::RawVecInner<A>::try_allocate_in(v146, v147, v92, v149, v149)
            v152 = arith.constant 24 : u32;
            v151 = hir.bitcast v100 : u32;
            v153 = arith.add v151, v152 : u32 #[overflow = checked];
            v1011 = arith.constant 4 : u32;
            v155 = arith.mod v153, v1011 : u32;
            hir.assertz v155 #[code = 250];
            v156 = hir.int_to_ptr v153 : ptr<byte, i32>;
            v157 = hir.load v156 : i32;
            v159 = arith.constant 20 : u32;
            v158 = hir.bitcast v100 : u32;
            v160 = arith.add v158, v159 : u32 #[overflow = checked];
            v1010 = arith.constant 4 : u32;
            v162 = arith.mod v160, v1010 : u32;
            hir.assertz v162 #[code = 250];
            v163 = hir.int_to_ptr v160 : ptr<byte, i32>;
            v164 = hir.load v163 : i32;
            v1009 = arith.constant 0 : i32;
            v165 = arith.constant 1 : i32;
            v166 = arith.neq v164, v165 : i1;
            v167 = arith.zext v166 : u32;
            v168 = hir.bitcast v167 : i32;
            v170 = arith.neq v168, v1009 : i1;
            cf.cond_br v170 ^block14, ^block15;
        ^block14:
            v1008 = arith.constant 8 : i32;
            v179 = arith.constant 8 : i32;
            v180 = arith.add v100, v179 : i32 #[overflow = wrapping];
            v182 = arith.add v180, v1008 : i32 #[overflow = wrapping];
            v184 = hir.bitcast v182 : u32;
            v1007 = arith.constant 4 : u32;
            v186 = arith.mod v184, v1007 : u32;
            hir.assertz v186 #[code = 250];
            v1006 = arith.constant 0 : i32;
            v187 = hir.int_to_ptr v184 : ptr<byte, i32>;
            hir.store v187, v1006;
            v189 = arith.constant 28 : u32;
            v188 = hir.bitcast v100 : u32;
            v190 = arith.add v188, v189 : u32 #[overflow = checked];
            v1005 = arith.constant 4 : u32;
            v192 = arith.mod v190, v1005 : u32;
            hir.assertz v192 #[code = 250];
            v193 = hir.int_to_ptr v190 : ptr<byte, i32>;
            v194 = hir.load v193 : i32;
            v1004 = arith.constant 12 : u32;
            v195 = hir.bitcast v100 : u32;
            v197 = arith.add v195, v1004 : u32 #[overflow = checked];
            v1003 = arith.constant 4 : u32;
            v199 = arith.mod v197, v1003 : u32;
            hir.assertz v199 #[code = 250];
            v200 = hir.int_to_ptr v197 : ptr<byte, i32>;
            hir.store v200, v194;
            v1002 = arith.constant 8 : u32;
            v201 = hir.bitcast v100 : u32;
            v203 = arith.add v201, v1002 : u32 #[overflow = checked];
            v1001 = arith.constant 4 : u32;
            v205 = arith.mod v203, v1001 : u32;
            hir.assertz v205 #[code = 250];
            v206 = hir.int_to_ptr v203 : ptr<byte, i32>;
            hir.store v206, v157;
            v209 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/intrinsics::felt::from_u64_unchecked(v119) : felt
            v1000 = arith.constant 8 : i32;
            v208 = arith.add v100, v1000 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/alloc::vec::Vec<T,A>::push(v208, v209)
            v212 = arith.trunc v127 : i32;
            v213 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/<miden_stdlib_sys::intrinsics::felt::Felt as core::convert::From<u32>>::from(v212) : felt
            v999 = arith.constant 8 : i32;
            v211 = arith.add v100, v999 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/alloc::vec::Vec<T,A>::push(v211, v213)
            v216 = arith.trunc v135 : i32;
            v217 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/<miden_stdlib_sys::intrinsics::felt::Felt as core::convert::From<u32>>::from(v216) : felt
            v998 = arith.constant 8 : i32;
            v215 = arith.add v100, v998 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/alloc::vec::Vec<T,A>::push(v215, v217)
            v220 = arith.trunc v143 : i32;
            v221 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/<miden_stdlib_sys::intrinsics::felt::Felt as core::convert::From<u32>>::from(v220) : felt
            v997 = arith.constant 8 : i32;
            v219 = arith.add v100, v997 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/alloc::vec::Vec<T,A>::push(v219, v221)
            v224 = arith.trunc v144 : i32;
            v225 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/<miden_stdlib_sys::intrinsics::felt::Felt as core::convert::From<u32>>::from(v224) : felt
            v996 = arith.constant 8 : i32;
            v223 = arith.add v100, v996 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/alloc::vec::Vec<T,A>::push(v223, v225)
            v228 = hir.bitcast v182 : u32;
            v995 = arith.constant 4 : u32;
            v230 = arith.mod v228, v995 : u32;
            hir.assertz v230 #[code = 250];
            v231 = hir.int_to_ptr v228 : ptr<byte, i32>;
            v232 = hir.load v231 : i32;
            v994 = arith.constant 8 : i32;
            v1018 = hir.load_local  : i32 #[local = lv0];
            v227 = arith.add v1018, v994 : i32 #[overflow = wrapping];
            v233 = hir.bitcast v227 : u32;
            v993 = arith.constant 4 : u32;
            v235 = arith.mod v233, v993 : u32;
            hir.assertz v235 #[code = 250];
            v236 = hir.int_to_ptr v233 : ptr<byte, i32>;
            hir.store v236, v232;
            v992 = arith.constant 8 : u32;
            v237 = hir.bitcast v100 : u32;
            v239 = arith.add v237, v992 : u32 #[overflow = checked];
            v991 = arith.constant 4 : u32;
            v241 = arith.mod v239, v991 : u32;
            hir.assertz v241 #[code = 250];
            v242 = hir.int_to_ptr v239 : ptr<byte, i64>;
            v243 = hir.load v242 : i64;
            v244 = hir.bitcast v1018 : u32;
            v990 = arith.constant 4 : u32;
            v246 = arith.mod v244, v990 : u32;
            hir.assertz v246 #[code = 250];
            v247 = hir.int_to_ptr v244 : ptr<byte, i64>;
            hir.store v247, v243;
            v989 = arith.constant 32 : i32;
            v249 = arith.add v100, v989 : i32 #[overflow = wrapping];
            v250 = builtin.global_symbol @root_ns:root@1.0.0/onchain_minimal_u64_bug/__stack_pointer : ptr<byte, u8>
            v251 = hir.bitcast v250 : ptr<byte, i32>;
            hir.store v251, v249;
            builtin.ret ;
        ^block15:
            v988 = arith.constant 28 : u32;
            v171 = hir.bitcast v100 : u32;
            v173 = arith.add v171, v988 : u32 #[overflow = checked];
            v987 = arith.constant 4 : u32;
            v175 = arith.mod v173, v987 : u32;
            hir.assertz v175 #[code = 250];
            v176 = hir.int_to_ptr v173 : ptr<byte, i32>;
            v177 = hir.load v176 : i32;
            v178 = arith.constant 1048588 : i32;
            hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/alloc::raw_vec::handle_error(v157, v177, v178)
            ub.unreachable ;
        };

        private builtin.function @__rustc::__rust_alloc(v252: i32, v253: i32) -> i32 {
        ^block16(v252: i32, v253: i32):
            v255 = arith.constant 1048604 : i32;
            v256 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v255, v253, v252) : i32
            builtin.ret v256;
        };

        private builtin.function @__rustc::__rust_realloc(v257: i32, v258: i32, v259: i32, v260: i32) -> i32 {
        ^block18(v257: i32, v258: i32, v259: i32, v260: i32):
            v262 = arith.constant 1048604 : i32;
            v263 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v262, v259, v260) : i32
            v1027 = arith.constant 0 : i32;
            v264 = arith.constant 0 : i32;
            v265 = arith.eq v263, v264 : i1;
            v266 = arith.zext v265 : u32;
            v267 = hir.bitcast v266 : i32;
            v269 = arith.neq v267, v1027 : i1;
            scf.if v269{
            ^block20:
                scf.yield ;
            } else {
            ^block21:
                v1026 = arith.constant 0 : i32;
                v271 = hir.bitcast v258 : u32;
                v270 = hir.bitcast v260 : u32;
                v272 = arith.lt v270, v271 : i1;
                v273 = arith.zext v272 : u32;
                v274 = hir.bitcast v273 : i32;
                v276 = arith.neq v274, v1026 : i1;
                v277 = cf.select v276, v260, v258 : i32;
                v1024 = arith.constant 0 : i32;
                v1025 = arith.constant 0 : i32;
                v279 = arith.eq v277, v1025 : i1;
                v280 = arith.zext v279 : u32;
                v281 = hir.bitcast v280 : i32;
                v283 = arith.neq v281, v1024 : i1;
                scf.if v283{
                ^block110:
                    scf.yield ;
                } else {
                ^block22:
                    v284 = hir.bitcast v277 : u32;
                    v285 = hir.bitcast v263 : u32;
                    v286 = hir.int_to_ptr v285 : ptr<byte, u8>;
                    v287 = hir.bitcast v257 : u32;
                    v288 = hir.int_to_ptr v287 : ptr<byte, u8>;
                    hir.mem_cpy v288, v286, v284;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v263;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v290: i32, v291: i32) -> i32 {
        ^block23(v290: i32, v291: i32):
            v293 = arith.constant 1048604 : i32;
            v294 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v293, v291, v290) : i32
            v1036 = arith.constant 0 : i32;
            v295 = arith.constant 0 : i32;
            v296 = arith.eq v294, v295 : i1;
            v297 = arith.zext v296 : u32;
            v298 = hir.bitcast v297 : i32;
            v300 = arith.neq v298, v1036 : i1;
            scf.if v300{
            ^block25:
                scf.yield ;
            } else {
            ^block26:
                v1034 = arith.constant 0 : i32;
                v1035 = arith.constant 0 : i32;
                v302 = arith.eq v290, v1035 : i1;
                v303 = arith.zext v302 : u32;
                v304 = hir.bitcast v303 : i32;
                v306 = arith.neq v304, v1034 : i1;
                scf.if v306{
                ^block113:
                    scf.yield ;
                } else {
                ^block27:
                    v1028 = arith.constant 0 : u8;
                    v309 = hir.bitcast v290 : u32;
                    v310 = hir.bitcast v294 : u32;
                    v311 = hir.int_to_ptr v310 : ptr<byte, u8>;
                    hir.mem_set v311, v309, v1028;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v294;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block28:
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v313: i32, v314: i32, v315: i32) -> i32 {
        ^block30(v313: i32, v314: i32, v315: i32):
            v318 = arith.constant 16 : i32;
            v317 = arith.constant 0 : i32;
            v1038 = arith.constant 16 : u32;
            v320 = hir.bitcast v314 : u32;
            v322 = arith.gt v320, v1038 : i1;
            v323 = arith.zext v322 : u32;
            v324 = hir.bitcast v323 : i32;
            v326 = arith.neq v324, v317 : i1;
            v327 = cf.select v326, v314, v318 : i32;
            v1078 = arith.constant 0 : i32;
            v328 = arith.constant -1 : i32;
            v329 = arith.add v327, v328 : i32 #[overflow = wrapping];
            v330 = arith.band v327, v329 : i32;
            v332 = arith.neq v330, v1078 : i1;
            v1047, v1048 = scf.if v332 : i32, u32 {
            ^block118:
                v1039 = arith.constant 0 : u32;
                v1043 = ub.poison i32 : i32;
                scf.yield v1043, v1039;
            } else {
            ^block33:
                v334 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/core::ptr::alignment::Alignment::max(v314, v327) : i32
                v1077 = arith.constant 0 : i32;
                v333 = arith.constant -2147483648 : i32;
                v335 = arith.sub v333, v334 : i32 #[overflow = wrapping];
                v337 = hir.bitcast v335 : u32;
                v336 = hir.bitcast v315 : u32;
                v338 = arith.gt v336, v337 : i1;
                v339 = arith.zext v338 : u32;
                v340 = hir.bitcast v339 : i32;
                v342 = arith.neq v340, v1077 : i1;
                v1062 = scf.if v342 : i32 {
                ^block117:
                    v1076 = ub.poison i32 : i32;
                    scf.yield v1076;
                } else {
                ^block34:
                    v1074 = arith.constant 0 : i32;
                    v348 = arith.sub v1074, v334 : i32 #[overflow = wrapping];
                    v1075 = arith.constant -1 : i32;
                    v344 = arith.add v315, v334 : i32 #[overflow = wrapping];
                    v346 = arith.add v344, v1075 : i32 #[overflow = wrapping];
                    v349 = arith.band v346, v348 : i32;
                    v350 = hir.bitcast v313 : u32;
                    v351 = arith.constant 4 : u32;
                    v352 = arith.mod v350, v351 : u32;
                    hir.assertz v352 #[code = 250];
                    v353 = hir.int_to_ptr v350 : ptr<byte, i32>;
                    v354 = hir.load v353 : i32;
                    v1073 = arith.constant 0 : i32;
                    v356 = arith.neq v354, v1073 : i1;
                    scf.if v356{
                    ^block116:
                        scf.yield ;
                    } else {
                    ^block36:
                        v357 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/intrinsics::mem::heap_base() : i32
                        v358 = hir.mem_size  : u32;
                        v364 = hir.bitcast v313 : u32;
                        v1072 = arith.constant 4 : u32;
                        v366 = arith.mod v364, v1072 : u32;
                        hir.assertz v366 #[code = 250];
                        v1071 = arith.constant 16 : u32;
                        v359 = hir.bitcast v358 : i32;
                        v362 = arith.shl v359, v1071 : i32;
                        v363 = arith.add v357, v362 : i32 #[overflow = wrapping];
                        v367 = hir.int_to_ptr v364 : ptr<byte, i32>;
                        hir.store v367, v363;
                        scf.yield ;
                    };
                    v370 = hir.bitcast v313 : u32;
                    v1070 = arith.constant 4 : u32;
                    v372 = arith.mod v370, v1070 : u32;
                    hir.assertz v372 #[code = 250];
                    v373 = hir.int_to_ptr v370 : ptr<byte, i32>;
                    v374 = hir.load v373 : i32;
                    v1068 = arith.constant 0 : i32;
                    v1069 = arith.constant -1 : i32;
                    v376 = arith.bxor v374, v1069 : i32;
                    v378 = hir.bitcast v376 : u32;
                    v377 = hir.bitcast v349 : u32;
                    v379 = arith.gt v377, v378 : i1;
                    v380 = arith.zext v379 : u32;
                    v381 = hir.bitcast v380 : i32;
                    v383 = arith.neq v381, v1068 : i1;
                    v1061 = scf.if v383 : i32 {
                    ^block37:
                        v1067 = arith.constant 0 : i32;
                        scf.yield v1067;
                    } else {
                    ^block38:
                        v385 = hir.bitcast v313 : u32;
                        v1066 = arith.constant 4 : u32;
                        v387 = arith.mod v385, v1066 : u32;
                        hir.assertz v387 #[code = 250];
                        v384 = arith.add v374, v349 : i32 #[overflow = wrapping];
                        v388 = hir.int_to_ptr v385 : ptr<byte, i32>;
                        hir.store v388, v384;
                        v390 = arith.add v374, v334 : i32 #[overflow = wrapping];
                        scf.yield v390;
                    };
                    scf.yield v1061;
                };
                v1044 = arith.constant 1 : u32;
                v1065 = arith.constant 0 : u32;
                v1063 = cf.select v342, v1065, v1044 : u32;
                scf.yield v1062, v1063;
            };
            v1064 = arith.constant 0 : u32;
            v1060 = arith.eq v1048, v1064 : i1;
            cf.cond_br v1060 ^block32, ^block120(v1047);
        ^block32:
            ub.unreachable ;
        ^block120(v1040: i32):
            builtin.ret v1040;
        };

        private builtin.function @intrinsics::mem::heap_base() -> i32 {
        ^block39:
            v393 = hir.exec @intrinsics/mem/heap_base() : i32
            builtin.ret v393;
        };

        private builtin.function @<miden_stdlib_sys::intrinsics::felt::Felt as core::convert::From<u32>>::from(v395: i32) -> felt {
        ^block43(v395: i32):
            v397 = hir.bitcast v395 : felt;
            builtin.ret v397;
        };

        private builtin.function @intrinsics::felt::from_u64_unchecked(v398: i64) -> felt {
        ^block45(v398: i64):
            v399 = hir.cast v398 : felt;
            builtin.ret v399;
        };

        private builtin.function @intrinsics::felt::from_u32(v401: i32) -> felt {
        ^block47(v401: i32):
            v402 = hir.bitcast v401 : felt;
            builtin.ret v402;
        };

        private builtin.function @intrinsics::felt::as_u64(v404: felt) -> i64 {
        ^block49(v404: felt):
            v405 = hir.cast v404 : i64;
            builtin.ret v405;
        };

        private builtin.function @intrinsics::felt::assert_eq(v407: felt, v408: felt) {
        ^block51(v407: felt, v408: felt):
            hir.assert_eq v407, v408;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::grow_amortized(v409: i32, v410: i32, v411: i32, v412: i32, v413: i32, v414: i32) {
        ^block53(v409: i32, v410: i32, v411: i32, v412: i32, v413: i32, v414: i32):
            v417 = builtin.global_symbol @root_ns:root@1.0.0/onchain_minimal_u64_bug/__stack_pointer : ptr<byte, u8>
            v418 = hir.bitcast v417 : ptr<byte, i32>;
            v419 = hir.load v418 : i32;
            v420 = arith.constant 32 : i32;
            v421 = arith.sub v419, v420 : i32 #[overflow = wrapping];
            v422 = builtin.global_symbol @root_ns:root@1.0.0/onchain_minimal_u64_bug/__stack_pointer : ptr<byte, u8>
            v423 = hir.bitcast v422 : ptr<byte, i32>;
            hir.store v423, v421;
            v1155 = arith.constant 0 : i32;
            v415 = arith.constant 0 : i32;
            v426 = arith.eq v414, v415 : i1;
            v427 = arith.zext v426 : u32;
            v428 = hir.bitcast v427 : i32;
            v430 = arith.neq v428, v1155 : i1;
            v1126, v1127 = scf.if v430 : i32, i32 {
            ^block56:
                v1154 = arith.constant 0 : i32;
                scf.yield v1154, v1154;
            } else {
            ^block57:
                v431 = arith.add v411, v412 : i32 #[overflow = wrapping];
                v1153 = arith.constant 0 : i32;
                v433 = hir.bitcast v411 : u32;
                v432 = hir.bitcast v431 : u32;
                v434 = arith.lt v432, v433 : i1;
                v435 = arith.zext v434 : u32;
                v436 = hir.bitcast v435 : i32;
                v438 = arith.neq v436, v1153 : i1;
                v1124, v1125 = scf.if v438 : i32, i32 {
                ^block126:
                    v1152 = arith.constant 0 : i32;
                    scf.yield v1152, v1152;
                } else {
                ^block58:
                    v449 = hir.bitcast v410 : u32;
                    v563 = arith.constant 4 : u32;
                    v451 = arith.mod v449, v563 : u32;
                    hir.assertz v451 #[code = 250];
                    v452 = hir.int_to_ptr v449 : ptr<byte, i32>;
                    v453 = hir.load v452 : i32;
                    v1080 = arith.constant 1 : u32;
                    v456 = arith.shl v453, v1080 : i32;
                    v1151 = arith.constant 0 : i32;
                    v458 = hir.bitcast v456 : u32;
                    v457 = hir.bitcast v431 : u32;
                    v459 = arith.gt v457, v458 : i1;
                    v460 = arith.zext v459 : u32;
                    v461 = hir.bitcast v460 : i32;
                    v463 = arith.neq v461, v1151 : i1;
                    v464 = cf.select v463, v431, v456 : i32;
                    v1148 = arith.constant 1 : i32;
                    v466 = arith.constant 4 : i32;
                    v1149 = arith.constant 0 : i32;
                    v1079 = arith.constant 1025 : u32;
                    v469 = hir.bitcast v414 : u32;
                    v471 = arith.lt v469, v1079 : i1;
                    v472 = arith.zext v471 : u32;
                    v473 = hir.bitcast v472 : i32;
                    v475 = arith.neq v473, v1149 : i1;
                    v476 = cf.select v475, v466, v1148 : i32;
                    v465 = arith.constant 8 : i32;
                    v1150 = arith.constant 0 : i32;
                    v454 = arith.constant 1 : i32;
                    v478 = arith.eq v414, v454 : i1;
                    v479 = arith.zext v478 : u32;
                    v480 = hir.bitcast v479 : i32;
                    v482 = arith.neq v480, v1150 : i1;
                    v483 = cf.select v482, v465, v476 : i32;
                    v1147 = arith.constant 0 : i32;
                    v485 = hir.bitcast v483 : u32;
                    v484 = hir.bitcast v464 : u32;
                    v486 = arith.gt v484, v485 : i1;
                    v487 = arith.zext v486 : u32;
                    v488 = hir.bitcast v487 : i32;
                    v490 = arith.neq v488, v1147 : i1;
                    v491 = cf.select v490, v464, v483 : i32;
                    v492 = hir.bitcast v491 : u32;
                    v493 = arith.zext v492 : u64;
                    v494 = hir.bitcast v493 : i64;
                    v1146 = arith.constant 0 : i32;
                    v444 = arith.sub v1146, v413 : i32 #[overflow = wrapping];
                    v441 = arith.constant -1 : i32;
                    v440 = arith.add v413, v414 : i32 #[overflow = wrapping];
                    v442 = arith.add v440, v441 : i32 #[overflow = wrapping];
                    v445 = arith.band v442, v444 : i32;
                    v446 = hir.bitcast v445 : u32;
                    v447 = arith.zext v446 : u64;
                    v448 = hir.bitcast v447 : i64;
                    v495 = arith.mul v448, v494 : i64 #[overflow = wrapping];
                    v1145 = arith.constant 0 : i32;
                    v496 = arith.constant 32 : i64;
                    v498 = hir.cast v496 : u32;
                    v497 = hir.bitcast v495 : u64;
                    v499 = arith.shr v497, v498 : u64;
                    v500 = hir.bitcast v499 : i64;
                    v501 = arith.trunc v500 : i32;
                    v503 = arith.neq v501, v1145 : i1;
                    v1122, v1123 = scf.if v503 : i32, i32 {
                    ^block125:
                        v1144 = arith.constant 0 : i32;
                        scf.yield v464, v1144;
                    } else {
                    ^block59:
                        v504 = arith.trunc v495 : i32;
                        v1143 = arith.constant 0 : i32;
                        v505 = arith.constant -2147483648 : i32;
                        v506 = arith.sub v505, v413 : i32 #[overflow = wrapping];
                        v508 = hir.bitcast v506 : u32;
                        v507 = hir.bitcast v504 : u32;
                        v509 = arith.gt v507, v508 : i1;
                        v510 = arith.zext v509 : u32;
                        v511 = hir.bitcast v510 : i32;
                        v513 = arith.neq v511, v1143 : i1;
                        v1120, v1121 = scf.if v513 : i32, i32 {
                        ^block124:
                            v1142 = arith.constant 0 : i32;
                            scf.yield v464, v1142;
                        } else {
                        ^block60:
                            v514 = arith.constant 20 : i32;
                            v515 = arith.add v421, v514 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/alloc::raw_vec::RawVecInner<A>::current_memory(v515, v410, v413, v414)
                            v1140 = arith.constant 20 : i32;
                            v519 = arith.add v421, v1140 : i32 #[overflow = wrapping];
                            v1141 = arith.constant 8 : i32;
                            v517 = arith.add v421, v1141 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/alloc::raw_vec::finish_grow(v517, v413, v504, v519, v409)
                            v521 = arith.constant 12 : u32;
                            v520 = hir.bitcast v421 : u32;
                            v522 = arith.add v520, v521 : u32 #[overflow = checked];
                            v1139 = arith.constant 4 : u32;
                            v524 = arith.mod v522, v1139 : u32;
                            hir.assertz v524 #[code = 250];
                            v525 = hir.int_to_ptr v522 : ptr<byte, i32>;
                            v526 = hir.load v525 : i32;
                            v528 = arith.constant 8 : u32;
                            v527 = hir.bitcast v421 : u32;
                            v529 = arith.add v527, v528 : u32 #[overflow = checked];
                            v1138 = arith.constant 4 : u32;
                            v531 = arith.mod v529, v1138 : u32;
                            hir.assertz v531 #[code = 250];
                            v532 = hir.int_to_ptr v529 : ptr<byte, i32>;
                            v533 = hir.load v532 : i32;
                            v1136 = arith.constant 0 : i32;
                            v1137 = arith.constant 0 : i32;
                            v535 = arith.eq v533, v1137 : i1;
                            v536 = arith.zext v535 : u32;
                            v537 = hir.bitcast v536 : i32;
                            v539 = arith.neq v537, v1136 : i1;
                            v1118 = scf.if v539 : i32 {
                            ^block61:
                                v547 = hir.bitcast v410 : u32;
                                v1135 = arith.constant 4 : u32;
                                v549 = arith.mod v547, v1135 : u32;
                                hir.assertz v549 #[code = 250];
                                v550 = hir.int_to_ptr v547 : ptr<byte, i32>;
                                hir.store v550, v491;
                                v1134 = arith.constant 4 : u32;
                                v551 = hir.bitcast v410 : u32;
                                v553 = arith.add v551, v1134 : u32 #[overflow = checked];
                                v1133 = arith.constant 4 : u32;
                                v555 = arith.mod v553, v1133 : u32;
                                hir.assertz v555 #[code = 250];
                                v556 = hir.int_to_ptr v553 : ptr<byte, i32>;
                                hir.store v556, v526;
                                scf.yield v464;
                            } else {
                            ^block62:
                                v541 = arith.constant 16 : u32;
                                v540 = hir.bitcast v421 : u32;
                                v542 = arith.add v540, v541 : u32 #[overflow = checked];
                                v1132 = arith.constant 4 : u32;
                                v544 = arith.mod v542, v1132 : u32;
                                hir.assertz v544 #[code = 250];
                                v545 = hir.int_to_ptr v542 : ptr<byte, i32>;
                                v546 = hir.load v545 : i32;
                                scf.yield v546;
                            };
                            v557 = arith.constant -2147483647 : i32;
                            v1119 = cf.select v539, v557, v526 : i32;
                            scf.yield v1118, v1119;
                        };
                        scf.yield v1120, v1121;
                    };
                    scf.yield v1122, v1123;
                };
                scf.yield v1124, v1125;
            };
            v1131 = arith.constant 4 : u32;
            v562 = hir.bitcast v409 : u32;
            v564 = arith.add v562, v1131 : u32 #[overflow = checked];
            v1130 = arith.constant 4 : u32;
            v566 = arith.mod v564, v1130 : u32;
            hir.assertz v566 #[code = 250];
            v567 = hir.int_to_ptr v564 : ptr<byte, i32>;
            hir.store v567, v1126;
            v570 = hir.bitcast v409 : u32;
            v1129 = arith.constant 4 : u32;
            v572 = arith.mod v570, v1129 : u32;
            hir.assertz v572 #[code = 250];
            v573 = hir.int_to_ptr v570 : ptr<byte, i32>;
            hir.store v573, v1127;
            v1128 = arith.constant 32 : i32;
            v577 = arith.add v421, v1128 : i32 #[overflow = wrapping];
            v578 = builtin.global_symbol @root_ns:root@1.0.0/onchain_minimal_u64_bug/__stack_pointer : ptr<byte, u8>
            v579 = hir.bitcast v578 : ptr<byte, i32>;
            hir.store v579, v577;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::try_allocate_in(v580: i32, v581: i32, v582: i32, v583: i32, v584: i32) {
        ^block63(v580: i32, v581: i32, v582: i32, v583: i32, v584: i32):
            v587 = builtin.global_symbol @root_ns:root@1.0.0/onchain_minimal_u64_bug/__stack_pointer : ptr<byte, u8>
            v588 = hir.bitcast v587 : ptr<byte, i32>;
            v589 = hir.load v588 : i32;
            v590 = arith.constant 16 : i32;
            v591 = arith.sub v589, v590 : i32 #[overflow = wrapping];
            v592 = builtin.global_symbol @root_ns:root@1.0.0/onchain_minimal_u64_bug/__stack_pointer : ptr<byte, u8>
            v593 = hir.bitcast v592 : ptr<byte, i32>;
            hir.store v593, v591;
            v603 = hir.bitcast v581 : u32;
            v604 = arith.zext v603 : u64;
            v605 = hir.bitcast v604 : i64;
            v585 = arith.constant 0 : i32;
            v598 = arith.sub v585, v583 : i32 #[overflow = wrapping];
            v595 = arith.constant -1 : i32;
            v594 = arith.add v583, v584 : i32 #[overflow = wrapping];
            v596 = arith.add v594, v595 : i32 #[overflow = wrapping];
            v599 = arith.band v596, v598 : i32;
            v600 = hir.bitcast v599 : u32;
            v601 = arith.zext v600 : u64;
            v602 = hir.bitcast v601 : i64;
            v606 = arith.mul v602, v605 : i64 #[overflow = wrapping];
            v1259 = arith.constant 0 : i32;
            v607 = arith.constant 32 : i64;
            v609 = hir.cast v607 : u32;
            v608 = hir.bitcast v606 : u64;
            v610 = arith.shr v608, v609 : u64;
            v611 = hir.bitcast v610 : i64;
            v612 = arith.trunc v611 : i32;
            v614 = arith.neq v612, v1259 : i1;
            v1171, v1172, v1173, v1174, v1175, v1176 = scf.if v614 : i32, i32, i32, i32, i32, u32 {
            ^block132:
                v1156 = arith.constant 0 : u32;
                v1163 = ub.poison i32 : i32;
                scf.yield v580, v591, v1163, v1163, v1163, v1156;
            } else {
            ^block68:
                v615 = arith.trunc v606 : i32;
                v1258 = arith.constant 0 : i32;
                v616 = arith.constant -2147483648 : i32;
                v617 = arith.sub v616, v583 : i32 #[overflow = wrapping];
                v619 = hir.bitcast v617 : u32;
                v618 = hir.bitcast v615 : u32;
                v620 = arith.lte v618, v619 : i1;
                v621 = arith.zext v620 : u32;
                v622 = hir.bitcast v621 : i32;
                v624 = arith.neq v622, v1258 : i1;
                v1219 = scf.if v624 : i32 {
                ^block66:
                    v1257 = arith.constant 0 : i32;
                    v635 = arith.neq v615, v1257 : i1;
                    v1218 = scf.if v635 : i32 {
                    ^block70:
                        v1256 = arith.constant 0 : i32;
                        v651 = arith.neq v582, v1256 : i1;
                        v1217 = scf.if v651 : i32 {
                        ^block73:
                            v633 = arith.constant 1 : i32;
                            hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/alloc::alloc::Global::alloc_impl(v591, v583, v615, v633)
                            v662 = hir.bitcast v591 : u32;
                            v707 = arith.constant 4 : u32;
                            v664 = arith.mod v662, v707 : u32;
                            hir.assertz v664 #[code = 250];
                            v665 = hir.int_to_ptr v662 : ptr<byte, i32>;
                            v666 = hir.load v665 : i32;
                            scf.yield v666;
                        } else {
                        ^block74:
                            v652 = arith.constant 8 : i32;
                            v653 = arith.add v591, v652 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v653, v583, v615)
                            v637 = arith.constant 8 : u32;
                            v654 = hir.bitcast v591 : u32;
                            v656 = arith.add v654, v637 : u32 #[overflow = checked];
                            v1255 = arith.constant 4 : u32;
                            v658 = arith.mod v656, v1255 : u32;
                            hir.assertz v658 #[code = 250];
                            v659 = hir.int_to_ptr v656 : ptr<byte, i32>;
                            v660 = hir.load v659 : i32;
                            scf.yield v660;
                        };
                        v1253 = arith.constant 0 : i32;
                        v1254 = arith.constant 0 : i32;
                        v669 = arith.eq v1217, v1254 : i1;
                        v670 = arith.zext v669 : u32;
                        v671 = hir.bitcast v670 : i32;
                        v673 = arith.neq v671, v1253 : i1;
                        scf.if v673{
                        ^block75:
                            v1252 = arith.constant 8 : u32;
                            v690 = hir.bitcast v580 : u32;
                            v692 = arith.add v690, v1252 : u32 #[overflow = checked];
                            v1251 = arith.constant 4 : u32;
                            v694 = arith.mod v692, v1251 : u32;
                            hir.assertz v694 #[code = 250];
                            v695 = hir.int_to_ptr v692 : ptr<byte, i32>;
                            hir.store v695, v615;
                            v1250 = arith.constant 4 : u32;
                            v697 = hir.bitcast v580 : u32;
                            v699 = arith.add v697, v1250 : u32 #[overflow = checked];
                            v1249 = arith.constant 4 : u32;
                            v701 = arith.mod v699, v1249 : u32;
                            hir.assertz v701 #[code = 250];
                            v702 = hir.int_to_ptr v699 : ptr<byte, i32>;
                            hir.store v702, v583;
                            scf.yield ;
                        } else {
                        ^block76:
                            v1248 = arith.constant 8 : u32;
                            v675 = hir.bitcast v580 : u32;
                            v677 = arith.add v675, v1248 : u32 #[overflow = checked];
                            v1247 = arith.constant 4 : u32;
                            v679 = arith.mod v677, v1247 : u32;
                            hir.assertz v679 #[code = 250];
                            v680 = hir.int_to_ptr v677 : ptr<byte, i32>;
                            hir.store v680, v1217;
                            v1246 = arith.constant 4 : u32;
                            v682 = hir.bitcast v580 : u32;
                            v684 = arith.add v682, v1246 : u32 #[overflow = checked];
                            v1245 = arith.constant 4 : u32;
                            v686 = arith.mod v684, v1245 : u32;
                            hir.assertz v686 #[code = 250];
                            v687 = hir.int_to_ptr v684 : ptr<byte, i32>;
                            hir.store v687, v581;
                            scf.yield ;
                        };
                        v1243 = arith.constant 0 : i32;
                        v1244 = arith.constant 1 : i32;
                        v1216 = cf.select v673, v1244, v1243 : i32;
                        scf.yield v1216;
                    } else {
                    ^block71:
                        v1242 = arith.constant 8 : u32;
                        v636 = hir.bitcast v580 : u32;
                        v638 = arith.add v636, v1242 : u32 #[overflow = checked];
                        v1241 = arith.constant 4 : u32;
                        v640 = arith.mod v638, v1241 : u32;
                        hir.assertz v640 #[code = 250];
                        v641 = hir.int_to_ptr v638 : ptr<byte, i32>;
                        hir.store v641, v583;
                        v1240 = arith.constant 4 : u32;
                        v644 = hir.bitcast v580 : u32;
                        v646 = arith.add v644, v1240 : u32 #[overflow = checked];
                        v1239 = arith.constant 4 : u32;
                        v648 = arith.mod v646, v1239 : u32;
                        hir.assertz v648 #[code = 250];
                        v1238 = arith.constant 0 : i32;
                        v649 = hir.int_to_ptr v646 : ptr<byte, i32>;
                        hir.store v649, v1238;
                        v1237 = arith.constant 0 : i32;
                        scf.yield v1237;
                    };
                    scf.yield v1218;
                } else {
                ^block69:
                    v1236 = ub.poison i32 : i32;
                    scf.yield v1236;
                };
                v1231 = arith.constant 0 : u32;
                v1164 = arith.constant 1 : u32;
                v1224 = cf.select v624, v1164, v1231 : u32;
                v1232 = ub.poison i32 : i32;
                v1223 = cf.select v624, v591, v1232 : i32;
                v1233 = ub.poison i32 : i32;
                v1222 = cf.select v624, v580, v1233 : i32;
                v1234 = ub.poison i32 : i32;
                v1221 = cf.select v624, v1234, v591 : i32;
                v1235 = ub.poison i32 : i32;
                v1220 = cf.select v624, v1235, v580 : i32;
                scf.yield v1220, v1221, v1222, v1219, v1223, v1224;
            };
            v1177, v1178, v1179 = scf.index_switch v1176 : i32, i32, i32 
            case 0 {
            ^block67:
                v1230 = arith.constant 4 : u32;
                v627 = hir.bitcast v1171 : u32;
                v629 = arith.add v627, v1230 : u32 #[overflow = checked];
                v1229 = arith.constant 4 : u32;
                v631 = arith.mod v629, v1229 : u32;
                hir.assertz v631 #[code = 250];
                v1228 = arith.constant 0 : i32;
                v632 = hir.int_to_ptr v629 : ptr<byte, i32>;
                hir.store v632, v1228;
                v1227 = arith.constant 1 : i32;
                scf.yield v1171, v1227, v1172;
            }
            default {
            ^block136:
                scf.yield v1173, v1174, v1175;
            };
            v706 = hir.bitcast v1177 : u32;
            v1226 = arith.constant 4 : u32;
            v708 = arith.mod v706, v1226 : u32;
            hir.assertz v708 #[code = 250];
            v709 = hir.int_to_ptr v706 : ptr<byte, i32>;
            hir.store v709, v1178;
            v1225 = arith.constant 16 : i32;
            v714 = arith.add v1179, v1225 : i32 #[overflow = wrapping];
            v715 = builtin.global_symbol @root_ns:root@1.0.0/onchain_minimal_u64_bug/__stack_pointer : ptr<byte, u8>
            v716 = hir.bitcast v715 : ptr<byte, i32>;
            hir.store v716, v714;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v717: i32, v718: i32, v719: i32) {
        ^block77(v717: i32, v718: i32, v719: i32):
            v721 = builtin.global_symbol @root_ns:root@1.0.0/onchain_minimal_u64_bug/__stack_pointer : ptr<byte, u8>
            v722 = hir.bitcast v721 : ptr<byte, i32>;
            v723 = hir.load v722 : i32;
            v724 = arith.constant 16 : i32;
            v725 = arith.sub v723, v724 : i32 #[overflow = wrapping];
            v726 = builtin.global_symbol @root_ns:root@1.0.0/onchain_minimal_u64_bug/__stack_pointer : ptr<byte, u8>
            v727 = hir.bitcast v726 : ptr<byte, i32>;
            hir.store v727, v725;
            v720 = arith.constant 0 : i32;
            v728 = arith.constant 8 : i32;
            v729 = arith.add v725, v728 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/alloc::alloc::Global::alloc_impl(v729, v718, v719, v720)
            v732 = arith.constant 12 : u32;
            v731 = hir.bitcast v725 : u32;
            v733 = arith.add v731, v732 : u32 #[overflow = checked];
            v734 = arith.constant 4 : u32;
            v735 = arith.mod v733, v734 : u32;
            hir.assertz v735 #[code = 250];
            v736 = hir.int_to_ptr v733 : ptr<byte, i32>;
            v737 = hir.load v736 : i32;
            v739 = arith.constant 8 : u32;
            v738 = hir.bitcast v725 : u32;
            v740 = arith.add v738, v739 : u32 #[overflow = checked];
            v1264 = arith.constant 4 : u32;
            v742 = arith.mod v740, v1264 : u32;
            hir.assertz v742 #[code = 250];
            v743 = hir.int_to_ptr v740 : ptr<byte, i32>;
            v744 = hir.load v743 : i32;
            v745 = hir.bitcast v717 : u32;
            v1263 = arith.constant 4 : u32;
            v747 = arith.mod v745, v1263 : u32;
            hir.assertz v747 #[code = 250];
            v748 = hir.int_to_ptr v745 : ptr<byte, i32>;
            hir.store v748, v744;
            v1262 = arith.constant 4 : u32;
            v749 = hir.bitcast v717 : u32;
            v751 = arith.add v749, v1262 : u32 #[overflow = checked];
            v1261 = arith.constant 4 : u32;
            v753 = arith.mod v751, v1261 : u32;
            hir.assertz v753 #[code = 250];
            v754 = hir.int_to_ptr v751 : ptr<byte, i32>;
            hir.store v754, v737;
            v1260 = arith.constant 16 : i32;
            v756 = arith.add v725, v1260 : i32 #[overflow = wrapping];
            v757 = builtin.global_symbol @root_ns:root@1.0.0/onchain_minimal_u64_bug/__stack_pointer : ptr<byte, u8>
            v758 = hir.bitcast v757 : ptr<byte, i32>;
            hir.store v758, v756;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v759: i32, v760: i32, v761: i32, v762: i32) {
        ^block79(v759: i32, v760: i32, v761: i32, v762: i32):
            v1280 = arith.constant 0 : i32;
            v763 = arith.constant 0 : i32;
            v764 = arith.eq v761, v763 : i1;
            v765 = arith.zext v764 : u32;
            v766 = hir.bitcast v765 : i32;
            v768 = arith.neq v766, v1280 : i1;
            v1276 = scf.if v768 : i32 {
            ^block139:
                scf.yield v760;
            } else {
            ^block82:
                hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/__rustc::__rust_no_alloc_shim_is_unstable_v2()
                v1279 = arith.constant 0 : i32;
                v770 = arith.neq v762, v1279 : i1;
                v1275 = scf.if v770 : i32 {
                ^block83:
                    v772 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/__rustc::__rust_alloc_zeroed(v761, v760) : i32
                    scf.yield v772;
                } else {
                ^block84:
                    v771 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/__rustc::__rust_alloc(v761, v760) : i32
                    scf.yield v771;
                };
                scf.yield v1275;
            };
            v776 = arith.constant 4 : u32;
            v775 = hir.bitcast v759 : u32;
            v777 = arith.add v775, v776 : u32 #[overflow = checked];
            v1278 = arith.constant 4 : u32;
            v779 = arith.mod v777, v1278 : u32;
            hir.assertz v779 #[code = 250];
            v780 = hir.int_to_ptr v777 : ptr<byte, i32>;
            hir.store v780, v761;
            v782 = hir.bitcast v759 : u32;
            v1277 = arith.constant 4 : u32;
            v784 = arith.mod v782, v1277 : u32;
            hir.assertz v784 #[code = 250];
            v785 = hir.int_to_ptr v782 : ptr<byte, i32>;
            hir.store v785, v1276;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v786: i32, v787: i32, v788: i32, v789: i32) {
        ^block85(v786: i32, v787: i32, v788: i32, v789: i32):
            v1306 = arith.constant 0 : i32;
            v790 = arith.constant 0 : i32;
            v794 = arith.eq v789, v790 : i1;
            v795 = arith.zext v794 : u32;
            v796 = hir.bitcast v795 : i32;
            v798 = arith.neq v796, v1306 : i1;
            v1293, v1294 = scf.if v798 : i32, i32 {
            ^block143:
                v1305 = arith.constant 0 : i32;
                v792 = arith.constant 4 : i32;
                scf.yield v792, v1305;
            } else {
            ^block88:
                v799 = hir.bitcast v787 : u32;
                v834 = arith.constant 4 : u32;
                v801 = arith.mod v799, v834 : u32;
                hir.assertz v801 #[code = 250];
                v802 = hir.int_to_ptr v799 : ptr<byte, i32>;
                v803 = hir.load v802 : i32;
                v1303 = arith.constant 0 : i32;
                v1304 = arith.constant 0 : i32;
                v805 = arith.eq v803, v1304 : i1;
                v806 = arith.zext v805 : u32;
                v807 = hir.bitcast v806 : i32;
                v809 = arith.neq v807, v1303 : i1;
                v1291 = scf.if v809 : i32 {
                ^block142:
                    v1302 = arith.constant 0 : i32;
                    scf.yield v1302;
                } else {
                ^block89:
                    v1301 = arith.constant 4 : u32;
                    v810 = hir.bitcast v786 : u32;
                    v812 = arith.add v810, v1301 : u32 #[overflow = checked];
                    v1300 = arith.constant 4 : u32;
                    v814 = arith.mod v812, v1300 : u32;
                    hir.assertz v814 #[code = 250];
                    v815 = hir.int_to_ptr v812 : ptr<byte, i32>;
                    hir.store v815, v788;
                    v1299 = arith.constant 4 : u32;
                    v816 = hir.bitcast v787 : u32;
                    v818 = arith.add v816, v1299 : u32 #[overflow = checked];
                    v1298 = arith.constant 4 : u32;
                    v820 = arith.mod v818, v1298 : u32;
                    hir.assertz v820 #[code = 250];
                    v821 = hir.int_to_ptr v818 : ptr<byte, i32>;
                    v822 = hir.load v821 : i32;
                    v823 = hir.bitcast v786 : u32;
                    v1297 = arith.constant 4 : u32;
                    v825 = arith.mod v823, v1297 : u32;
                    hir.assertz v825 #[code = 250];
                    v826 = hir.int_to_ptr v823 : ptr<byte, i32>;
                    hir.store v826, v822;
                    v827 = arith.mul v803, v789 : i32 #[overflow = wrapping];
                    scf.yield v827;
                };
                v828 = arith.constant 8 : i32;
                v1296 = arith.constant 4 : i32;
                v1292 = cf.select v809, v1296, v828 : i32;
                scf.yield v1292, v1291;
            };
            v831 = arith.add v786, v1293 : i32 #[overflow = wrapping];
            v833 = hir.bitcast v831 : u32;
            v1295 = arith.constant 4 : u32;
            v835 = arith.mod v833, v1295 : u32;
            hir.assertz v835 #[code = 250];
            v836 = hir.int_to_ptr v833 : ptr<byte, i32>;
            hir.store v836, v1294;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::finish_grow(v837: i32, v838: i32, v839: i32, v840: i32, v841: i32) {
        ^block90(v837: i32, v838: i32, v839: i32, v840: i32, v841: i32):
            v843 = builtin.global_symbol @root_ns:root@1.0.0/onchain_minimal_u64_bug/__stack_pointer : ptr<byte, u8>
            v844 = hir.bitcast v843 : ptr<byte, i32>;
            v845 = hir.load v844 : i32;
            v846 = arith.constant 16 : i32;
            v847 = arith.sub v845, v846 : i32 #[overflow = wrapping];
            v848 = builtin.global_symbol @root_ns:root@1.0.0/onchain_minimal_u64_bug/__stack_pointer : ptr<byte, u8>
            v849 = hir.bitcast v848 : ptr<byte, i32>;
            hir.store v849, v847;
            v1361 = arith.constant 0 : i32;
            v842 = arith.constant 0 : i32;
            v852 = arith.gte v839, v842 : i1;
            v853 = arith.zext v852 : u32;
            v854 = hir.bitcast v853 : i32;
            v856 = arith.neq v854, v1361 : i1;
            v1335, v1336 = scf.if v856 : i32, i32 {
            ^block93:
                v943 = arith.constant 4 : u32;
                v859 = hir.bitcast v840 : u32;
                v861 = arith.add v859, v943 : u32 #[overflow = checked];
                v1360 = arith.constant 4 : u32;
                v863 = arith.mod v861, v1360 : u32;
                hir.assertz v863 #[code = 250];
                v864 = hir.int_to_ptr v861 : ptr<byte, i32>;
                v865 = hir.load v864 : i32;
                v1358 = arith.constant 0 : i32;
                v1359 = arith.constant 0 : i32;
                v867 = arith.eq v865, v1359 : i1;
                v868 = arith.zext v867 : u32;
                v869 = hir.bitcast v868 : i32;
                v871 = arith.neq v869, v1358 : i1;
                v1333, v1334 = scf.if v871 : i32, i32 {
                ^block96:
                    hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v847, v838, v839)
                    v1357 = arith.constant 4 : u32;
                    v904 = hir.bitcast v847 : u32;
                    v906 = arith.add v904, v1357 : u32 #[overflow = checked];
                    v1356 = arith.constant 4 : u32;
                    v908 = arith.mod v906, v1356 : u32;
                    hir.assertz v908 #[code = 250];
                    v909 = hir.int_to_ptr v906 : ptr<byte, i32>;
                    v910 = hir.load v909 : i32;
                    v911 = hir.bitcast v847 : u32;
                    v1355 = arith.constant 4 : u32;
                    v913 = arith.mod v911, v1355 : u32;
                    hir.assertz v913 #[code = 250];
                    v914 = hir.int_to_ptr v911 : ptr<byte, i32>;
                    v915 = hir.load v914 : i32;
                    scf.yield v915, v910;
                } else {
                ^block97:
                    v873 = arith.constant 8 : u32;
                    v872 = hir.bitcast v840 : u32;
                    v874 = arith.add v872, v873 : u32 #[overflow = checked];
                    v1354 = arith.constant 4 : u32;
                    v876 = arith.mod v874, v1354 : u32;
                    hir.assertz v876 #[code = 250];
                    v877 = hir.int_to_ptr v874 : ptr<byte, i32>;
                    v878 = hir.load v877 : i32;
                    v1353 = arith.constant 0 : i32;
                    v880 = arith.neq v878, v1353 : i1;
                    v1331, v1332 = scf.if v880 : i32, i32 {
                    ^block98:
                        v898 = hir.bitcast v840 : u32;
                        v1352 = arith.constant 4 : u32;
                        v900 = arith.mod v898, v1352 : u32;
                        hir.assertz v900 #[code = 250];
                        v901 = hir.int_to_ptr v898 : ptr<byte, i32>;
                        v902 = hir.load v901 : i32;
                        v903 = hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/__rustc::__rust_realloc(v902, v878, v838, v839) : i32
                        scf.yield v903, v839;
                    } else {
                    ^block99:
                        v1351 = arith.constant 0 : i32;
                        v937 = arith.constant 8 : i32;
                        v882 = arith.add v847, v937 : i32 #[overflow = wrapping];
                        hir.exec @root_ns:root@1.0.0/onchain_minimal_u64_bug/alloc::alloc::Global::alloc_impl(v882, v838, v839, v1351)
                        v885 = arith.constant 12 : u32;
                        v884 = hir.bitcast v847 : u32;
                        v886 = arith.add v884, v885 : u32 #[overflow = checked];
                        v1350 = arith.constant 4 : u32;
                        v888 = arith.mod v886, v1350 : u32;
                        hir.assertz v888 #[code = 250];
                        v889 = hir.int_to_ptr v886 : ptr<byte, i32>;
                        v890 = hir.load v889 : i32;
                        v1349 = arith.constant 8 : u32;
                        v891 = hir.bitcast v847 : u32;
                        v893 = arith.add v891, v1349 : u32 #[overflow = checked];
                        v1348 = arith.constant 4 : u32;
                        v895 = arith.mod v893, v1348 : u32;
                        hir.assertz v895 #[code = 250];
                        v896 = hir.int_to_ptr v893 : ptr<byte, i32>;
                        v897 = hir.load v896 : i32;
                        scf.yield v897, v890;
                    };
                    scf.yield v1331, v1332;
                };
                v1347 = arith.constant 4 : u32;
                v922 = hir.bitcast v837 : u32;
                v924 = arith.add v922, v1347 : u32 #[overflow = checked];
                v1346 = arith.constant 4 : u32;
                v926 = arith.mod v924, v1346 : u32;
                hir.assertz v926 #[code = 250];
                v1345 = arith.constant 0 : i32;
                v920 = arith.neq v1333, v1345 : i1;
                v921 = cf.select v920, v1333, v838 : i32;
                v927 = hir.int_to_ptr v924 : ptr<byte, i32>;
                hir.store v927, v921;
                v1343 = arith.constant 0 : i32;
                v934 = arith.eq v1333, v1343 : i1;
                v935 = arith.zext v934 : u32;
                v936 = hir.bitcast v935 : i32;
                v1344 = arith.constant 0 : i32;
                v931 = arith.neq v1333, v1344 : i1;
                v932 = cf.select v931, v1334, v839 : i32;
                scf.yield v932, v936;
            } else {
            ^block94:
                v857 = arith.constant 1 : i32;
                v1342 = arith.constant 0 : i32;
                scf.yield v1342, v857;
            };
            v858 = arith.constant 4 : i32;
            v1341 = arith.constant 8 : i32;
            v1337 = cf.select v856, v1341, v858 : i32;
            v940 = arith.add v837, v1337 : i32 #[overflow = wrapping];
            v942 = hir.bitcast v940 : u32;
            v1340 = arith.constant 4 : u32;
            v944 = arith.mod v942, v1340 : u32;
            hir.assertz v944 #[code = 250];
            v945 = hir.int_to_ptr v942 : ptr<byte, i32>;
            hir.store v945, v1335;
            v947 = hir.bitcast v837 : u32;
            v1339 = arith.constant 4 : u32;
            v949 = arith.mod v947, v1339 : u32;
            hir.assertz v949 #[code = 250];
            v950 = hir.int_to_ptr v947 : ptr<byte, i32>;
            hir.store v950, v1336;
            v1338 = arith.constant 16 : i32;
            v954 = arith.add v847, v1338 : i32 #[overflow = wrapping];
            v955 = builtin.global_symbol @root_ns:root@1.0.0/onchain_minimal_u64_bug/__stack_pointer : ptr<byte, u8>
            v956 = hir.bitcast v955 : ptr<byte, i32>;
            hir.store v956, v954;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v957: i32, v958: i32, v959: i32) {
        ^block100(v957: i32, v958: i32, v959: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v960: i32, v961: i32) -> i32 {
        ^block102(v960: i32, v961: i32):
            v968 = arith.constant 0 : i32;
            v964 = hir.bitcast v961 : u32;
            v963 = hir.bitcast v960 : u32;
            v965 = arith.gt v963, v964 : i1;
            v966 = arith.zext v965 : u32;
            v967 = hir.bitcast v966 : i32;
            v969 = arith.neq v967, v968 : i1;
            v970 = cf.select v969, v960, v961 : i32;
            builtin.ret v970;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.segment readonly @1048576 = 0x00000000000000000000000a0010000000003e64657463616465723c;
    };
};