builtin.component root_ns:root@1.0.0 {
    builtin.module public @onchain_two_felts_struct {
        private builtin.function @core::ptr::drop_in_place<alloc::vec::into_iter::IntoIter<miden_stdlib_sys::intrinsics::felt::Felt>>(v0: i32) {
        ^block4(v0: i32):
            v2 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v3 = hir.bitcast v2 : ptr<byte, i32>;
            v4 = hir.load v3 : i32;
            v5 = arith.constant 16 : i32;
            v6 = arith.sub v4, v5 : i32 #[overflow = wrapping];
            v7 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v8 = hir.bitcast v7 : ptr<byte, i32>;
            hir.store v8, v6;
            v9 = hir.bitcast v0 : u32;
            v10 = arith.constant 4 : u32;
            v11 = arith.mod v9, v10 : u32;
            hir.assertz v11 #[code = 250];
            v12 = hir.int_to_ptr v9 : ptr<byte, i32>;
            v13 = hir.load v12 : i32;
            v15 = arith.constant 12 : u32;
            v14 = hir.bitcast v6 : u32;
            v16 = arith.add v14, v15 : u32 #[overflow = checked];
            v950 = arith.constant 4 : u32;
            v18 = arith.mod v16, v950 : u32;
            hir.assertz v18 #[code = 250];
            v19 = hir.int_to_ptr v16 : ptr<byte, i32>;
            hir.store v19, v13;
            v21 = arith.constant 8 : u32;
            v20 = hir.bitcast v0 : u32;
            v22 = arith.add v20, v21 : u32 #[overflow = checked];
            v949 = arith.constant 4 : u32;
            v24 = arith.mod v22, v949 : u32;
            hir.assertz v24 #[code = 250];
            v25 = hir.int_to_ptr v22 : ptr<byte, i32>;
            v26 = hir.load v25 : i32;
            v948 = arith.constant 8 : u32;
            v27 = hir.bitcast v6 : u32;
            v29 = arith.add v27, v948 : u32 #[overflow = checked];
            v947 = arith.constant 4 : u32;
            v31 = arith.mod v29, v947 : u32;
            hir.assertz v31 #[code = 250];
            v32 = hir.int_to_ptr v29 : ptr<byte, i32>;
            hir.store v32, v26;
            v35 = arith.constant 4 : i32;
            v33 = arith.constant 8 : i32;
            v34 = arith.add v6, v33 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::raw_vec::RawVecInner<A>::deallocate(v34, v35, v35)
            v946 = arith.constant 16 : i32;
            v38 = arith.add v6, v946 : i32 #[overflow = wrapping];
            v39 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v40 = hir.bitcast v39 : ptr<byte, i32>;
            hir.store v40, v38;
            builtin.ret ;
        };

        private builtin.function @alloc::vec::Vec<T,A>::push(v41: i32, v42: felt) {
        ^block6(v41: i32, v42: felt):
            v45 = arith.constant 8 : u32;
            v44 = hir.bitcast v41 : u32;
            v46 = arith.add v44, v45 : u32 #[overflow = checked];
            v47 = arith.constant 4 : u32;
            v48 = arith.mod v46, v47 : u32;
            hir.assertz v48 #[code = 250];
            v49 = hir.int_to_ptr v46 : ptr<byte, i32>;
            v50 = hir.load v49 : i32;
            v51 = hir.bitcast v41 : u32;
            v961 = arith.constant 4 : u32;
            v53 = arith.mod v51, v961 : u32;
            hir.assertz v53 #[code = 250];
            v54 = hir.int_to_ptr v51 : ptr<byte, i32>;
            v55 = hir.load v54 : i32;
            v43 = arith.constant 0 : i32;
            v56 = arith.neq v50, v55 : i1;
            v57 = arith.zext v56 : u32;
            v58 = hir.bitcast v57 : i32;
            v60 = arith.neq v58, v43 : i1;
            scf.if v60{
            ^block104:
                scf.yield ;
            } else {
            ^block9:
                hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::raw_vec::RawVec<T,A>::grow_one(v41)
                scf.yield ;
            };
            v960 = arith.constant 4 : u32;
            v62 = hir.bitcast v41 : u32;
            v64 = arith.add v62, v960 : u32 #[overflow = checked];
            v959 = arith.constant 4 : u32;
            v66 = arith.mod v64, v959 : u32;
            hir.assertz v66 #[code = 250];
            v67 = hir.int_to_ptr v64 : ptr<byte, i32>;
            v68 = hir.load v67 : i32;
            v951 = arith.constant 2 : u32;
            v72 = arith.shl v50, v951 : i32;
            v73 = arith.add v68, v72 : i32 #[overflow = wrapping];
            v75 = hir.bitcast v73 : u32;
            v958 = arith.constant 4 : u32;
            v77 = arith.mod v75, v958 : u32;
            hir.assertz v77 #[code = 250];
            v78 = hir.int_to_ptr v75 : ptr<byte, felt>;
            hir.store v78, v42;
            v957 = arith.constant 8 : u32;
            v81 = hir.bitcast v41 : u32;
            v83 = arith.add v81, v957 : u32 #[overflow = checked];
            v956 = arith.constant 4 : u32;
            v85 = arith.mod v83, v956 : u32;
            hir.assertz v85 #[code = 250];
            v79 = arith.constant 1 : i32;
            v80 = arith.add v50, v79 : i32 #[overflow = wrapping];
            v86 = hir.int_to_ptr v83 : ptr<byte, i32>;
            hir.store v86, v80;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVec<T,A>::grow_one(v87: i32) {
        ^block10(v87: i32):
            v89 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v90 = hir.bitcast v89 : ptr<byte, i32>;
            v91 = hir.load v90 : i32;
            v92 = arith.constant 16 : i32;
            v93 = arith.sub v91, v92 : i32 #[overflow = wrapping];
            v94 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v95 = hir.bitcast v94 : ptr<byte, i32>;
            hir.store v95, v93;
            v98 = hir.bitcast v87 : u32;
            v99 = arith.constant 4 : u32;
            v100 = arith.mod v98, v99 : u32;
            hir.assertz v100 #[code = 250];
            v101 = hir.int_to_ptr v98 : ptr<byte, i32>;
            v102 = hir.load v101 : i32;
            v104 = arith.constant 4 : i32;
            v103 = arith.constant 1 : i32;
            v96 = arith.constant 8 : i32;
            v97 = arith.add v93, v96 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::raw_vec::RawVecInner<A>::grow_amortized(v97, v87, v102, v103, v104, v104)
            v107 = arith.constant 8 : u32;
            v106 = hir.bitcast v93 : u32;
            v108 = arith.add v106, v107 : u32 #[overflow = checked];
            v965 = arith.constant 4 : u32;
            v110 = arith.mod v108, v965 : u32;
            hir.assertz v110 #[code = 250];
            v111 = hir.int_to_ptr v108 : ptr<byte, i32>;
            v112 = hir.load v111 : i32;
            v88 = arith.constant 0 : i32;
            v113 = arith.constant -2147483647 : i32;
            v114 = arith.eq v112, v113 : i1;
            v115 = arith.zext v114 : u32;
            v116 = hir.bitcast v115 : i32;
            v118 = arith.neq v116, v88 : i1;
            cf.cond_br v118 ^block12, ^block13;
        ^block12:
            v964 = arith.constant 16 : i32;
            v128 = arith.add v93, v964 : i32 #[overflow = wrapping];
            v129 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v130 = hir.bitcast v129 : ptr<byte, i32>;
            hir.store v130, v128;
            builtin.ret ;
        ^block13:
            v120 = arith.constant 12 : u32;
            v119 = hir.bitcast v93 : u32;
            v121 = arith.add v119, v120 : u32 #[overflow = checked];
            v963 = arith.constant 4 : u32;
            v123 = arith.mod v121, v963 : u32;
            hir.assertz v123 #[code = 250];
            v124 = hir.int_to_ptr v121 : ptr<byte, i32>;
            v125 = hir.load v124 : i32;
            v126 = arith.constant 1048588 : i32;
            hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::raw_vec::handle_error(v112, v125, v126)
            ub.unreachable ;
        };

        private builtin.function @alloc::alloc::exchange_malloc() -> i32 {
        ^block14:
            hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/__rustc::__rust_no_alloc_shim_is_unstable_v2()
            v133 = arith.constant 4 : i32;
            v135 = hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/__rustc::__rust_alloc(v133, v133) : i32
            v132 = arith.constant 0 : i32;
            v137 = arith.neq v135, v132 : i1;
            cf.cond_br v137 ^block16, ^block17;
        ^block16:
            builtin.ret v135;
        ^block17:
            v968 = arith.constant 4 : i32;
            hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::alloc::handle_alloc_error(v968, v968)
            ub.unreachable ;
        };

        private builtin.function @__rustc::__rust_alloc(v140: i32, v141: i32) -> i32 {
        ^block18(v140: i32, v141: i32):
            v143 = arith.constant 1048604 : i32;
            v144 = hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v143, v141, v140) : i32
            builtin.ret v144;
        };

        public builtin.function @entrypoint(v145: i32, v146: i32) {
        ^block20(v145: i32, v146: i32):
            v150 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v151 = hir.bitcast v150 : ptr<byte, i32>;
            v152 = hir.load v151 : i32;
            v153 = arith.constant 32 : i32;
            v154 = arith.sub v152, v153 : i32 #[overflow = wrapping];
            v155 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v156 = hir.bitcast v155 : ptr<byte, i32>;
            hir.store v156, v154;
            v158 = arith.constant 4 : u32;
            v157 = hir.bitcast v146 : u32;
            v159 = arith.add v157, v158 : u32 #[overflow = checked];
            v1192 = arith.constant 4 : u32;
            v161 = arith.mod v159, v1192 : u32;
            hir.assertz v161 #[code = 250];
            v162 = hir.int_to_ptr v159 : ptr<byte, felt>;
            v163 = hir.load v162 : felt;
            v164 = hir.bitcast v146 : u32;
            v1191 = arith.constant 4 : u32;
            v166 = arith.mod v164, v1191 : u32;
            hir.assertz v166 #[code = 250];
            v167 = hir.int_to_ptr v164 : ptr<byte, felt>;
            v168 = hir.load v167 : felt;
            v172 = arith.constant 12 : u32;
            v171 = hir.bitcast v154 : u32;
            v173 = arith.add v171, v172 : u32 #[overflow = checked];
            v1190 = arith.constant 4 : u32;
            v175 = arith.mod v173, v1190 : u32;
            hir.assertz v175 #[code = 250];
            v147 = arith.constant 0 : i32;
            v176 = hir.int_to_ptr v173 : ptr<byte, i32>;
            hir.store v176, v147;
            v1189 = arith.constant 4 : u32;
            v178 = hir.bitcast v154 : u32;
            v180 = arith.add v178, v1189 : u32 #[overflow = checked];
            v1188 = arith.constant 4 : u32;
            v182 = arith.mod v180, v1188 : u32;
            hir.assertz v182 #[code = 250];
            v177 = arith.constant 17179869184 : i64;
            v183 = hir.int_to_ptr v180 : ptr<byte, i64>;
            hir.store v183, v177;
            v184 = hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::alloc::exchange_malloc() : i32
            v185 = hir.bitcast v184 : u32;
            v1187 = arith.constant 4 : u32;
            v187 = arith.mod v185, v1187 : u32;
            hir.assertz v187 #[code = 250];
            v188 = hir.int_to_ptr v185 : ptr<byte, felt>;
            hir.store v188, v168;
            v192 = arith.constant 28 : u32;
            v191 = hir.bitcast v154 : u32;
            v193 = arith.add v191, v192 : u32 #[overflow = checked];
            v1186 = arith.constant 4 : u32;
            v195 = arith.mod v193, v1186 : u32;
            hir.assertz v195 #[code = 250];
            v189 = arith.constant 4 : i32;
            v190 = arith.add v184, v189 : i32 #[overflow = wrapping];
            v196 = hir.int_to_ptr v193 : ptr<byte, i32>;
            hir.store v196, v190;
            v199 = arith.constant 24 : u32;
            v198 = hir.bitcast v154 : u32;
            v200 = arith.add v198, v199 : u32 #[overflow = checked];
            v1185 = arith.constant 4 : u32;
            v202 = arith.mod v200, v1185 : u32;
            hir.assertz v202 #[code = 250];
            v197 = arith.constant 1 : i32;
            v203 = hir.int_to_ptr v200 : ptr<byte, i32>;
            hir.store v203, v197;
            v205 = arith.constant 16 : u32;
            v204 = hir.bitcast v154 : u32;
            v206 = arith.add v204, v205 : u32 #[overflow = checked];
            v1184 = arith.constant 4 : u32;
            v208 = arith.mod v206, v1184 : u32;
            hir.assertz v208 #[code = 250];
            v209 = hir.int_to_ptr v206 : ptr<byte, i32>;
            hir.store v209, v184;
            v1183 = arith.constant 0 : i32;
            v1119, v1120, v1121, v1122, v1123, v1124, v1125, v1126, v1127 = scf.while v184, v1183, v154, v163, v145 : i32, i32, i32, felt, i32, i32, felt, i32, i32 {
            ^block125(v1128: i32, v1129: i32, v1130: i32, v1131: felt, v1132: i32):
                v212 = arith.add v1128, v1129 : i32 #[overflow = wrapping];
                v1181 = arith.constant 0 : i32;
                v1182 = arith.constant 4 : i32;
                v214 = arith.eq v1129, v1182 : i1;
                v215 = arith.zext v214 : u32;
                v216 = hir.bitcast v215 : i32;
                v218 = arith.neq v216, v1181 : i1;
                v1112 = scf.if v218 : i32 {
                ^block121:
                    v977 = ub.poison i32 : i32;
                    scf.yield v977;
                } else {
                ^block25:
                    v222 = hir.bitcast v212 : u32;
                    v1180 = arith.constant 4 : u32;
                    v224 = arith.mod v222, v1180 : u32;
                    hir.assertz v224 #[code = 250];
                    v225 = hir.int_to_ptr v222 : ptr<byte, felt>;
                    v226 = hir.load v225 : felt;
                    v1179 = arith.constant 4 : i32;
                    v221 = arith.add v1130, v1179 : i32 #[overflow = wrapping];
                    hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::vec::Vec<T,A>::push(v221, v226)
                    v1178 = arith.constant 4 : i32;
                    v228 = arith.add v1129, v1178 : i32 #[overflow = wrapping];
                    scf.yield v228;
                };
                v1175 = ub.poison i32 : i32;
                v1116 = cf.select v218, v1175, v1132 : i32;
                v1024 = ub.poison felt : felt;
                v1115 = cf.select v218, v1024, v1131 : felt;
                v1176 = ub.poison i32 : i32;
                v1114 = cf.select v218, v1176, v1130 : i32;
                v1177 = ub.poison i32 : i32;
                v1113 = cf.select v218, v1177, v1128 : i32;
                v976 = arith.constant 1 : u32;
                v969 = arith.constant 0 : u32;
                v1118 = cf.select v218, v969, v976 : u32;
                v1074 = arith.trunc v1118 : i1;
                scf.condition v1074, v1113, v1112, v1114, v1115, v1116, v1130, v1131, v1132, v212;
            } do {
            ^block126(v1133: i32, v1134: i32, v1135: i32, v1136: felt, v1137: i32, v1138: i32, v1139: felt, v1140: i32, v1141: i32):
                scf.yield v1133, v1134, v1135, v1136, v1137;
            };
            v230 = arith.constant 20 : u32;
            v229 = hir.bitcast v1124 : u32;
            v231 = arith.add v229, v230 : u32 #[overflow = checked];
            v1174 = arith.constant 4 : u32;
            v233 = arith.mod v231, v1174 : u32;
            hir.assertz v233 #[code = 250];
            v234 = hir.int_to_ptr v231 : ptr<byte, i32>;
            hir.store v234, v1127;
            v235 = arith.constant 16 : i32;
            v236 = arith.add v1124, v235 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/core::ptr::drop_in_place<alloc::vec::into_iter::IntoIter<miden_stdlib_sys::intrinsics::felt::Felt>>(v236)
            v237 = hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::alloc::exchange_malloc() : i32
            v239 = hir.bitcast v237 : u32;
            v1173 = arith.constant 4 : u32;
            v241 = arith.mod v239, v1173 : u32;
            hir.assertz v241 #[code = 250];
            v242 = hir.int_to_ptr v239 : ptr<byte, felt>;
            hir.store v242, v1125;
            v1172 = arith.constant 28 : u32;
            v245 = hir.bitcast v1124 : u32;
            v247 = arith.add v245, v1172 : u32 #[overflow = checked];
            v1171 = arith.constant 4 : u32;
            v249 = arith.mod v247, v1171 : u32;
            hir.assertz v249 #[code = 250];
            v1170 = arith.constant 4 : i32;
            v244 = arith.add v237, v1170 : i32 #[overflow = wrapping];
            v250 = hir.int_to_ptr v247 : ptr<byte, i32>;
            hir.store v250, v244;
            v1169 = arith.constant 24 : u32;
            v252 = hir.bitcast v1124 : u32;
            v254 = arith.add v252, v1169 : u32 #[overflow = checked];
            v1168 = arith.constant 4 : u32;
            v256 = arith.mod v254, v1168 : u32;
            hir.assertz v256 #[code = 250];
            v1167 = arith.constant 1 : i32;
            v257 = hir.int_to_ptr v254 : ptr<byte, i32>;
            hir.store v257, v1167;
            v1166 = arith.constant 16 : u32;
            v258 = hir.bitcast v1124 : u32;
            v260 = arith.add v258, v1166 : u32 #[overflow = checked];
            v1165 = arith.constant 4 : u32;
            v262 = arith.mod v260, v1165 : u32;
            hir.assertz v262 #[code = 250];
            v263 = hir.int_to_ptr v260 : ptr<byte, i32>;
            hir.store v263, v237;
            v1164 = arith.constant 0 : i32;
            v1094, v1095, v1096, v1097, v1098, v1099, v1100 = scf.while v237, v1164, v1124, v1126 : i32, i32, i32, i32, i32, i32, i32 {
            ^block123(v1101: i32, v1102: i32, v1103: i32, v1104: i32):
                v267 = arith.add v1101, v1102 : i32 #[overflow = wrapping];
                v1162 = arith.constant 0 : i32;
                v1163 = arith.constant 4 : i32;
                v269 = arith.eq v1102, v1163 : i1;
                v270 = arith.zext v269 : u32;
                v271 = hir.bitcast v270 : i32;
                v273 = arith.neq v271, v1162 : i1;
                v1088 = scf.if v273 : i32 {
                ^block122:
                    v1161 = ub.poison i32 : i32;
                    scf.yield v1161;
                } else {
                ^block29:
                    v277 = hir.bitcast v267 : u32;
                    v1160 = arith.constant 4 : u32;
                    v279 = arith.mod v277, v1160 : u32;
                    hir.assertz v279 #[code = 250];
                    v280 = hir.int_to_ptr v277 : ptr<byte, felt>;
                    v281 = hir.load v280 : felt;
                    v1159 = arith.constant 4 : i32;
                    v276 = arith.add v1103, v1159 : i32 #[overflow = wrapping];
                    hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::vec::Vec<T,A>::push(v276, v281)
                    v1158 = arith.constant 4 : i32;
                    v283 = arith.add v1102, v1158 : i32 #[overflow = wrapping];
                    scf.yield v283;
                };
                v1153 = ub.poison i32 : i32;
                v1091 = cf.select v273, v1153, v1104 : i32;
                v1154 = ub.poison i32 : i32;
                v1090 = cf.select v273, v1154, v1103 : i32;
                v1155 = ub.poison i32 : i32;
                v1089 = cf.select v273, v1155, v1101 : i32;
                v1156 = arith.constant 1 : u32;
                v1157 = arith.constant 0 : u32;
                v1093 = cf.select v273, v1157, v1156 : u32;
                v1016 = arith.trunc v1093 : i1;
                scf.condition v1016, v1089, v1088, v1090, v1091, v1103, v1104, v267;
            } do {
            ^block124(v1105: i32, v1106: i32, v1107: i32, v1108: i32, v1109: i32, v1110: i32, v1111: i32):
                scf.yield v1105, v1106, v1107, v1108;
            };
            v1152 = arith.constant 20 : u32;
            v284 = hir.bitcast v1098 : u32;
            v286 = arith.add v284, v1152 : u32 #[overflow = checked];
            v1151 = arith.constant 4 : u32;
            v288 = arith.mod v286, v1151 : u32;
            hir.assertz v288 #[code = 250];
            v289 = hir.int_to_ptr v286 : ptr<byte, i32>;
            hir.store v289, v1100;
            v1150 = arith.constant 16 : i32;
            v291 = arith.add v1098, v1150 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/core::ptr::drop_in_place<alloc::vec::into_iter::IntoIter<miden_stdlib_sys::intrinsics::felt::Felt>>(v291)
            v294 = arith.constant 8 : i32;
            v1149 = arith.constant 4 : i32;
            v297 = arith.add v1098, v1149 : i32 #[overflow = wrapping];
            v299 = arith.add v297, v294 : i32 #[overflow = wrapping];
            v300 = hir.bitcast v299 : u32;
            v1148 = arith.constant 4 : u32;
            v302 = arith.mod v300, v1148 : u32;
            hir.assertz v302 #[code = 250];
            v303 = hir.int_to_ptr v300 : ptr<byte, i32>;
            v304 = hir.load v303 : i32;
            v1147 = arith.constant 8 : i32;
            v295 = arith.add v1099, v1147 : i32 #[overflow = wrapping];
            v305 = hir.bitcast v295 : u32;
            v1146 = arith.constant 4 : u32;
            v307 = arith.mod v305, v1146 : u32;
            hir.assertz v307 #[code = 250];
            v308 = hir.int_to_ptr v305 : ptr<byte, i32>;
            hir.store v308, v304;
            v1145 = arith.constant 4 : u32;
            v309 = hir.bitcast v1098 : u32;
            v311 = arith.add v309, v1145 : u32 #[overflow = checked];
            v1144 = arith.constant 4 : u32;
            v313 = arith.mod v311, v1144 : u32;
            hir.assertz v313 #[code = 250];
            v314 = hir.int_to_ptr v311 : ptr<byte, i64>;
            v315 = hir.load v314 : i64;
            v316 = hir.bitcast v1099 : u32;
            v1143 = arith.constant 4 : u32;
            v318 = arith.mod v316, v1143 : u32;
            hir.assertz v318 #[code = 250];
            v319 = hir.int_to_ptr v316 : ptr<byte, i64>;
            hir.store v319, v315;
            v1142 = arith.constant 32 : i32;
            v321 = arith.add v1098, v1142 : i32 #[overflow = wrapping];
            v322 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v323 = hir.bitcast v322 : ptr<byte, i32>;
            hir.store v323, v321;
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_dealloc(v324: i32, v325: i32, v326: i32) {
        ^block30(v324: i32, v325: i32, v326: i32):
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_realloc(v327: i32, v328: i32, v329: i32, v330: i32) -> i32 {
        ^block32(v327: i32, v328: i32, v329: i32, v330: i32):
            v332 = arith.constant 1048604 : i32;
            v333 = hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v332, v329, v330) : i32
            v1201 = arith.constant 0 : i32;
            v334 = arith.constant 0 : i32;
            v335 = arith.eq v333, v334 : i1;
            v336 = arith.zext v335 : u32;
            v337 = hir.bitcast v336 : i32;
            v339 = arith.neq v337, v1201 : i1;
            scf.if v339{
            ^block34:
                scf.yield ;
            } else {
            ^block35:
                v1200 = arith.constant 0 : i32;
                v341 = hir.bitcast v328 : u32;
                v340 = hir.bitcast v330 : u32;
                v342 = arith.lt v340, v341 : i1;
                v343 = arith.zext v342 : u32;
                v344 = hir.bitcast v343 : i32;
                v346 = arith.neq v344, v1200 : i1;
                v347 = cf.select v346, v330, v328 : i32;
                v1198 = arith.constant 0 : i32;
                v1199 = arith.constant 0 : i32;
                v349 = arith.eq v347, v1199 : i1;
                v350 = arith.zext v349 : u32;
                v351 = hir.bitcast v350 : i32;
                v353 = arith.neq v351, v1198 : i1;
                scf.if v353{
                ^block127:
                    scf.yield ;
                } else {
                ^block36:
                    v354 = hir.bitcast v347 : u32;
                    v355 = hir.bitcast v333 : u32;
                    v356 = hir.int_to_ptr v355 : ptr<byte, u8>;
                    v357 = hir.bitcast v327 : u32;
                    v358 = hir.int_to_ptr v357 : ptr<byte, u8>;
                    hir.mem_cpy v358, v356, v354;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v333;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v360: i32, v361: i32) -> i32 {
        ^block37(v360: i32, v361: i32):
            v363 = arith.constant 1048604 : i32;
            v364 = hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v363, v361, v360) : i32
            v1210 = arith.constant 0 : i32;
            v365 = arith.constant 0 : i32;
            v366 = arith.eq v364, v365 : i1;
            v367 = arith.zext v366 : u32;
            v368 = hir.bitcast v367 : i32;
            v370 = arith.neq v368, v1210 : i1;
            scf.if v370{
            ^block39:
                scf.yield ;
            } else {
            ^block40:
                v1208 = arith.constant 0 : i32;
                v1209 = arith.constant 0 : i32;
                v372 = arith.eq v360, v1209 : i1;
                v373 = arith.zext v372 : u32;
                v374 = hir.bitcast v373 : i32;
                v376 = arith.neq v374, v1208 : i1;
                scf.if v376{
                ^block130:
                    scf.yield ;
                } else {
                ^block41:
                    v1202 = arith.constant 0 : u8;
                    v379 = hir.bitcast v360 : u32;
                    v380 = hir.bitcast v364 : u32;
                    v381 = hir.int_to_ptr v380 : ptr<byte, u8>;
                    hir.mem_set v381, v379, v1202;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v364;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block42:
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v383: i32, v384: i32, v385: i32) -> i32 {
        ^block44(v383: i32, v384: i32, v385: i32):
            v388 = arith.constant 16 : i32;
            v387 = arith.constant 0 : i32;
            v1212 = arith.constant 16 : u32;
            v390 = hir.bitcast v384 : u32;
            v392 = arith.gt v390, v1212 : i1;
            v393 = arith.zext v392 : u32;
            v394 = hir.bitcast v393 : i32;
            v396 = arith.neq v394, v387 : i1;
            v397 = cf.select v396, v384, v388 : i32;
            v1252 = arith.constant 0 : i32;
            v398 = arith.constant -1 : i32;
            v399 = arith.add v397, v398 : i32 #[overflow = wrapping];
            v400 = arith.band v397, v399 : i32;
            v402 = arith.neq v400, v1252 : i1;
            v1221, v1222 = scf.if v402 : i32, u32 {
            ^block135:
                v1213 = arith.constant 0 : u32;
                v1217 = ub.poison i32 : i32;
                scf.yield v1217, v1213;
            } else {
            ^block47:
                v404 = hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/core::ptr::alignment::Alignment::max(v384, v397) : i32
                v1251 = arith.constant 0 : i32;
                v403 = arith.constant -2147483648 : i32;
                v405 = arith.sub v403, v404 : i32 #[overflow = wrapping];
                v407 = hir.bitcast v405 : u32;
                v406 = hir.bitcast v385 : u32;
                v408 = arith.gt v406, v407 : i1;
                v409 = arith.zext v408 : u32;
                v410 = hir.bitcast v409 : i32;
                v412 = arith.neq v410, v1251 : i1;
                v1236 = scf.if v412 : i32 {
                ^block134:
                    v1250 = ub.poison i32 : i32;
                    scf.yield v1250;
                } else {
                ^block48:
                    v1248 = arith.constant 0 : i32;
                    v418 = arith.sub v1248, v404 : i32 #[overflow = wrapping];
                    v1249 = arith.constant -1 : i32;
                    v414 = arith.add v385, v404 : i32 #[overflow = wrapping];
                    v416 = arith.add v414, v1249 : i32 #[overflow = wrapping];
                    v419 = arith.band v416, v418 : i32;
                    v420 = hir.bitcast v383 : u32;
                    v421 = arith.constant 4 : u32;
                    v422 = arith.mod v420, v421 : u32;
                    hir.assertz v422 #[code = 250];
                    v423 = hir.int_to_ptr v420 : ptr<byte, i32>;
                    v424 = hir.load v423 : i32;
                    v1247 = arith.constant 0 : i32;
                    v426 = arith.neq v424, v1247 : i1;
                    scf.if v426{
                    ^block133:
                        scf.yield ;
                    } else {
                    ^block50:
                        v427 = hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/intrinsics::mem::heap_base() : i32
                        v428 = hir.mem_size  : u32;
                        v434 = hir.bitcast v383 : u32;
                        v1246 = arith.constant 4 : u32;
                        v436 = arith.mod v434, v1246 : u32;
                        hir.assertz v436 #[code = 250];
                        v1245 = arith.constant 16 : u32;
                        v429 = hir.bitcast v428 : i32;
                        v432 = arith.shl v429, v1245 : i32;
                        v433 = arith.add v427, v432 : i32 #[overflow = wrapping];
                        v437 = hir.int_to_ptr v434 : ptr<byte, i32>;
                        hir.store v437, v433;
                        scf.yield ;
                    };
                    v440 = hir.bitcast v383 : u32;
                    v1244 = arith.constant 4 : u32;
                    v442 = arith.mod v440, v1244 : u32;
                    hir.assertz v442 #[code = 250];
                    v443 = hir.int_to_ptr v440 : ptr<byte, i32>;
                    v444 = hir.load v443 : i32;
                    v1242 = arith.constant 0 : i32;
                    v1243 = arith.constant -1 : i32;
                    v446 = arith.bxor v444, v1243 : i32;
                    v448 = hir.bitcast v446 : u32;
                    v447 = hir.bitcast v419 : u32;
                    v449 = arith.gt v447, v448 : i1;
                    v450 = arith.zext v449 : u32;
                    v451 = hir.bitcast v450 : i32;
                    v453 = arith.neq v451, v1242 : i1;
                    v1235 = scf.if v453 : i32 {
                    ^block51:
                        v1241 = arith.constant 0 : i32;
                        scf.yield v1241;
                    } else {
                    ^block52:
                        v455 = hir.bitcast v383 : u32;
                        v1240 = arith.constant 4 : u32;
                        v457 = arith.mod v455, v1240 : u32;
                        hir.assertz v457 #[code = 250];
                        v454 = arith.add v444, v419 : i32 #[overflow = wrapping];
                        v458 = hir.int_to_ptr v455 : ptr<byte, i32>;
                        hir.store v458, v454;
                        v460 = arith.add v444, v404 : i32 #[overflow = wrapping];
                        scf.yield v460;
                    };
                    scf.yield v1235;
                };
                v1218 = arith.constant 1 : u32;
                v1239 = arith.constant 0 : u32;
                v1237 = cf.select v412, v1239, v1218 : u32;
                scf.yield v1236, v1237;
            };
            v1238 = arith.constant 0 : u32;
            v1234 = arith.eq v1222, v1238 : i1;
            cf.cond_br v1234 ^block46, ^block137(v1221);
        ^block46:
            ub.unreachable ;
        ^block137(v1214: i32):
            builtin.ret v1214;
        };

        private builtin.function @intrinsics::mem::heap_base() -> i32 {
        ^block53:
            v463 = hir.exec @intrinsics/mem/heap_base() : i32
            builtin.ret v463;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::grow_amortized(v465: i32, v466: i32, v467: i32, v468: i32, v469: i32, v470: i32) {
        ^block57(v465: i32, v466: i32, v467: i32, v468: i32, v469: i32, v470: i32):
            v473 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v474 = hir.bitcast v473 : ptr<byte, i32>;
            v475 = hir.load v474 : i32;
            v476 = arith.constant 32 : i32;
            v477 = arith.sub v475, v476 : i32 #[overflow = wrapping];
            v478 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v479 = hir.bitcast v478 : ptr<byte, i32>;
            hir.store v479, v477;
            v1329 = arith.constant 0 : i32;
            v471 = arith.constant 0 : i32;
            v482 = arith.eq v470, v471 : i1;
            v483 = arith.zext v482 : u32;
            v484 = hir.bitcast v483 : i32;
            v486 = arith.neq v484, v1329 : i1;
            v1300, v1301 = scf.if v486 : i32, i32 {
            ^block60:
                v1328 = arith.constant 0 : i32;
                scf.yield v1328, v1328;
            } else {
            ^block61:
                v487 = arith.add v467, v468 : i32 #[overflow = wrapping];
                v1327 = arith.constant 0 : i32;
                v489 = hir.bitcast v467 : u32;
                v488 = hir.bitcast v487 : u32;
                v490 = arith.lt v488, v489 : i1;
                v491 = arith.zext v490 : u32;
                v492 = hir.bitcast v491 : i32;
                v494 = arith.neq v492, v1327 : i1;
                v1298, v1299 = scf.if v494 : i32, i32 {
                ^block143:
                    v1326 = arith.constant 0 : i32;
                    scf.yield v1326, v1326;
                } else {
                ^block62:
                    v505 = hir.bitcast v466 : u32;
                    v619 = arith.constant 4 : u32;
                    v507 = arith.mod v505, v619 : u32;
                    hir.assertz v507 #[code = 250];
                    v508 = hir.int_to_ptr v505 : ptr<byte, i32>;
                    v509 = hir.load v508 : i32;
                    v1254 = arith.constant 1 : u32;
                    v512 = arith.shl v509, v1254 : i32;
                    v1325 = arith.constant 0 : i32;
                    v514 = hir.bitcast v512 : u32;
                    v513 = hir.bitcast v487 : u32;
                    v515 = arith.gt v513, v514 : i1;
                    v516 = arith.zext v515 : u32;
                    v517 = hir.bitcast v516 : i32;
                    v519 = arith.neq v517, v1325 : i1;
                    v520 = cf.select v519, v487, v512 : i32;
                    v1322 = arith.constant 1 : i32;
                    v522 = arith.constant 4 : i32;
                    v1323 = arith.constant 0 : i32;
                    v1253 = arith.constant 1025 : u32;
                    v525 = hir.bitcast v470 : u32;
                    v527 = arith.lt v525, v1253 : i1;
                    v528 = arith.zext v527 : u32;
                    v529 = hir.bitcast v528 : i32;
                    v531 = arith.neq v529, v1323 : i1;
                    v532 = cf.select v531, v522, v1322 : i32;
                    v521 = arith.constant 8 : i32;
                    v1324 = arith.constant 0 : i32;
                    v510 = arith.constant 1 : i32;
                    v534 = arith.eq v470, v510 : i1;
                    v535 = arith.zext v534 : u32;
                    v536 = hir.bitcast v535 : i32;
                    v538 = arith.neq v536, v1324 : i1;
                    v539 = cf.select v538, v521, v532 : i32;
                    v1321 = arith.constant 0 : i32;
                    v541 = hir.bitcast v539 : u32;
                    v540 = hir.bitcast v520 : u32;
                    v542 = arith.gt v540, v541 : i1;
                    v543 = arith.zext v542 : u32;
                    v544 = hir.bitcast v543 : i32;
                    v546 = arith.neq v544, v1321 : i1;
                    v547 = cf.select v546, v520, v539 : i32;
                    v548 = hir.bitcast v547 : u32;
                    v549 = arith.zext v548 : u64;
                    v550 = hir.bitcast v549 : i64;
                    v1320 = arith.constant 0 : i32;
                    v500 = arith.sub v1320, v469 : i32 #[overflow = wrapping];
                    v497 = arith.constant -1 : i32;
                    v496 = arith.add v469, v470 : i32 #[overflow = wrapping];
                    v498 = arith.add v496, v497 : i32 #[overflow = wrapping];
                    v501 = arith.band v498, v500 : i32;
                    v502 = hir.bitcast v501 : u32;
                    v503 = arith.zext v502 : u64;
                    v504 = hir.bitcast v503 : i64;
                    v551 = arith.mul v504, v550 : i64 #[overflow = wrapping];
                    v1319 = arith.constant 0 : i32;
                    v552 = arith.constant 32 : i64;
                    v554 = hir.cast v552 : u32;
                    v553 = hir.bitcast v551 : u64;
                    v555 = arith.shr v553, v554 : u64;
                    v556 = hir.bitcast v555 : i64;
                    v557 = arith.trunc v556 : i32;
                    v559 = arith.neq v557, v1319 : i1;
                    v1296, v1297 = scf.if v559 : i32, i32 {
                    ^block142:
                        v1318 = arith.constant 0 : i32;
                        scf.yield v520, v1318;
                    } else {
                    ^block63:
                        v560 = arith.trunc v551 : i32;
                        v1317 = arith.constant 0 : i32;
                        v561 = arith.constant -2147483648 : i32;
                        v562 = arith.sub v561, v469 : i32 #[overflow = wrapping];
                        v564 = hir.bitcast v562 : u32;
                        v563 = hir.bitcast v560 : u32;
                        v565 = arith.gt v563, v564 : i1;
                        v566 = arith.zext v565 : u32;
                        v567 = hir.bitcast v566 : i32;
                        v569 = arith.neq v567, v1317 : i1;
                        v1294, v1295 = scf.if v569 : i32, i32 {
                        ^block141:
                            v1316 = arith.constant 0 : i32;
                            scf.yield v520, v1316;
                        } else {
                        ^block64:
                            v570 = arith.constant 20 : i32;
                            v571 = arith.add v477, v570 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::raw_vec::RawVecInner<A>::current_memory(v571, v466, v469, v470)
                            v1314 = arith.constant 20 : i32;
                            v575 = arith.add v477, v1314 : i32 #[overflow = wrapping];
                            v1315 = arith.constant 8 : i32;
                            v573 = arith.add v477, v1315 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::raw_vec::finish_grow(v573, v469, v560, v575, v465)
                            v577 = arith.constant 12 : u32;
                            v576 = hir.bitcast v477 : u32;
                            v578 = arith.add v576, v577 : u32 #[overflow = checked];
                            v1313 = arith.constant 4 : u32;
                            v580 = arith.mod v578, v1313 : u32;
                            hir.assertz v580 #[code = 250];
                            v581 = hir.int_to_ptr v578 : ptr<byte, i32>;
                            v582 = hir.load v581 : i32;
                            v584 = arith.constant 8 : u32;
                            v583 = hir.bitcast v477 : u32;
                            v585 = arith.add v583, v584 : u32 #[overflow = checked];
                            v1312 = arith.constant 4 : u32;
                            v587 = arith.mod v585, v1312 : u32;
                            hir.assertz v587 #[code = 250];
                            v588 = hir.int_to_ptr v585 : ptr<byte, i32>;
                            v589 = hir.load v588 : i32;
                            v1310 = arith.constant 0 : i32;
                            v1311 = arith.constant 0 : i32;
                            v591 = arith.eq v589, v1311 : i1;
                            v592 = arith.zext v591 : u32;
                            v593 = hir.bitcast v592 : i32;
                            v595 = arith.neq v593, v1310 : i1;
                            v1292 = scf.if v595 : i32 {
                            ^block65:
                                v603 = hir.bitcast v466 : u32;
                                v1309 = arith.constant 4 : u32;
                                v605 = arith.mod v603, v1309 : u32;
                                hir.assertz v605 #[code = 250];
                                v606 = hir.int_to_ptr v603 : ptr<byte, i32>;
                                hir.store v606, v547;
                                v1308 = arith.constant 4 : u32;
                                v607 = hir.bitcast v466 : u32;
                                v609 = arith.add v607, v1308 : u32 #[overflow = checked];
                                v1307 = arith.constant 4 : u32;
                                v611 = arith.mod v609, v1307 : u32;
                                hir.assertz v611 #[code = 250];
                                v612 = hir.int_to_ptr v609 : ptr<byte, i32>;
                                hir.store v612, v582;
                                scf.yield v520;
                            } else {
                            ^block66:
                                v597 = arith.constant 16 : u32;
                                v596 = hir.bitcast v477 : u32;
                                v598 = arith.add v596, v597 : u32 #[overflow = checked];
                                v1306 = arith.constant 4 : u32;
                                v600 = arith.mod v598, v1306 : u32;
                                hir.assertz v600 #[code = 250];
                                v601 = hir.int_to_ptr v598 : ptr<byte, i32>;
                                v602 = hir.load v601 : i32;
                                scf.yield v602;
                            };
                            v613 = arith.constant -2147483647 : i32;
                            v1293 = cf.select v595, v613, v582 : i32;
                            scf.yield v1292, v1293;
                        };
                        scf.yield v1294, v1295;
                    };
                    scf.yield v1296, v1297;
                };
                scf.yield v1298, v1299;
            };
            v1305 = arith.constant 4 : u32;
            v618 = hir.bitcast v465 : u32;
            v620 = arith.add v618, v1305 : u32 #[overflow = checked];
            v1304 = arith.constant 4 : u32;
            v622 = arith.mod v620, v1304 : u32;
            hir.assertz v622 #[code = 250];
            v623 = hir.int_to_ptr v620 : ptr<byte, i32>;
            hir.store v623, v1300;
            v626 = hir.bitcast v465 : u32;
            v1303 = arith.constant 4 : u32;
            v628 = arith.mod v626, v1303 : u32;
            hir.assertz v628 #[code = 250];
            v629 = hir.int_to_ptr v626 : ptr<byte, i32>;
            hir.store v629, v1301;
            v1302 = arith.constant 32 : i32;
            v633 = arith.add v477, v1302 : i32 #[overflow = wrapping];
            v634 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v635 = hir.bitcast v634 : ptr<byte, i32>;
            hir.store v635, v633;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::deallocate(v636: i32, v637: i32, v638: i32) {
        ^block67(v636: i32, v637: i32, v638: i32):
            v640 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v641 = hir.bitcast v640 : ptr<byte, i32>;
            v642 = hir.load v641 : i32;
            v643 = arith.constant 16 : i32;
            v644 = arith.sub v642, v643 : i32 #[overflow = wrapping];
            v645 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v646 = hir.bitcast v645 : ptr<byte, i32>;
            hir.store v646, v644;
            v647 = arith.constant 4 : i32;
            v648 = arith.add v644, v647 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::raw_vec::RawVecInner<A>::current_memory(v648, v636, v637, v638)
            v650 = arith.constant 8 : u32;
            v649 = hir.bitcast v644 : u32;
            v651 = arith.add v649, v650 : u32 #[overflow = checked];
            v652 = arith.constant 4 : u32;
            v653 = arith.mod v651, v652 : u32;
            hir.assertz v653 #[code = 250];
            v654 = hir.int_to_ptr v651 : ptr<byte, i32>;
            v655 = hir.load v654 : i32;
            v1336 = arith.constant 0 : i32;
            v639 = arith.constant 0 : i32;
            v657 = arith.eq v655, v639 : i1;
            v658 = arith.zext v657 : u32;
            v659 = hir.bitcast v658 : i32;
            v661 = arith.neq v659, v1336 : i1;
            scf.if v661{
            ^block149:
                scf.yield ;
            } else {
            ^block70:
                v1335 = arith.constant 4 : u32;
                v662 = hir.bitcast v644 : u32;
                v664 = arith.add v662, v1335 : u32 #[overflow = checked];
                v1334 = arith.constant 4 : u32;
                v666 = arith.mod v664, v1334 : u32;
                hir.assertz v666 #[code = 250];
                v667 = hir.int_to_ptr v664 : ptr<byte, i32>;
                v668 = hir.load v667 : i32;
                v670 = arith.constant 12 : u32;
                v669 = hir.bitcast v644 : u32;
                v671 = arith.add v669, v670 : u32 #[overflow = checked];
                v1333 = arith.constant 4 : u32;
                v673 = arith.mod v671, v1333 : u32;
                hir.assertz v673 #[code = 250];
                v674 = hir.int_to_ptr v671 : ptr<byte, i32>;
                v675 = hir.load v674 : i32;
                hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v668, v655, v675)
                scf.yield ;
            };
            v1332 = arith.constant 16 : i32;
            v678 = arith.add v644, v1332 : i32 #[overflow = wrapping];
            v679 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v680 = hir.bitcast v679 : ptr<byte, i32>;
            hir.store v680, v678;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v681: i32, v682: i32, v683: i32) {
        ^block71(v681: i32, v682: i32, v683: i32):
            v685 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v686 = hir.bitcast v685 : ptr<byte, i32>;
            v687 = hir.load v686 : i32;
            v688 = arith.constant 16 : i32;
            v689 = arith.sub v687, v688 : i32 #[overflow = wrapping];
            v690 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v691 = hir.bitcast v690 : ptr<byte, i32>;
            hir.store v691, v689;
            v684 = arith.constant 0 : i32;
            v692 = arith.constant 8 : i32;
            v693 = arith.add v689, v692 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::alloc::Global::alloc_impl(v693, v682, v683, v684)
            v696 = arith.constant 12 : u32;
            v695 = hir.bitcast v689 : u32;
            v697 = arith.add v695, v696 : u32 #[overflow = checked];
            v698 = arith.constant 4 : u32;
            v699 = arith.mod v697, v698 : u32;
            hir.assertz v699 #[code = 250];
            v700 = hir.int_to_ptr v697 : ptr<byte, i32>;
            v701 = hir.load v700 : i32;
            v703 = arith.constant 8 : u32;
            v702 = hir.bitcast v689 : u32;
            v704 = arith.add v702, v703 : u32 #[overflow = checked];
            v1341 = arith.constant 4 : u32;
            v706 = arith.mod v704, v1341 : u32;
            hir.assertz v706 #[code = 250];
            v707 = hir.int_to_ptr v704 : ptr<byte, i32>;
            v708 = hir.load v707 : i32;
            v709 = hir.bitcast v681 : u32;
            v1340 = arith.constant 4 : u32;
            v711 = arith.mod v709, v1340 : u32;
            hir.assertz v711 #[code = 250];
            v712 = hir.int_to_ptr v709 : ptr<byte, i32>;
            hir.store v712, v708;
            v1339 = arith.constant 4 : u32;
            v713 = hir.bitcast v681 : u32;
            v715 = arith.add v713, v1339 : u32 #[overflow = checked];
            v1338 = arith.constant 4 : u32;
            v717 = arith.mod v715, v1338 : u32;
            hir.assertz v717 #[code = 250];
            v718 = hir.int_to_ptr v715 : ptr<byte, i32>;
            hir.store v718, v701;
            v1337 = arith.constant 16 : i32;
            v720 = arith.add v689, v1337 : i32 #[overflow = wrapping];
            v721 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v722 = hir.bitcast v721 : ptr<byte, i32>;
            hir.store v722, v720;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v723: i32, v724: i32, v725: i32, v726: i32) {
        ^block73(v723: i32, v724: i32, v725: i32, v726: i32):
            v1357 = arith.constant 0 : i32;
            v727 = arith.constant 0 : i32;
            v728 = arith.eq v725, v727 : i1;
            v729 = arith.zext v728 : u32;
            v730 = hir.bitcast v729 : i32;
            v732 = arith.neq v730, v1357 : i1;
            v1353 = scf.if v732 : i32 {
            ^block151:
                scf.yield v724;
            } else {
            ^block76:
                hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/__rustc::__rust_no_alloc_shim_is_unstable_v2()
                v1356 = arith.constant 0 : i32;
                v734 = arith.neq v726, v1356 : i1;
                v1352 = scf.if v734 : i32 {
                ^block77:
                    v736 = hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/__rustc::__rust_alloc_zeroed(v725, v724) : i32
                    scf.yield v736;
                } else {
                ^block78:
                    v735 = hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/__rustc::__rust_alloc(v725, v724) : i32
                    scf.yield v735;
                };
                scf.yield v1352;
            };
            v740 = arith.constant 4 : u32;
            v739 = hir.bitcast v723 : u32;
            v741 = arith.add v739, v740 : u32 #[overflow = checked];
            v1355 = arith.constant 4 : u32;
            v743 = arith.mod v741, v1355 : u32;
            hir.assertz v743 #[code = 250];
            v744 = hir.int_to_ptr v741 : ptr<byte, i32>;
            hir.store v744, v725;
            v746 = hir.bitcast v723 : u32;
            v1354 = arith.constant 4 : u32;
            v748 = arith.mod v746, v1354 : u32;
            hir.assertz v748 #[code = 250];
            v749 = hir.int_to_ptr v746 : ptr<byte, i32>;
            hir.store v749, v1353;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v750: i32, v751: i32, v752: i32, v753: i32) {
        ^block79(v750: i32, v751: i32, v752: i32, v753: i32):
            v1383 = arith.constant 0 : i32;
            v754 = arith.constant 0 : i32;
            v758 = arith.eq v753, v754 : i1;
            v759 = arith.zext v758 : u32;
            v760 = hir.bitcast v759 : i32;
            v762 = arith.neq v760, v1383 : i1;
            v1370, v1371 = scf.if v762 : i32, i32 {
            ^block155:
                v1382 = arith.constant 0 : i32;
                v756 = arith.constant 4 : i32;
                scf.yield v756, v1382;
            } else {
            ^block82:
                v763 = hir.bitcast v751 : u32;
                v798 = arith.constant 4 : u32;
                v765 = arith.mod v763, v798 : u32;
                hir.assertz v765 #[code = 250];
                v766 = hir.int_to_ptr v763 : ptr<byte, i32>;
                v767 = hir.load v766 : i32;
                v1380 = arith.constant 0 : i32;
                v1381 = arith.constant 0 : i32;
                v769 = arith.eq v767, v1381 : i1;
                v770 = arith.zext v769 : u32;
                v771 = hir.bitcast v770 : i32;
                v773 = arith.neq v771, v1380 : i1;
                v1368 = scf.if v773 : i32 {
                ^block154:
                    v1379 = arith.constant 0 : i32;
                    scf.yield v1379;
                } else {
                ^block83:
                    v1378 = arith.constant 4 : u32;
                    v774 = hir.bitcast v750 : u32;
                    v776 = arith.add v774, v1378 : u32 #[overflow = checked];
                    v1377 = arith.constant 4 : u32;
                    v778 = arith.mod v776, v1377 : u32;
                    hir.assertz v778 #[code = 250];
                    v779 = hir.int_to_ptr v776 : ptr<byte, i32>;
                    hir.store v779, v752;
                    v1376 = arith.constant 4 : u32;
                    v780 = hir.bitcast v751 : u32;
                    v782 = arith.add v780, v1376 : u32 #[overflow = checked];
                    v1375 = arith.constant 4 : u32;
                    v784 = arith.mod v782, v1375 : u32;
                    hir.assertz v784 #[code = 250];
                    v785 = hir.int_to_ptr v782 : ptr<byte, i32>;
                    v786 = hir.load v785 : i32;
                    v787 = hir.bitcast v750 : u32;
                    v1374 = arith.constant 4 : u32;
                    v789 = arith.mod v787, v1374 : u32;
                    hir.assertz v789 #[code = 250];
                    v790 = hir.int_to_ptr v787 : ptr<byte, i32>;
                    hir.store v790, v786;
                    v791 = arith.mul v767, v753 : i32 #[overflow = wrapping];
                    scf.yield v791;
                };
                v792 = arith.constant 8 : i32;
                v1373 = arith.constant 4 : i32;
                v1369 = cf.select v773, v1373, v792 : i32;
                scf.yield v1369, v1368;
            };
            v795 = arith.add v750, v1370 : i32 #[overflow = wrapping];
            v797 = hir.bitcast v795 : u32;
            v1372 = arith.constant 4 : u32;
            v799 = arith.mod v797, v1372 : u32;
            hir.assertz v799 #[code = 250];
            v800 = hir.int_to_ptr v797 : ptr<byte, i32>;
            hir.store v800, v1371;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::finish_grow(v801: i32, v802: i32, v803: i32, v804: i32, v805: i32) {
        ^block84(v801: i32, v802: i32, v803: i32, v804: i32, v805: i32):
            v807 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v808 = hir.bitcast v807 : ptr<byte, i32>;
            v809 = hir.load v808 : i32;
            v810 = arith.constant 16 : i32;
            v811 = arith.sub v809, v810 : i32 #[overflow = wrapping];
            v812 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v813 = hir.bitcast v812 : ptr<byte, i32>;
            hir.store v813, v811;
            v1438 = arith.constant 0 : i32;
            v806 = arith.constant 0 : i32;
            v816 = arith.gte v803, v806 : i1;
            v817 = arith.zext v816 : u32;
            v818 = hir.bitcast v817 : i32;
            v820 = arith.neq v818, v1438 : i1;
            v1412, v1413 = scf.if v820 : i32, i32 {
            ^block87:
                v907 = arith.constant 4 : u32;
                v823 = hir.bitcast v804 : u32;
                v825 = arith.add v823, v907 : u32 #[overflow = checked];
                v1437 = arith.constant 4 : u32;
                v827 = arith.mod v825, v1437 : u32;
                hir.assertz v827 #[code = 250];
                v828 = hir.int_to_ptr v825 : ptr<byte, i32>;
                v829 = hir.load v828 : i32;
                v1435 = arith.constant 0 : i32;
                v1436 = arith.constant 0 : i32;
                v831 = arith.eq v829, v1436 : i1;
                v832 = arith.zext v831 : u32;
                v833 = hir.bitcast v832 : i32;
                v835 = arith.neq v833, v1435 : i1;
                v1410, v1411 = scf.if v835 : i32, i32 {
                ^block90:
                    hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v811, v802, v803)
                    v1434 = arith.constant 4 : u32;
                    v868 = hir.bitcast v811 : u32;
                    v870 = arith.add v868, v1434 : u32 #[overflow = checked];
                    v1433 = arith.constant 4 : u32;
                    v872 = arith.mod v870, v1433 : u32;
                    hir.assertz v872 #[code = 250];
                    v873 = hir.int_to_ptr v870 : ptr<byte, i32>;
                    v874 = hir.load v873 : i32;
                    v875 = hir.bitcast v811 : u32;
                    v1432 = arith.constant 4 : u32;
                    v877 = arith.mod v875, v1432 : u32;
                    hir.assertz v877 #[code = 250];
                    v878 = hir.int_to_ptr v875 : ptr<byte, i32>;
                    v879 = hir.load v878 : i32;
                    scf.yield v879, v874;
                } else {
                ^block91:
                    v837 = arith.constant 8 : u32;
                    v836 = hir.bitcast v804 : u32;
                    v838 = arith.add v836, v837 : u32 #[overflow = checked];
                    v1431 = arith.constant 4 : u32;
                    v840 = arith.mod v838, v1431 : u32;
                    hir.assertz v840 #[code = 250];
                    v841 = hir.int_to_ptr v838 : ptr<byte, i32>;
                    v842 = hir.load v841 : i32;
                    v1430 = arith.constant 0 : i32;
                    v844 = arith.neq v842, v1430 : i1;
                    v1408, v1409 = scf.if v844 : i32, i32 {
                    ^block92:
                        v862 = hir.bitcast v804 : u32;
                        v1429 = arith.constant 4 : u32;
                        v864 = arith.mod v862, v1429 : u32;
                        hir.assertz v864 #[code = 250];
                        v865 = hir.int_to_ptr v862 : ptr<byte, i32>;
                        v866 = hir.load v865 : i32;
                        v867 = hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/__rustc::__rust_realloc(v866, v842, v802, v803) : i32
                        scf.yield v867, v803;
                    } else {
                    ^block93:
                        v1428 = arith.constant 0 : i32;
                        v901 = arith.constant 8 : i32;
                        v846 = arith.add v811, v901 : i32 #[overflow = wrapping];
                        hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::alloc::Global::alloc_impl(v846, v802, v803, v1428)
                        v849 = arith.constant 12 : u32;
                        v848 = hir.bitcast v811 : u32;
                        v850 = arith.add v848, v849 : u32 #[overflow = checked];
                        v1427 = arith.constant 4 : u32;
                        v852 = arith.mod v850, v1427 : u32;
                        hir.assertz v852 #[code = 250];
                        v853 = hir.int_to_ptr v850 : ptr<byte, i32>;
                        v854 = hir.load v853 : i32;
                        v1426 = arith.constant 8 : u32;
                        v855 = hir.bitcast v811 : u32;
                        v857 = arith.add v855, v1426 : u32 #[overflow = checked];
                        v1425 = arith.constant 4 : u32;
                        v859 = arith.mod v857, v1425 : u32;
                        hir.assertz v859 #[code = 250];
                        v860 = hir.int_to_ptr v857 : ptr<byte, i32>;
                        v861 = hir.load v860 : i32;
                        scf.yield v861, v854;
                    };
                    scf.yield v1408, v1409;
                };
                v1424 = arith.constant 4 : u32;
                v886 = hir.bitcast v801 : u32;
                v888 = arith.add v886, v1424 : u32 #[overflow = checked];
                v1423 = arith.constant 4 : u32;
                v890 = arith.mod v888, v1423 : u32;
                hir.assertz v890 #[code = 250];
                v1422 = arith.constant 0 : i32;
                v884 = arith.neq v1410, v1422 : i1;
                v885 = cf.select v884, v1410, v802 : i32;
                v891 = hir.int_to_ptr v888 : ptr<byte, i32>;
                hir.store v891, v885;
                v1420 = arith.constant 0 : i32;
                v898 = arith.eq v1410, v1420 : i1;
                v899 = arith.zext v898 : u32;
                v900 = hir.bitcast v899 : i32;
                v1421 = arith.constant 0 : i32;
                v895 = arith.neq v1410, v1421 : i1;
                v896 = cf.select v895, v1411, v803 : i32;
                scf.yield v896, v900;
            } else {
            ^block88:
                v821 = arith.constant 1 : i32;
                v1419 = arith.constant 0 : i32;
                scf.yield v1419, v821;
            };
            v822 = arith.constant 4 : i32;
            v1418 = arith.constant 8 : i32;
            v1414 = cf.select v820, v1418, v822 : i32;
            v904 = arith.add v801, v1414 : i32 #[overflow = wrapping];
            v906 = hir.bitcast v904 : u32;
            v1417 = arith.constant 4 : u32;
            v908 = arith.mod v906, v1417 : u32;
            hir.assertz v908 #[code = 250];
            v909 = hir.int_to_ptr v906 : ptr<byte, i32>;
            hir.store v909, v1412;
            v911 = hir.bitcast v801 : u32;
            v1416 = arith.constant 4 : u32;
            v913 = arith.mod v911, v1416 : u32;
            hir.assertz v913 #[code = 250];
            v914 = hir.int_to_ptr v911 : ptr<byte, i32>;
            hir.store v914, v1413;
            v1415 = arith.constant 16 : i32;
            v918 = arith.add v811, v1415 : i32 #[overflow = wrapping];
            v919 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v920 = hir.bitcast v919 : ptr<byte, i32>;
            hir.store v920, v918;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::deallocate(v921: i32, v922: i32, v923: i32) {
        ^block94(v921: i32, v922: i32, v923: i32):
            v1440 = arith.constant 0 : i32;
            v924 = arith.constant 0 : i32;
            v925 = arith.eq v923, v924 : i1;
            v926 = arith.zext v925 : u32;
            v927 = hir.bitcast v926 : i32;
            v929 = arith.neq v927, v1440 : i1;
            scf.if v929{
            ^block96:
                scf.yield ;
            } else {
            ^block97:
                hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/__rustc::__rust_dealloc(v921, v923, v922)
                scf.yield ;
            };
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v930: i32, v931: i32, v932: i32) {
        ^block98(v930: i32, v931: i32, v932: i32):
            ub.unreachable ;
        };

        private builtin.function @alloc::alloc::handle_alloc_error(v933: i32, v934: i32) {
        ^block100(v933: i32, v934: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v935: i32, v936: i32) -> i32 {
        ^block102(v935: i32, v936: i32):
            v943 = arith.constant 0 : i32;
            v939 = hir.bitcast v936 : u32;
            v938 = hir.bitcast v935 : u32;
            v940 = arith.gt v938, v939 : i1;
            v941 = arith.zext v940 : u32;
            v942 = hir.bitcast v941 : i32;
            v944 = arith.neq v942, v943 : i1;
            v945 = cf.select v944, v935, v936 : i32;
            builtin.ret v945;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.segment readonly @1048576 = 0x00000000000000000000000a0010000000003e64657463616465723c;
    };
};