builtin.component root_ns:root@1.0.0 {
    builtin.module public @onchain_two_felts_struct {
        private builtin.function @alloc::vec::Vec<T,A>::push(v0: i32, v1: felt) {
        ^block4(v0: i32, v1: felt):
            v4 = arith.constant 8 : u32;
            v3 = hir.bitcast v0 : u32;
            v5 = arith.add v3, v4 : u32 #[overflow = checked];
            v6 = arith.constant 4 : u32;
            v7 = arith.mod v5, v6 : u32;
            hir.assertz v7 #[code = 250];
            v8 = hir.int_to_ptr v5 : ptr<byte, i32>;
            v9 = hir.load v8 : i32;
            v10 = hir.bitcast v0 : u32;
            v737 = arith.constant 4 : u32;
            v12 = arith.mod v10, v737 : u32;
            hir.assertz v12 #[code = 250];
            v13 = hir.int_to_ptr v10 : ptr<byte, i32>;
            v14 = hir.load v13 : i32;
            v2 = arith.constant 0 : i32;
            v15 = arith.neq v9, v14 : i1;
            v16 = arith.zext v15 : u32;
            v17 = hir.bitcast v16 : i32;
            v19 = arith.neq v17, v2 : i1;
            scf.if v19{
            ^block78:
                scf.yield ;
            } else {
            ^block7:
                hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::raw_vec::RawVec<T,A>::grow_one(v0)
                scf.yield ;
            };
            v736 = arith.constant 4 : u32;
            v21 = hir.bitcast v0 : u32;
            v23 = arith.add v21, v736 : u32 #[overflow = checked];
            v735 = arith.constant 4 : u32;
            v25 = arith.mod v23, v735 : u32;
            hir.assertz v25 #[code = 250];
            v26 = hir.int_to_ptr v23 : ptr<byte, i32>;
            v27 = hir.load v26 : i32;
            v727 = arith.constant 2 : u32;
            v31 = arith.shl v9, v727 : i32;
            v32 = arith.add v27, v31 : i32 #[overflow = wrapping];
            v34 = hir.bitcast v32 : u32;
            v734 = arith.constant 4 : u32;
            v36 = arith.mod v34, v734 : u32;
            hir.assertz v36 #[code = 250];
            v37 = hir.int_to_ptr v34 : ptr<byte, felt>;
            hir.store v37, v1;
            v733 = arith.constant 8 : u32;
            v40 = hir.bitcast v0 : u32;
            v42 = arith.add v40, v733 : u32 #[overflow = checked];
            v732 = arith.constant 4 : u32;
            v44 = arith.mod v42, v732 : u32;
            hir.assertz v44 #[code = 250];
            v38 = arith.constant 1 : i32;
            v39 = arith.add v9, v38 : i32 #[overflow = wrapping];
            v45 = hir.int_to_ptr v42 : ptr<byte, i32>;
            hir.store v45, v39;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVec<T,A>::grow_one(v46: i32) {
        ^block8(v46: i32):
            v48 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v49 = hir.bitcast v48 : ptr<byte, i32>;
            v50 = hir.load v49 : i32;
            v51 = arith.constant 16 : i32;
            v52 = arith.sub v50, v51 : i32 #[overflow = wrapping];
            v53 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v54 = hir.bitcast v53 : ptr<byte, i32>;
            hir.store v54, v52;
            v57 = hir.bitcast v46 : u32;
            v58 = arith.constant 4 : u32;
            v59 = arith.mod v57, v58 : u32;
            hir.assertz v59 #[code = 250];
            v60 = hir.int_to_ptr v57 : ptr<byte, i32>;
            v61 = hir.load v60 : i32;
            v63 = arith.constant 4 : i32;
            v62 = arith.constant 1 : i32;
            v55 = arith.constant 8 : i32;
            v56 = arith.add v52, v55 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::raw_vec::RawVecInner<A>::grow_amortized(v56, v46, v61, v62, v63, v63)
            v66 = arith.constant 8 : u32;
            v65 = hir.bitcast v52 : u32;
            v67 = arith.add v65, v66 : u32 #[overflow = checked];
            v741 = arith.constant 4 : u32;
            v69 = arith.mod v67, v741 : u32;
            hir.assertz v69 #[code = 250];
            v70 = hir.int_to_ptr v67 : ptr<byte, i32>;
            v71 = hir.load v70 : i32;
            v47 = arith.constant 0 : i32;
            v72 = arith.constant -2147483647 : i32;
            v73 = arith.eq v71, v72 : i1;
            v74 = arith.zext v73 : u32;
            v75 = hir.bitcast v74 : i32;
            v77 = arith.neq v75, v47 : i1;
            cf.cond_br v77 ^block10, ^block11;
        ^block10:
            v740 = arith.constant 16 : i32;
            v87 = arith.add v52, v740 : i32 #[overflow = wrapping];
            v88 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v89 = hir.bitcast v88 : ptr<byte, i32>;
            hir.store v89, v87;
            builtin.ret ;
        ^block11:
            v79 = arith.constant 12 : u32;
            v78 = hir.bitcast v52 : u32;
            v80 = arith.add v78, v79 : u32 #[overflow = checked];
            v739 = arith.constant 4 : u32;
            v82 = arith.mod v80, v739 : u32;
            hir.assertz v82 #[code = 250];
            v83 = hir.int_to_ptr v80 : ptr<byte, i32>;
            v84 = hir.load v83 : i32;
            v85 = arith.constant 1048588 : i32;
            hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::raw_vec::handle_error(v71, v84, v85)
            ub.unreachable ;
        };

        public builtin.function @entrypoint(v90: i32, v91: i32) {
        ^block12(v90: i32, v91: i32):
            v94 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v95 = hir.bitcast v94 : ptr<byte, i32>;
            v96 = hir.load v95 : i32;
            v97 = arith.constant 16 : i32;
            v98 = arith.sub v96, v97 : i32 #[overflow = wrapping];
            v99 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v100 = hir.bitcast v99 : ptr<byte, i32>;
            hir.store v100, v98;
            v102 = arith.constant 4 : u32;
            v101 = hir.bitcast v91 : u32;
            v103 = arith.add v101, v102 : u32 #[overflow = checked];
            v755 = arith.constant 4 : u32;
            v105 = arith.mod v103, v755 : u32;
            hir.assertz v105 #[code = 250];
            v106 = hir.int_to_ptr v103 : ptr<byte, felt>;
            v107 = hir.load v106 : felt;
            v108 = hir.bitcast v91 : u32;
            v754 = arith.constant 4 : u32;
            v110 = arith.mod v108, v754 : u32;
            hir.assertz v110 #[code = 250];
            v111 = hir.int_to_ptr v108 : ptr<byte, felt>;
            v112 = hir.load v111 : felt;
            v115 = arith.constant 8 : i32;
            v113 = arith.constant 4 : i32;
            v114 = arith.add v98, v113 : i32 #[overflow = wrapping];
            v116 = arith.add v114, v115 : i32 #[overflow = wrapping];
            v118 = hir.bitcast v116 : u32;
            v753 = arith.constant 4 : u32;
            v120 = arith.mod v118, v753 : u32;
            hir.assertz v120 #[code = 250];
            v92 = arith.constant 0 : i32;
            v121 = hir.int_to_ptr v118 : ptr<byte, i32>;
            hir.store v121, v92;
            v752 = arith.constant 4 : u32;
            v123 = hir.bitcast v98 : u32;
            v125 = arith.add v123, v752 : u32 #[overflow = checked];
            v751 = arith.constant 4 : u32;
            v127 = arith.mod v125, v751 : u32;
            hir.assertz v127 #[code = 250];
            v122 = arith.constant 17179869184 : i64;
            v128 = hir.int_to_ptr v125 : ptr<byte, i64>;
            hir.store v128, v122;
            v750 = arith.constant 4 : i32;
            v130 = arith.add v98, v750 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::vec::Vec<T,A>::push(v130, v112)
            v749 = arith.constant 4 : i32;
            v132 = arith.add v98, v749 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::vec::Vec<T,A>::push(v132, v107)
            v135 = hir.bitcast v116 : u32;
            v748 = arith.constant 4 : u32;
            v137 = arith.mod v135, v748 : u32;
            hir.assertz v137 #[code = 250];
            v138 = hir.int_to_ptr v135 : ptr<byte, i32>;
            v139 = hir.load v138 : i32;
            v747 = arith.constant 8 : i32;
            v134 = arith.add v90, v747 : i32 #[overflow = wrapping];
            v140 = hir.bitcast v134 : u32;
            v746 = arith.constant 4 : u32;
            v142 = arith.mod v140, v746 : u32;
            hir.assertz v142 #[code = 250];
            v143 = hir.int_to_ptr v140 : ptr<byte, i32>;
            hir.store v143, v139;
            v745 = arith.constant 4 : u32;
            v144 = hir.bitcast v98 : u32;
            v146 = arith.add v144, v745 : u32 #[overflow = checked];
            v744 = arith.constant 4 : u32;
            v148 = arith.mod v146, v744 : u32;
            hir.assertz v148 #[code = 250];
            v149 = hir.int_to_ptr v146 : ptr<byte, i64>;
            v150 = hir.load v149 : i64;
            v151 = hir.bitcast v90 : u32;
            v743 = arith.constant 4 : u32;
            v153 = arith.mod v151, v743 : u32;
            hir.assertz v153 #[code = 250];
            v154 = hir.int_to_ptr v151 : ptr<byte, i64>;
            hir.store v154, v150;
            v742 = arith.constant 16 : i32;
            v156 = arith.add v98, v742 : i32 #[overflow = wrapping];
            v157 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v158 = hir.bitcast v157 : ptr<byte, i32>;
            hir.store v158, v156;
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc(v159: i32, v160: i32) -> i32 {
        ^block14(v159: i32, v160: i32):
            v162 = arith.constant 1048604 : i32;
            v163 = hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v162, v160, v159) : i32
            builtin.ret v163;
        };

        private builtin.function @__rustc::__rust_realloc(v164: i32, v165: i32, v166: i32, v167: i32) -> i32 {
        ^block16(v164: i32, v165: i32, v166: i32, v167: i32):
            v169 = arith.constant 1048604 : i32;
            v170 = hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v169, v166, v167) : i32
            v764 = arith.constant 0 : i32;
            v171 = arith.constant 0 : i32;
            v172 = arith.eq v170, v171 : i1;
            v173 = arith.zext v172 : u32;
            v174 = hir.bitcast v173 : i32;
            v176 = arith.neq v174, v764 : i1;
            scf.if v176{
            ^block18:
                scf.yield ;
            } else {
            ^block19:
                v763 = arith.constant 0 : i32;
                v178 = hir.bitcast v165 : u32;
                v177 = hir.bitcast v167 : u32;
                v179 = arith.lt v177, v178 : i1;
                v180 = arith.zext v179 : u32;
                v181 = hir.bitcast v180 : i32;
                v183 = arith.neq v181, v763 : i1;
                v184 = cf.select v183, v167, v165 : i32;
                v761 = arith.constant 0 : i32;
                v762 = arith.constant 0 : i32;
                v186 = arith.eq v184, v762 : i1;
                v187 = arith.zext v186 : u32;
                v188 = hir.bitcast v187 : i32;
                v190 = arith.neq v188, v761 : i1;
                scf.if v190{
                ^block82:
                    scf.yield ;
                } else {
                ^block20:
                    v191 = hir.bitcast v184 : u32;
                    v192 = hir.bitcast v170 : u32;
                    v193 = hir.int_to_ptr v192 : ptr<byte, u8>;
                    v194 = hir.bitcast v164 : u32;
                    v195 = hir.int_to_ptr v194 : ptr<byte, u8>;
                    hir.mem_cpy v195, v193, v191;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v170;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v197: i32, v198: i32) -> i32 {
        ^block21(v197: i32, v198: i32):
            v200 = arith.constant 1048604 : i32;
            v201 = hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v200, v198, v197) : i32
            v773 = arith.constant 0 : i32;
            v202 = arith.constant 0 : i32;
            v203 = arith.eq v201, v202 : i1;
            v204 = arith.zext v203 : u32;
            v205 = hir.bitcast v204 : i32;
            v207 = arith.neq v205, v773 : i1;
            scf.if v207{
            ^block23:
                scf.yield ;
            } else {
            ^block24:
                v771 = arith.constant 0 : i32;
                v772 = arith.constant 0 : i32;
                v209 = arith.eq v197, v772 : i1;
                v210 = arith.zext v209 : u32;
                v211 = hir.bitcast v210 : i32;
                v213 = arith.neq v211, v771 : i1;
                scf.if v213{
                ^block85:
                    scf.yield ;
                } else {
                ^block25:
                    v765 = arith.constant 0 : u8;
                    v216 = hir.bitcast v197 : u32;
                    v217 = hir.bitcast v201 : u32;
                    v218 = hir.int_to_ptr v217 : ptr<byte, u8>;
                    hir.mem_set v218, v216, v765;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v201;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block26:
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v220: i32, v221: i32, v222: i32) -> i32 {
        ^block28(v220: i32, v221: i32, v222: i32):
            v225 = arith.constant 16 : i32;
            v224 = arith.constant 0 : i32;
            v775 = arith.constant 16 : u32;
            v227 = hir.bitcast v221 : u32;
            v229 = arith.gt v227, v775 : i1;
            v230 = arith.zext v229 : u32;
            v231 = hir.bitcast v230 : i32;
            v233 = arith.neq v231, v224 : i1;
            v234 = cf.select v233, v221, v225 : i32;
            v815 = arith.constant 0 : i32;
            v235 = arith.constant -1 : i32;
            v236 = arith.add v234, v235 : i32 #[overflow = wrapping];
            v237 = arith.band v234, v236 : i32;
            v239 = arith.neq v237, v815 : i1;
            v784, v785 = scf.if v239 : i32, u32 {
            ^block90:
                v776 = arith.constant 0 : u32;
                v780 = ub.poison i32 : i32;
                scf.yield v780, v776;
            } else {
            ^block31:
                v241 = hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/core::ptr::alignment::Alignment::max(v221, v234) : i32
                v814 = arith.constant 0 : i32;
                v240 = arith.constant -2147483648 : i32;
                v242 = arith.sub v240, v241 : i32 #[overflow = wrapping];
                v244 = hir.bitcast v242 : u32;
                v243 = hir.bitcast v222 : u32;
                v245 = arith.gt v243, v244 : i1;
                v246 = arith.zext v245 : u32;
                v247 = hir.bitcast v246 : i32;
                v249 = arith.neq v247, v814 : i1;
                v799 = scf.if v249 : i32 {
                ^block89:
                    v813 = ub.poison i32 : i32;
                    scf.yield v813;
                } else {
                ^block32:
                    v811 = arith.constant 0 : i32;
                    v255 = arith.sub v811, v241 : i32 #[overflow = wrapping];
                    v812 = arith.constant -1 : i32;
                    v251 = arith.add v222, v241 : i32 #[overflow = wrapping];
                    v253 = arith.add v251, v812 : i32 #[overflow = wrapping];
                    v256 = arith.band v253, v255 : i32;
                    v257 = hir.bitcast v220 : u32;
                    v258 = arith.constant 4 : u32;
                    v259 = arith.mod v257, v258 : u32;
                    hir.assertz v259 #[code = 250];
                    v260 = hir.int_to_ptr v257 : ptr<byte, i32>;
                    v261 = hir.load v260 : i32;
                    v810 = arith.constant 0 : i32;
                    v263 = arith.neq v261, v810 : i1;
                    scf.if v263{
                    ^block88:
                        scf.yield ;
                    } else {
                    ^block34:
                        v264 = hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/intrinsics::mem::heap_base() : i32
                        v265 = hir.mem_size  : u32;
                        v271 = hir.bitcast v220 : u32;
                        v809 = arith.constant 4 : u32;
                        v273 = arith.mod v271, v809 : u32;
                        hir.assertz v273 #[code = 250];
                        v808 = arith.constant 16 : u32;
                        v266 = hir.bitcast v265 : i32;
                        v269 = arith.shl v266, v808 : i32;
                        v270 = arith.add v264, v269 : i32 #[overflow = wrapping];
                        v274 = hir.int_to_ptr v271 : ptr<byte, i32>;
                        hir.store v274, v270;
                        scf.yield ;
                    };
                    v277 = hir.bitcast v220 : u32;
                    v807 = arith.constant 4 : u32;
                    v279 = arith.mod v277, v807 : u32;
                    hir.assertz v279 #[code = 250];
                    v280 = hir.int_to_ptr v277 : ptr<byte, i32>;
                    v281 = hir.load v280 : i32;
                    v805 = arith.constant 0 : i32;
                    v806 = arith.constant -1 : i32;
                    v283 = arith.bxor v281, v806 : i32;
                    v285 = hir.bitcast v283 : u32;
                    v284 = hir.bitcast v256 : u32;
                    v286 = arith.gt v284, v285 : i1;
                    v287 = arith.zext v286 : u32;
                    v288 = hir.bitcast v287 : i32;
                    v290 = arith.neq v288, v805 : i1;
                    v798 = scf.if v290 : i32 {
                    ^block35:
                        v804 = arith.constant 0 : i32;
                        scf.yield v804;
                    } else {
                    ^block36:
                        v292 = hir.bitcast v220 : u32;
                        v803 = arith.constant 4 : u32;
                        v294 = arith.mod v292, v803 : u32;
                        hir.assertz v294 #[code = 250];
                        v291 = arith.add v281, v256 : i32 #[overflow = wrapping];
                        v295 = hir.int_to_ptr v292 : ptr<byte, i32>;
                        hir.store v295, v291;
                        v297 = arith.add v281, v241 : i32 #[overflow = wrapping];
                        scf.yield v297;
                    };
                    scf.yield v798;
                };
                v781 = arith.constant 1 : u32;
                v802 = arith.constant 0 : u32;
                v800 = cf.select v249, v802, v781 : u32;
                scf.yield v799, v800;
            };
            v801 = arith.constant 0 : u32;
            v797 = arith.eq v785, v801 : i1;
            cf.cond_br v797 ^block30, ^block92(v784);
        ^block30:
            ub.unreachable ;
        ^block92(v777: i32):
            builtin.ret v777;
        };

        private builtin.function @intrinsics::mem::heap_base() -> i32 {
        ^block37:
            v300 = hir.exec @intrinsics/mem/heap_base() : i32
            builtin.ret v300;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::grow_amortized(v302: i32, v303: i32, v304: i32, v305: i32, v306: i32, v307: i32) {
        ^block41(v302: i32, v303: i32, v304: i32, v305: i32, v306: i32, v307: i32):
            v310 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v311 = hir.bitcast v310 : ptr<byte, i32>;
            v312 = hir.load v311 : i32;
            v313 = arith.constant 32 : i32;
            v314 = arith.sub v312, v313 : i32 #[overflow = wrapping];
            v315 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v316 = hir.bitcast v315 : ptr<byte, i32>;
            hir.store v316, v314;
            v892 = arith.constant 0 : i32;
            v308 = arith.constant 0 : i32;
            v319 = arith.eq v307, v308 : i1;
            v320 = arith.zext v319 : u32;
            v321 = hir.bitcast v320 : i32;
            v323 = arith.neq v321, v892 : i1;
            v863, v864 = scf.if v323 : i32, i32 {
            ^block44:
                v891 = arith.constant 0 : i32;
                scf.yield v891, v891;
            } else {
            ^block45:
                v324 = arith.add v304, v305 : i32 #[overflow = wrapping];
                v890 = arith.constant 0 : i32;
                v326 = hir.bitcast v304 : u32;
                v325 = hir.bitcast v324 : u32;
                v327 = arith.lt v325, v326 : i1;
                v328 = arith.zext v327 : u32;
                v329 = hir.bitcast v328 : i32;
                v331 = arith.neq v329, v890 : i1;
                v861, v862 = scf.if v331 : i32, i32 {
                ^block98:
                    v889 = arith.constant 0 : i32;
                    scf.yield v889, v889;
                } else {
                ^block46:
                    v342 = hir.bitcast v303 : u32;
                    v456 = arith.constant 4 : u32;
                    v344 = arith.mod v342, v456 : u32;
                    hir.assertz v344 #[code = 250];
                    v345 = hir.int_to_ptr v342 : ptr<byte, i32>;
                    v346 = hir.load v345 : i32;
                    v817 = arith.constant 1 : u32;
                    v349 = arith.shl v346, v817 : i32;
                    v888 = arith.constant 0 : i32;
                    v351 = hir.bitcast v349 : u32;
                    v350 = hir.bitcast v324 : u32;
                    v352 = arith.gt v350, v351 : i1;
                    v353 = arith.zext v352 : u32;
                    v354 = hir.bitcast v353 : i32;
                    v356 = arith.neq v354, v888 : i1;
                    v357 = cf.select v356, v324, v349 : i32;
                    v885 = arith.constant 1 : i32;
                    v359 = arith.constant 4 : i32;
                    v886 = arith.constant 0 : i32;
                    v816 = arith.constant 1025 : u32;
                    v362 = hir.bitcast v307 : u32;
                    v364 = arith.lt v362, v816 : i1;
                    v365 = arith.zext v364 : u32;
                    v366 = hir.bitcast v365 : i32;
                    v368 = arith.neq v366, v886 : i1;
                    v369 = cf.select v368, v359, v885 : i32;
                    v358 = arith.constant 8 : i32;
                    v887 = arith.constant 0 : i32;
                    v347 = arith.constant 1 : i32;
                    v371 = arith.eq v307, v347 : i1;
                    v372 = arith.zext v371 : u32;
                    v373 = hir.bitcast v372 : i32;
                    v375 = arith.neq v373, v887 : i1;
                    v376 = cf.select v375, v358, v369 : i32;
                    v884 = arith.constant 0 : i32;
                    v378 = hir.bitcast v376 : u32;
                    v377 = hir.bitcast v357 : u32;
                    v379 = arith.gt v377, v378 : i1;
                    v380 = arith.zext v379 : u32;
                    v381 = hir.bitcast v380 : i32;
                    v383 = arith.neq v381, v884 : i1;
                    v384 = cf.select v383, v357, v376 : i32;
                    v385 = hir.bitcast v384 : u32;
                    v386 = arith.zext v385 : u64;
                    v387 = hir.bitcast v386 : i64;
                    v883 = arith.constant 0 : i32;
                    v337 = arith.sub v883, v306 : i32 #[overflow = wrapping];
                    v334 = arith.constant -1 : i32;
                    v333 = arith.add v306, v307 : i32 #[overflow = wrapping];
                    v335 = arith.add v333, v334 : i32 #[overflow = wrapping];
                    v338 = arith.band v335, v337 : i32;
                    v339 = hir.bitcast v338 : u32;
                    v340 = arith.zext v339 : u64;
                    v341 = hir.bitcast v340 : i64;
                    v388 = arith.mul v341, v387 : i64 #[overflow = wrapping];
                    v882 = arith.constant 0 : i32;
                    v389 = arith.constant 32 : i64;
                    v391 = hir.cast v389 : u32;
                    v390 = hir.bitcast v388 : u64;
                    v392 = arith.shr v390, v391 : u64;
                    v393 = hir.bitcast v392 : i64;
                    v394 = arith.trunc v393 : i32;
                    v396 = arith.neq v394, v882 : i1;
                    v859, v860 = scf.if v396 : i32, i32 {
                    ^block97:
                        v881 = arith.constant 0 : i32;
                        scf.yield v357, v881;
                    } else {
                    ^block47:
                        v397 = arith.trunc v388 : i32;
                        v880 = arith.constant 0 : i32;
                        v398 = arith.constant -2147483648 : i32;
                        v399 = arith.sub v398, v306 : i32 #[overflow = wrapping];
                        v401 = hir.bitcast v399 : u32;
                        v400 = hir.bitcast v397 : u32;
                        v402 = arith.gt v400, v401 : i1;
                        v403 = arith.zext v402 : u32;
                        v404 = hir.bitcast v403 : i32;
                        v406 = arith.neq v404, v880 : i1;
                        v857, v858 = scf.if v406 : i32, i32 {
                        ^block96:
                            v879 = arith.constant 0 : i32;
                            scf.yield v357, v879;
                        } else {
                        ^block48:
                            v407 = arith.constant 20 : i32;
                            v408 = arith.add v314, v407 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::raw_vec::RawVecInner<A>::current_memory(v408, v303, v306, v307)
                            v877 = arith.constant 20 : i32;
                            v412 = arith.add v314, v877 : i32 #[overflow = wrapping];
                            v878 = arith.constant 8 : i32;
                            v410 = arith.add v314, v878 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::raw_vec::finish_grow(v410, v306, v397, v412, v302)
                            v414 = arith.constant 12 : u32;
                            v413 = hir.bitcast v314 : u32;
                            v415 = arith.add v413, v414 : u32 #[overflow = checked];
                            v876 = arith.constant 4 : u32;
                            v417 = arith.mod v415, v876 : u32;
                            hir.assertz v417 #[code = 250];
                            v418 = hir.int_to_ptr v415 : ptr<byte, i32>;
                            v419 = hir.load v418 : i32;
                            v421 = arith.constant 8 : u32;
                            v420 = hir.bitcast v314 : u32;
                            v422 = arith.add v420, v421 : u32 #[overflow = checked];
                            v875 = arith.constant 4 : u32;
                            v424 = arith.mod v422, v875 : u32;
                            hir.assertz v424 #[code = 250];
                            v425 = hir.int_to_ptr v422 : ptr<byte, i32>;
                            v426 = hir.load v425 : i32;
                            v873 = arith.constant 0 : i32;
                            v874 = arith.constant 0 : i32;
                            v428 = arith.eq v426, v874 : i1;
                            v429 = arith.zext v428 : u32;
                            v430 = hir.bitcast v429 : i32;
                            v432 = arith.neq v430, v873 : i1;
                            v855 = scf.if v432 : i32 {
                            ^block49:
                                v440 = hir.bitcast v303 : u32;
                                v872 = arith.constant 4 : u32;
                                v442 = arith.mod v440, v872 : u32;
                                hir.assertz v442 #[code = 250];
                                v443 = hir.int_to_ptr v440 : ptr<byte, i32>;
                                hir.store v443, v384;
                                v871 = arith.constant 4 : u32;
                                v444 = hir.bitcast v303 : u32;
                                v446 = arith.add v444, v871 : u32 #[overflow = checked];
                                v870 = arith.constant 4 : u32;
                                v448 = arith.mod v446, v870 : u32;
                                hir.assertz v448 #[code = 250];
                                v449 = hir.int_to_ptr v446 : ptr<byte, i32>;
                                hir.store v449, v419;
                                scf.yield v357;
                            } else {
                            ^block50:
                                v434 = arith.constant 16 : u32;
                                v433 = hir.bitcast v314 : u32;
                                v435 = arith.add v433, v434 : u32 #[overflow = checked];
                                v869 = arith.constant 4 : u32;
                                v437 = arith.mod v435, v869 : u32;
                                hir.assertz v437 #[code = 250];
                                v438 = hir.int_to_ptr v435 : ptr<byte, i32>;
                                v439 = hir.load v438 : i32;
                                scf.yield v439;
                            };
                            v450 = arith.constant -2147483647 : i32;
                            v856 = cf.select v432, v450, v419 : i32;
                            scf.yield v855, v856;
                        };
                        scf.yield v857, v858;
                    };
                    scf.yield v859, v860;
                };
                scf.yield v861, v862;
            };
            v868 = arith.constant 4 : u32;
            v455 = hir.bitcast v302 : u32;
            v457 = arith.add v455, v868 : u32 #[overflow = checked];
            v867 = arith.constant 4 : u32;
            v459 = arith.mod v457, v867 : u32;
            hir.assertz v459 #[code = 250];
            v460 = hir.int_to_ptr v457 : ptr<byte, i32>;
            hir.store v460, v863;
            v463 = hir.bitcast v302 : u32;
            v866 = arith.constant 4 : u32;
            v465 = arith.mod v463, v866 : u32;
            hir.assertz v465 #[code = 250];
            v466 = hir.int_to_ptr v463 : ptr<byte, i32>;
            hir.store v466, v864;
            v865 = arith.constant 32 : i32;
            v470 = arith.add v314, v865 : i32 #[overflow = wrapping];
            v471 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v472 = hir.bitcast v471 : ptr<byte, i32>;
            hir.store v472, v470;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v473: i32, v474: i32, v475: i32) {
        ^block51(v473: i32, v474: i32, v475: i32):
            v477 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v478 = hir.bitcast v477 : ptr<byte, i32>;
            v479 = hir.load v478 : i32;
            v480 = arith.constant 16 : i32;
            v481 = arith.sub v479, v480 : i32 #[overflow = wrapping];
            v482 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v483 = hir.bitcast v482 : ptr<byte, i32>;
            hir.store v483, v481;
            v476 = arith.constant 0 : i32;
            v484 = arith.constant 8 : i32;
            v485 = arith.add v481, v484 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::alloc::Global::alloc_impl(v485, v474, v475, v476)
            v488 = arith.constant 12 : u32;
            v487 = hir.bitcast v481 : u32;
            v489 = arith.add v487, v488 : u32 #[overflow = checked];
            v490 = arith.constant 4 : u32;
            v491 = arith.mod v489, v490 : u32;
            hir.assertz v491 #[code = 250];
            v492 = hir.int_to_ptr v489 : ptr<byte, i32>;
            v493 = hir.load v492 : i32;
            v495 = arith.constant 8 : u32;
            v494 = hir.bitcast v481 : u32;
            v496 = arith.add v494, v495 : u32 #[overflow = checked];
            v897 = arith.constant 4 : u32;
            v498 = arith.mod v496, v897 : u32;
            hir.assertz v498 #[code = 250];
            v499 = hir.int_to_ptr v496 : ptr<byte, i32>;
            v500 = hir.load v499 : i32;
            v501 = hir.bitcast v473 : u32;
            v896 = arith.constant 4 : u32;
            v503 = arith.mod v501, v896 : u32;
            hir.assertz v503 #[code = 250];
            v504 = hir.int_to_ptr v501 : ptr<byte, i32>;
            hir.store v504, v500;
            v895 = arith.constant 4 : u32;
            v505 = hir.bitcast v473 : u32;
            v507 = arith.add v505, v895 : u32 #[overflow = checked];
            v894 = arith.constant 4 : u32;
            v509 = arith.mod v507, v894 : u32;
            hir.assertz v509 #[code = 250];
            v510 = hir.int_to_ptr v507 : ptr<byte, i32>;
            hir.store v510, v493;
            v893 = arith.constant 16 : i32;
            v512 = arith.add v481, v893 : i32 #[overflow = wrapping];
            v513 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v514 = hir.bitcast v513 : ptr<byte, i32>;
            hir.store v514, v512;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v515: i32, v516: i32, v517: i32, v518: i32) {
        ^block53(v515: i32, v516: i32, v517: i32, v518: i32):
            v913 = arith.constant 0 : i32;
            v519 = arith.constant 0 : i32;
            v520 = arith.eq v517, v519 : i1;
            v521 = arith.zext v520 : u32;
            v522 = hir.bitcast v521 : i32;
            v524 = arith.neq v522, v913 : i1;
            v909 = scf.if v524 : i32 {
            ^block104:
                scf.yield v516;
            } else {
            ^block56:
                hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/__rustc::__rust_no_alloc_shim_is_unstable_v2()
                v912 = arith.constant 0 : i32;
                v526 = arith.neq v518, v912 : i1;
                v908 = scf.if v526 : i32 {
                ^block57:
                    v528 = hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/__rustc::__rust_alloc_zeroed(v517, v516) : i32
                    scf.yield v528;
                } else {
                ^block58:
                    v527 = hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/__rustc::__rust_alloc(v517, v516) : i32
                    scf.yield v527;
                };
                scf.yield v908;
            };
            v532 = arith.constant 4 : u32;
            v531 = hir.bitcast v515 : u32;
            v533 = arith.add v531, v532 : u32 #[overflow = checked];
            v911 = arith.constant 4 : u32;
            v535 = arith.mod v533, v911 : u32;
            hir.assertz v535 #[code = 250];
            v536 = hir.int_to_ptr v533 : ptr<byte, i32>;
            hir.store v536, v517;
            v538 = hir.bitcast v515 : u32;
            v910 = arith.constant 4 : u32;
            v540 = arith.mod v538, v910 : u32;
            hir.assertz v540 #[code = 250];
            v541 = hir.int_to_ptr v538 : ptr<byte, i32>;
            hir.store v541, v909;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v542: i32, v543: i32, v544: i32, v545: i32) {
        ^block59(v542: i32, v543: i32, v544: i32, v545: i32):
            v939 = arith.constant 0 : i32;
            v546 = arith.constant 0 : i32;
            v550 = arith.eq v545, v546 : i1;
            v551 = arith.zext v550 : u32;
            v552 = hir.bitcast v551 : i32;
            v554 = arith.neq v552, v939 : i1;
            v926, v927 = scf.if v554 : i32, i32 {
            ^block108:
                v938 = arith.constant 0 : i32;
                v548 = arith.constant 4 : i32;
                scf.yield v548, v938;
            } else {
            ^block62:
                v555 = hir.bitcast v543 : u32;
                v590 = arith.constant 4 : u32;
                v557 = arith.mod v555, v590 : u32;
                hir.assertz v557 #[code = 250];
                v558 = hir.int_to_ptr v555 : ptr<byte, i32>;
                v559 = hir.load v558 : i32;
                v936 = arith.constant 0 : i32;
                v937 = arith.constant 0 : i32;
                v561 = arith.eq v559, v937 : i1;
                v562 = arith.zext v561 : u32;
                v563 = hir.bitcast v562 : i32;
                v565 = arith.neq v563, v936 : i1;
                v924 = scf.if v565 : i32 {
                ^block107:
                    v935 = arith.constant 0 : i32;
                    scf.yield v935;
                } else {
                ^block63:
                    v934 = arith.constant 4 : u32;
                    v566 = hir.bitcast v542 : u32;
                    v568 = arith.add v566, v934 : u32 #[overflow = checked];
                    v933 = arith.constant 4 : u32;
                    v570 = arith.mod v568, v933 : u32;
                    hir.assertz v570 #[code = 250];
                    v571 = hir.int_to_ptr v568 : ptr<byte, i32>;
                    hir.store v571, v544;
                    v932 = arith.constant 4 : u32;
                    v572 = hir.bitcast v543 : u32;
                    v574 = arith.add v572, v932 : u32 #[overflow = checked];
                    v931 = arith.constant 4 : u32;
                    v576 = arith.mod v574, v931 : u32;
                    hir.assertz v576 #[code = 250];
                    v577 = hir.int_to_ptr v574 : ptr<byte, i32>;
                    v578 = hir.load v577 : i32;
                    v579 = hir.bitcast v542 : u32;
                    v930 = arith.constant 4 : u32;
                    v581 = arith.mod v579, v930 : u32;
                    hir.assertz v581 #[code = 250];
                    v582 = hir.int_to_ptr v579 : ptr<byte, i32>;
                    hir.store v582, v578;
                    v583 = arith.mul v559, v545 : i32 #[overflow = wrapping];
                    scf.yield v583;
                };
                v584 = arith.constant 8 : i32;
                v929 = arith.constant 4 : i32;
                v925 = cf.select v565, v929, v584 : i32;
                scf.yield v925, v924;
            };
            v587 = arith.add v542, v926 : i32 #[overflow = wrapping];
            v589 = hir.bitcast v587 : u32;
            v928 = arith.constant 4 : u32;
            v591 = arith.mod v589, v928 : u32;
            hir.assertz v591 #[code = 250];
            v592 = hir.int_to_ptr v589 : ptr<byte, i32>;
            hir.store v592, v927;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::finish_grow(v593: i32, v594: i32, v595: i32, v596: i32, v597: i32) {
        ^block64(v593: i32, v594: i32, v595: i32, v596: i32, v597: i32):
            v599 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v600 = hir.bitcast v599 : ptr<byte, i32>;
            v601 = hir.load v600 : i32;
            v602 = arith.constant 16 : i32;
            v603 = arith.sub v601, v602 : i32 #[overflow = wrapping];
            v604 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v605 = hir.bitcast v604 : ptr<byte, i32>;
            hir.store v605, v603;
            v994 = arith.constant 0 : i32;
            v598 = arith.constant 0 : i32;
            v608 = arith.gte v595, v598 : i1;
            v609 = arith.zext v608 : u32;
            v610 = hir.bitcast v609 : i32;
            v612 = arith.neq v610, v994 : i1;
            v968, v969 = scf.if v612 : i32, i32 {
            ^block67:
                v699 = arith.constant 4 : u32;
                v615 = hir.bitcast v596 : u32;
                v617 = arith.add v615, v699 : u32 #[overflow = checked];
                v993 = arith.constant 4 : u32;
                v619 = arith.mod v617, v993 : u32;
                hir.assertz v619 #[code = 250];
                v620 = hir.int_to_ptr v617 : ptr<byte, i32>;
                v621 = hir.load v620 : i32;
                v991 = arith.constant 0 : i32;
                v992 = arith.constant 0 : i32;
                v623 = arith.eq v621, v992 : i1;
                v624 = arith.zext v623 : u32;
                v625 = hir.bitcast v624 : i32;
                v627 = arith.neq v625, v991 : i1;
                v966, v967 = scf.if v627 : i32, i32 {
                ^block70:
                    hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v603, v594, v595)
                    v990 = arith.constant 4 : u32;
                    v660 = hir.bitcast v603 : u32;
                    v662 = arith.add v660, v990 : u32 #[overflow = checked];
                    v989 = arith.constant 4 : u32;
                    v664 = arith.mod v662, v989 : u32;
                    hir.assertz v664 #[code = 250];
                    v665 = hir.int_to_ptr v662 : ptr<byte, i32>;
                    v666 = hir.load v665 : i32;
                    v667 = hir.bitcast v603 : u32;
                    v988 = arith.constant 4 : u32;
                    v669 = arith.mod v667, v988 : u32;
                    hir.assertz v669 #[code = 250];
                    v670 = hir.int_to_ptr v667 : ptr<byte, i32>;
                    v671 = hir.load v670 : i32;
                    scf.yield v671, v666;
                } else {
                ^block71:
                    v629 = arith.constant 8 : u32;
                    v628 = hir.bitcast v596 : u32;
                    v630 = arith.add v628, v629 : u32 #[overflow = checked];
                    v987 = arith.constant 4 : u32;
                    v632 = arith.mod v630, v987 : u32;
                    hir.assertz v632 #[code = 250];
                    v633 = hir.int_to_ptr v630 : ptr<byte, i32>;
                    v634 = hir.load v633 : i32;
                    v986 = arith.constant 0 : i32;
                    v636 = arith.neq v634, v986 : i1;
                    v964, v965 = scf.if v636 : i32, i32 {
                    ^block72:
                        v654 = hir.bitcast v596 : u32;
                        v985 = arith.constant 4 : u32;
                        v656 = arith.mod v654, v985 : u32;
                        hir.assertz v656 #[code = 250];
                        v657 = hir.int_to_ptr v654 : ptr<byte, i32>;
                        v658 = hir.load v657 : i32;
                        v659 = hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/__rustc::__rust_realloc(v658, v634, v594, v595) : i32
                        scf.yield v659, v595;
                    } else {
                    ^block73:
                        v984 = arith.constant 0 : i32;
                        v693 = arith.constant 8 : i32;
                        v638 = arith.add v603, v693 : i32 #[overflow = wrapping];
                        hir.exec @root_ns:root@1.0.0/onchain_two_felts_struct/alloc::alloc::Global::alloc_impl(v638, v594, v595, v984)
                        v641 = arith.constant 12 : u32;
                        v640 = hir.bitcast v603 : u32;
                        v642 = arith.add v640, v641 : u32 #[overflow = checked];
                        v983 = arith.constant 4 : u32;
                        v644 = arith.mod v642, v983 : u32;
                        hir.assertz v644 #[code = 250];
                        v645 = hir.int_to_ptr v642 : ptr<byte, i32>;
                        v646 = hir.load v645 : i32;
                        v982 = arith.constant 8 : u32;
                        v647 = hir.bitcast v603 : u32;
                        v649 = arith.add v647, v982 : u32 #[overflow = checked];
                        v981 = arith.constant 4 : u32;
                        v651 = arith.mod v649, v981 : u32;
                        hir.assertz v651 #[code = 250];
                        v652 = hir.int_to_ptr v649 : ptr<byte, i32>;
                        v653 = hir.load v652 : i32;
                        scf.yield v653, v646;
                    };
                    scf.yield v964, v965;
                };
                v980 = arith.constant 4 : u32;
                v678 = hir.bitcast v593 : u32;
                v680 = arith.add v678, v980 : u32 #[overflow = checked];
                v979 = arith.constant 4 : u32;
                v682 = arith.mod v680, v979 : u32;
                hir.assertz v682 #[code = 250];
                v978 = arith.constant 0 : i32;
                v676 = arith.neq v966, v978 : i1;
                v677 = cf.select v676, v966, v594 : i32;
                v683 = hir.int_to_ptr v680 : ptr<byte, i32>;
                hir.store v683, v677;
                v976 = arith.constant 0 : i32;
                v690 = arith.eq v966, v976 : i1;
                v691 = arith.zext v690 : u32;
                v692 = hir.bitcast v691 : i32;
                v977 = arith.constant 0 : i32;
                v687 = arith.neq v966, v977 : i1;
                v688 = cf.select v687, v967, v595 : i32;
                scf.yield v688, v692;
            } else {
            ^block68:
                v613 = arith.constant 1 : i32;
                v975 = arith.constant 0 : i32;
                scf.yield v975, v613;
            };
            v614 = arith.constant 4 : i32;
            v974 = arith.constant 8 : i32;
            v970 = cf.select v612, v974, v614 : i32;
            v696 = arith.add v593, v970 : i32 #[overflow = wrapping];
            v698 = hir.bitcast v696 : u32;
            v973 = arith.constant 4 : u32;
            v700 = arith.mod v698, v973 : u32;
            hir.assertz v700 #[code = 250];
            v701 = hir.int_to_ptr v698 : ptr<byte, i32>;
            hir.store v701, v968;
            v703 = hir.bitcast v593 : u32;
            v972 = arith.constant 4 : u32;
            v705 = arith.mod v703, v972 : u32;
            hir.assertz v705 #[code = 250];
            v706 = hir.int_to_ptr v703 : ptr<byte, i32>;
            hir.store v706, v969;
            v971 = arith.constant 16 : i32;
            v710 = arith.add v603, v971 : i32 #[overflow = wrapping];
            v711 = builtin.global_symbol @root_ns:root@1.0.0/onchain_two_felts_struct/__stack_pointer : ptr<byte, u8>
            v712 = hir.bitcast v711 : ptr<byte, i32>;
            hir.store v712, v710;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v713: i32, v714: i32, v715: i32) {
        ^block74(v713: i32, v714: i32, v715: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v716: i32, v717: i32) -> i32 {
        ^block76(v716: i32, v717: i32):
            v724 = arith.constant 0 : i32;
            v720 = hir.bitcast v717 : u32;
            v719 = hir.bitcast v716 : u32;
            v721 = arith.gt v719, v720 : i1;
            v722 = arith.zext v721 : u32;
            v723 = hir.bitcast v722 : i32;
            v725 = arith.neq v723, v724 : i1;
            v726 = cf.select v725, v716, v717 : i32;
            builtin.ret v726;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.segment readonly @1048576 = 0x00000000000000000000000a0010000000003e64657463616465723c;
    };
};