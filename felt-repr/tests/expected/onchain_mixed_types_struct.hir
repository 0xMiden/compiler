builtin.component root_ns:root@1.0.0 {
    builtin.module public @onchain_mixed_types_struct {
        private builtin.function @alloc::vec::Vec<T,A>::push(v0: i32, v1: felt) {
        ^block4(v0: i32, v1: felt):
            v4 = arith.constant 8 : u32;
            v3 = hir.bitcast v0 : u32;
            v5 = arith.add v3, v4 : u32 #[overflow = checked];
            v6 = arith.constant 4 : u32;
            v7 = arith.mod v5, v6 : u32;
            hir.assertz v7 #[code = 250];
            v8 = hir.int_to_ptr v5 : ptr<byte, i32>;
            v9 = hir.load v8 : i32;
            v10 = hir.bitcast v0 : u32;
            v987 = arith.constant 4 : u32;
            v12 = arith.mod v10, v987 : u32;
            hir.assertz v12 #[code = 250];
            v13 = hir.int_to_ptr v10 : ptr<byte, i32>;
            v14 = hir.load v13 : i32;
            v2 = arith.constant 0 : i32;
            v15 = arith.neq v9, v14 : i1;
            v16 = arith.zext v15 : u32;
            v17 = hir.bitcast v16 : i32;
            v19 = arith.neq v17, v2 : i1;
            scf.if v19{
            ^block104:
                scf.yield ;
            } else {
            ^block7:
                hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/alloc::raw_vec::RawVec<T,A>::grow_one(v0)
                scf.yield ;
            };
            v986 = arith.constant 4 : u32;
            v21 = hir.bitcast v0 : u32;
            v23 = arith.add v21, v986 : u32 #[overflow = checked];
            v985 = arith.constant 4 : u32;
            v25 = arith.mod v23, v985 : u32;
            hir.assertz v25 #[code = 250];
            v26 = hir.int_to_ptr v23 : ptr<byte, i32>;
            v27 = hir.load v26 : i32;
            v977 = arith.constant 2 : u32;
            v31 = arith.shl v9, v977 : i32;
            v32 = arith.add v27, v31 : i32 #[overflow = wrapping];
            v34 = hir.bitcast v32 : u32;
            v984 = arith.constant 4 : u32;
            v36 = arith.mod v34, v984 : u32;
            hir.assertz v36 #[code = 250];
            v37 = hir.int_to_ptr v34 : ptr<byte, felt>;
            hir.store v37, v1;
            v983 = arith.constant 8 : u32;
            v40 = hir.bitcast v0 : u32;
            v42 = arith.add v40, v983 : u32 #[overflow = checked];
            v982 = arith.constant 4 : u32;
            v44 = arith.mod v42, v982 : u32;
            hir.assertz v44 #[code = 250];
            v38 = arith.constant 1 : i32;
            v39 = arith.add v9, v38 : i32 #[overflow = wrapping];
            v45 = hir.int_to_ptr v42 : ptr<byte, i32>;
            hir.store v45, v39;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVec<T,A>::grow_one(v46: i32) {
        ^block8(v46: i32):
            v48 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_struct/__stack_pointer : ptr<byte, u8>
            v49 = hir.bitcast v48 : ptr<byte, i32>;
            v50 = hir.load v49 : i32;
            v51 = arith.constant 16 : i32;
            v52 = arith.sub v50, v51 : i32 #[overflow = wrapping];
            v53 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_struct/__stack_pointer : ptr<byte, u8>
            v54 = hir.bitcast v53 : ptr<byte, i32>;
            hir.store v54, v52;
            v57 = hir.bitcast v46 : u32;
            v58 = arith.constant 4 : u32;
            v59 = arith.mod v57, v58 : u32;
            hir.assertz v59 #[code = 250];
            v60 = hir.int_to_ptr v57 : ptr<byte, i32>;
            v61 = hir.load v60 : i32;
            v63 = arith.constant 4 : i32;
            v62 = arith.constant 1 : i32;
            v55 = arith.constant 8 : i32;
            v56 = arith.add v52, v55 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/alloc::raw_vec::RawVecInner<A>::grow_amortized(v56, v46, v61, v62, v63, v63)
            v66 = arith.constant 8 : u32;
            v65 = hir.bitcast v52 : u32;
            v67 = arith.add v65, v66 : u32 #[overflow = checked];
            v991 = arith.constant 4 : u32;
            v69 = arith.mod v67, v991 : u32;
            hir.assertz v69 #[code = 250];
            v70 = hir.int_to_ptr v67 : ptr<byte, i32>;
            v71 = hir.load v70 : i32;
            v47 = arith.constant 0 : i32;
            v72 = arith.constant -2147483647 : i32;
            v73 = arith.eq v71, v72 : i1;
            v74 = arith.zext v73 : u32;
            v75 = hir.bitcast v74 : i32;
            v77 = arith.neq v75, v47 : i1;
            cf.cond_br v77 ^block10, ^block11;
        ^block10:
            v990 = arith.constant 16 : i32;
            v87 = arith.add v52, v990 : i32 #[overflow = wrapping];
            v88 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_struct/__stack_pointer : ptr<byte, u8>
            v89 = hir.bitcast v88 : ptr<byte, i32>;
            hir.store v89, v87;
            builtin.ret ;
        ^block11:
            v79 = arith.constant 12 : u32;
            v78 = hir.bitcast v52 : u32;
            v80 = arith.add v78, v79 : u32 #[overflow = checked];
            v989 = arith.constant 4 : u32;
            v82 = arith.mod v80, v989 : u32;
            hir.assertz v82 #[code = 250];
            v83 = hir.int_to_ptr v80 : ptr<byte, i32>;
            v84 = hir.load v83 : i32;
            v85 = arith.constant 1048588 : i32;
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/alloc::raw_vec::handle_error(v71, v84, v85)
            ub.unreachable ;
        };

        public builtin.function @entrypoint(v90: i32, v91: i32) {
        ^block12(v90: i32, v91: i32):
            v96 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_struct/__stack_pointer : ptr<byte, u8>
            v97 = hir.bitcast v96 : ptr<byte, i32>;
            v98 = hir.load v97 : i32;
            v99 = arith.constant 32 : i32;
            v100 = arith.sub v98, v99 : i32 #[overflow = wrapping];
            v101 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_struct/__stack_pointer : ptr<byte, u8>
            v102 = hir.bitcast v101 : ptr<byte, i32>;
            hir.store v102, v100;
            v104 = arith.constant 4 : u32;
            v103 = hir.bitcast v91 : u32;
            v105 = arith.add v103, v104 : u32 #[overflow = checked];
            v1025 = arith.constant 4 : u32;
            v107 = arith.mod v105, v1025 : u32;
            hir.assertz v107 #[code = 250];
            v108 = hir.int_to_ptr v105 : ptr<byte, felt>;
            v109 = hir.load v108 : felt;
            v110 = hir.bitcast v91 : u32;
            v1024 = arith.constant 4 : u32;
            v112 = arith.mod v110, v1024 : u32;
            hir.assertz v112 #[code = 250];
            v113 = hir.int_to_ptr v110 : ptr<byte, felt>;
            v114 = hir.load v113 : felt;
            v116 = arith.constant 8 : u32;
            v115 = hir.bitcast v91 : u32;
            v117 = arith.add v115, v116 : u32 #[overflow = checked];
            v1023 = arith.constant 4 : u32;
            v119 = arith.mod v117, v1023 : u32;
            hir.assertz v119 #[code = 250];
            v120 = hir.int_to_ptr v117 : ptr<byte, felt>;
            v121 = hir.load v120 : felt;
            v122 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/intrinsics::felt::as_u64(v121) : i64
            v124 = arith.constant 12 : u32;
            v123 = hir.bitcast v91 : u32;
            v125 = arith.add v123, v124 : u32 #[overflow = checked];
            v1022 = arith.constant 4 : u32;
            v127 = arith.mod v125, v1022 : u32;
            hir.assertz v127 #[code = 250];
            v128 = hir.int_to_ptr v125 : ptr<byte, felt>;
            v129 = hir.load v128 : felt;
            v130 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/intrinsics::felt::as_u64(v129) : i64
            v132 = arith.constant 16 : u32;
            v131 = hir.bitcast v91 : u32;
            v133 = arith.add v131, v132 : u32 #[overflow = checked];
            v1021 = arith.constant 4 : u32;
            v135 = arith.mod v133, v1021 : u32;
            hir.assertz v135 #[code = 250];
            v136 = hir.int_to_ptr v133 : ptr<byte, felt>;
            v137 = hir.load v136 : felt;
            v138 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/intrinsics::felt::as_u64(v137) : i64
            v140 = arith.constant 20 : u32;
            v139 = hir.bitcast v91 : u32;
            v141 = arith.add v139, v140 : u32 #[overflow = checked];
            v1020 = arith.constant 4 : u32;
            v143 = arith.mod v141, v1020 : u32;
            hir.assertz v143 #[code = 250];
            v144 = hir.int_to_ptr v141 : ptr<byte, felt>;
            v145 = hir.load v144 : felt;
            v146 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/intrinsics::felt::as_u64(v145) : i64
            v148 = arith.constant 255 : i32;
            v147 = arith.trunc v146 : i32;
            v149 = arith.band v147, v148 : i32;
            v150 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/<miden_stdlib_sys::intrinsics::felt::Felt as core::convert::From<u32>>::from(v149) : felt
            v151 = arith.constant 66 : i32;
            v152 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/intrinsics::felt::from_u32(v151) : felt
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/intrinsics::felt::assert_eq(v150, v152)
            v157 = arith.constant 4 : i32;
            v92 = arith.constant 0 : i32;
            v155 = arith.constant 256 : i32;
            v153 = arith.constant 20 : i32;
            v154 = arith.add v100, v153 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/alloc::raw_vec::RawVecInner<A>::try_allocate_in(v154, v155, v92, v157, v157)
            v160 = arith.constant 24 : u32;
            v159 = hir.bitcast v100 : u32;
            v161 = arith.add v159, v160 : u32 #[overflow = checked];
            v1019 = arith.constant 4 : u32;
            v163 = arith.mod v161, v1019 : u32;
            hir.assertz v163 #[code = 250];
            v164 = hir.int_to_ptr v161 : ptr<byte, i32>;
            v165 = hir.load v164 : i32;
            v1018 = arith.constant 20 : u32;
            v166 = hir.bitcast v100 : u32;
            v168 = arith.add v166, v1018 : u32 #[overflow = checked];
            v1017 = arith.constant 4 : u32;
            v170 = arith.mod v168, v1017 : u32;
            hir.assertz v170 #[code = 250];
            v171 = hir.int_to_ptr v168 : ptr<byte, i32>;
            v172 = hir.load v171 : i32;
            v1016 = arith.constant 0 : i32;
            v173 = arith.constant 1 : i32;
            v174 = arith.neq v172, v173 : i1;
            v175 = arith.zext v174 : u32;
            v176 = hir.bitcast v175 : i32;
            v178 = arith.neq v176, v1016 : i1;
            cf.cond_br v178 ^block14, ^block15;
        ^block14:
            v1015 = arith.constant 8 : i32;
            v187 = arith.constant 8 : i32;
            v188 = arith.add v100, v187 : i32 #[overflow = wrapping];
            v190 = arith.add v188, v1015 : i32 #[overflow = wrapping];
            v192 = hir.bitcast v190 : u32;
            v1014 = arith.constant 4 : u32;
            v194 = arith.mod v192, v1014 : u32;
            hir.assertz v194 #[code = 250];
            v1013 = arith.constant 0 : i32;
            v195 = hir.int_to_ptr v192 : ptr<byte, i32>;
            hir.store v195, v1013;
            v197 = arith.constant 28 : u32;
            v196 = hir.bitcast v100 : u32;
            v198 = arith.add v196, v197 : u32 #[overflow = checked];
            v1012 = arith.constant 4 : u32;
            v200 = arith.mod v198, v1012 : u32;
            hir.assertz v200 #[code = 250];
            v201 = hir.int_to_ptr v198 : ptr<byte, i32>;
            v202 = hir.load v201 : i32;
            v1011 = arith.constant 12 : u32;
            v203 = hir.bitcast v100 : u32;
            v205 = arith.add v203, v1011 : u32 #[overflow = checked];
            v1010 = arith.constant 4 : u32;
            v207 = arith.mod v205, v1010 : u32;
            hir.assertz v207 #[code = 250];
            v208 = hir.int_to_ptr v205 : ptr<byte, i32>;
            hir.store v208, v202;
            v1009 = arith.constant 8 : u32;
            v209 = hir.bitcast v100 : u32;
            v211 = arith.add v209, v1009 : u32 #[overflow = checked];
            v1008 = arith.constant 4 : u32;
            v213 = arith.mod v211, v1008 : u32;
            hir.assertz v213 #[code = 250];
            v214 = hir.int_to_ptr v211 : ptr<byte, i32>;
            hir.store v214, v165;
            v1007 = arith.constant 8 : i32;
            v216 = arith.add v100, v1007 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/alloc::vec::Vec<T,A>::push(v216, v114)
            v1006 = arith.constant 8 : i32;
            v218 = arith.add v100, v1006 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/alloc::vec::Vec<T,A>::push(v218, v109)
            v221 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/intrinsics::felt::from_u64_unchecked(v122) : felt
            v1005 = arith.constant 8 : i32;
            v220 = arith.add v100, v1005 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/alloc::vec::Vec<T,A>::push(v220, v221)
            v224 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/intrinsics::felt::from_u64_unchecked(v130) : felt
            v1004 = arith.constant 8 : i32;
            v223 = arith.add v100, v1004 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/alloc::vec::Vec<T,A>::push(v223, v224)
            v227 = arith.trunc v138 : i32;
            v228 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/<miden_stdlib_sys::intrinsics::felt::Felt as core::convert::From<u32>>::from(v227) : felt
            v1003 = arith.constant 8 : i32;
            v226 = arith.add v100, v1003 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/alloc::vec::Vec<T,A>::push(v226, v228)
            v231 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/<miden_stdlib_sys::intrinsics::felt::Felt as core::convert::From<u32>>::from(v149) : felt
            v1002 = arith.constant 8 : i32;
            v230 = arith.add v100, v1002 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/alloc::vec::Vec<T,A>::push(v230, v231)
            v234 = hir.bitcast v190 : u32;
            v1001 = arith.constant 4 : u32;
            v236 = arith.mod v234, v1001 : u32;
            hir.assertz v236 #[code = 250];
            v237 = hir.int_to_ptr v234 : ptr<byte, i32>;
            v238 = hir.load v237 : i32;
            v1000 = arith.constant 8 : i32;
            v233 = arith.add v90, v1000 : i32 #[overflow = wrapping];
            v239 = hir.bitcast v233 : u32;
            v999 = arith.constant 4 : u32;
            v241 = arith.mod v239, v999 : u32;
            hir.assertz v241 #[code = 250];
            v242 = hir.int_to_ptr v239 : ptr<byte, i32>;
            hir.store v242, v238;
            v998 = arith.constant 8 : u32;
            v243 = hir.bitcast v100 : u32;
            v245 = arith.add v243, v998 : u32 #[overflow = checked];
            v997 = arith.constant 4 : u32;
            v247 = arith.mod v245, v997 : u32;
            hir.assertz v247 #[code = 250];
            v248 = hir.int_to_ptr v245 : ptr<byte, i64>;
            v249 = hir.load v248 : i64;
            v250 = hir.bitcast v90 : u32;
            v996 = arith.constant 4 : u32;
            v252 = arith.mod v250, v996 : u32;
            hir.assertz v252 #[code = 250];
            v253 = hir.int_to_ptr v250 : ptr<byte, i64>;
            hir.store v253, v249;
            v995 = arith.constant 32 : i32;
            v255 = arith.add v100, v995 : i32 #[overflow = wrapping];
            v256 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_struct/__stack_pointer : ptr<byte, u8>
            v257 = hir.bitcast v256 : ptr<byte, i32>;
            hir.store v257, v255;
            builtin.ret ;
        ^block15:
            v994 = arith.constant 28 : u32;
            v179 = hir.bitcast v100 : u32;
            v181 = arith.add v179, v994 : u32 #[overflow = checked];
            v993 = arith.constant 4 : u32;
            v183 = arith.mod v181, v993 : u32;
            hir.assertz v183 #[code = 250];
            v184 = hir.int_to_ptr v181 : ptr<byte, i32>;
            v185 = hir.load v184 : i32;
            v186 = arith.constant 1048588 : i32;
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/alloc::raw_vec::handle_error(v165, v185, v186)
            ub.unreachable ;
        };

        private builtin.function @__rustc::__rust_alloc(v258: i32, v259: i32) -> i32 {
        ^block16(v258: i32, v259: i32):
            v261 = arith.constant 1048604 : i32;
            v262 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v261, v259, v258) : i32
            builtin.ret v262;
        };

        private builtin.function @__rustc::__rust_realloc(v263: i32, v264: i32, v265: i32, v266: i32) -> i32 {
        ^block18(v263: i32, v264: i32, v265: i32, v266: i32):
            v268 = arith.constant 1048604 : i32;
            v269 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v268, v265, v266) : i32
            v1034 = arith.constant 0 : i32;
            v270 = arith.constant 0 : i32;
            v271 = arith.eq v269, v270 : i1;
            v272 = arith.zext v271 : u32;
            v273 = hir.bitcast v272 : i32;
            v275 = arith.neq v273, v1034 : i1;
            scf.if v275{
            ^block20:
                scf.yield ;
            } else {
            ^block21:
                v1033 = arith.constant 0 : i32;
                v277 = hir.bitcast v264 : u32;
                v276 = hir.bitcast v266 : u32;
                v278 = arith.lt v276, v277 : i1;
                v279 = arith.zext v278 : u32;
                v280 = hir.bitcast v279 : i32;
                v282 = arith.neq v280, v1033 : i1;
                v283 = cf.select v282, v266, v264 : i32;
                v1031 = arith.constant 0 : i32;
                v1032 = arith.constant 0 : i32;
                v285 = arith.eq v283, v1032 : i1;
                v286 = arith.zext v285 : u32;
                v287 = hir.bitcast v286 : i32;
                v289 = arith.neq v287, v1031 : i1;
                scf.if v289{
                ^block110:
                    scf.yield ;
                } else {
                ^block22:
                    v290 = hir.bitcast v283 : u32;
                    v291 = hir.bitcast v269 : u32;
                    v292 = hir.int_to_ptr v291 : ptr<byte, u8>;
                    v293 = hir.bitcast v263 : u32;
                    v294 = hir.int_to_ptr v293 : ptr<byte, u8>;
                    hir.mem_cpy v294, v292, v290;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v269;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v296: i32, v297: i32) -> i32 {
        ^block23(v296: i32, v297: i32):
            v299 = arith.constant 1048604 : i32;
            v300 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v299, v297, v296) : i32
            v1043 = arith.constant 0 : i32;
            v301 = arith.constant 0 : i32;
            v302 = arith.eq v300, v301 : i1;
            v303 = arith.zext v302 : u32;
            v304 = hir.bitcast v303 : i32;
            v306 = arith.neq v304, v1043 : i1;
            scf.if v306{
            ^block25:
                scf.yield ;
            } else {
            ^block26:
                v1041 = arith.constant 0 : i32;
                v1042 = arith.constant 0 : i32;
                v308 = arith.eq v296, v1042 : i1;
                v309 = arith.zext v308 : u32;
                v310 = hir.bitcast v309 : i32;
                v312 = arith.neq v310, v1041 : i1;
                scf.if v312{
                ^block113:
                    scf.yield ;
                } else {
                ^block27:
                    v1035 = arith.constant 0 : u8;
                    v315 = hir.bitcast v296 : u32;
                    v316 = hir.bitcast v300 : u32;
                    v317 = hir.int_to_ptr v316 : ptr<byte, u8>;
                    hir.mem_set v317, v315, v1035;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v300;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block28:
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v319: i32, v320: i32, v321: i32) -> i32 {
        ^block30(v319: i32, v320: i32, v321: i32):
            v324 = arith.constant 16 : i32;
            v323 = arith.constant 0 : i32;
            v1045 = arith.constant 16 : u32;
            v326 = hir.bitcast v320 : u32;
            v328 = arith.gt v326, v1045 : i1;
            v329 = arith.zext v328 : u32;
            v330 = hir.bitcast v329 : i32;
            v332 = arith.neq v330, v323 : i1;
            v333 = cf.select v332, v320, v324 : i32;
            v1085 = arith.constant 0 : i32;
            v334 = arith.constant -1 : i32;
            v335 = arith.add v333, v334 : i32 #[overflow = wrapping];
            v336 = arith.band v333, v335 : i32;
            v338 = arith.neq v336, v1085 : i1;
            v1054, v1055 = scf.if v338 : i32, u32 {
            ^block118:
                v1046 = arith.constant 0 : u32;
                v1050 = ub.poison i32 : i32;
                scf.yield v1050, v1046;
            } else {
            ^block33:
                v340 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/core::ptr::alignment::Alignment::max(v320, v333) : i32
                v1084 = arith.constant 0 : i32;
                v339 = arith.constant -2147483648 : i32;
                v341 = arith.sub v339, v340 : i32 #[overflow = wrapping];
                v343 = hir.bitcast v341 : u32;
                v342 = hir.bitcast v321 : u32;
                v344 = arith.gt v342, v343 : i1;
                v345 = arith.zext v344 : u32;
                v346 = hir.bitcast v345 : i32;
                v348 = arith.neq v346, v1084 : i1;
                v1069 = scf.if v348 : i32 {
                ^block117:
                    v1083 = ub.poison i32 : i32;
                    scf.yield v1083;
                } else {
                ^block34:
                    v1081 = arith.constant 0 : i32;
                    v354 = arith.sub v1081, v340 : i32 #[overflow = wrapping];
                    v1082 = arith.constant -1 : i32;
                    v350 = arith.add v321, v340 : i32 #[overflow = wrapping];
                    v352 = arith.add v350, v1082 : i32 #[overflow = wrapping];
                    v355 = arith.band v352, v354 : i32;
                    v356 = hir.bitcast v319 : u32;
                    v357 = arith.constant 4 : u32;
                    v358 = arith.mod v356, v357 : u32;
                    hir.assertz v358 #[code = 250];
                    v359 = hir.int_to_ptr v356 : ptr<byte, i32>;
                    v360 = hir.load v359 : i32;
                    v1080 = arith.constant 0 : i32;
                    v362 = arith.neq v360, v1080 : i1;
                    scf.if v362{
                    ^block116:
                        scf.yield ;
                    } else {
                    ^block36:
                        v363 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/intrinsics::mem::heap_base() : i32
                        v364 = hir.mem_size  : u32;
                        v370 = hir.bitcast v319 : u32;
                        v1079 = arith.constant 4 : u32;
                        v372 = arith.mod v370, v1079 : u32;
                        hir.assertz v372 #[code = 250];
                        v1078 = arith.constant 16 : u32;
                        v365 = hir.bitcast v364 : i32;
                        v368 = arith.shl v365, v1078 : i32;
                        v369 = arith.add v363, v368 : i32 #[overflow = wrapping];
                        v373 = hir.int_to_ptr v370 : ptr<byte, i32>;
                        hir.store v373, v369;
                        scf.yield ;
                    };
                    v376 = hir.bitcast v319 : u32;
                    v1077 = arith.constant 4 : u32;
                    v378 = arith.mod v376, v1077 : u32;
                    hir.assertz v378 #[code = 250];
                    v379 = hir.int_to_ptr v376 : ptr<byte, i32>;
                    v380 = hir.load v379 : i32;
                    v1075 = arith.constant 0 : i32;
                    v1076 = arith.constant -1 : i32;
                    v382 = arith.bxor v380, v1076 : i32;
                    v384 = hir.bitcast v382 : u32;
                    v383 = hir.bitcast v355 : u32;
                    v385 = arith.gt v383, v384 : i1;
                    v386 = arith.zext v385 : u32;
                    v387 = hir.bitcast v386 : i32;
                    v389 = arith.neq v387, v1075 : i1;
                    v1068 = scf.if v389 : i32 {
                    ^block37:
                        v1074 = arith.constant 0 : i32;
                        scf.yield v1074;
                    } else {
                    ^block38:
                        v391 = hir.bitcast v319 : u32;
                        v1073 = arith.constant 4 : u32;
                        v393 = arith.mod v391, v1073 : u32;
                        hir.assertz v393 #[code = 250];
                        v390 = arith.add v380, v355 : i32 #[overflow = wrapping];
                        v394 = hir.int_to_ptr v391 : ptr<byte, i32>;
                        hir.store v394, v390;
                        v396 = arith.add v380, v340 : i32 #[overflow = wrapping];
                        scf.yield v396;
                    };
                    scf.yield v1068;
                };
                v1051 = arith.constant 1 : u32;
                v1072 = arith.constant 0 : u32;
                v1070 = cf.select v348, v1072, v1051 : u32;
                scf.yield v1069, v1070;
            };
            v1071 = arith.constant 0 : u32;
            v1067 = arith.eq v1055, v1071 : i1;
            cf.cond_br v1067 ^block32, ^block120(v1054);
        ^block32:
            ub.unreachable ;
        ^block120(v1047: i32):
            builtin.ret v1047;
        };

        private builtin.function @intrinsics::mem::heap_base() -> i32 {
        ^block39:
            v399 = hir.exec @intrinsics/mem/heap_base() : i32
            builtin.ret v399;
        };

        private builtin.function @<miden_stdlib_sys::intrinsics::felt::Felt as core::convert::From<u32>>::from(v401: i32) -> felt {
        ^block43(v401: i32):
            v403 = hir.bitcast v401 : felt;
            builtin.ret v403;
        };

        private builtin.function @intrinsics::felt::from_u64_unchecked(v404: i64) -> felt {
        ^block45(v404: i64):
            v405 = hir.cast v404 : felt;
            builtin.ret v405;
        };

        private builtin.function @intrinsics::felt::from_u32(v407: i32) -> felt {
        ^block47(v407: i32):
            v408 = hir.bitcast v407 : felt;
            builtin.ret v408;
        };

        private builtin.function @intrinsics::felt::as_u64(v410: felt) -> i64 {
        ^block49(v410: felt):
            v411 = hir.cast v410 : i64;
            builtin.ret v411;
        };

        private builtin.function @intrinsics::felt::assert_eq(v413: felt, v414: felt) {
        ^block51(v413: felt, v414: felt):
            hir.assert_eq v413, v414;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::grow_amortized(v415: i32, v416: i32, v417: i32, v418: i32, v419: i32, v420: i32) {
        ^block53(v415: i32, v416: i32, v417: i32, v418: i32, v419: i32, v420: i32):
            v423 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_struct/__stack_pointer : ptr<byte, u8>
            v424 = hir.bitcast v423 : ptr<byte, i32>;
            v425 = hir.load v424 : i32;
            v426 = arith.constant 32 : i32;
            v427 = arith.sub v425, v426 : i32 #[overflow = wrapping];
            v428 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_struct/__stack_pointer : ptr<byte, u8>
            v429 = hir.bitcast v428 : ptr<byte, i32>;
            hir.store v429, v427;
            v1162 = arith.constant 0 : i32;
            v421 = arith.constant 0 : i32;
            v432 = arith.eq v420, v421 : i1;
            v433 = arith.zext v432 : u32;
            v434 = hir.bitcast v433 : i32;
            v436 = arith.neq v434, v1162 : i1;
            v1133, v1134 = scf.if v436 : i32, i32 {
            ^block56:
                v1161 = arith.constant 0 : i32;
                scf.yield v1161, v1161;
            } else {
            ^block57:
                v437 = arith.add v417, v418 : i32 #[overflow = wrapping];
                v1160 = arith.constant 0 : i32;
                v439 = hir.bitcast v417 : u32;
                v438 = hir.bitcast v437 : u32;
                v440 = arith.lt v438, v439 : i1;
                v441 = arith.zext v440 : u32;
                v442 = hir.bitcast v441 : i32;
                v444 = arith.neq v442, v1160 : i1;
                v1131, v1132 = scf.if v444 : i32, i32 {
                ^block126:
                    v1159 = arith.constant 0 : i32;
                    scf.yield v1159, v1159;
                } else {
                ^block58:
                    v455 = hir.bitcast v416 : u32;
                    v569 = arith.constant 4 : u32;
                    v457 = arith.mod v455, v569 : u32;
                    hir.assertz v457 #[code = 250];
                    v458 = hir.int_to_ptr v455 : ptr<byte, i32>;
                    v459 = hir.load v458 : i32;
                    v1087 = arith.constant 1 : u32;
                    v462 = arith.shl v459, v1087 : i32;
                    v1158 = arith.constant 0 : i32;
                    v464 = hir.bitcast v462 : u32;
                    v463 = hir.bitcast v437 : u32;
                    v465 = arith.gt v463, v464 : i1;
                    v466 = arith.zext v465 : u32;
                    v467 = hir.bitcast v466 : i32;
                    v469 = arith.neq v467, v1158 : i1;
                    v470 = cf.select v469, v437, v462 : i32;
                    v1155 = arith.constant 1 : i32;
                    v472 = arith.constant 4 : i32;
                    v1156 = arith.constant 0 : i32;
                    v1086 = arith.constant 1025 : u32;
                    v475 = hir.bitcast v420 : u32;
                    v477 = arith.lt v475, v1086 : i1;
                    v478 = arith.zext v477 : u32;
                    v479 = hir.bitcast v478 : i32;
                    v481 = arith.neq v479, v1156 : i1;
                    v482 = cf.select v481, v472, v1155 : i32;
                    v471 = arith.constant 8 : i32;
                    v1157 = arith.constant 0 : i32;
                    v460 = arith.constant 1 : i32;
                    v484 = arith.eq v420, v460 : i1;
                    v485 = arith.zext v484 : u32;
                    v486 = hir.bitcast v485 : i32;
                    v488 = arith.neq v486, v1157 : i1;
                    v489 = cf.select v488, v471, v482 : i32;
                    v1154 = arith.constant 0 : i32;
                    v491 = hir.bitcast v489 : u32;
                    v490 = hir.bitcast v470 : u32;
                    v492 = arith.gt v490, v491 : i1;
                    v493 = arith.zext v492 : u32;
                    v494 = hir.bitcast v493 : i32;
                    v496 = arith.neq v494, v1154 : i1;
                    v497 = cf.select v496, v470, v489 : i32;
                    v498 = hir.bitcast v497 : u32;
                    v499 = arith.zext v498 : u64;
                    v500 = hir.bitcast v499 : i64;
                    v1153 = arith.constant 0 : i32;
                    v450 = arith.sub v1153, v419 : i32 #[overflow = wrapping];
                    v447 = arith.constant -1 : i32;
                    v446 = arith.add v419, v420 : i32 #[overflow = wrapping];
                    v448 = arith.add v446, v447 : i32 #[overflow = wrapping];
                    v451 = arith.band v448, v450 : i32;
                    v452 = hir.bitcast v451 : u32;
                    v453 = arith.zext v452 : u64;
                    v454 = hir.bitcast v453 : i64;
                    v501 = arith.mul v454, v500 : i64 #[overflow = wrapping];
                    v1152 = arith.constant 0 : i32;
                    v502 = arith.constant 32 : i64;
                    v504 = hir.cast v502 : u32;
                    v503 = hir.bitcast v501 : u64;
                    v505 = arith.shr v503, v504 : u64;
                    v506 = hir.bitcast v505 : i64;
                    v507 = arith.trunc v506 : i32;
                    v509 = arith.neq v507, v1152 : i1;
                    v1129, v1130 = scf.if v509 : i32, i32 {
                    ^block125:
                        v1151 = arith.constant 0 : i32;
                        scf.yield v470, v1151;
                    } else {
                    ^block59:
                        v510 = arith.trunc v501 : i32;
                        v1150 = arith.constant 0 : i32;
                        v511 = arith.constant -2147483648 : i32;
                        v512 = arith.sub v511, v419 : i32 #[overflow = wrapping];
                        v514 = hir.bitcast v512 : u32;
                        v513 = hir.bitcast v510 : u32;
                        v515 = arith.gt v513, v514 : i1;
                        v516 = arith.zext v515 : u32;
                        v517 = hir.bitcast v516 : i32;
                        v519 = arith.neq v517, v1150 : i1;
                        v1127, v1128 = scf.if v519 : i32, i32 {
                        ^block124:
                            v1149 = arith.constant 0 : i32;
                            scf.yield v470, v1149;
                        } else {
                        ^block60:
                            v520 = arith.constant 20 : i32;
                            v521 = arith.add v427, v520 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/alloc::raw_vec::RawVecInner<A>::current_memory(v521, v416, v419, v420)
                            v1147 = arith.constant 20 : i32;
                            v525 = arith.add v427, v1147 : i32 #[overflow = wrapping];
                            v1148 = arith.constant 8 : i32;
                            v523 = arith.add v427, v1148 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/alloc::raw_vec::finish_grow(v523, v419, v510, v525, v415)
                            v527 = arith.constant 12 : u32;
                            v526 = hir.bitcast v427 : u32;
                            v528 = arith.add v526, v527 : u32 #[overflow = checked];
                            v1146 = arith.constant 4 : u32;
                            v530 = arith.mod v528, v1146 : u32;
                            hir.assertz v530 #[code = 250];
                            v531 = hir.int_to_ptr v528 : ptr<byte, i32>;
                            v532 = hir.load v531 : i32;
                            v534 = arith.constant 8 : u32;
                            v533 = hir.bitcast v427 : u32;
                            v535 = arith.add v533, v534 : u32 #[overflow = checked];
                            v1145 = arith.constant 4 : u32;
                            v537 = arith.mod v535, v1145 : u32;
                            hir.assertz v537 #[code = 250];
                            v538 = hir.int_to_ptr v535 : ptr<byte, i32>;
                            v539 = hir.load v538 : i32;
                            v1143 = arith.constant 0 : i32;
                            v1144 = arith.constant 0 : i32;
                            v541 = arith.eq v539, v1144 : i1;
                            v542 = arith.zext v541 : u32;
                            v543 = hir.bitcast v542 : i32;
                            v545 = arith.neq v543, v1143 : i1;
                            v1125 = scf.if v545 : i32 {
                            ^block61:
                                v553 = hir.bitcast v416 : u32;
                                v1142 = arith.constant 4 : u32;
                                v555 = arith.mod v553, v1142 : u32;
                                hir.assertz v555 #[code = 250];
                                v556 = hir.int_to_ptr v553 : ptr<byte, i32>;
                                hir.store v556, v497;
                                v1141 = arith.constant 4 : u32;
                                v557 = hir.bitcast v416 : u32;
                                v559 = arith.add v557, v1141 : u32 #[overflow = checked];
                                v1140 = arith.constant 4 : u32;
                                v561 = arith.mod v559, v1140 : u32;
                                hir.assertz v561 #[code = 250];
                                v562 = hir.int_to_ptr v559 : ptr<byte, i32>;
                                hir.store v562, v532;
                                scf.yield v470;
                            } else {
                            ^block62:
                                v547 = arith.constant 16 : u32;
                                v546 = hir.bitcast v427 : u32;
                                v548 = arith.add v546, v547 : u32 #[overflow = checked];
                                v1139 = arith.constant 4 : u32;
                                v550 = arith.mod v548, v1139 : u32;
                                hir.assertz v550 #[code = 250];
                                v551 = hir.int_to_ptr v548 : ptr<byte, i32>;
                                v552 = hir.load v551 : i32;
                                scf.yield v552;
                            };
                            v563 = arith.constant -2147483647 : i32;
                            v1126 = cf.select v545, v563, v532 : i32;
                            scf.yield v1125, v1126;
                        };
                        scf.yield v1127, v1128;
                    };
                    scf.yield v1129, v1130;
                };
                scf.yield v1131, v1132;
            };
            v1138 = arith.constant 4 : u32;
            v568 = hir.bitcast v415 : u32;
            v570 = arith.add v568, v1138 : u32 #[overflow = checked];
            v1137 = arith.constant 4 : u32;
            v572 = arith.mod v570, v1137 : u32;
            hir.assertz v572 #[code = 250];
            v573 = hir.int_to_ptr v570 : ptr<byte, i32>;
            hir.store v573, v1133;
            v576 = hir.bitcast v415 : u32;
            v1136 = arith.constant 4 : u32;
            v578 = arith.mod v576, v1136 : u32;
            hir.assertz v578 #[code = 250];
            v579 = hir.int_to_ptr v576 : ptr<byte, i32>;
            hir.store v579, v1134;
            v1135 = arith.constant 32 : i32;
            v583 = arith.add v427, v1135 : i32 #[overflow = wrapping];
            v584 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_struct/__stack_pointer : ptr<byte, u8>
            v585 = hir.bitcast v584 : ptr<byte, i32>;
            hir.store v585, v583;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::try_allocate_in(v586: i32, v587: i32, v588: i32, v589: i32, v590: i32) {
        ^block63(v586: i32, v587: i32, v588: i32, v589: i32, v590: i32):
            v593 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_struct/__stack_pointer : ptr<byte, u8>
            v594 = hir.bitcast v593 : ptr<byte, i32>;
            v595 = hir.load v594 : i32;
            v596 = arith.constant 16 : i32;
            v597 = arith.sub v595, v596 : i32 #[overflow = wrapping];
            v598 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_struct/__stack_pointer : ptr<byte, u8>
            v599 = hir.bitcast v598 : ptr<byte, i32>;
            hir.store v599, v597;
            v609 = hir.bitcast v587 : u32;
            v610 = arith.zext v609 : u64;
            v611 = hir.bitcast v610 : i64;
            v591 = arith.constant 0 : i32;
            v604 = arith.sub v591, v589 : i32 #[overflow = wrapping];
            v601 = arith.constant -1 : i32;
            v600 = arith.add v589, v590 : i32 #[overflow = wrapping];
            v602 = arith.add v600, v601 : i32 #[overflow = wrapping];
            v605 = arith.band v602, v604 : i32;
            v606 = hir.bitcast v605 : u32;
            v607 = arith.zext v606 : u64;
            v608 = hir.bitcast v607 : i64;
            v612 = arith.mul v608, v611 : i64 #[overflow = wrapping];
            v1266 = arith.constant 0 : i32;
            v613 = arith.constant 32 : i64;
            v615 = hir.cast v613 : u32;
            v614 = hir.bitcast v612 : u64;
            v616 = arith.shr v614, v615 : u64;
            v617 = hir.bitcast v616 : i64;
            v618 = arith.trunc v617 : i32;
            v620 = arith.neq v618, v1266 : i1;
            v1178, v1179, v1180, v1181, v1182, v1183 = scf.if v620 : i32, i32, i32, i32, i32, u32 {
            ^block132:
                v1163 = arith.constant 0 : u32;
                v1170 = ub.poison i32 : i32;
                scf.yield v586, v597, v1170, v1170, v1170, v1163;
            } else {
            ^block68:
                v621 = arith.trunc v612 : i32;
                v1265 = arith.constant 0 : i32;
                v622 = arith.constant -2147483648 : i32;
                v623 = arith.sub v622, v589 : i32 #[overflow = wrapping];
                v625 = hir.bitcast v623 : u32;
                v624 = hir.bitcast v621 : u32;
                v626 = arith.lte v624, v625 : i1;
                v627 = arith.zext v626 : u32;
                v628 = hir.bitcast v627 : i32;
                v630 = arith.neq v628, v1265 : i1;
                v1226 = scf.if v630 : i32 {
                ^block66:
                    v1264 = arith.constant 0 : i32;
                    v641 = arith.neq v621, v1264 : i1;
                    v1225 = scf.if v641 : i32 {
                    ^block70:
                        v1263 = arith.constant 0 : i32;
                        v657 = arith.neq v588, v1263 : i1;
                        v1224 = scf.if v657 : i32 {
                        ^block73:
                            v639 = arith.constant 1 : i32;
                            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/alloc::alloc::Global::alloc_impl(v597, v589, v621, v639)
                            v668 = hir.bitcast v597 : u32;
                            v713 = arith.constant 4 : u32;
                            v670 = arith.mod v668, v713 : u32;
                            hir.assertz v670 #[code = 250];
                            v671 = hir.int_to_ptr v668 : ptr<byte, i32>;
                            v672 = hir.load v671 : i32;
                            scf.yield v672;
                        } else {
                        ^block74:
                            v658 = arith.constant 8 : i32;
                            v659 = arith.add v597, v658 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v659, v589, v621)
                            v643 = arith.constant 8 : u32;
                            v660 = hir.bitcast v597 : u32;
                            v662 = arith.add v660, v643 : u32 #[overflow = checked];
                            v1262 = arith.constant 4 : u32;
                            v664 = arith.mod v662, v1262 : u32;
                            hir.assertz v664 #[code = 250];
                            v665 = hir.int_to_ptr v662 : ptr<byte, i32>;
                            v666 = hir.load v665 : i32;
                            scf.yield v666;
                        };
                        v1260 = arith.constant 0 : i32;
                        v1261 = arith.constant 0 : i32;
                        v675 = arith.eq v1224, v1261 : i1;
                        v676 = arith.zext v675 : u32;
                        v677 = hir.bitcast v676 : i32;
                        v679 = arith.neq v677, v1260 : i1;
                        scf.if v679{
                        ^block75:
                            v1259 = arith.constant 8 : u32;
                            v696 = hir.bitcast v586 : u32;
                            v698 = arith.add v696, v1259 : u32 #[overflow = checked];
                            v1258 = arith.constant 4 : u32;
                            v700 = arith.mod v698, v1258 : u32;
                            hir.assertz v700 #[code = 250];
                            v701 = hir.int_to_ptr v698 : ptr<byte, i32>;
                            hir.store v701, v621;
                            v1257 = arith.constant 4 : u32;
                            v703 = hir.bitcast v586 : u32;
                            v705 = arith.add v703, v1257 : u32 #[overflow = checked];
                            v1256 = arith.constant 4 : u32;
                            v707 = arith.mod v705, v1256 : u32;
                            hir.assertz v707 #[code = 250];
                            v708 = hir.int_to_ptr v705 : ptr<byte, i32>;
                            hir.store v708, v589;
                            scf.yield ;
                        } else {
                        ^block76:
                            v1255 = arith.constant 8 : u32;
                            v681 = hir.bitcast v586 : u32;
                            v683 = arith.add v681, v1255 : u32 #[overflow = checked];
                            v1254 = arith.constant 4 : u32;
                            v685 = arith.mod v683, v1254 : u32;
                            hir.assertz v685 #[code = 250];
                            v686 = hir.int_to_ptr v683 : ptr<byte, i32>;
                            hir.store v686, v1224;
                            v1253 = arith.constant 4 : u32;
                            v688 = hir.bitcast v586 : u32;
                            v690 = arith.add v688, v1253 : u32 #[overflow = checked];
                            v1252 = arith.constant 4 : u32;
                            v692 = arith.mod v690, v1252 : u32;
                            hir.assertz v692 #[code = 250];
                            v693 = hir.int_to_ptr v690 : ptr<byte, i32>;
                            hir.store v693, v587;
                            scf.yield ;
                        };
                        v1250 = arith.constant 0 : i32;
                        v1251 = arith.constant 1 : i32;
                        v1223 = cf.select v679, v1251, v1250 : i32;
                        scf.yield v1223;
                    } else {
                    ^block71:
                        v1249 = arith.constant 8 : u32;
                        v642 = hir.bitcast v586 : u32;
                        v644 = arith.add v642, v1249 : u32 #[overflow = checked];
                        v1248 = arith.constant 4 : u32;
                        v646 = arith.mod v644, v1248 : u32;
                        hir.assertz v646 #[code = 250];
                        v647 = hir.int_to_ptr v644 : ptr<byte, i32>;
                        hir.store v647, v589;
                        v1247 = arith.constant 4 : u32;
                        v650 = hir.bitcast v586 : u32;
                        v652 = arith.add v650, v1247 : u32 #[overflow = checked];
                        v1246 = arith.constant 4 : u32;
                        v654 = arith.mod v652, v1246 : u32;
                        hir.assertz v654 #[code = 250];
                        v1245 = arith.constant 0 : i32;
                        v655 = hir.int_to_ptr v652 : ptr<byte, i32>;
                        hir.store v655, v1245;
                        v1244 = arith.constant 0 : i32;
                        scf.yield v1244;
                    };
                    scf.yield v1225;
                } else {
                ^block69:
                    v1243 = ub.poison i32 : i32;
                    scf.yield v1243;
                };
                v1238 = arith.constant 0 : u32;
                v1171 = arith.constant 1 : u32;
                v1231 = cf.select v630, v1171, v1238 : u32;
                v1239 = ub.poison i32 : i32;
                v1230 = cf.select v630, v597, v1239 : i32;
                v1240 = ub.poison i32 : i32;
                v1229 = cf.select v630, v586, v1240 : i32;
                v1241 = ub.poison i32 : i32;
                v1228 = cf.select v630, v1241, v597 : i32;
                v1242 = ub.poison i32 : i32;
                v1227 = cf.select v630, v1242, v586 : i32;
                scf.yield v1227, v1228, v1229, v1226, v1230, v1231;
            };
            v1184, v1185, v1186 = scf.index_switch v1183 : i32, i32, i32 
            case 0 {
            ^block67:
                v1237 = arith.constant 4 : u32;
                v633 = hir.bitcast v1178 : u32;
                v635 = arith.add v633, v1237 : u32 #[overflow = checked];
                v1236 = arith.constant 4 : u32;
                v637 = arith.mod v635, v1236 : u32;
                hir.assertz v637 #[code = 250];
                v1235 = arith.constant 0 : i32;
                v638 = hir.int_to_ptr v635 : ptr<byte, i32>;
                hir.store v638, v1235;
                v1234 = arith.constant 1 : i32;
                scf.yield v1178, v1234, v1179;
            }
            default {
            ^block136:
                scf.yield v1180, v1181, v1182;
            };
            v712 = hir.bitcast v1184 : u32;
            v1233 = arith.constant 4 : u32;
            v714 = arith.mod v712, v1233 : u32;
            hir.assertz v714 #[code = 250];
            v715 = hir.int_to_ptr v712 : ptr<byte, i32>;
            hir.store v715, v1185;
            v1232 = arith.constant 16 : i32;
            v720 = arith.add v1186, v1232 : i32 #[overflow = wrapping];
            v721 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_struct/__stack_pointer : ptr<byte, u8>
            v722 = hir.bitcast v721 : ptr<byte, i32>;
            hir.store v722, v720;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v723: i32, v724: i32, v725: i32) {
        ^block77(v723: i32, v724: i32, v725: i32):
            v727 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_struct/__stack_pointer : ptr<byte, u8>
            v728 = hir.bitcast v727 : ptr<byte, i32>;
            v729 = hir.load v728 : i32;
            v730 = arith.constant 16 : i32;
            v731 = arith.sub v729, v730 : i32 #[overflow = wrapping];
            v732 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_struct/__stack_pointer : ptr<byte, u8>
            v733 = hir.bitcast v732 : ptr<byte, i32>;
            hir.store v733, v731;
            v726 = arith.constant 0 : i32;
            v734 = arith.constant 8 : i32;
            v735 = arith.add v731, v734 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/alloc::alloc::Global::alloc_impl(v735, v724, v725, v726)
            v738 = arith.constant 12 : u32;
            v737 = hir.bitcast v731 : u32;
            v739 = arith.add v737, v738 : u32 #[overflow = checked];
            v740 = arith.constant 4 : u32;
            v741 = arith.mod v739, v740 : u32;
            hir.assertz v741 #[code = 250];
            v742 = hir.int_to_ptr v739 : ptr<byte, i32>;
            v743 = hir.load v742 : i32;
            v745 = arith.constant 8 : u32;
            v744 = hir.bitcast v731 : u32;
            v746 = arith.add v744, v745 : u32 #[overflow = checked];
            v1271 = arith.constant 4 : u32;
            v748 = arith.mod v746, v1271 : u32;
            hir.assertz v748 #[code = 250];
            v749 = hir.int_to_ptr v746 : ptr<byte, i32>;
            v750 = hir.load v749 : i32;
            v751 = hir.bitcast v723 : u32;
            v1270 = arith.constant 4 : u32;
            v753 = arith.mod v751, v1270 : u32;
            hir.assertz v753 #[code = 250];
            v754 = hir.int_to_ptr v751 : ptr<byte, i32>;
            hir.store v754, v750;
            v1269 = arith.constant 4 : u32;
            v755 = hir.bitcast v723 : u32;
            v757 = arith.add v755, v1269 : u32 #[overflow = checked];
            v1268 = arith.constant 4 : u32;
            v759 = arith.mod v757, v1268 : u32;
            hir.assertz v759 #[code = 250];
            v760 = hir.int_to_ptr v757 : ptr<byte, i32>;
            hir.store v760, v743;
            v1267 = arith.constant 16 : i32;
            v762 = arith.add v731, v1267 : i32 #[overflow = wrapping];
            v763 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_struct/__stack_pointer : ptr<byte, u8>
            v764 = hir.bitcast v763 : ptr<byte, i32>;
            hir.store v764, v762;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v765: i32, v766: i32, v767: i32, v768: i32) {
        ^block79(v765: i32, v766: i32, v767: i32, v768: i32):
            v1287 = arith.constant 0 : i32;
            v769 = arith.constant 0 : i32;
            v770 = arith.eq v767, v769 : i1;
            v771 = arith.zext v770 : u32;
            v772 = hir.bitcast v771 : i32;
            v774 = arith.neq v772, v1287 : i1;
            v1283 = scf.if v774 : i32 {
            ^block139:
                scf.yield v766;
            } else {
            ^block82:
                hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/__rustc::__rust_no_alloc_shim_is_unstable_v2()
                v1286 = arith.constant 0 : i32;
                v776 = arith.neq v768, v1286 : i1;
                v1282 = scf.if v776 : i32 {
                ^block83:
                    v778 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/__rustc::__rust_alloc_zeroed(v767, v766) : i32
                    scf.yield v778;
                } else {
                ^block84:
                    v777 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/__rustc::__rust_alloc(v767, v766) : i32
                    scf.yield v777;
                };
                scf.yield v1282;
            };
            v782 = arith.constant 4 : u32;
            v781 = hir.bitcast v765 : u32;
            v783 = arith.add v781, v782 : u32 #[overflow = checked];
            v1285 = arith.constant 4 : u32;
            v785 = arith.mod v783, v1285 : u32;
            hir.assertz v785 #[code = 250];
            v786 = hir.int_to_ptr v783 : ptr<byte, i32>;
            hir.store v786, v767;
            v788 = hir.bitcast v765 : u32;
            v1284 = arith.constant 4 : u32;
            v790 = arith.mod v788, v1284 : u32;
            hir.assertz v790 #[code = 250];
            v791 = hir.int_to_ptr v788 : ptr<byte, i32>;
            hir.store v791, v1283;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v792: i32, v793: i32, v794: i32, v795: i32) {
        ^block85(v792: i32, v793: i32, v794: i32, v795: i32):
            v1313 = arith.constant 0 : i32;
            v796 = arith.constant 0 : i32;
            v800 = arith.eq v795, v796 : i1;
            v801 = arith.zext v800 : u32;
            v802 = hir.bitcast v801 : i32;
            v804 = arith.neq v802, v1313 : i1;
            v1300, v1301 = scf.if v804 : i32, i32 {
            ^block143:
                v1312 = arith.constant 0 : i32;
                v798 = arith.constant 4 : i32;
                scf.yield v798, v1312;
            } else {
            ^block88:
                v805 = hir.bitcast v793 : u32;
                v840 = arith.constant 4 : u32;
                v807 = arith.mod v805, v840 : u32;
                hir.assertz v807 #[code = 250];
                v808 = hir.int_to_ptr v805 : ptr<byte, i32>;
                v809 = hir.load v808 : i32;
                v1310 = arith.constant 0 : i32;
                v1311 = arith.constant 0 : i32;
                v811 = arith.eq v809, v1311 : i1;
                v812 = arith.zext v811 : u32;
                v813 = hir.bitcast v812 : i32;
                v815 = arith.neq v813, v1310 : i1;
                v1298 = scf.if v815 : i32 {
                ^block142:
                    v1309 = arith.constant 0 : i32;
                    scf.yield v1309;
                } else {
                ^block89:
                    v1308 = arith.constant 4 : u32;
                    v816 = hir.bitcast v792 : u32;
                    v818 = arith.add v816, v1308 : u32 #[overflow = checked];
                    v1307 = arith.constant 4 : u32;
                    v820 = arith.mod v818, v1307 : u32;
                    hir.assertz v820 #[code = 250];
                    v821 = hir.int_to_ptr v818 : ptr<byte, i32>;
                    hir.store v821, v794;
                    v1306 = arith.constant 4 : u32;
                    v822 = hir.bitcast v793 : u32;
                    v824 = arith.add v822, v1306 : u32 #[overflow = checked];
                    v1305 = arith.constant 4 : u32;
                    v826 = arith.mod v824, v1305 : u32;
                    hir.assertz v826 #[code = 250];
                    v827 = hir.int_to_ptr v824 : ptr<byte, i32>;
                    v828 = hir.load v827 : i32;
                    v829 = hir.bitcast v792 : u32;
                    v1304 = arith.constant 4 : u32;
                    v831 = arith.mod v829, v1304 : u32;
                    hir.assertz v831 #[code = 250];
                    v832 = hir.int_to_ptr v829 : ptr<byte, i32>;
                    hir.store v832, v828;
                    v833 = arith.mul v809, v795 : i32 #[overflow = wrapping];
                    scf.yield v833;
                };
                v834 = arith.constant 8 : i32;
                v1303 = arith.constant 4 : i32;
                v1299 = cf.select v815, v1303, v834 : i32;
                scf.yield v1299, v1298;
            };
            v837 = arith.add v792, v1300 : i32 #[overflow = wrapping];
            v839 = hir.bitcast v837 : u32;
            v1302 = arith.constant 4 : u32;
            v841 = arith.mod v839, v1302 : u32;
            hir.assertz v841 #[code = 250];
            v842 = hir.int_to_ptr v839 : ptr<byte, i32>;
            hir.store v842, v1301;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::finish_grow(v843: i32, v844: i32, v845: i32, v846: i32, v847: i32) {
        ^block90(v843: i32, v844: i32, v845: i32, v846: i32, v847: i32):
            v849 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_struct/__stack_pointer : ptr<byte, u8>
            v850 = hir.bitcast v849 : ptr<byte, i32>;
            v851 = hir.load v850 : i32;
            v852 = arith.constant 16 : i32;
            v853 = arith.sub v851, v852 : i32 #[overflow = wrapping];
            v854 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_struct/__stack_pointer : ptr<byte, u8>
            v855 = hir.bitcast v854 : ptr<byte, i32>;
            hir.store v855, v853;
            v1368 = arith.constant 0 : i32;
            v848 = arith.constant 0 : i32;
            v858 = arith.gte v845, v848 : i1;
            v859 = arith.zext v858 : u32;
            v860 = hir.bitcast v859 : i32;
            v862 = arith.neq v860, v1368 : i1;
            v1342, v1343 = scf.if v862 : i32, i32 {
            ^block93:
                v949 = arith.constant 4 : u32;
                v865 = hir.bitcast v846 : u32;
                v867 = arith.add v865, v949 : u32 #[overflow = checked];
                v1367 = arith.constant 4 : u32;
                v869 = arith.mod v867, v1367 : u32;
                hir.assertz v869 #[code = 250];
                v870 = hir.int_to_ptr v867 : ptr<byte, i32>;
                v871 = hir.load v870 : i32;
                v1365 = arith.constant 0 : i32;
                v1366 = arith.constant 0 : i32;
                v873 = arith.eq v871, v1366 : i1;
                v874 = arith.zext v873 : u32;
                v875 = hir.bitcast v874 : i32;
                v877 = arith.neq v875, v1365 : i1;
                v1340, v1341 = scf.if v877 : i32, i32 {
                ^block96:
                    hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v853, v844, v845)
                    v1364 = arith.constant 4 : u32;
                    v910 = hir.bitcast v853 : u32;
                    v912 = arith.add v910, v1364 : u32 #[overflow = checked];
                    v1363 = arith.constant 4 : u32;
                    v914 = arith.mod v912, v1363 : u32;
                    hir.assertz v914 #[code = 250];
                    v915 = hir.int_to_ptr v912 : ptr<byte, i32>;
                    v916 = hir.load v915 : i32;
                    v917 = hir.bitcast v853 : u32;
                    v1362 = arith.constant 4 : u32;
                    v919 = arith.mod v917, v1362 : u32;
                    hir.assertz v919 #[code = 250];
                    v920 = hir.int_to_ptr v917 : ptr<byte, i32>;
                    v921 = hir.load v920 : i32;
                    scf.yield v921, v916;
                } else {
                ^block97:
                    v879 = arith.constant 8 : u32;
                    v878 = hir.bitcast v846 : u32;
                    v880 = arith.add v878, v879 : u32 #[overflow = checked];
                    v1361 = arith.constant 4 : u32;
                    v882 = arith.mod v880, v1361 : u32;
                    hir.assertz v882 #[code = 250];
                    v883 = hir.int_to_ptr v880 : ptr<byte, i32>;
                    v884 = hir.load v883 : i32;
                    v1360 = arith.constant 0 : i32;
                    v886 = arith.neq v884, v1360 : i1;
                    v1338, v1339 = scf.if v886 : i32, i32 {
                    ^block98:
                        v904 = hir.bitcast v846 : u32;
                        v1359 = arith.constant 4 : u32;
                        v906 = arith.mod v904, v1359 : u32;
                        hir.assertz v906 #[code = 250];
                        v907 = hir.int_to_ptr v904 : ptr<byte, i32>;
                        v908 = hir.load v907 : i32;
                        v909 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/__rustc::__rust_realloc(v908, v884, v844, v845) : i32
                        scf.yield v909, v845;
                    } else {
                    ^block99:
                        v1358 = arith.constant 0 : i32;
                        v943 = arith.constant 8 : i32;
                        v888 = arith.add v853, v943 : i32 #[overflow = wrapping];
                        hir.exec @root_ns:root@1.0.0/onchain_mixed_types_struct/alloc::alloc::Global::alloc_impl(v888, v844, v845, v1358)
                        v891 = arith.constant 12 : u32;
                        v890 = hir.bitcast v853 : u32;
                        v892 = arith.add v890, v891 : u32 #[overflow = checked];
                        v1357 = arith.constant 4 : u32;
                        v894 = arith.mod v892, v1357 : u32;
                        hir.assertz v894 #[code = 250];
                        v895 = hir.int_to_ptr v892 : ptr<byte, i32>;
                        v896 = hir.load v895 : i32;
                        v1356 = arith.constant 8 : u32;
                        v897 = hir.bitcast v853 : u32;
                        v899 = arith.add v897, v1356 : u32 #[overflow = checked];
                        v1355 = arith.constant 4 : u32;
                        v901 = arith.mod v899, v1355 : u32;
                        hir.assertz v901 #[code = 250];
                        v902 = hir.int_to_ptr v899 : ptr<byte, i32>;
                        v903 = hir.load v902 : i32;
                        scf.yield v903, v896;
                    };
                    scf.yield v1338, v1339;
                };
                v1354 = arith.constant 4 : u32;
                v928 = hir.bitcast v843 : u32;
                v930 = arith.add v928, v1354 : u32 #[overflow = checked];
                v1353 = arith.constant 4 : u32;
                v932 = arith.mod v930, v1353 : u32;
                hir.assertz v932 #[code = 250];
                v1352 = arith.constant 0 : i32;
                v926 = arith.neq v1340, v1352 : i1;
                v927 = cf.select v926, v1340, v844 : i32;
                v933 = hir.int_to_ptr v930 : ptr<byte, i32>;
                hir.store v933, v927;
                v1350 = arith.constant 0 : i32;
                v940 = arith.eq v1340, v1350 : i1;
                v941 = arith.zext v940 : u32;
                v942 = hir.bitcast v941 : i32;
                v1351 = arith.constant 0 : i32;
                v937 = arith.neq v1340, v1351 : i1;
                v938 = cf.select v937, v1341, v845 : i32;
                scf.yield v938, v942;
            } else {
            ^block94:
                v863 = arith.constant 1 : i32;
                v1349 = arith.constant 0 : i32;
                scf.yield v1349, v863;
            };
            v864 = arith.constant 4 : i32;
            v1348 = arith.constant 8 : i32;
            v1344 = cf.select v862, v1348, v864 : i32;
            v946 = arith.add v843, v1344 : i32 #[overflow = wrapping];
            v948 = hir.bitcast v946 : u32;
            v1347 = arith.constant 4 : u32;
            v950 = arith.mod v948, v1347 : u32;
            hir.assertz v950 #[code = 250];
            v951 = hir.int_to_ptr v948 : ptr<byte, i32>;
            hir.store v951, v1342;
            v953 = hir.bitcast v843 : u32;
            v1346 = arith.constant 4 : u32;
            v955 = arith.mod v953, v1346 : u32;
            hir.assertz v955 #[code = 250];
            v956 = hir.int_to_ptr v953 : ptr<byte, i32>;
            hir.store v956, v1343;
            v1345 = arith.constant 16 : i32;
            v960 = arith.add v853, v1345 : i32 #[overflow = wrapping];
            v961 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_struct/__stack_pointer : ptr<byte, u8>
            v962 = hir.bitcast v961 : ptr<byte, i32>;
            hir.store v962, v960;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v963: i32, v964: i32, v965: i32) {
        ^block100(v963: i32, v964: i32, v965: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v966: i32, v967: i32) -> i32 {
        ^block102(v966: i32, v967: i32):
            v974 = arith.constant 0 : i32;
            v970 = hir.bitcast v967 : u32;
            v969 = hir.bitcast v966 : u32;
            v971 = arith.gt v969, v970 : i1;
            v972 = arith.zext v971 : u32;
            v973 = hir.bitcast v972 : i32;
            v975 = arith.neq v973, v974 : i1;
            v976 = cf.select v975, v966, v967 : i32;
            builtin.ret v976;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.segment readonly @1048576 = 0x00000000000000000000000a0010000000003e64657463616465723c;
    };
};