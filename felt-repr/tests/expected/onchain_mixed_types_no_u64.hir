builtin.component root_ns:root@1.0.0 {
    builtin.module public @onchain_mixed_types_no_u64 {
        private builtin.function @alloc::vec::Vec<T,A>::push(v0: i32, v1: felt) {
        ^block4(v0: i32, v1: felt):
            v4 = arith.constant 8 : u32;
            v3 = hir.bitcast v0 : u32;
            v5 = arith.add v3, v4 : u32 #[overflow = checked];
            v6 = arith.constant 4 : u32;
            v7 = arith.mod v5, v6 : u32;
            hir.assertz v7 #[code = 250];
            v8 = hir.int_to_ptr v5 : ptr<byte, i32>;
            v9 = hir.load v8 : i32;
            v10 = hir.bitcast v0 : u32;
            v972 = arith.constant 4 : u32;
            v12 = arith.mod v10, v972 : u32;
            hir.assertz v12 #[code = 250];
            v13 = hir.int_to_ptr v10 : ptr<byte, i32>;
            v14 = hir.load v13 : i32;
            v2 = arith.constant 0 : i32;
            v15 = arith.neq v9, v14 : i1;
            v16 = arith.zext v15 : u32;
            v17 = hir.bitcast v16 : i32;
            v19 = arith.neq v17, v2 : i1;
            scf.if v19{
            ^block98:
                scf.yield ;
            } else {
            ^block7:
                hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/alloc::raw_vec::RawVec<T,A>::grow_one(v0)
                scf.yield ;
            };
            v971 = arith.constant 4 : u32;
            v21 = hir.bitcast v0 : u32;
            v23 = arith.add v21, v971 : u32 #[overflow = checked];
            v970 = arith.constant 4 : u32;
            v25 = arith.mod v23, v970 : u32;
            hir.assertz v25 #[code = 250];
            v26 = hir.int_to_ptr v23 : ptr<byte, i32>;
            v27 = hir.load v26 : i32;
            v962 = arith.constant 2 : u32;
            v31 = arith.shl v9, v962 : i32;
            v32 = arith.add v27, v31 : i32 #[overflow = wrapping];
            v34 = hir.bitcast v32 : u32;
            v969 = arith.constant 4 : u32;
            v36 = arith.mod v34, v969 : u32;
            hir.assertz v36 #[code = 250];
            v37 = hir.int_to_ptr v34 : ptr<byte, felt>;
            hir.store v37, v1;
            v968 = arith.constant 8 : u32;
            v40 = hir.bitcast v0 : u32;
            v42 = arith.add v40, v968 : u32 #[overflow = checked];
            v967 = arith.constant 4 : u32;
            v44 = arith.mod v42, v967 : u32;
            hir.assertz v44 #[code = 250];
            v38 = arith.constant 1 : i32;
            v39 = arith.add v9, v38 : i32 #[overflow = wrapping];
            v45 = hir.int_to_ptr v42 : ptr<byte, i32>;
            hir.store v45, v39;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVec<T,A>::grow_one(v46: i32) {
        ^block8(v46: i32):
            v48 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__stack_pointer : ptr<byte, u8>
            v49 = hir.bitcast v48 : ptr<byte, i32>;
            v50 = hir.load v49 : i32;
            v51 = arith.constant 16 : i32;
            v52 = arith.sub v50, v51 : i32 #[overflow = wrapping];
            v53 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__stack_pointer : ptr<byte, u8>
            v54 = hir.bitcast v53 : ptr<byte, i32>;
            hir.store v54, v52;
            v57 = hir.bitcast v46 : u32;
            v58 = arith.constant 4 : u32;
            v59 = arith.mod v57, v58 : u32;
            hir.assertz v59 #[code = 250];
            v60 = hir.int_to_ptr v57 : ptr<byte, i32>;
            v61 = hir.load v60 : i32;
            v63 = arith.constant 4 : i32;
            v62 = arith.constant 1 : i32;
            v55 = arith.constant 8 : i32;
            v56 = arith.add v52, v55 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/alloc::raw_vec::RawVecInner<A>::grow_amortized(v56, v46, v61, v62, v63, v63)
            v66 = arith.constant 8 : u32;
            v65 = hir.bitcast v52 : u32;
            v67 = arith.add v65, v66 : u32 #[overflow = checked];
            v976 = arith.constant 4 : u32;
            v69 = arith.mod v67, v976 : u32;
            hir.assertz v69 #[code = 250];
            v70 = hir.int_to_ptr v67 : ptr<byte, i32>;
            v71 = hir.load v70 : i32;
            v47 = arith.constant 0 : i32;
            v72 = arith.constant -2147483647 : i32;
            v73 = arith.eq v71, v72 : i1;
            v74 = arith.zext v73 : u32;
            v75 = hir.bitcast v74 : i32;
            v77 = arith.neq v75, v47 : i1;
            cf.cond_br v77 ^block10, ^block11;
        ^block10:
            v975 = arith.constant 16 : i32;
            v87 = arith.add v52, v975 : i32 #[overflow = wrapping];
            v88 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__stack_pointer : ptr<byte, u8>
            v89 = hir.bitcast v88 : ptr<byte, i32>;
            hir.store v89, v87;
            builtin.ret ;
        ^block11:
            v79 = arith.constant 12 : u32;
            v78 = hir.bitcast v52 : u32;
            v80 = arith.add v78, v79 : u32 #[overflow = checked];
            v974 = arith.constant 4 : u32;
            v82 = arith.mod v80, v974 : u32;
            hir.assertz v82 #[code = 250];
            v83 = hir.int_to_ptr v80 : ptr<byte, i32>;
            v84 = hir.load v83 : i32;
            v85 = arith.constant 1048588 : i32;
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/alloc::raw_vec::handle_error(v71, v84, v85)
            ub.unreachable ;
        };

        public builtin.function @entrypoint(v90: i32, v91: i32) {
        ^block12(v90: i32, v91: i32):
            v96 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__stack_pointer : ptr<byte, u8>
            v97 = hir.bitcast v96 : ptr<byte, i32>;
            v98 = hir.load v97 : i32;
            v99 = arith.constant 32 : i32;
            v100 = arith.sub v98, v99 : i32 #[overflow = wrapping];
            v101 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__stack_pointer : ptr<byte, u8>
            v102 = hir.bitcast v101 : ptr<byte, i32>;
            hir.store v102, v100;
            v104 = arith.constant 12 : u32;
            v103 = hir.bitcast v91 : u32;
            v105 = arith.add v103, v104 : u32 #[overflow = checked];
            v106 = arith.constant 4 : u32;
            v107 = arith.mod v105, v106 : u32;
            hir.assertz v107 #[code = 250];
            v108 = hir.int_to_ptr v105 : ptr<byte, felt>;
            v109 = hir.load v108 : felt;
            v111 = arith.constant 8 : u32;
            v110 = hir.bitcast v91 : u32;
            v112 = arith.add v110, v111 : u32 #[overflow = checked];
            v1010 = arith.constant 4 : u32;
            v114 = arith.mod v112, v1010 : u32;
            hir.assertz v114 #[code = 250];
            v115 = hir.int_to_ptr v112 : ptr<byte, felt>;
            v116 = hir.load v115 : felt;
            v1009 = arith.constant 4 : u32;
            v117 = hir.bitcast v91 : u32;
            v119 = arith.add v117, v1009 : u32 #[overflow = checked];
            v1008 = arith.constant 4 : u32;
            v121 = arith.mod v119, v1008 : u32;
            hir.assertz v121 #[code = 250];
            v122 = hir.int_to_ptr v119 : ptr<byte, felt>;
            v123 = hir.load v122 : felt;
            v124 = hir.bitcast v91 : u32;
            v1007 = arith.constant 4 : u32;
            v126 = arith.mod v124, v1007 : u32;
            hir.assertz v126 #[code = 250];
            v127 = hir.int_to_ptr v124 : ptr<byte, felt>;
            v128 = hir.load v127 : felt;
            v130 = arith.constant 16 : u32;
            v129 = hir.bitcast v91 : u32;
            v131 = arith.add v129, v130 : u32 #[overflow = checked];
            v1006 = arith.constant 4 : u32;
            v133 = arith.mod v131, v1006 : u32;
            hir.assertz v133 #[code = 250];
            v134 = hir.int_to_ptr v131 : ptr<byte, felt>;
            v135 = hir.load v134 : felt;
            v136 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/intrinsics::felt::as_u64(v135) : i64
            v138 = arith.constant 20 : u32;
            v137 = hir.bitcast v91 : u32;
            v139 = arith.add v137, v138 : u32 #[overflow = checked];
            v1005 = arith.constant 4 : u32;
            v141 = arith.mod v139, v1005 : u32;
            hir.assertz v141 #[code = 250];
            v142 = hir.int_to_ptr v139 : ptr<byte, felt>;
            v143 = hir.load v142 : felt;
            v144 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/intrinsics::felt::as_u64(v143) : i64
            v149 = arith.constant 4 : i32;
            v92 = arith.constant 0 : i32;
            v147 = arith.constant 256 : i32;
            v145 = arith.constant 20 : i32;
            v146 = arith.add v100, v145 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/alloc::raw_vec::RawVecInner<A>::try_allocate_in(v146, v147, v92, v149, v149)
            v152 = arith.constant 24 : u32;
            v151 = hir.bitcast v100 : u32;
            v153 = arith.add v151, v152 : u32 #[overflow = checked];
            v1004 = arith.constant 4 : u32;
            v155 = arith.mod v153, v1004 : u32;
            hir.assertz v155 #[code = 250];
            v156 = hir.int_to_ptr v153 : ptr<byte, i32>;
            v157 = hir.load v156 : i32;
            v1003 = arith.constant 20 : u32;
            v158 = hir.bitcast v100 : u32;
            v160 = arith.add v158, v1003 : u32 #[overflow = checked];
            v1002 = arith.constant 4 : u32;
            v162 = arith.mod v160, v1002 : u32;
            hir.assertz v162 #[code = 250];
            v163 = hir.int_to_ptr v160 : ptr<byte, i32>;
            v164 = hir.load v163 : i32;
            v1001 = arith.constant 0 : i32;
            v165 = arith.constant 1 : i32;
            v166 = arith.neq v164, v165 : i1;
            v167 = arith.zext v166 : u32;
            v168 = hir.bitcast v167 : i32;
            v170 = arith.neq v168, v1001 : i1;
            cf.cond_br v170 ^block14, ^block15;
        ^block14:
            v1000 = arith.constant 8 : i32;
            v179 = arith.constant 8 : i32;
            v180 = arith.add v100, v179 : i32 #[overflow = wrapping];
            v182 = arith.add v180, v1000 : i32 #[overflow = wrapping];
            v184 = hir.bitcast v182 : u32;
            v999 = arith.constant 4 : u32;
            v186 = arith.mod v184, v999 : u32;
            hir.assertz v186 #[code = 250];
            v998 = arith.constant 0 : i32;
            v187 = hir.int_to_ptr v184 : ptr<byte, i32>;
            hir.store v187, v998;
            v189 = arith.constant 28 : u32;
            v188 = hir.bitcast v100 : u32;
            v190 = arith.add v188, v189 : u32 #[overflow = checked];
            v997 = arith.constant 4 : u32;
            v192 = arith.mod v190, v997 : u32;
            hir.assertz v192 #[code = 250];
            v193 = hir.int_to_ptr v190 : ptr<byte, i32>;
            v194 = hir.load v193 : i32;
            v996 = arith.constant 12 : u32;
            v195 = hir.bitcast v100 : u32;
            v197 = arith.add v195, v996 : u32 #[overflow = checked];
            v995 = arith.constant 4 : u32;
            v199 = arith.mod v197, v995 : u32;
            hir.assertz v199 #[code = 250];
            v200 = hir.int_to_ptr v197 : ptr<byte, i32>;
            hir.store v200, v194;
            v994 = arith.constant 8 : u32;
            v201 = hir.bitcast v100 : u32;
            v203 = arith.add v201, v994 : u32 #[overflow = checked];
            v993 = arith.constant 4 : u32;
            v205 = arith.mod v203, v993 : u32;
            hir.assertz v205 #[code = 250];
            v206 = hir.int_to_ptr v203 : ptr<byte, i32>;
            hir.store v206, v157;
            v992 = arith.constant 8 : i32;
            v208 = arith.add v100, v992 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/alloc::vec::Vec<T,A>::push(v208, v128)
            v991 = arith.constant 8 : i32;
            v210 = arith.add v100, v991 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/alloc::vec::Vec<T,A>::push(v210, v123)
            v990 = arith.constant 8 : i32;
            v212 = arith.add v100, v990 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/alloc::vec::Vec<T,A>::push(v212, v116)
            v989 = arith.constant 8 : i32;
            v214 = arith.add v100, v989 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/alloc::vec::Vec<T,A>::push(v214, v109)
            v217 = arith.trunc v136 : i32;
            v218 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/<miden_stdlib_sys::intrinsics::felt::Felt as core::convert::From<u32>>::from(v217) : felt
            v988 = arith.constant 8 : i32;
            v216 = arith.add v100, v988 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/alloc::vec::Vec<T,A>::push(v216, v218)
            v222 = arith.constant 255 : i32;
            v221 = arith.trunc v144 : i32;
            v223 = arith.band v221, v222 : i32;
            v224 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/<miden_stdlib_sys::intrinsics::felt::Felt as core::convert::From<u32>>::from(v223) : felt
            v987 = arith.constant 8 : i32;
            v220 = arith.add v100, v987 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/alloc::vec::Vec<T,A>::push(v220, v224)
            v227 = hir.bitcast v182 : u32;
            v986 = arith.constant 4 : u32;
            v229 = arith.mod v227, v986 : u32;
            hir.assertz v229 #[code = 250];
            v230 = hir.int_to_ptr v227 : ptr<byte, i32>;
            v231 = hir.load v230 : i32;
            v985 = arith.constant 8 : i32;
            v226 = arith.add v90, v985 : i32 #[overflow = wrapping];
            v232 = hir.bitcast v226 : u32;
            v984 = arith.constant 4 : u32;
            v234 = arith.mod v232, v984 : u32;
            hir.assertz v234 #[code = 250];
            v235 = hir.int_to_ptr v232 : ptr<byte, i32>;
            hir.store v235, v231;
            v983 = arith.constant 8 : u32;
            v236 = hir.bitcast v100 : u32;
            v238 = arith.add v236, v983 : u32 #[overflow = checked];
            v982 = arith.constant 4 : u32;
            v240 = arith.mod v238, v982 : u32;
            hir.assertz v240 #[code = 250];
            v241 = hir.int_to_ptr v238 : ptr<byte, i64>;
            v242 = hir.load v241 : i64;
            v243 = hir.bitcast v90 : u32;
            v981 = arith.constant 4 : u32;
            v245 = arith.mod v243, v981 : u32;
            hir.assertz v245 #[code = 250];
            v246 = hir.int_to_ptr v243 : ptr<byte, i64>;
            hir.store v246, v242;
            v980 = arith.constant 32 : i32;
            v248 = arith.add v100, v980 : i32 #[overflow = wrapping];
            v249 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__stack_pointer : ptr<byte, u8>
            v250 = hir.bitcast v249 : ptr<byte, i32>;
            hir.store v250, v248;
            builtin.ret ;
        ^block15:
            v979 = arith.constant 28 : u32;
            v171 = hir.bitcast v100 : u32;
            v173 = arith.add v171, v979 : u32 #[overflow = checked];
            v978 = arith.constant 4 : u32;
            v175 = arith.mod v173, v978 : u32;
            hir.assertz v175 #[code = 250];
            v176 = hir.int_to_ptr v173 : ptr<byte, i32>;
            v177 = hir.load v176 : i32;
            v178 = arith.constant 1048588 : i32;
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/alloc::raw_vec::handle_error(v157, v177, v178)
            ub.unreachable ;
        };

        private builtin.function @__rustc::__rust_alloc(v251: i32, v252: i32) -> i32 {
        ^block16(v251: i32, v252: i32):
            v254 = arith.constant 1048604 : i32;
            v255 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v254, v252, v251) : i32
            builtin.ret v255;
        };

        private builtin.function @__rustc::__rust_realloc(v256: i32, v257: i32, v258: i32, v259: i32) -> i32 {
        ^block18(v256: i32, v257: i32, v258: i32, v259: i32):
            v261 = arith.constant 1048604 : i32;
            v262 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v261, v258, v259) : i32
            v1019 = arith.constant 0 : i32;
            v263 = arith.constant 0 : i32;
            v264 = arith.eq v262, v263 : i1;
            v265 = arith.zext v264 : u32;
            v266 = hir.bitcast v265 : i32;
            v268 = arith.neq v266, v1019 : i1;
            scf.if v268{
            ^block20:
                scf.yield ;
            } else {
            ^block21:
                v1018 = arith.constant 0 : i32;
                v270 = hir.bitcast v257 : u32;
                v269 = hir.bitcast v259 : u32;
                v271 = arith.lt v269, v270 : i1;
                v272 = arith.zext v271 : u32;
                v273 = hir.bitcast v272 : i32;
                v275 = arith.neq v273, v1018 : i1;
                v276 = cf.select v275, v259, v257 : i32;
                v1016 = arith.constant 0 : i32;
                v1017 = arith.constant 0 : i32;
                v278 = arith.eq v276, v1017 : i1;
                v279 = arith.zext v278 : u32;
                v280 = hir.bitcast v279 : i32;
                v282 = arith.neq v280, v1016 : i1;
                scf.if v282{
                ^block104:
                    scf.yield ;
                } else {
                ^block22:
                    v283 = hir.bitcast v276 : u32;
                    v284 = hir.bitcast v262 : u32;
                    v285 = hir.int_to_ptr v284 : ptr<byte, u8>;
                    v286 = hir.bitcast v256 : u32;
                    v287 = hir.int_to_ptr v286 : ptr<byte, u8>;
                    hir.mem_cpy v287, v285, v283;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v262;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v289: i32, v290: i32) -> i32 {
        ^block23(v289: i32, v290: i32):
            v292 = arith.constant 1048604 : i32;
            v293 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v292, v290, v289) : i32
            v1028 = arith.constant 0 : i32;
            v294 = arith.constant 0 : i32;
            v295 = arith.eq v293, v294 : i1;
            v296 = arith.zext v295 : u32;
            v297 = hir.bitcast v296 : i32;
            v299 = arith.neq v297, v1028 : i1;
            scf.if v299{
            ^block25:
                scf.yield ;
            } else {
            ^block26:
                v1026 = arith.constant 0 : i32;
                v1027 = arith.constant 0 : i32;
                v301 = arith.eq v289, v1027 : i1;
                v302 = arith.zext v301 : u32;
                v303 = hir.bitcast v302 : i32;
                v305 = arith.neq v303, v1026 : i1;
                scf.if v305{
                ^block107:
                    scf.yield ;
                } else {
                ^block27:
                    v1020 = arith.constant 0 : u8;
                    v308 = hir.bitcast v289 : u32;
                    v309 = hir.bitcast v293 : u32;
                    v310 = hir.int_to_ptr v309 : ptr<byte, u8>;
                    hir.mem_set v310, v308, v1020;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v293;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block28:
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v312: i32, v313: i32, v314: i32) -> i32 {
        ^block30(v312: i32, v313: i32, v314: i32):
            v317 = arith.constant 16 : i32;
            v316 = arith.constant 0 : i32;
            v1030 = arith.constant 16 : u32;
            v319 = hir.bitcast v313 : u32;
            v321 = arith.gt v319, v1030 : i1;
            v322 = arith.zext v321 : u32;
            v323 = hir.bitcast v322 : i32;
            v325 = arith.neq v323, v316 : i1;
            v326 = cf.select v325, v313, v317 : i32;
            v1070 = arith.constant 0 : i32;
            v327 = arith.constant -1 : i32;
            v328 = arith.add v326, v327 : i32 #[overflow = wrapping];
            v329 = arith.band v326, v328 : i32;
            v331 = arith.neq v329, v1070 : i1;
            v1039, v1040 = scf.if v331 : i32, u32 {
            ^block112:
                v1031 = arith.constant 0 : u32;
                v1035 = ub.poison i32 : i32;
                scf.yield v1035, v1031;
            } else {
            ^block33:
                v333 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/core::ptr::alignment::Alignment::max(v313, v326) : i32
                v1069 = arith.constant 0 : i32;
                v332 = arith.constant -2147483648 : i32;
                v334 = arith.sub v332, v333 : i32 #[overflow = wrapping];
                v336 = hir.bitcast v334 : u32;
                v335 = hir.bitcast v314 : u32;
                v337 = arith.gt v335, v336 : i1;
                v338 = arith.zext v337 : u32;
                v339 = hir.bitcast v338 : i32;
                v341 = arith.neq v339, v1069 : i1;
                v1054 = scf.if v341 : i32 {
                ^block111:
                    v1068 = ub.poison i32 : i32;
                    scf.yield v1068;
                } else {
                ^block34:
                    v1066 = arith.constant 0 : i32;
                    v347 = arith.sub v1066, v333 : i32 #[overflow = wrapping];
                    v1067 = arith.constant -1 : i32;
                    v343 = arith.add v314, v333 : i32 #[overflow = wrapping];
                    v345 = arith.add v343, v1067 : i32 #[overflow = wrapping];
                    v348 = arith.band v345, v347 : i32;
                    v349 = hir.bitcast v312 : u32;
                    v350 = arith.constant 4 : u32;
                    v351 = arith.mod v349, v350 : u32;
                    hir.assertz v351 #[code = 250];
                    v352 = hir.int_to_ptr v349 : ptr<byte, i32>;
                    v353 = hir.load v352 : i32;
                    v1065 = arith.constant 0 : i32;
                    v355 = arith.neq v353, v1065 : i1;
                    scf.if v355{
                    ^block110:
                        scf.yield ;
                    } else {
                    ^block36:
                        v356 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/intrinsics::mem::heap_base() : i32
                        v357 = hir.mem_size  : u32;
                        v363 = hir.bitcast v312 : u32;
                        v1064 = arith.constant 4 : u32;
                        v365 = arith.mod v363, v1064 : u32;
                        hir.assertz v365 #[code = 250];
                        v1063 = arith.constant 16 : u32;
                        v358 = hir.bitcast v357 : i32;
                        v361 = arith.shl v358, v1063 : i32;
                        v362 = arith.add v356, v361 : i32 #[overflow = wrapping];
                        v366 = hir.int_to_ptr v363 : ptr<byte, i32>;
                        hir.store v366, v362;
                        scf.yield ;
                    };
                    v369 = hir.bitcast v312 : u32;
                    v1062 = arith.constant 4 : u32;
                    v371 = arith.mod v369, v1062 : u32;
                    hir.assertz v371 #[code = 250];
                    v372 = hir.int_to_ptr v369 : ptr<byte, i32>;
                    v373 = hir.load v372 : i32;
                    v1060 = arith.constant 0 : i32;
                    v1061 = arith.constant -1 : i32;
                    v375 = arith.bxor v373, v1061 : i32;
                    v377 = hir.bitcast v375 : u32;
                    v376 = hir.bitcast v348 : u32;
                    v378 = arith.gt v376, v377 : i1;
                    v379 = arith.zext v378 : u32;
                    v380 = hir.bitcast v379 : i32;
                    v382 = arith.neq v380, v1060 : i1;
                    v1053 = scf.if v382 : i32 {
                    ^block37:
                        v1059 = arith.constant 0 : i32;
                        scf.yield v1059;
                    } else {
                    ^block38:
                        v384 = hir.bitcast v312 : u32;
                        v1058 = arith.constant 4 : u32;
                        v386 = arith.mod v384, v1058 : u32;
                        hir.assertz v386 #[code = 250];
                        v383 = arith.add v373, v348 : i32 #[overflow = wrapping];
                        v387 = hir.int_to_ptr v384 : ptr<byte, i32>;
                        hir.store v387, v383;
                        v389 = arith.add v373, v333 : i32 #[overflow = wrapping];
                        scf.yield v389;
                    };
                    scf.yield v1053;
                };
                v1036 = arith.constant 1 : u32;
                v1057 = arith.constant 0 : u32;
                v1055 = cf.select v341, v1057, v1036 : u32;
                scf.yield v1054, v1055;
            };
            v1056 = arith.constant 0 : u32;
            v1052 = arith.eq v1040, v1056 : i1;
            cf.cond_br v1052 ^block32, ^block114(v1039);
        ^block32:
            ub.unreachable ;
        ^block114(v1032: i32):
            builtin.ret v1032;
        };

        private builtin.function @intrinsics::mem::heap_base() -> i32 {
        ^block39:
            v392 = hir.exec @intrinsics/mem/heap_base() : i32
            builtin.ret v392;
        };

        private builtin.function @<miden_stdlib_sys::intrinsics::felt::Felt as core::convert::From<u32>>::from(v394: i32) -> felt {
        ^block43(v394: i32):
            v396 = hir.bitcast v394 : felt;
            builtin.ret v396;
        };

        private builtin.function @intrinsics::felt::as_u64(v397: felt) -> i64 {
        ^block45(v397: felt):
            v398 = hir.cast v397 : i64;
            builtin.ret v398;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::grow_amortized(v400: i32, v401: i32, v402: i32, v403: i32, v404: i32, v405: i32) {
        ^block47(v400: i32, v401: i32, v402: i32, v403: i32, v404: i32, v405: i32):
            v408 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__stack_pointer : ptr<byte, u8>
            v409 = hir.bitcast v408 : ptr<byte, i32>;
            v410 = hir.load v409 : i32;
            v411 = arith.constant 32 : i32;
            v412 = arith.sub v410, v411 : i32 #[overflow = wrapping];
            v413 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__stack_pointer : ptr<byte, u8>
            v414 = hir.bitcast v413 : ptr<byte, i32>;
            hir.store v414, v412;
            v1147 = arith.constant 0 : i32;
            v406 = arith.constant 0 : i32;
            v417 = arith.eq v405, v406 : i1;
            v418 = arith.zext v417 : u32;
            v419 = hir.bitcast v418 : i32;
            v421 = arith.neq v419, v1147 : i1;
            v1118, v1119 = scf.if v421 : i32, i32 {
            ^block50:
                v1146 = arith.constant 0 : i32;
                scf.yield v1146, v1146;
            } else {
            ^block51:
                v422 = arith.add v402, v403 : i32 #[overflow = wrapping];
                v1145 = arith.constant 0 : i32;
                v424 = hir.bitcast v402 : u32;
                v423 = hir.bitcast v422 : u32;
                v425 = arith.lt v423, v424 : i1;
                v426 = arith.zext v425 : u32;
                v427 = hir.bitcast v426 : i32;
                v429 = arith.neq v427, v1145 : i1;
                v1116, v1117 = scf.if v429 : i32, i32 {
                ^block120:
                    v1144 = arith.constant 0 : i32;
                    scf.yield v1144, v1144;
                } else {
                ^block52:
                    v440 = hir.bitcast v401 : u32;
                    v554 = arith.constant 4 : u32;
                    v442 = arith.mod v440, v554 : u32;
                    hir.assertz v442 #[code = 250];
                    v443 = hir.int_to_ptr v440 : ptr<byte, i32>;
                    v444 = hir.load v443 : i32;
                    v1072 = arith.constant 1 : u32;
                    v447 = arith.shl v444, v1072 : i32;
                    v1143 = arith.constant 0 : i32;
                    v449 = hir.bitcast v447 : u32;
                    v448 = hir.bitcast v422 : u32;
                    v450 = arith.gt v448, v449 : i1;
                    v451 = arith.zext v450 : u32;
                    v452 = hir.bitcast v451 : i32;
                    v454 = arith.neq v452, v1143 : i1;
                    v455 = cf.select v454, v422, v447 : i32;
                    v1140 = arith.constant 1 : i32;
                    v457 = arith.constant 4 : i32;
                    v1141 = arith.constant 0 : i32;
                    v1071 = arith.constant 1025 : u32;
                    v460 = hir.bitcast v405 : u32;
                    v462 = arith.lt v460, v1071 : i1;
                    v463 = arith.zext v462 : u32;
                    v464 = hir.bitcast v463 : i32;
                    v466 = arith.neq v464, v1141 : i1;
                    v467 = cf.select v466, v457, v1140 : i32;
                    v456 = arith.constant 8 : i32;
                    v1142 = arith.constant 0 : i32;
                    v445 = arith.constant 1 : i32;
                    v469 = arith.eq v405, v445 : i1;
                    v470 = arith.zext v469 : u32;
                    v471 = hir.bitcast v470 : i32;
                    v473 = arith.neq v471, v1142 : i1;
                    v474 = cf.select v473, v456, v467 : i32;
                    v1139 = arith.constant 0 : i32;
                    v476 = hir.bitcast v474 : u32;
                    v475 = hir.bitcast v455 : u32;
                    v477 = arith.gt v475, v476 : i1;
                    v478 = arith.zext v477 : u32;
                    v479 = hir.bitcast v478 : i32;
                    v481 = arith.neq v479, v1139 : i1;
                    v482 = cf.select v481, v455, v474 : i32;
                    v483 = hir.bitcast v482 : u32;
                    v484 = arith.zext v483 : u64;
                    v485 = hir.bitcast v484 : i64;
                    v1138 = arith.constant 0 : i32;
                    v435 = arith.sub v1138, v404 : i32 #[overflow = wrapping];
                    v432 = arith.constant -1 : i32;
                    v431 = arith.add v404, v405 : i32 #[overflow = wrapping];
                    v433 = arith.add v431, v432 : i32 #[overflow = wrapping];
                    v436 = arith.band v433, v435 : i32;
                    v437 = hir.bitcast v436 : u32;
                    v438 = arith.zext v437 : u64;
                    v439 = hir.bitcast v438 : i64;
                    v486 = arith.mul v439, v485 : i64 #[overflow = wrapping];
                    v1137 = arith.constant 0 : i32;
                    v487 = arith.constant 32 : i64;
                    v489 = hir.cast v487 : u32;
                    v488 = hir.bitcast v486 : u64;
                    v490 = arith.shr v488, v489 : u64;
                    v491 = hir.bitcast v490 : i64;
                    v492 = arith.trunc v491 : i32;
                    v494 = arith.neq v492, v1137 : i1;
                    v1114, v1115 = scf.if v494 : i32, i32 {
                    ^block119:
                        v1136 = arith.constant 0 : i32;
                        scf.yield v455, v1136;
                    } else {
                    ^block53:
                        v495 = arith.trunc v486 : i32;
                        v1135 = arith.constant 0 : i32;
                        v496 = arith.constant -2147483648 : i32;
                        v497 = arith.sub v496, v404 : i32 #[overflow = wrapping];
                        v499 = hir.bitcast v497 : u32;
                        v498 = hir.bitcast v495 : u32;
                        v500 = arith.gt v498, v499 : i1;
                        v501 = arith.zext v500 : u32;
                        v502 = hir.bitcast v501 : i32;
                        v504 = arith.neq v502, v1135 : i1;
                        v1112, v1113 = scf.if v504 : i32, i32 {
                        ^block118:
                            v1134 = arith.constant 0 : i32;
                            scf.yield v455, v1134;
                        } else {
                        ^block54:
                            v505 = arith.constant 20 : i32;
                            v506 = arith.add v412, v505 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/alloc::raw_vec::RawVecInner<A>::current_memory(v506, v401, v404, v405)
                            v1132 = arith.constant 20 : i32;
                            v510 = arith.add v412, v1132 : i32 #[overflow = wrapping];
                            v1133 = arith.constant 8 : i32;
                            v508 = arith.add v412, v1133 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/alloc::raw_vec::finish_grow(v508, v404, v495, v510, v400)
                            v512 = arith.constant 12 : u32;
                            v511 = hir.bitcast v412 : u32;
                            v513 = arith.add v511, v512 : u32 #[overflow = checked];
                            v1131 = arith.constant 4 : u32;
                            v515 = arith.mod v513, v1131 : u32;
                            hir.assertz v515 #[code = 250];
                            v516 = hir.int_to_ptr v513 : ptr<byte, i32>;
                            v517 = hir.load v516 : i32;
                            v519 = arith.constant 8 : u32;
                            v518 = hir.bitcast v412 : u32;
                            v520 = arith.add v518, v519 : u32 #[overflow = checked];
                            v1130 = arith.constant 4 : u32;
                            v522 = arith.mod v520, v1130 : u32;
                            hir.assertz v522 #[code = 250];
                            v523 = hir.int_to_ptr v520 : ptr<byte, i32>;
                            v524 = hir.load v523 : i32;
                            v1128 = arith.constant 0 : i32;
                            v1129 = arith.constant 0 : i32;
                            v526 = arith.eq v524, v1129 : i1;
                            v527 = arith.zext v526 : u32;
                            v528 = hir.bitcast v527 : i32;
                            v530 = arith.neq v528, v1128 : i1;
                            v1110 = scf.if v530 : i32 {
                            ^block55:
                                v538 = hir.bitcast v401 : u32;
                                v1127 = arith.constant 4 : u32;
                                v540 = arith.mod v538, v1127 : u32;
                                hir.assertz v540 #[code = 250];
                                v541 = hir.int_to_ptr v538 : ptr<byte, i32>;
                                hir.store v541, v482;
                                v1126 = arith.constant 4 : u32;
                                v542 = hir.bitcast v401 : u32;
                                v544 = arith.add v542, v1126 : u32 #[overflow = checked];
                                v1125 = arith.constant 4 : u32;
                                v546 = arith.mod v544, v1125 : u32;
                                hir.assertz v546 #[code = 250];
                                v547 = hir.int_to_ptr v544 : ptr<byte, i32>;
                                hir.store v547, v517;
                                scf.yield v455;
                            } else {
                            ^block56:
                                v532 = arith.constant 16 : u32;
                                v531 = hir.bitcast v412 : u32;
                                v533 = arith.add v531, v532 : u32 #[overflow = checked];
                                v1124 = arith.constant 4 : u32;
                                v535 = arith.mod v533, v1124 : u32;
                                hir.assertz v535 #[code = 250];
                                v536 = hir.int_to_ptr v533 : ptr<byte, i32>;
                                v537 = hir.load v536 : i32;
                                scf.yield v537;
                            };
                            v548 = arith.constant -2147483647 : i32;
                            v1111 = cf.select v530, v548, v517 : i32;
                            scf.yield v1110, v1111;
                        };
                        scf.yield v1112, v1113;
                    };
                    scf.yield v1114, v1115;
                };
                scf.yield v1116, v1117;
            };
            v1123 = arith.constant 4 : u32;
            v553 = hir.bitcast v400 : u32;
            v555 = arith.add v553, v1123 : u32 #[overflow = checked];
            v1122 = arith.constant 4 : u32;
            v557 = arith.mod v555, v1122 : u32;
            hir.assertz v557 #[code = 250];
            v558 = hir.int_to_ptr v555 : ptr<byte, i32>;
            hir.store v558, v1118;
            v561 = hir.bitcast v400 : u32;
            v1121 = arith.constant 4 : u32;
            v563 = arith.mod v561, v1121 : u32;
            hir.assertz v563 #[code = 250];
            v564 = hir.int_to_ptr v561 : ptr<byte, i32>;
            hir.store v564, v1119;
            v1120 = arith.constant 32 : i32;
            v568 = arith.add v412, v1120 : i32 #[overflow = wrapping];
            v569 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__stack_pointer : ptr<byte, u8>
            v570 = hir.bitcast v569 : ptr<byte, i32>;
            hir.store v570, v568;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::try_allocate_in(v571: i32, v572: i32, v573: i32, v574: i32, v575: i32) {
        ^block57(v571: i32, v572: i32, v573: i32, v574: i32, v575: i32):
            v578 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__stack_pointer : ptr<byte, u8>
            v579 = hir.bitcast v578 : ptr<byte, i32>;
            v580 = hir.load v579 : i32;
            v581 = arith.constant 16 : i32;
            v582 = arith.sub v580, v581 : i32 #[overflow = wrapping];
            v583 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__stack_pointer : ptr<byte, u8>
            v584 = hir.bitcast v583 : ptr<byte, i32>;
            hir.store v584, v582;
            v594 = hir.bitcast v572 : u32;
            v595 = arith.zext v594 : u64;
            v596 = hir.bitcast v595 : i64;
            v576 = arith.constant 0 : i32;
            v589 = arith.sub v576, v574 : i32 #[overflow = wrapping];
            v586 = arith.constant -1 : i32;
            v585 = arith.add v574, v575 : i32 #[overflow = wrapping];
            v587 = arith.add v585, v586 : i32 #[overflow = wrapping];
            v590 = arith.band v587, v589 : i32;
            v591 = hir.bitcast v590 : u32;
            v592 = arith.zext v591 : u64;
            v593 = hir.bitcast v592 : i64;
            v597 = arith.mul v593, v596 : i64 #[overflow = wrapping];
            v1251 = arith.constant 0 : i32;
            v598 = arith.constant 32 : i64;
            v600 = hir.cast v598 : u32;
            v599 = hir.bitcast v597 : u64;
            v601 = arith.shr v599, v600 : u64;
            v602 = hir.bitcast v601 : i64;
            v603 = arith.trunc v602 : i32;
            v605 = arith.neq v603, v1251 : i1;
            v1163, v1164, v1165, v1166, v1167, v1168 = scf.if v605 : i32, i32, i32, i32, i32, u32 {
            ^block126:
                v1148 = arith.constant 0 : u32;
                v1155 = ub.poison i32 : i32;
                scf.yield v571, v582, v1155, v1155, v1155, v1148;
            } else {
            ^block62:
                v606 = arith.trunc v597 : i32;
                v1250 = arith.constant 0 : i32;
                v607 = arith.constant -2147483648 : i32;
                v608 = arith.sub v607, v574 : i32 #[overflow = wrapping];
                v610 = hir.bitcast v608 : u32;
                v609 = hir.bitcast v606 : u32;
                v611 = arith.lte v609, v610 : i1;
                v612 = arith.zext v611 : u32;
                v613 = hir.bitcast v612 : i32;
                v615 = arith.neq v613, v1250 : i1;
                v1211 = scf.if v615 : i32 {
                ^block60:
                    v1249 = arith.constant 0 : i32;
                    v626 = arith.neq v606, v1249 : i1;
                    v1210 = scf.if v626 : i32 {
                    ^block64:
                        v1248 = arith.constant 0 : i32;
                        v642 = arith.neq v573, v1248 : i1;
                        v1209 = scf.if v642 : i32 {
                        ^block67:
                            v624 = arith.constant 1 : i32;
                            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/alloc::alloc::Global::alloc_impl(v582, v574, v606, v624)
                            v653 = hir.bitcast v582 : u32;
                            v698 = arith.constant 4 : u32;
                            v655 = arith.mod v653, v698 : u32;
                            hir.assertz v655 #[code = 250];
                            v656 = hir.int_to_ptr v653 : ptr<byte, i32>;
                            v657 = hir.load v656 : i32;
                            scf.yield v657;
                        } else {
                        ^block68:
                            v643 = arith.constant 8 : i32;
                            v644 = arith.add v582, v643 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v644, v574, v606)
                            v628 = arith.constant 8 : u32;
                            v645 = hir.bitcast v582 : u32;
                            v647 = arith.add v645, v628 : u32 #[overflow = checked];
                            v1247 = arith.constant 4 : u32;
                            v649 = arith.mod v647, v1247 : u32;
                            hir.assertz v649 #[code = 250];
                            v650 = hir.int_to_ptr v647 : ptr<byte, i32>;
                            v651 = hir.load v650 : i32;
                            scf.yield v651;
                        };
                        v1245 = arith.constant 0 : i32;
                        v1246 = arith.constant 0 : i32;
                        v660 = arith.eq v1209, v1246 : i1;
                        v661 = arith.zext v660 : u32;
                        v662 = hir.bitcast v661 : i32;
                        v664 = arith.neq v662, v1245 : i1;
                        scf.if v664{
                        ^block69:
                            v1244 = arith.constant 8 : u32;
                            v681 = hir.bitcast v571 : u32;
                            v683 = arith.add v681, v1244 : u32 #[overflow = checked];
                            v1243 = arith.constant 4 : u32;
                            v685 = arith.mod v683, v1243 : u32;
                            hir.assertz v685 #[code = 250];
                            v686 = hir.int_to_ptr v683 : ptr<byte, i32>;
                            hir.store v686, v606;
                            v1242 = arith.constant 4 : u32;
                            v688 = hir.bitcast v571 : u32;
                            v690 = arith.add v688, v1242 : u32 #[overflow = checked];
                            v1241 = arith.constant 4 : u32;
                            v692 = arith.mod v690, v1241 : u32;
                            hir.assertz v692 #[code = 250];
                            v693 = hir.int_to_ptr v690 : ptr<byte, i32>;
                            hir.store v693, v574;
                            scf.yield ;
                        } else {
                        ^block70:
                            v1240 = arith.constant 8 : u32;
                            v666 = hir.bitcast v571 : u32;
                            v668 = arith.add v666, v1240 : u32 #[overflow = checked];
                            v1239 = arith.constant 4 : u32;
                            v670 = arith.mod v668, v1239 : u32;
                            hir.assertz v670 #[code = 250];
                            v671 = hir.int_to_ptr v668 : ptr<byte, i32>;
                            hir.store v671, v1209;
                            v1238 = arith.constant 4 : u32;
                            v673 = hir.bitcast v571 : u32;
                            v675 = arith.add v673, v1238 : u32 #[overflow = checked];
                            v1237 = arith.constant 4 : u32;
                            v677 = arith.mod v675, v1237 : u32;
                            hir.assertz v677 #[code = 250];
                            v678 = hir.int_to_ptr v675 : ptr<byte, i32>;
                            hir.store v678, v572;
                            scf.yield ;
                        };
                        v1235 = arith.constant 0 : i32;
                        v1236 = arith.constant 1 : i32;
                        v1208 = cf.select v664, v1236, v1235 : i32;
                        scf.yield v1208;
                    } else {
                    ^block65:
                        v1234 = arith.constant 8 : u32;
                        v627 = hir.bitcast v571 : u32;
                        v629 = arith.add v627, v1234 : u32 #[overflow = checked];
                        v1233 = arith.constant 4 : u32;
                        v631 = arith.mod v629, v1233 : u32;
                        hir.assertz v631 #[code = 250];
                        v632 = hir.int_to_ptr v629 : ptr<byte, i32>;
                        hir.store v632, v574;
                        v1232 = arith.constant 4 : u32;
                        v635 = hir.bitcast v571 : u32;
                        v637 = arith.add v635, v1232 : u32 #[overflow = checked];
                        v1231 = arith.constant 4 : u32;
                        v639 = arith.mod v637, v1231 : u32;
                        hir.assertz v639 #[code = 250];
                        v1230 = arith.constant 0 : i32;
                        v640 = hir.int_to_ptr v637 : ptr<byte, i32>;
                        hir.store v640, v1230;
                        v1229 = arith.constant 0 : i32;
                        scf.yield v1229;
                    };
                    scf.yield v1210;
                } else {
                ^block63:
                    v1228 = ub.poison i32 : i32;
                    scf.yield v1228;
                };
                v1223 = arith.constant 0 : u32;
                v1156 = arith.constant 1 : u32;
                v1216 = cf.select v615, v1156, v1223 : u32;
                v1224 = ub.poison i32 : i32;
                v1215 = cf.select v615, v582, v1224 : i32;
                v1225 = ub.poison i32 : i32;
                v1214 = cf.select v615, v571, v1225 : i32;
                v1226 = ub.poison i32 : i32;
                v1213 = cf.select v615, v1226, v582 : i32;
                v1227 = ub.poison i32 : i32;
                v1212 = cf.select v615, v1227, v571 : i32;
                scf.yield v1212, v1213, v1214, v1211, v1215, v1216;
            };
            v1169, v1170, v1171 = scf.index_switch v1168 : i32, i32, i32 
            case 0 {
            ^block61:
                v1222 = arith.constant 4 : u32;
                v618 = hir.bitcast v1163 : u32;
                v620 = arith.add v618, v1222 : u32 #[overflow = checked];
                v1221 = arith.constant 4 : u32;
                v622 = arith.mod v620, v1221 : u32;
                hir.assertz v622 #[code = 250];
                v1220 = arith.constant 0 : i32;
                v623 = hir.int_to_ptr v620 : ptr<byte, i32>;
                hir.store v623, v1220;
                v1219 = arith.constant 1 : i32;
                scf.yield v1163, v1219, v1164;
            }
            default {
            ^block130:
                scf.yield v1165, v1166, v1167;
            };
            v697 = hir.bitcast v1169 : u32;
            v1218 = arith.constant 4 : u32;
            v699 = arith.mod v697, v1218 : u32;
            hir.assertz v699 #[code = 250];
            v700 = hir.int_to_ptr v697 : ptr<byte, i32>;
            hir.store v700, v1170;
            v1217 = arith.constant 16 : i32;
            v705 = arith.add v1171, v1217 : i32 #[overflow = wrapping];
            v706 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__stack_pointer : ptr<byte, u8>
            v707 = hir.bitcast v706 : ptr<byte, i32>;
            hir.store v707, v705;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v708: i32, v709: i32, v710: i32) {
        ^block71(v708: i32, v709: i32, v710: i32):
            v712 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__stack_pointer : ptr<byte, u8>
            v713 = hir.bitcast v712 : ptr<byte, i32>;
            v714 = hir.load v713 : i32;
            v715 = arith.constant 16 : i32;
            v716 = arith.sub v714, v715 : i32 #[overflow = wrapping];
            v717 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__stack_pointer : ptr<byte, u8>
            v718 = hir.bitcast v717 : ptr<byte, i32>;
            hir.store v718, v716;
            v711 = arith.constant 0 : i32;
            v719 = arith.constant 8 : i32;
            v720 = arith.add v716, v719 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/alloc::alloc::Global::alloc_impl(v720, v709, v710, v711)
            v723 = arith.constant 12 : u32;
            v722 = hir.bitcast v716 : u32;
            v724 = arith.add v722, v723 : u32 #[overflow = checked];
            v725 = arith.constant 4 : u32;
            v726 = arith.mod v724, v725 : u32;
            hir.assertz v726 #[code = 250];
            v727 = hir.int_to_ptr v724 : ptr<byte, i32>;
            v728 = hir.load v727 : i32;
            v730 = arith.constant 8 : u32;
            v729 = hir.bitcast v716 : u32;
            v731 = arith.add v729, v730 : u32 #[overflow = checked];
            v1256 = arith.constant 4 : u32;
            v733 = arith.mod v731, v1256 : u32;
            hir.assertz v733 #[code = 250];
            v734 = hir.int_to_ptr v731 : ptr<byte, i32>;
            v735 = hir.load v734 : i32;
            v736 = hir.bitcast v708 : u32;
            v1255 = arith.constant 4 : u32;
            v738 = arith.mod v736, v1255 : u32;
            hir.assertz v738 #[code = 250];
            v739 = hir.int_to_ptr v736 : ptr<byte, i32>;
            hir.store v739, v735;
            v1254 = arith.constant 4 : u32;
            v740 = hir.bitcast v708 : u32;
            v742 = arith.add v740, v1254 : u32 #[overflow = checked];
            v1253 = arith.constant 4 : u32;
            v744 = arith.mod v742, v1253 : u32;
            hir.assertz v744 #[code = 250];
            v745 = hir.int_to_ptr v742 : ptr<byte, i32>;
            hir.store v745, v728;
            v1252 = arith.constant 16 : i32;
            v747 = arith.add v716, v1252 : i32 #[overflow = wrapping];
            v748 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__stack_pointer : ptr<byte, u8>
            v749 = hir.bitcast v748 : ptr<byte, i32>;
            hir.store v749, v747;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v750: i32, v751: i32, v752: i32, v753: i32) {
        ^block73(v750: i32, v751: i32, v752: i32, v753: i32):
            v1272 = arith.constant 0 : i32;
            v754 = arith.constant 0 : i32;
            v755 = arith.eq v752, v754 : i1;
            v756 = arith.zext v755 : u32;
            v757 = hir.bitcast v756 : i32;
            v759 = arith.neq v757, v1272 : i1;
            v1268 = scf.if v759 : i32 {
            ^block133:
                scf.yield v751;
            } else {
            ^block76:
                hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__rustc::__rust_no_alloc_shim_is_unstable_v2()
                v1271 = arith.constant 0 : i32;
                v761 = arith.neq v753, v1271 : i1;
                v1267 = scf.if v761 : i32 {
                ^block77:
                    v763 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__rustc::__rust_alloc_zeroed(v752, v751) : i32
                    scf.yield v763;
                } else {
                ^block78:
                    v762 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__rustc::__rust_alloc(v752, v751) : i32
                    scf.yield v762;
                };
                scf.yield v1267;
            };
            v767 = arith.constant 4 : u32;
            v766 = hir.bitcast v750 : u32;
            v768 = arith.add v766, v767 : u32 #[overflow = checked];
            v1270 = arith.constant 4 : u32;
            v770 = arith.mod v768, v1270 : u32;
            hir.assertz v770 #[code = 250];
            v771 = hir.int_to_ptr v768 : ptr<byte, i32>;
            hir.store v771, v752;
            v773 = hir.bitcast v750 : u32;
            v1269 = arith.constant 4 : u32;
            v775 = arith.mod v773, v1269 : u32;
            hir.assertz v775 #[code = 250];
            v776 = hir.int_to_ptr v773 : ptr<byte, i32>;
            hir.store v776, v1268;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v777: i32, v778: i32, v779: i32, v780: i32) {
        ^block79(v777: i32, v778: i32, v779: i32, v780: i32):
            v1298 = arith.constant 0 : i32;
            v781 = arith.constant 0 : i32;
            v785 = arith.eq v780, v781 : i1;
            v786 = arith.zext v785 : u32;
            v787 = hir.bitcast v786 : i32;
            v789 = arith.neq v787, v1298 : i1;
            v1285, v1286 = scf.if v789 : i32, i32 {
            ^block137:
                v1297 = arith.constant 0 : i32;
                v783 = arith.constant 4 : i32;
                scf.yield v783, v1297;
            } else {
            ^block82:
                v790 = hir.bitcast v778 : u32;
                v825 = arith.constant 4 : u32;
                v792 = arith.mod v790, v825 : u32;
                hir.assertz v792 #[code = 250];
                v793 = hir.int_to_ptr v790 : ptr<byte, i32>;
                v794 = hir.load v793 : i32;
                v1295 = arith.constant 0 : i32;
                v1296 = arith.constant 0 : i32;
                v796 = arith.eq v794, v1296 : i1;
                v797 = arith.zext v796 : u32;
                v798 = hir.bitcast v797 : i32;
                v800 = arith.neq v798, v1295 : i1;
                v1283 = scf.if v800 : i32 {
                ^block136:
                    v1294 = arith.constant 0 : i32;
                    scf.yield v1294;
                } else {
                ^block83:
                    v1293 = arith.constant 4 : u32;
                    v801 = hir.bitcast v777 : u32;
                    v803 = arith.add v801, v1293 : u32 #[overflow = checked];
                    v1292 = arith.constant 4 : u32;
                    v805 = arith.mod v803, v1292 : u32;
                    hir.assertz v805 #[code = 250];
                    v806 = hir.int_to_ptr v803 : ptr<byte, i32>;
                    hir.store v806, v779;
                    v1291 = arith.constant 4 : u32;
                    v807 = hir.bitcast v778 : u32;
                    v809 = arith.add v807, v1291 : u32 #[overflow = checked];
                    v1290 = arith.constant 4 : u32;
                    v811 = arith.mod v809, v1290 : u32;
                    hir.assertz v811 #[code = 250];
                    v812 = hir.int_to_ptr v809 : ptr<byte, i32>;
                    v813 = hir.load v812 : i32;
                    v814 = hir.bitcast v777 : u32;
                    v1289 = arith.constant 4 : u32;
                    v816 = arith.mod v814, v1289 : u32;
                    hir.assertz v816 #[code = 250];
                    v817 = hir.int_to_ptr v814 : ptr<byte, i32>;
                    hir.store v817, v813;
                    v818 = arith.mul v794, v780 : i32 #[overflow = wrapping];
                    scf.yield v818;
                };
                v819 = arith.constant 8 : i32;
                v1288 = arith.constant 4 : i32;
                v1284 = cf.select v800, v1288, v819 : i32;
                scf.yield v1284, v1283;
            };
            v822 = arith.add v777, v1285 : i32 #[overflow = wrapping];
            v824 = hir.bitcast v822 : u32;
            v1287 = arith.constant 4 : u32;
            v826 = arith.mod v824, v1287 : u32;
            hir.assertz v826 #[code = 250];
            v827 = hir.int_to_ptr v824 : ptr<byte, i32>;
            hir.store v827, v1286;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::finish_grow(v828: i32, v829: i32, v830: i32, v831: i32, v832: i32) {
        ^block84(v828: i32, v829: i32, v830: i32, v831: i32, v832: i32):
            v834 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__stack_pointer : ptr<byte, u8>
            v835 = hir.bitcast v834 : ptr<byte, i32>;
            v836 = hir.load v835 : i32;
            v837 = arith.constant 16 : i32;
            v838 = arith.sub v836, v837 : i32 #[overflow = wrapping];
            v839 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__stack_pointer : ptr<byte, u8>
            v840 = hir.bitcast v839 : ptr<byte, i32>;
            hir.store v840, v838;
            v1353 = arith.constant 0 : i32;
            v833 = arith.constant 0 : i32;
            v843 = arith.gte v830, v833 : i1;
            v844 = arith.zext v843 : u32;
            v845 = hir.bitcast v844 : i32;
            v847 = arith.neq v845, v1353 : i1;
            v1327, v1328 = scf.if v847 : i32, i32 {
            ^block87:
                v934 = arith.constant 4 : u32;
                v850 = hir.bitcast v831 : u32;
                v852 = arith.add v850, v934 : u32 #[overflow = checked];
                v1352 = arith.constant 4 : u32;
                v854 = arith.mod v852, v1352 : u32;
                hir.assertz v854 #[code = 250];
                v855 = hir.int_to_ptr v852 : ptr<byte, i32>;
                v856 = hir.load v855 : i32;
                v1350 = arith.constant 0 : i32;
                v1351 = arith.constant 0 : i32;
                v858 = arith.eq v856, v1351 : i1;
                v859 = arith.zext v858 : u32;
                v860 = hir.bitcast v859 : i32;
                v862 = arith.neq v860, v1350 : i1;
                v1325, v1326 = scf.if v862 : i32, i32 {
                ^block90:
                    hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v838, v829, v830)
                    v1349 = arith.constant 4 : u32;
                    v895 = hir.bitcast v838 : u32;
                    v897 = arith.add v895, v1349 : u32 #[overflow = checked];
                    v1348 = arith.constant 4 : u32;
                    v899 = arith.mod v897, v1348 : u32;
                    hir.assertz v899 #[code = 250];
                    v900 = hir.int_to_ptr v897 : ptr<byte, i32>;
                    v901 = hir.load v900 : i32;
                    v902 = hir.bitcast v838 : u32;
                    v1347 = arith.constant 4 : u32;
                    v904 = arith.mod v902, v1347 : u32;
                    hir.assertz v904 #[code = 250];
                    v905 = hir.int_to_ptr v902 : ptr<byte, i32>;
                    v906 = hir.load v905 : i32;
                    scf.yield v906, v901;
                } else {
                ^block91:
                    v864 = arith.constant 8 : u32;
                    v863 = hir.bitcast v831 : u32;
                    v865 = arith.add v863, v864 : u32 #[overflow = checked];
                    v1346 = arith.constant 4 : u32;
                    v867 = arith.mod v865, v1346 : u32;
                    hir.assertz v867 #[code = 250];
                    v868 = hir.int_to_ptr v865 : ptr<byte, i32>;
                    v869 = hir.load v868 : i32;
                    v1345 = arith.constant 0 : i32;
                    v871 = arith.neq v869, v1345 : i1;
                    v1323, v1324 = scf.if v871 : i32, i32 {
                    ^block92:
                        v889 = hir.bitcast v831 : u32;
                        v1344 = arith.constant 4 : u32;
                        v891 = arith.mod v889, v1344 : u32;
                        hir.assertz v891 #[code = 250];
                        v892 = hir.int_to_ptr v889 : ptr<byte, i32>;
                        v893 = hir.load v892 : i32;
                        v894 = hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__rustc::__rust_realloc(v893, v869, v829, v830) : i32
                        scf.yield v894, v830;
                    } else {
                    ^block93:
                        v1343 = arith.constant 0 : i32;
                        v928 = arith.constant 8 : i32;
                        v873 = arith.add v838, v928 : i32 #[overflow = wrapping];
                        hir.exec @root_ns:root@1.0.0/onchain_mixed_types_no_u64/alloc::alloc::Global::alloc_impl(v873, v829, v830, v1343)
                        v876 = arith.constant 12 : u32;
                        v875 = hir.bitcast v838 : u32;
                        v877 = arith.add v875, v876 : u32 #[overflow = checked];
                        v1342 = arith.constant 4 : u32;
                        v879 = arith.mod v877, v1342 : u32;
                        hir.assertz v879 #[code = 250];
                        v880 = hir.int_to_ptr v877 : ptr<byte, i32>;
                        v881 = hir.load v880 : i32;
                        v1341 = arith.constant 8 : u32;
                        v882 = hir.bitcast v838 : u32;
                        v884 = arith.add v882, v1341 : u32 #[overflow = checked];
                        v1340 = arith.constant 4 : u32;
                        v886 = arith.mod v884, v1340 : u32;
                        hir.assertz v886 #[code = 250];
                        v887 = hir.int_to_ptr v884 : ptr<byte, i32>;
                        v888 = hir.load v887 : i32;
                        scf.yield v888, v881;
                    };
                    scf.yield v1323, v1324;
                };
                v1339 = arith.constant 4 : u32;
                v913 = hir.bitcast v828 : u32;
                v915 = arith.add v913, v1339 : u32 #[overflow = checked];
                v1338 = arith.constant 4 : u32;
                v917 = arith.mod v915, v1338 : u32;
                hir.assertz v917 #[code = 250];
                v1337 = arith.constant 0 : i32;
                v911 = arith.neq v1325, v1337 : i1;
                v912 = cf.select v911, v1325, v829 : i32;
                v918 = hir.int_to_ptr v915 : ptr<byte, i32>;
                hir.store v918, v912;
                v1335 = arith.constant 0 : i32;
                v925 = arith.eq v1325, v1335 : i1;
                v926 = arith.zext v925 : u32;
                v927 = hir.bitcast v926 : i32;
                v1336 = arith.constant 0 : i32;
                v922 = arith.neq v1325, v1336 : i1;
                v923 = cf.select v922, v1326, v830 : i32;
                scf.yield v923, v927;
            } else {
            ^block88:
                v848 = arith.constant 1 : i32;
                v1334 = arith.constant 0 : i32;
                scf.yield v1334, v848;
            };
            v849 = arith.constant 4 : i32;
            v1333 = arith.constant 8 : i32;
            v1329 = cf.select v847, v1333, v849 : i32;
            v931 = arith.add v828, v1329 : i32 #[overflow = wrapping];
            v933 = hir.bitcast v931 : u32;
            v1332 = arith.constant 4 : u32;
            v935 = arith.mod v933, v1332 : u32;
            hir.assertz v935 #[code = 250];
            v936 = hir.int_to_ptr v933 : ptr<byte, i32>;
            hir.store v936, v1327;
            v938 = hir.bitcast v828 : u32;
            v1331 = arith.constant 4 : u32;
            v940 = arith.mod v938, v1331 : u32;
            hir.assertz v940 #[code = 250];
            v941 = hir.int_to_ptr v938 : ptr<byte, i32>;
            hir.store v941, v1328;
            v1330 = arith.constant 16 : i32;
            v945 = arith.add v838, v1330 : i32 #[overflow = wrapping];
            v946 = builtin.global_symbol @root_ns:root@1.0.0/onchain_mixed_types_no_u64/__stack_pointer : ptr<byte, u8>
            v947 = hir.bitcast v946 : ptr<byte, i32>;
            hir.store v947, v945;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v948: i32, v949: i32, v950: i32) {
        ^block94(v948: i32, v949: i32, v950: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v951: i32, v952: i32) -> i32 {
        ^block96(v951: i32, v952: i32):
            v959 = arith.constant 0 : i32;
            v955 = hir.bitcast v952 : u32;
            v954 = hir.bitcast v951 : u32;
            v956 = arith.gt v954, v955 : i1;
            v957 = arith.zext v956 : u32;
            v958 = hir.bitcast v957 : i32;
            v960 = arith.neq v958, v959 : i1;
            v961 = cf.select v960, v951, v952 : i32;
            builtin.ret v961;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.segment readonly @1048576 = 0x00000000000000000000000a0010000000003e64657463616465723c;
    };
};