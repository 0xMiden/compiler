builtin.component root_ns:root@1.0.0 {
    builtin.module public @onchain_four_felts_struct {
        private builtin.function @alloc::vec::Vec<T,A>::push(v0: i32, v1: felt) {
        ^block4(v0: i32, v1: felt):
            v4 = arith.constant 8 : u32;
            v3 = hir.bitcast v0 : u32;
            v5 = arith.add v3, v4 : u32 #[overflow = checked];
            v6 = arith.constant 4 : u32;
            v7 = arith.mod v5, v6 : u32;
            hir.assertz v7 #[code = 250];
            v8 = hir.int_to_ptr v5 : ptr<byte, i32>;
            v9 = hir.load v8 : i32;
            v10 = hir.bitcast v0 : u32;
            v755 = arith.constant 4 : u32;
            v12 = arith.mod v10, v755 : u32;
            hir.assertz v12 #[code = 250];
            v13 = hir.int_to_ptr v10 : ptr<byte, i32>;
            v14 = hir.load v13 : i32;
            v2 = arith.constant 0 : i32;
            v15 = arith.neq v9, v14 : i1;
            v16 = arith.zext v15 : u32;
            v17 = hir.bitcast v16 : i32;
            v19 = arith.neq v17, v2 : i1;
            scf.if v19{
            ^block78:
                scf.yield ;
            } else {
            ^block7:
                hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/alloc::raw_vec::RawVec<T,A>::grow_one(v0)
                scf.yield ;
            };
            v754 = arith.constant 4 : u32;
            v21 = hir.bitcast v0 : u32;
            v23 = arith.add v21, v754 : u32 #[overflow = checked];
            v753 = arith.constant 4 : u32;
            v25 = arith.mod v23, v753 : u32;
            hir.assertz v25 #[code = 250];
            v26 = hir.int_to_ptr v23 : ptr<byte, i32>;
            v27 = hir.load v26 : i32;
            v745 = arith.constant 2 : u32;
            v31 = arith.shl v9, v745 : i32;
            v32 = arith.add v27, v31 : i32 #[overflow = wrapping];
            v34 = hir.bitcast v32 : u32;
            v752 = arith.constant 4 : u32;
            v36 = arith.mod v34, v752 : u32;
            hir.assertz v36 #[code = 250];
            v37 = hir.int_to_ptr v34 : ptr<byte, felt>;
            hir.store v37, v1;
            v751 = arith.constant 8 : u32;
            v40 = hir.bitcast v0 : u32;
            v42 = arith.add v40, v751 : u32 #[overflow = checked];
            v750 = arith.constant 4 : u32;
            v44 = arith.mod v42, v750 : u32;
            hir.assertz v44 #[code = 250];
            v38 = arith.constant 1 : i32;
            v39 = arith.add v9, v38 : i32 #[overflow = wrapping];
            v45 = hir.int_to_ptr v42 : ptr<byte, i32>;
            hir.store v45, v39;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVec<T,A>::grow_one(v46: i32) {
        ^block8(v46: i32):
            v48 = builtin.global_symbol @root_ns:root@1.0.0/onchain_four_felts_struct/__stack_pointer : ptr<byte, u8>
            v49 = hir.bitcast v48 : ptr<byte, i32>;
            v50 = hir.load v49 : i32;
            v51 = arith.constant 16 : i32;
            v52 = arith.sub v50, v51 : i32 #[overflow = wrapping];
            v53 = builtin.global_symbol @root_ns:root@1.0.0/onchain_four_felts_struct/__stack_pointer : ptr<byte, u8>
            v54 = hir.bitcast v53 : ptr<byte, i32>;
            hir.store v54, v52;
            v57 = hir.bitcast v46 : u32;
            v58 = arith.constant 4 : u32;
            v59 = arith.mod v57, v58 : u32;
            hir.assertz v59 #[code = 250];
            v60 = hir.int_to_ptr v57 : ptr<byte, i32>;
            v61 = hir.load v60 : i32;
            v63 = arith.constant 4 : i32;
            v62 = arith.constant 1 : i32;
            v55 = arith.constant 8 : i32;
            v56 = arith.add v52, v55 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/alloc::raw_vec::RawVecInner<A>::grow_amortized(v56, v46, v61, v62, v63, v63)
            v66 = arith.constant 8 : u32;
            v65 = hir.bitcast v52 : u32;
            v67 = arith.add v65, v66 : u32 #[overflow = checked];
            v759 = arith.constant 4 : u32;
            v69 = arith.mod v67, v759 : u32;
            hir.assertz v69 #[code = 250];
            v70 = hir.int_to_ptr v67 : ptr<byte, i32>;
            v71 = hir.load v70 : i32;
            v47 = arith.constant 0 : i32;
            v72 = arith.constant -2147483647 : i32;
            v73 = arith.eq v71, v72 : i1;
            v74 = arith.zext v73 : u32;
            v75 = hir.bitcast v74 : i32;
            v77 = arith.neq v75, v47 : i1;
            cf.cond_br v77 ^block10, ^block11;
        ^block10:
            v758 = arith.constant 16 : i32;
            v87 = arith.add v52, v758 : i32 #[overflow = wrapping];
            v88 = builtin.global_symbol @root_ns:root@1.0.0/onchain_four_felts_struct/__stack_pointer : ptr<byte, u8>
            v89 = hir.bitcast v88 : ptr<byte, i32>;
            hir.store v89, v87;
            builtin.ret ;
        ^block11:
            v79 = arith.constant 12 : u32;
            v78 = hir.bitcast v52 : u32;
            v80 = arith.add v78, v79 : u32 #[overflow = checked];
            v757 = arith.constant 4 : u32;
            v82 = arith.mod v80, v757 : u32;
            hir.assertz v82 #[code = 250];
            v83 = hir.int_to_ptr v80 : ptr<byte, i32>;
            v84 = hir.load v83 : i32;
            v85 = arith.constant 1048588 : i32;
            hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/alloc::raw_vec::handle_error(v71, v84, v85)
            ub.unreachable ;
        };

        public builtin.function @entrypoint(v90: i32, v91: i32) {
        ^block12(v90: i32, v91: i32):
            v94 = builtin.global_symbol @root_ns:root@1.0.0/onchain_four_felts_struct/__stack_pointer : ptr<byte, u8>
            v95 = hir.bitcast v94 : ptr<byte, i32>;
            v96 = hir.load v95 : i32;
            v97 = arith.constant 16 : i32;
            v98 = arith.sub v96, v97 : i32 #[overflow = wrapping];
            v99 = builtin.global_symbol @root_ns:root@1.0.0/onchain_four_felts_struct/__stack_pointer : ptr<byte, u8>
            v100 = hir.bitcast v99 : ptr<byte, i32>;
            hir.store v100, v98;
            v102 = arith.constant 12 : u32;
            v101 = hir.bitcast v91 : u32;
            v103 = arith.add v101, v102 : u32 #[overflow = checked];
            v104 = arith.constant 4 : u32;
            v105 = arith.mod v103, v104 : u32;
            hir.assertz v105 #[code = 250];
            v106 = hir.int_to_ptr v103 : ptr<byte, felt>;
            v107 = hir.load v106 : felt;
            v109 = arith.constant 8 : u32;
            v108 = hir.bitcast v91 : u32;
            v110 = arith.add v108, v109 : u32 #[overflow = checked];
            v777 = arith.constant 4 : u32;
            v112 = arith.mod v110, v777 : u32;
            hir.assertz v112 #[code = 250];
            v113 = hir.int_to_ptr v110 : ptr<byte, felt>;
            v114 = hir.load v113 : felt;
            v776 = arith.constant 4 : u32;
            v115 = hir.bitcast v91 : u32;
            v117 = arith.add v115, v776 : u32 #[overflow = checked];
            v775 = arith.constant 4 : u32;
            v119 = arith.mod v117, v775 : u32;
            hir.assertz v119 #[code = 250];
            v120 = hir.int_to_ptr v117 : ptr<byte, felt>;
            v121 = hir.load v120 : felt;
            v122 = hir.bitcast v91 : u32;
            v774 = arith.constant 4 : u32;
            v124 = arith.mod v122, v774 : u32;
            hir.assertz v124 #[code = 250];
            v125 = hir.int_to_ptr v122 : ptr<byte, felt>;
            v126 = hir.load v125 : felt;
            v129 = arith.constant 8 : i32;
            v127 = arith.constant 4 : i32;
            v128 = arith.add v98, v127 : i32 #[overflow = wrapping];
            v130 = arith.add v128, v129 : i32 #[overflow = wrapping];
            v132 = hir.bitcast v130 : u32;
            v773 = arith.constant 4 : u32;
            v134 = arith.mod v132, v773 : u32;
            hir.assertz v134 #[code = 250];
            v92 = arith.constant 0 : i32;
            v135 = hir.int_to_ptr v132 : ptr<byte, i32>;
            hir.store v135, v92;
            v772 = arith.constant 4 : u32;
            v137 = hir.bitcast v98 : u32;
            v139 = arith.add v137, v772 : u32 #[overflow = checked];
            v771 = arith.constant 4 : u32;
            v141 = arith.mod v139, v771 : u32;
            hir.assertz v141 #[code = 250];
            v136 = arith.constant 17179869184 : i64;
            v142 = hir.int_to_ptr v139 : ptr<byte, i64>;
            hir.store v142, v136;
            v770 = arith.constant 4 : i32;
            v144 = arith.add v98, v770 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/alloc::vec::Vec<T,A>::push(v144, v126)
            v769 = arith.constant 4 : i32;
            v146 = arith.add v98, v769 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/alloc::vec::Vec<T,A>::push(v146, v121)
            v768 = arith.constant 4 : i32;
            v148 = arith.add v98, v768 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/alloc::vec::Vec<T,A>::push(v148, v114)
            v767 = arith.constant 4 : i32;
            v150 = arith.add v98, v767 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/alloc::vec::Vec<T,A>::push(v150, v107)
            v153 = hir.bitcast v130 : u32;
            v766 = arith.constant 4 : u32;
            v155 = arith.mod v153, v766 : u32;
            hir.assertz v155 #[code = 250];
            v156 = hir.int_to_ptr v153 : ptr<byte, i32>;
            v157 = hir.load v156 : i32;
            v765 = arith.constant 8 : i32;
            v152 = arith.add v90, v765 : i32 #[overflow = wrapping];
            v158 = hir.bitcast v152 : u32;
            v764 = arith.constant 4 : u32;
            v160 = arith.mod v158, v764 : u32;
            hir.assertz v160 #[code = 250];
            v161 = hir.int_to_ptr v158 : ptr<byte, i32>;
            hir.store v161, v157;
            v763 = arith.constant 4 : u32;
            v162 = hir.bitcast v98 : u32;
            v164 = arith.add v162, v763 : u32 #[overflow = checked];
            v762 = arith.constant 4 : u32;
            v166 = arith.mod v164, v762 : u32;
            hir.assertz v166 #[code = 250];
            v167 = hir.int_to_ptr v164 : ptr<byte, i64>;
            v168 = hir.load v167 : i64;
            v169 = hir.bitcast v90 : u32;
            v761 = arith.constant 4 : u32;
            v171 = arith.mod v169, v761 : u32;
            hir.assertz v171 #[code = 250];
            v172 = hir.int_to_ptr v169 : ptr<byte, i64>;
            hir.store v172, v168;
            v760 = arith.constant 16 : i32;
            v174 = arith.add v98, v760 : i32 #[overflow = wrapping];
            v175 = builtin.global_symbol @root_ns:root@1.0.0/onchain_four_felts_struct/__stack_pointer : ptr<byte, u8>
            v176 = hir.bitcast v175 : ptr<byte, i32>;
            hir.store v176, v174;
            builtin.ret ;
        };

        private builtin.function @__rustc::__rust_alloc(v177: i32, v178: i32) -> i32 {
        ^block14(v177: i32, v178: i32):
            v180 = arith.constant 1048604 : i32;
            v181 = hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v180, v178, v177) : i32
            builtin.ret v181;
        };

        private builtin.function @__rustc::__rust_realloc(v182: i32, v183: i32, v184: i32, v185: i32) -> i32 {
        ^block16(v182: i32, v183: i32, v184: i32, v185: i32):
            v187 = arith.constant 1048604 : i32;
            v188 = hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v187, v184, v185) : i32
            v786 = arith.constant 0 : i32;
            v189 = arith.constant 0 : i32;
            v190 = arith.eq v188, v189 : i1;
            v191 = arith.zext v190 : u32;
            v192 = hir.bitcast v191 : i32;
            v194 = arith.neq v192, v786 : i1;
            scf.if v194{
            ^block18:
                scf.yield ;
            } else {
            ^block19:
                v785 = arith.constant 0 : i32;
                v196 = hir.bitcast v183 : u32;
                v195 = hir.bitcast v185 : u32;
                v197 = arith.lt v195, v196 : i1;
                v198 = arith.zext v197 : u32;
                v199 = hir.bitcast v198 : i32;
                v201 = arith.neq v199, v785 : i1;
                v202 = cf.select v201, v185, v183 : i32;
                v783 = arith.constant 0 : i32;
                v784 = arith.constant 0 : i32;
                v204 = arith.eq v202, v784 : i1;
                v205 = arith.zext v204 : u32;
                v206 = hir.bitcast v205 : i32;
                v208 = arith.neq v206, v783 : i1;
                scf.if v208{
                ^block82:
                    scf.yield ;
                } else {
                ^block20:
                    v209 = hir.bitcast v202 : u32;
                    v210 = hir.bitcast v188 : u32;
                    v211 = hir.int_to_ptr v210 : ptr<byte, u8>;
                    v212 = hir.bitcast v182 : u32;
                    v213 = hir.int_to_ptr v212 : ptr<byte, u8>;
                    hir.mem_cpy v213, v211, v209;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v188;
        };

        private builtin.function @__rustc::__rust_alloc_zeroed(v215: i32, v216: i32) -> i32 {
        ^block21(v215: i32, v216: i32):
            v218 = arith.constant 1048604 : i32;
            v219 = hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v218, v216, v215) : i32
            v795 = arith.constant 0 : i32;
            v220 = arith.constant 0 : i32;
            v221 = arith.eq v219, v220 : i1;
            v222 = arith.zext v221 : u32;
            v223 = hir.bitcast v222 : i32;
            v225 = arith.neq v223, v795 : i1;
            scf.if v225{
            ^block23:
                scf.yield ;
            } else {
            ^block24:
                v793 = arith.constant 0 : i32;
                v794 = arith.constant 0 : i32;
                v227 = arith.eq v215, v794 : i1;
                v228 = arith.zext v227 : u32;
                v229 = hir.bitcast v228 : i32;
                v231 = arith.neq v229, v793 : i1;
                scf.if v231{
                ^block85:
                    scf.yield ;
                } else {
                ^block25:
                    v787 = arith.constant 0 : u8;
                    v234 = hir.bitcast v215 : u32;
                    v235 = hir.bitcast v219 : u32;
                    v236 = hir.int_to_ptr v235 : ptr<byte, u8>;
                    hir.mem_set v236, v234, v787;
                    scf.yield ;
                };
                scf.yield ;
            };
            builtin.ret v219;
        };

        private builtin.function @__rustc::__rust_no_alloc_shim_is_unstable_v2() {
        ^block26:
            builtin.ret ;
        };

        private builtin.function @<miden_sdk_alloc::BumpAlloc as core::alloc::global::GlobalAlloc>::alloc(v238: i32, v239: i32, v240: i32) -> i32 {
        ^block28(v238: i32, v239: i32, v240: i32):
            v243 = arith.constant 16 : i32;
            v242 = arith.constant 0 : i32;
            v797 = arith.constant 16 : u32;
            v245 = hir.bitcast v239 : u32;
            v247 = arith.gt v245, v797 : i1;
            v248 = arith.zext v247 : u32;
            v249 = hir.bitcast v248 : i32;
            v251 = arith.neq v249, v242 : i1;
            v252 = cf.select v251, v239, v243 : i32;
            v837 = arith.constant 0 : i32;
            v253 = arith.constant -1 : i32;
            v254 = arith.add v252, v253 : i32 #[overflow = wrapping];
            v255 = arith.band v252, v254 : i32;
            v257 = arith.neq v255, v837 : i1;
            v806, v807 = scf.if v257 : i32, u32 {
            ^block90:
                v798 = arith.constant 0 : u32;
                v802 = ub.poison i32 : i32;
                scf.yield v802, v798;
            } else {
            ^block31:
                v259 = hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/core::ptr::alignment::Alignment::max(v239, v252) : i32
                v836 = arith.constant 0 : i32;
                v258 = arith.constant -2147483648 : i32;
                v260 = arith.sub v258, v259 : i32 #[overflow = wrapping];
                v262 = hir.bitcast v260 : u32;
                v261 = hir.bitcast v240 : u32;
                v263 = arith.gt v261, v262 : i1;
                v264 = arith.zext v263 : u32;
                v265 = hir.bitcast v264 : i32;
                v267 = arith.neq v265, v836 : i1;
                v821 = scf.if v267 : i32 {
                ^block89:
                    v835 = ub.poison i32 : i32;
                    scf.yield v835;
                } else {
                ^block32:
                    v833 = arith.constant 0 : i32;
                    v273 = arith.sub v833, v259 : i32 #[overflow = wrapping];
                    v834 = arith.constant -1 : i32;
                    v269 = arith.add v240, v259 : i32 #[overflow = wrapping];
                    v271 = arith.add v269, v834 : i32 #[overflow = wrapping];
                    v274 = arith.band v271, v273 : i32;
                    v275 = hir.bitcast v238 : u32;
                    v276 = arith.constant 4 : u32;
                    v277 = arith.mod v275, v276 : u32;
                    hir.assertz v277 #[code = 250];
                    v278 = hir.int_to_ptr v275 : ptr<byte, i32>;
                    v279 = hir.load v278 : i32;
                    v832 = arith.constant 0 : i32;
                    v281 = arith.neq v279, v832 : i1;
                    scf.if v281{
                    ^block88:
                        scf.yield ;
                    } else {
                    ^block34:
                        v282 = hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/intrinsics::mem::heap_base() : i32
                        v283 = hir.mem_size  : u32;
                        v289 = hir.bitcast v238 : u32;
                        v831 = arith.constant 4 : u32;
                        v291 = arith.mod v289, v831 : u32;
                        hir.assertz v291 #[code = 250];
                        v830 = arith.constant 16 : u32;
                        v284 = hir.bitcast v283 : i32;
                        v287 = arith.shl v284, v830 : i32;
                        v288 = arith.add v282, v287 : i32 #[overflow = wrapping];
                        v292 = hir.int_to_ptr v289 : ptr<byte, i32>;
                        hir.store v292, v288;
                        scf.yield ;
                    };
                    v295 = hir.bitcast v238 : u32;
                    v829 = arith.constant 4 : u32;
                    v297 = arith.mod v295, v829 : u32;
                    hir.assertz v297 #[code = 250];
                    v298 = hir.int_to_ptr v295 : ptr<byte, i32>;
                    v299 = hir.load v298 : i32;
                    v827 = arith.constant 0 : i32;
                    v828 = arith.constant -1 : i32;
                    v301 = arith.bxor v299, v828 : i32;
                    v303 = hir.bitcast v301 : u32;
                    v302 = hir.bitcast v274 : u32;
                    v304 = arith.gt v302, v303 : i1;
                    v305 = arith.zext v304 : u32;
                    v306 = hir.bitcast v305 : i32;
                    v308 = arith.neq v306, v827 : i1;
                    v820 = scf.if v308 : i32 {
                    ^block35:
                        v826 = arith.constant 0 : i32;
                        scf.yield v826;
                    } else {
                    ^block36:
                        v310 = hir.bitcast v238 : u32;
                        v825 = arith.constant 4 : u32;
                        v312 = arith.mod v310, v825 : u32;
                        hir.assertz v312 #[code = 250];
                        v309 = arith.add v299, v274 : i32 #[overflow = wrapping];
                        v313 = hir.int_to_ptr v310 : ptr<byte, i32>;
                        hir.store v313, v309;
                        v315 = arith.add v299, v259 : i32 #[overflow = wrapping];
                        scf.yield v315;
                    };
                    scf.yield v820;
                };
                v803 = arith.constant 1 : u32;
                v824 = arith.constant 0 : u32;
                v822 = cf.select v267, v824, v803 : u32;
                scf.yield v821, v822;
            };
            v823 = arith.constant 0 : u32;
            v819 = arith.eq v807, v823 : i1;
            cf.cond_br v819 ^block30, ^block92(v806);
        ^block30:
            ub.unreachable ;
        ^block92(v799: i32):
            builtin.ret v799;
        };

        private builtin.function @intrinsics::mem::heap_base() -> i32 {
        ^block37:
            v318 = hir.exec @intrinsics/mem/heap_base() : i32
            builtin.ret v318;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::grow_amortized(v320: i32, v321: i32, v322: i32, v323: i32, v324: i32, v325: i32) {
        ^block41(v320: i32, v321: i32, v322: i32, v323: i32, v324: i32, v325: i32):
            v328 = builtin.global_symbol @root_ns:root@1.0.0/onchain_four_felts_struct/__stack_pointer : ptr<byte, u8>
            v329 = hir.bitcast v328 : ptr<byte, i32>;
            v330 = hir.load v329 : i32;
            v331 = arith.constant 32 : i32;
            v332 = arith.sub v330, v331 : i32 #[overflow = wrapping];
            v333 = builtin.global_symbol @root_ns:root@1.0.0/onchain_four_felts_struct/__stack_pointer : ptr<byte, u8>
            v334 = hir.bitcast v333 : ptr<byte, i32>;
            hir.store v334, v332;
            v914 = arith.constant 0 : i32;
            v326 = arith.constant 0 : i32;
            v337 = arith.eq v325, v326 : i1;
            v338 = arith.zext v337 : u32;
            v339 = hir.bitcast v338 : i32;
            v341 = arith.neq v339, v914 : i1;
            v885, v886 = scf.if v341 : i32, i32 {
            ^block44:
                v913 = arith.constant 0 : i32;
                scf.yield v913, v913;
            } else {
            ^block45:
                v342 = arith.add v322, v323 : i32 #[overflow = wrapping];
                v912 = arith.constant 0 : i32;
                v344 = hir.bitcast v322 : u32;
                v343 = hir.bitcast v342 : u32;
                v345 = arith.lt v343, v344 : i1;
                v346 = arith.zext v345 : u32;
                v347 = hir.bitcast v346 : i32;
                v349 = arith.neq v347, v912 : i1;
                v883, v884 = scf.if v349 : i32, i32 {
                ^block98:
                    v911 = arith.constant 0 : i32;
                    scf.yield v911, v911;
                } else {
                ^block46:
                    v360 = hir.bitcast v321 : u32;
                    v474 = arith.constant 4 : u32;
                    v362 = arith.mod v360, v474 : u32;
                    hir.assertz v362 #[code = 250];
                    v363 = hir.int_to_ptr v360 : ptr<byte, i32>;
                    v364 = hir.load v363 : i32;
                    v839 = arith.constant 1 : u32;
                    v367 = arith.shl v364, v839 : i32;
                    v910 = arith.constant 0 : i32;
                    v369 = hir.bitcast v367 : u32;
                    v368 = hir.bitcast v342 : u32;
                    v370 = arith.gt v368, v369 : i1;
                    v371 = arith.zext v370 : u32;
                    v372 = hir.bitcast v371 : i32;
                    v374 = arith.neq v372, v910 : i1;
                    v375 = cf.select v374, v342, v367 : i32;
                    v907 = arith.constant 1 : i32;
                    v377 = arith.constant 4 : i32;
                    v908 = arith.constant 0 : i32;
                    v838 = arith.constant 1025 : u32;
                    v380 = hir.bitcast v325 : u32;
                    v382 = arith.lt v380, v838 : i1;
                    v383 = arith.zext v382 : u32;
                    v384 = hir.bitcast v383 : i32;
                    v386 = arith.neq v384, v908 : i1;
                    v387 = cf.select v386, v377, v907 : i32;
                    v376 = arith.constant 8 : i32;
                    v909 = arith.constant 0 : i32;
                    v365 = arith.constant 1 : i32;
                    v389 = arith.eq v325, v365 : i1;
                    v390 = arith.zext v389 : u32;
                    v391 = hir.bitcast v390 : i32;
                    v393 = arith.neq v391, v909 : i1;
                    v394 = cf.select v393, v376, v387 : i32;
                    v906 = arith.constant 0 : i32;
                    v396 = hir.bitcast v394 : u32;
                    v395 = hir.bitcast v375 : u32;
                    v397 = arith.gt v395, v396 : i1;
                    v398 = arith.zext v397 : u32;
                    v399 = hir.bitcast v398 : i32;
                    v401 = arith.neq v399, v906 : i1;
                    v402 = cf.select v401, v375, v394 : i32;
                    v403 = hir.bitcast v402 : u32;
                    v404 = arith.zext v403 : u64;
                    v405 = hir.bitcast v404 : i64;
                    v905 = arith.constant 0 : i32;
                    v355 = arith.sub v905, v324 : i32 #[overflow = wrapping];
                    v352 = arith.constant -1 : i32;
                    v351 = arith.add v324, v325 : i32 #[overflow = wrapping];
                    v353 = arith.add v351, v352 : i32 #[overflow = wrapping];
                    v356 = arith.band v353, v355 : i32;
                    v357 = hir.bitcast v356 : u32;
                    v358 = arith.zext v357 : u64;
                    v359 = hir.bitcast v358 : i64;
                    v406 = arith.mul v359, v405 : i64 #[overflow = wrapping];
                    v904 = arith.constant 0 : i32;
                    v407 = arith.constant 32 : i64;
                    v409 = hir.cast v407 : u32;
                    v408 = hir.bitcast v406 : u64;
                    v410 = arith.shr v408, v409 : u64;
                    v411 = hir.bitcast v410 : i64;
                    v412 = arith.trunc v411 : i32;
                    v414 = arith.neq v412, v904 : i1;
                    v881, v882 = scf.if v414 : i32, i32 {
                    ^block97:
                        v903 = arith.constant 0 : i32;
                        scf.yield v375, v903;
                    } else {
                    ^block47:
                        v415 = arith.trunc v406 : i32;
                        v902 = arith.constant 0 : i32;
                        v416 = arith.constant -2147483648 : i32;
                        v417 = arith.sub v416, v324 : i32 #[overflow = wrapping];
                        v419 = hir.bitcast v417 : u32;
                        v418 = hir.bitcast v415 : u32;
                        v420 = arith.gt v418, v419 : i1;
                        v421 = arith.zext v420 : u32;
                        v422 = hir.bitcast v421 : i32;
                        v424 = arith.neq v422, v902 : i1;
                        v879, v880 = scf.if v424 : i32, i32 {
                        ^block96:
                            v901 = arith.constant 0 : i32;
                            scf.yield v375, v901;
                        } else {
                        ^block48:
                            v425 = arith.constant 20 : i32;
                            v426 = arith.add v332, v425 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/alloc::raw_vec::RawVecInner<A>::current_memory(v426, v321, v324, v325)
                            v899 = arith.constant 20 : i32;
                            v430 = arith.add v332, v899 : i32 #[overflow = wrapping];
                            v900 = arith.constant 8 : i32;
                            v428 = arith.add v332, v900 : i32 #[overflow = wrapping];
                            hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/alloc::raw_vec::finish_grow(v428, v324, v415, v430, v320)
                            v432 = arith.constant 12 : u32;
                            v431 = hir.bitcast v332 : u32;
                            v433 = arith.add v431, v432 : u32 #[overflow = checked];
                            v898 = arith.constant 4 : u32;
                            v435 = arith.mod v433, v898 : u32;
                            hir.assertz v435 #[code = 250];
                            v436 = hir.int_to_ptr v433 : ptr<byte, i32>;
                            v437 = hir.load v436 : i32;
                            v439 = arith.constant 8 : u32;
                            v438 = hir.bitcast v332 : u32;
                            v440 = arith.add v438, v439 : u32 #[overflow = checked];
                            v897 = arith.constant 4 : u32;
                            v442 = arith.mod v440, v897 : u32;
                            hir.assertz v442 #[code = 250];
                            v443 = hir.int_to_ptr v440 : ptr<byte, i32>;
                            v444 = hir.load v443 : i32;
                            v895 = arith.constant 0 : i32;
                            v896 = arith.constant 0 : i32;
                            v446 = arith.eq v444, v896 : i1;
                            v447 = arith.zext v446 : u32;
                            v448 = hir.bitcast v447 : i32;
                            v450 = arith.neq v448, v895 : i1;
                            v877 = scf.if v450 : i32 {
                            ^block49:
                                v458 = hir.bitcast v321 : u32;
                                v894 = arith.constant 4 : u32;
                                v460 = arith.mod v458, v894 : u32;
                                hir.assertz v460 #[code = 250];
                                v461 = hir.int_to_ptr v458 : ptr<byte, i32>;
                                hir.store v461, v402;
                                v893 = arith.constant 4 : u32;
                                v462 = hir.bitcast v321 : u32;
                                v464 = arith.add v462, v893 : u32 #[overflow = checked];
                                v892 = arith.constant 4 : u32;
                                v466 = arith.mod v464, v892 : u32;
                                hir.assertz v466 #[code = 250];
                                v467 = hir.int_to_ptr v464 : ptr<byte, i32>;
                                hir.store v467, v437;
                                scf.yield v375;
                            } else {
                            ^block50:
                                v452 = arith.constant 16 : u32;
                                v451 = hir.bitcast v332 : u32;
                                v453 = arith.add v451, v452 : u32 #[overflow = checked];
                                v891 = arith.constant 4 : u32;
                                v455 = arith.mod v453, v891 : u32;
                                hir.assertz v455 #[code = 250];
                                v456 = hir.int_to_ptr v453 : ptr<byte, i32>;
                                v457 = hir.load v456 : i32;
                                scf.yield v457;
                            };
                            v468 = arith.constant -2147483647 : i32;
                            v878 = cf.select v450, v468, v437 : i32;
                            scf.yield v877, v878;
                        };
                        scf.yield v879, v880;
                    };
                    scf.yield v881, v882;
                };
                scf.yield v883, v884;
            };
            v890 = arith.constant 4 : u32;
            v473 = hir.bitcast v320 : u32;
            v475 = arith.add v473, v890 : u32 #[overflow = checked];
            v889 = arith.constant 4 : u32;
            v477 = arith.mod v475, v889 : u32;
            hir.assertz v477 #[code = 250];
            v478 = hir.int_to_ptr v475 : ptr<byte, i32>;
            hir.store v478, v885;
            v481 = hir.bitcast v320 : u32;
            v888 = arith.constant 4 : u32;
            v483 = arith.mod v481, v888 : u32;
            hir.assertz v483 #[code = 250];
            v484 = hir.int_to_ptr v481 : ptr<byte, i32>;
            hir.store v484, v886;
            v887 = arith.constant 32 : i32;
            v488 = arith.add v332, v887 : i32 #[overflow = wrapping];
            v489 = builtin.global_symbol @root_ns:root@1.0.0/onchain_four_felts_struct/__stack_pointer : ptr<byte, u8>
            v490 = hir.bitcast v489 : ptr<byte, i32>;
            hir.store v490, v488;
            builtin.ret ;
        };

        private builtin.function @<alloc::alloc::Global as core::alloc::Allocator>::allocate(v491: i32, v492: i32, v493: i32) {
        ^block51(v491: i32, v492: i32, v493: i32):
            v495 = builtin.global_symbol @root_ns:root@1.0.0/onchain_four_felts_struct/__stack_pointer : ptr<byte, u8>
            v496 = hir.bitcast v495 : ptr<byte, i32>;
            v497 = hir.load v496 : i32;
            v498 = arith.constant 16 : i32;
            v499 = arith.sub v497, v498 : i32 #[overflow = wrapping];
            v500 = builtin.global_symbol @root_ns:root@1.0.0/onchain_four_felts_struct/__stack_pointer : ptr<byte, u8>
            v501 = hir.bitcast v500 : ptr<byte, i32>;
            hir.store v501, v499;
            v494 = arith.constant 0 : i32;
            v502 = arith.constant 8 : i32;
            v503 = arith.add v499, v502 : i32 #[overflow = wrapping];
            hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/alloc::alloc::Global::alloc_impl(v503, v492, v493, v494)
            v506 = arith.constant 12 : u32;
            v505 = hir.bitcast v499 : u32;
            v507 = arith.add v505, v506 : u32 #[overflow = checked];
            v508 = arith.constant 4 : u32;
            v509 = arith.mod v507, v508 : u32;
            hir.assertz v509 #[code = 250];
            v510 = hir.int_to_ptr v507 : ptr<byte, i32>;
            v511 = hir.load v510 : i32;
            v513 = arith.constant 8 : u32;
            v512 = hir.bitcast v499 : u32;
            v514 = arith.add v512, v513 : u32 #[overflow = checked];
            v919 = arith.constant 4 : u32;
            v516 = arith.mod v514, v919 : u32;
            hir.assertz v516 #[code = 250];
            v517 = hir.int_to_ptr v514 : ptr<byte, i32>;
            v518 = hir.load v517 : i32;
            v519 = hir.bitcast v491 : u32;
            v918 = arith.constant 4 : u32;
            v521 = arith.mod v519, v918 : u32;
            hir.assertz v521 #[code = 250];
            v522 = hir.int_to_ptr v519 : ptr<byte, i32>;
            hir.store v522, v518;
            v917 = arith.constant 4 : u32;
            v523 = hir.bitcast v491 : u32;
            v525 = arith.add v523, v917 : u32 #[overflow = checked];
            v916 = arith.constant 4 : u32;
            v527 = arith.mod v525, v916 : u32;
            hir.assertz v527 #[code = 250];
            v528 = hir.int_to_ptr v525 : ptr<byte, i32>;
            hir.store v528, v511;
            v915 = arith.constant 16 : i32;
            v530 = arith.add v499, v915 : i32 #[overflow = wrapping];
            v531 = builtin.global_symbol @root_ns:root@1.0.0/onchain_four_felts_struct/__stack_pointer : ptr<byte, u8>
            v532 = hir.bitcast v531 : ptr<byte, i32>;
            hir.store v532, v530;
            builtin.ret ;
        };

        private builtin.function @alloc::alloc::Global::alloc_impl(v533: i32, v534: i32, v535: i32, v536: i32) {
        ^block53(v533: i32, v534: i32, v535: i32, v536: i32):
            v935 = arith.constant 0 : i32;
            v537 = arith.constant 0 : i32;
            v538 = arith.eq v535, v537 : i1;
            v539 = arith.zext v538 : u32;
            v540 = hir.bitcast v539 : i32;
            v542 = arith.neq v540, v935 : i1;
            v931 = scf.if v542 : i32 {
            ^block104:
                scf.yield v534;
            } else {
            ^block56:
                hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/__rustc::__rust_no_alloc_shim_is_unstable_v2()
                v934 = arith.constant 0 : i32;
                v544 = arith.neq v536, v934 : i1;
                v930 = scf.if v544 : i32 {
                ^block57:
                    v546 = hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/__rustc::__rust_alloc_zeroed(v535, v534) : i32
                    scf.yield v546;
                } else {
                ^block58:
                    v545 = hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/__rustc::__rust_alloc(v535, v534) : i32
                    scf.yield v545;
                };
                scf.yield v930;
            };
            v550 = arith.constant 4 : u32;
            v549 = hir.bitcast v533 : u32;
            v551 = arith.add v549, v550 : u32 #[overflow = checked];
            v933 = arith.constant 4 : u32;
            v553 = arith.mod v551, v933 : u32;
            hir.assertz v553 #[code = 250];
            v554 = hir.int_to_ptr v551 : ptr<byte, i32>;
            hir.store v554, v535;
            v556 = hir.bitcast v533 : u32;
            v932 = arith.constant 4 : u32;
            v558 = arith.mod v556, v932 : u32;
            hir.assertz v558 #[code = 250];
            v559 = hir.int_to_ptr v556 : ptr<byte, i32>;
            hir.store v559, v931;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::RawVecInner<A>::current_memory(v560: i32, v561: i32, v562: i32, v563: i32) {
        ^block59(v560: i32, v561: i32, v562: i32, v563: i32):
            v961 = arith.constant 0 : i32;
            v564 = arith.constant 0 : i32;
            v568 = arith.eq v563, v564 : i1;
            v569 = arith.zext v568 : u32;
            v570 = hir.bitcast v569 : i32;
            v572 = arith.neq v570, v961 : i1;
            v948, v949 = scf.if v572 : i32, i32 {
            ^block108:
                v960 = arith.constant 0 : i32;
                v566 = arith.constant 4 : i32;
                scf.yield v566, v960;
            } else {
            ^block62:
                v573 = hir.bitcast v561 : u32;
                v608 = arith.constant 4 : u32;
                v575 = arith.mod v573, v608 : u32;
                hir.assertz v575 #[code = 250];
                v576 = hir.int_to_ptr v573 : ptr<byte, i32>;
                v577 = hir.load v576 : i32;
                v958 = arith.constant 0 : i32;
                v959 = arith.constant 0 : i32;
                v579 = arith.eq v577, v959 : i1;
                v580 = arith.zext v579 : u32;
                v581 = hir.bitcast v580 : i32;
                v583 = arith.neq v581, v958 : i1;
                v946 = scf.if v583 : i32 {
                ^block107:
                    v957 = arith.constant 0 : i32;
                    scf.yield v957;
                } else {
                ^block63:
                    v956 = arith.constant 4 : u32;
                    v584 = hir.bitcast v560 : u32;
                    v586 = arith.add v584, v956 : u32 #[overflow = checked];
                    v955 = arith.constant 4 : u32;
                    v588 = arith.mod v586, v955 : u32;
                    hir.assertz v588 #[code = 250];
                    v589 = hir.int_to_ptr v586 : ptr<byte, i32>;
                    hir.store v589, v562;
                    v954 = arith.constant 4 : u32;
                    v590 = hir.bitcast v561 : u32;
                    v592 = arith.add v590, v954 : u32 #[overflow = checked];
                    v953 = arith.constant 4 : u32;
                    v594 = arith.mod v592, v953 : u32;
                    hir.assertz v594 #[code = 250];
                    v595 = hir.int_to_ptr v592 : ptr<byte, i32>;
                    v596 = hir.load v595 : i32;
                    v597 = hir.bitcast v560 : u32;
                    v952 = arith.constant 4 : u32;
                    v599 = arith.mod v597, v952 : u32;
                    hir.assertz v599 #[code = 250];
                    v600 = hir.int_to_ptr v597 : ptr<byte, i32>;
                    hir.store v600, v596;
                    v601 = arith.mul v577, v563 : i32 #[overflow = wrapping];
                    scf.yield v601;
                };
                v602 = arith.constant 8 : i32;
                v951 = arith.constant 4 : i32;
                v947 = cf.select v583, v951, v602 : i32;
                scf.yield v947, v946;
            };
            v605 = arith.add v560, v948 : i32 #[overflow = wrapping];
            v607 = hir.bitcast v605 : u32;
            v950 = arith.constant 4 : u32;
            v609 = arith.mod v607, v950 : u32;
            hir.assertz v609 #[code = 250];
            v610 = hir.int_to_ptr v607 : ptr<byte, i32>;
            hir.store v610, v949;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::finish_grow(v611: i32, v612: i32, v613: i32, v614: i32, v615: i32) {
        ^block64(v611: i32, v612: i32, v613: i32, v614: i32, v615: i32):
            v617 = builtin.global_symbol @root_ns:root@1.0.0/onchain_four_felts_struct/__stack_pointer : ptr<byte, u8>
            v618 = hir.bitcast v617 : ptr<byte, i32>;
            v619 = hir.load v618 : i32;
            v620 = arith.constant 16 : i32;
            v621 = arith.sub v619, v620 : i32 #[overflow = wrapping];
            v622 = builtin.global_symbol @root_ns:root@1.0.0/onchain_four_felts_struct/__stack_pointer : ptr<byte, u8>
            v623 = hir.bitcast v622 : ptr<byte, i32>;
            hir.store v623, v621;
            v1016 = arith.constant 0 : i32;
            v616 = arith.constant 0 : i32;
            v626 = arith.gte v613, v616 : i1;
            v627 = arith.zext v626 : u32;
            v628 = hir.bitcast v627 : i32;
            v630 = arith.neq v628, v1016 : i1;
            v990, v991 = scf.if v630 : i32, i32 {
            ^block67:
                v717 = arith.constant 4 : u32;
                v633 = hir.bitcast v614 : u32;
                v635 = arith.add v633, v717 : u32 #[overflow = checked];
                v1015 = arith.constant 4 : u32;
                v637 = arith.mod v635, v1015 : u32;
                hir.assertz v637 #[code = 250];
                v638 = hir.int_to_ptr v635 : ptr<byte, i32>;
                v639 = hir.load v638 : i32;
                v1013 = arith.constant 0 : i32;
                v1014 = arith.constant 0 : i32;
                v641 = arith.eq v639, v1014 : i1;
                v642 = arith.zext v641 : u32;
                v643 = hir.bitcast v642 : i32;
                v645 = arith.neq v643, v1013 : i1;
                v988, v989 = scf.if v645 : i32, i32 {
                ^block70:
                    hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/<alloc::alloc::Global as core::alloc::Allocator>::allocate(v621, v612, v613)
                    v1012 = arith.constant 4 : u32;
                    v678 = hir.bitcast v621 : u32;
                    v680 = arith.add v678, v1012 : u32 #[overflow = checked];
                    v1011 = arith.constant 4 : u32;
                    v682 = arith.mod v680, v1011 : u32;
                    hir.assertz v682 #[code = 250];
                    v683 = hir.int_to_ptr v680 : ptr<byte, i32>;
                    v684 = hir.load v683 : i32;
                    v685 = hir.bitcast v621 : u32;
                    v1010 = arith.constant 4 : u32;
                    v687 = arith.mod v685, v1010 : u32;
                    hir.assertz v687 #[code = 250];
                    v688 = hir.int_to_ptr v685 : ptr<byte, i32>;
                    v689 = hir.load v688 : i32;
                    scf.yield v689, v684;
                } else {
                ^block71:
                    v647 = arith.constant 8 : u32;
                    v646 = hir.bitcast v614 : u32;
                    v648 = arith.add v646, v647 : u32 #[overflow = checked];
                    v1009 = arith.constant 4 : u32;
                    v650 = arith.mod v648, v1009 : u32;
                    hir.assertz v650 #[code = 250];
                    v651 = hir.int_to_ptr v648 : ptr<byte, i32>;
                    v652 = hir.load v651 : i32;
                    v1008 = arith.constant 0 : i32;
                    v654 = arith.neq v652, v1008 : i1;
                    v986, v987 = scf.if v654 : i32, i32 {
                    ^block72:
                        v672 = hir.bitcast v614 : u32;
                        v1007 = arith.constant 4 : u32;
                        v674 = arith.mod v672, v1007 : u32;
                        hir.assertz v674 #[code = 250];
                        v675 = hir.int_to_ptr v672 : ptr<byte, i32>;
                        v676 = hir.load v675 : i32;
                        v677 = hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/__rustc::__rust_realloc(v676, v652, v612, v613) : i32
                        scf.yield v677, v613;
                    } else {
                    ^block73:
                        v1006 = arith.constant 0 : i32;
                        v711 = arith.constant 8 : i32;
                        v656 = arith.add v621, v711 : i32 #[overflow = wrapping];
                        hir.exec @root_ns:root@1.0.0/onchain_four_felts_struct/alloc::alloc::Global::alloc_impl(v656, v612, v613, v1006)
                        v659 = arith.constant 12 : u32;
                        v658 = hir.bitcast v621 : u32;
                        v660 = arith.add v658, v659 : u32 #[overflow = checked];
                        v1005 = arith.constant 4 : u32;
                        v662 = arith.mod v660, v1005 : u32;
                        hir.assertz v662 #[code = 250];
                        v663 = hir.int_to_ptr v660 : ptr<byte, i32>;
                        v664 = hir.load v663 : i32;
                        v1004 = arith.constant 8 : u32;
                        v665 = hir.bitcast v621 : u32;
                        v667 = arith.add v665, v1004 : u32 #[overflow = checked];
                        v1003 = arith.constant 4 : u32;
                        v669 = arith.mod v667, v1003 : u32;
                        hir.assertz v669 #[code = 250];
                        v670 = hir.int_to_ptr v667 : ptr<byte, i32>;
                        v671 = hir.load v670 : i32;
                        scf.yield v671, v664;
                    };
                    scf.yield v986, v987;
                };
                v1002 = arith.constant 4 : u32;
                v696 = hir.bitcast v611 : u32;
                v698 = arith.add v696, v1002 : u32 #[overflow = checked];
                v1001 = arith.constant 4 : u32;
                v700 = arith.mod v698, v1001 : u32;
                hir.assertz v700 #[code = 250];
                v1000 = arith.constant 0 : i32;
                v694 = arith.neq v988, v1000 : i1;
                v695 = cf.select v694, v988, v612 : i32;
                v701 = hir.int_to_ptr v698 : ptr<byte, i32>;
                hir.store v701, v695;
                v998 = arith.constant 0 : i32;
                v708 = arith.eq v988, v998 : i1;
                v709 = arith.zext v708 : u32;
                v710 = hir.bitcast v709 : i32;
                v999 = arith.constant 0 : i32;
                v705 = arith.neq v988, v999 : i1;
                v706 = cf.select v705, v989, v613 : i32;
                scf.yield v706, v710;
            } else {
            ^block68:
                v631 = arith.constant 1 : i32;
                v997 = arith.constant 0 : i32;
                scf.yield v997, v631;
            };
            v632 = arith.constant 4 : i32;
            v996 = arith.constant 8 : i32;
            v992 = cf.select v630, v996, v632 : i32;
            v714 = arith.add v611, v992 : i32 #[overflow = wrapping];
            v716 = hir.bitcast v714 : u32;
            v995 = arith.constant 4 : u32;
            v718 = arith.mod v716, v995 : u32;
            hir.assertz v718 #[code = 250];
            v719 = hir.int_to_ptr v716 : ptr<byte, i32>;
            hir.store v719, v990;
            v721 = hir.bitcast v611 : u32;
            v994 = arith.constant 4 : u32;
            v723 = arith.mod v721, v994 : u32;
            hir.assertz v723 #[code = 250];
            v724 = hir.int_to_ptr v721 : ptr<byte, i32>;
            hir.store v724, v991;
            v993 = arith.constant 16 : i32;
            v728 = arith.add v621, v993 : i32 #[overflow = wrapping];
            v729 = builtin.global_symbol @root_ns:root@1.0.0/onchain_four_felts_struct/__stack_pointer : ptr<byte, u8>
            v730 = hir.bitcast v729 : ptr<byte, i32>;
            hir.store v730, v728;
            builtin.ret ;
        };

        private builtin.function @alloc::raw_vec::handle_error(v731: i32, v732: i32, v733: i32) {
        ^block74(v731: i32, v732: i32, v733: i32):
            ub.unreachable ;
        };

        private builtin.function @core::ptr::alignment::Alignment::max(v734: i32, v735: i32) -> i32 {
        ^block76(v734: i32, v735: i32):
            v742 = arith.constant 0 : i32;
            v738 = hir.bitcast v735 : u32;
            v737 = hir.bitcast v734 : u32;
            v739 = arith.gt v737, v738 : i1;
            v740 = arith.zext v739 : u32;
            v741 = hir.bitcast v740 : i32;
            v743 = arith.neq v741, v742 : i1;
            v744 = cf.select v743, v734, v735 : i32;
            builtin.ret v744;
        };

        builtin.global_variable private @#__stack_pointer : i32 {
            builtin.ret_imm 1048576;
        };

        builtin.segment readonly @1048576 = 0x00000000000000000000000a0010000000003e64657463616465723c;
    };
};