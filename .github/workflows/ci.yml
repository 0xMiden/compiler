name: CI

permissions:
  contents: read

on:
  workflow_dispatch:
  push:
    branches:
      - main
      - next
    paths-ignore:
      - "**.md"
      - "**.txt"
      - "docs/**"
  pull_request:
    paths-ignore:
      - "**.md"
      - "**.txt"
      - "docs/**"

env:
  # Set the new value when the cache grows too much and we hit the runner's disk space limit
  # via https://github.com/rust-lang/docs.rs/pull/2433
  RUST_CACHE_KEY: rust-cache-20250528

jobs:
  lint:
    name: lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      - name: Install Rust
        run: |
          rustup update --no-self-update
          rustc --version
      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          # Use a common cache for the basic compilation/formatter/clippy checks
          shared-key: ${{ github.workflow }}-shared
          prefix-key: ${{ env.RUST_CACHE_KEY }}
          save-if: ${{ github.ref == 'refs/heads/next' }}
      - name: Install cargo-make
        run: |
          if ! cargo make --version 2>/dev/null; then
            cargo install cargo-make --force
          fi
      - name: Clippy
        run: |
          cargo make clippy

  check_format:
    name: check formatting
    runs-on: ubuntu-latest
    # Run this job after the linter, so the cache is hot
    needs: [lint]
    # But run this check even if the lint check failed
    if: ${{ always() }}
    steps:
      - uses: actions/checkout@v5
      - name: Install Rust
        run: |
          rustup update --no-self-update
          rustc --version
      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          # Use a common cache for the basic compilation/formatter/clippy checks
          shared-key: ${{ github.workflow }}-shared
          prefix-key: ${{ env.RUST_CACHE_KEY }}
          # But do not save this cache, just use it
          save-if: false
      - name: Install cargo-make
        run: |
          if ! cargo make --version 2>/dev/null; then
            cargo install cargo-make --force
          fi
      - name: Check Formatting
        run: |
          cargo make check-format

  unit_tests:
    name: midenc unit tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      - name: Install Rust
        run: |
          rustup update --no-self-update
          rustc --version
      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          # NOTE: We use a different cache for the tests, so they can be run in parallel, but we
          # also share the cache for the tests for efficiency
          shared-key: ${{ github.workflow }}-shared-tests
          prefix-key: ${{ env.RUST_CACHE_KEY }}
          save-if: ${{ github.ref == 'refs/heads/next' }}
      - name: Install cargo-make
        run: |
          if ! cargo make --version 2>/dev/null; then
            cargo install cargo-make --force
          fi
      - name: Check
        # We run `cargo check` to verify that the workspace compiles correctly before attempting
        # to execute the tests from each crate. This produces easier to read output if a compilation
        # error occurs
        run: |
          cargo make check --tests
      - name: Test
        run: |
          cargo make test -E 'not (package(miden-integration-tests) or package(miden-integration-node-tests) or package(cargo-miden))'

  check_release:
    name: release checks
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      - name: Install Rust
        run: |
          rustup update --no-self-update
          rustc --version
      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          # NOTE: We use a different cache for the these release checks
          shared-key: ${{ github.workflow }}-shared-release-checks
          prefix-key: ${{ env.RUST_CACHE_KEY }}
          save-if: ${{ github.ref == 'refs/heads/next' }}
      - name: Install cargo-make
        run: |
          if ! cargo make --version 2>/dev/null; then
            cargo install cargo-make --force
          fi
      - name: Check(release)
        # We run `check` with `--release` to check the release build (without
        # `debug_assertions`, etc.)
        run: |
          cargo make check --release --tests
      - name: Check each member (release)
        # To uncover any compilation errors hidden by the workspace feature
        # unification and avoid surprises on publishing the crates.
        run: |
          cargo make check-each --release --all-features

  midenc_integration_tests:
    name: midenc integration tests
    runs-on: ubuntu-latest
    # We only want to run the integration tests if the unit tests pass, and that has the added
    # benefit that we can re-use the cache from the unit test job for all integration tests
    needs: [unit_tests]
    steps:
      - uses: actions/checkout@v5
      - name: Install Rust
        run: |
          rustup update --no-self-update
          rustc --version
      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: ${{ github.workflow }}-shared-tests
          prefix-key: ${{ env.RUST_CACHE_KEY }}
          # Do not persist the cache, leave that to the unit tests, we just use the cache here
          save-if: false
      - name: Install cargo-make
        run: |
          if ! cargo make --version 2>/dev/null; then
            cargo install cargo-make --force
          fi
      - name: Test
        # Skip some tests cause they are a space hog and run them in the separate job
        run: |
          cargo make test -E 'package(miden-integration-tests) - test(~rust_masm_tests::examples)'


  midenc_integration_tests_examples:
    name: midenc integration tests
    runs-on: ubuntu-latest
    # We only want to run the integration tests if the unit tests pass, and that has the added
    # benefit that we can re-use the cache from the unit test job for all integration tests
    needs: [unit_tests]
    steps:
      - uses: actions/checkout@v5
      - name: Install Rust
        run: |
          rustup update --no-self-update
          rustc --version
      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: ${{ github.workflow }}-shared-tests
          prefix-key: ${{ env.RUST_CACHE_KEY }}
          # Do not persist the cache, leave that to the unit tests, we just use the cache here
          save-if: false
      - name: Install cargo-make
        run: |
          if ! cargo make --version 2>/dev/null; then
            cargo install cargo-make --force
          fi
      - name: Test
        # Skip some tests cause they are a space hog and run them in the separate job
        run: |
          cargo make test -E 'test(~rust_masm_tests::examples)'

  cargo_miden_integration_tests:
    name: cargo-miden integration tests
    runs-on: ubuntu-latest
    # We only want to run the integration tests if the unit tests pass, and that has the added
    # benefit that we can re-use the cache from the unit test job for all integration tests
    needs: [unit_tests]
    steps:
      - uses: actions/checkout@v5
      - name: Install Rust
        run: |
          rustup update --no-self-update
          rustc --version
      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: ${{ github.workflow }}-shared-tests
          prefix-key: ${{ env.RUST_CACHE_KEY }}
          # Do not persist the cache, leave that to the unit tests, we just use the cache here
          save-if: false
      - name: Install cargo-make
        run: |
          if ! cargo make --version 2>/dev/null; then
            cargo install cargo-make --force
          fi
      - name: Test
        # Skip running the some test since they are a disc space hog.
        run: |
          cargo make test -E 'package(cargo-miden) - test(new_project_integration_tests_pass) - test(test_all_templates_and_examples)'

  cargo_miden_tests_mpt:
    name: cargo-miden test Miden project template
    runs-on: ubuntu-latest
    # We only want to run the integration tests if the unit tests pass, and that has the added
    # benefit that we can re-use the cache from the unit test job for all integration tests
    needs: [unit_tests]
    steps:
      - uses: actions/checkout@v5
      - name: Install Rust
        run: |
          rustup update --no-self-update
          rustc --version
      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: ${{ github.workflow }}-shared-tests
          prefix-key: ${{ env.RUST_CACHE_KEY }}
          # Do not persist the cache, leave that to the unit tests, we just use the cache here
          save-if: false
      - name: Install cargo-make
        run: |
          if ! cargo make --version 2>/dev/null; then
            cargo install cargo-make --force
          fi
      - name: Test
        run: |
          cargo make test -E 'test(new_project_integration_tests_pass)'

  cargo_miden_tests_templates_and_examples:
    name: cargo-miden test new project templates and examples
    runs-on: ubuntu-latest
    # We only want to run the integration tests if the unit tests pass, and that has the added
    # benefit that we can re-use the cache from the unit test job for all integration tests
    needs: [unit_tests]
    steps:
      - uses: actions/checkout@v5
      - name: Install Rust
        run: |
          rustup update --no-self-update
          rustc --version
      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: ${{ github.workflow }}-shared-tests
          prefix-key: ${{ env.RUST_CACHE_KEY }}
          # Do not persist the cache, leave that to the unit tests, we just use the cache here
          save-if: false
      - name: Install cargo-make
        run: |
          if ! cargo make --version 2>/dev/null; then
            cargo install cargo-make --force
          fi
      - name: Test
        run: |
          cargo make test -E 'test(test_all_templates_and_examples)'

  miden_integration_node_tests:
    name: miden integration node tests
    runs-on: ubuntu-latest
    # We only want to run the integration tests if the unit tests pass, and that has the added
    # benefit that we can re-use the cache from the unit test job for all integration tests
    needs: [unit_tests]
    steps:
      - uses: actions/checkout@v5
      - name: Install Rust
        run: |
          rustup update --no-self-update
          rustc --version
      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: ${{ github.workflow }}-shared-tests
          prefix-key: ${{ env.RUST_CACHE_KEY }}
          # Do not persist the cache, leave that to the unit tests, we just use the cache here
          save-if: false
      - name: Install cargo-make
        run: |
          if ! cargo make --version 2>/dev/null; then
            cargo install cargo-make --force
          fi
      - name: Test
        run: |
          # Run sequentially as a workaround until
          # https://github.com/0xMiden/compiler/issues/766 is resolved
          cargo make test -E 'package(miden-integration-node-tests)' --test-threads 1

  cargo_publish_dry_run:
    name: cargo publish dry run
    runs-on: ubuntu-latest
    needs: [unit_tests]
    steps:
      - uses: actions/checkout@v5
      - name: Install Rust
        run: |
          rustup update --no-self-update
          rustc --version
      - name: Cache Cargo
        uses: Swatinem/rust-cache@v2
        with:
          # Use a common cache for the basic compilation/formatter/clippy checks
          shared-key: ${{ github.workflow }}-shared
          prefix-key: ${{ env.RUST_CACHE_KEY }}
          save-if: ${{ github.ref == 'refs/heads/next' }}
      - name: Install cargo-make
        run: |
          if ! cargo make --version 2>/dev/null; then
            cargo install cargo-make --force
          fi
      - name: cargo publish dry run
        # Simulate publishing to uncover any build errors when each crate folder is built in isolation
        run: |
          cargo make publish-dry-run
