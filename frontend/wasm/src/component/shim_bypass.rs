use midenc_hir::FxHashMap;

use crate::module::module_env::ParsedModule;

/// Checks if a module is a shim module generated by wit-component for indirect lowering.
///
/// Shim modules have these characteristics:
/// 1. Export a table named "$imports"
/// 2. Export functions (may have numeric names or other patterns)
/// 3. Functions contain only call_indirect instructions
/// 4. Usually have minimal imports
pub fn is_shim_module(module: &ParsedModule) -> bool {
    log::trace!(target: "shim-bypass",
        "Checking if module is shim module. Exports: {:?}",
        module.module.exports.keys().collect::<Vec<_>>()
    );

    // Check for table export named "$imports"
    let has_imports_table = module.module.exports.iter().any(|(name, _)| *name == "$imports");
    log::trace!(target: "shim-bypass", "Has $imports table: {}", has_imports_table);

    // If it has the $imports table, it's likely a shim module
    if has_imports_table {
        // Additional checks to confirm it's a shim module
        let has_function_exports =
            module.module.exports.iter().any(|(_, entity)| {
                matches!(entity, crate::module::types::EntityIndex::Function(_))
            });

        // Shim modules typically have few imports (or none)
        let has_few_imports = module.module.imports.len() <= 2;

        let is_shim = has_function_exports && has_few_imports;
        log::debug!(target: "shim-bypass",
            "Module is shim: {} (has_imports_table: {}, has_function_exports: {}, \
             has_few_imports: {})",
            is_shim,
            has_imports_table,
            has_function_exports,
            has_few_imports
        );

        return is_shim;
    }

    // Fallback: check for minimal shim module characteristics
    // A shim module typically has a table export and minimal other structure
    let has_table_export = module
        .module
        .exports
        .iter()
        .any(|(_, entity)| matches!(entity, crate::module::types::EntityIndex::Table(_)));

    let has_minimal_structure =
        module.module.exports.len() <= 3 && module.module.imports.len() <= 2;

    let is_shim = has_table_export && has_minimal_structure;
    log::debug!(target: "shim-bypass",
        "Module is shim (fallback): {} (has_table_export: {}, has_minimal_structure: {})",
        is_shim,
        has_table_export,
        has_minimal_structure
    );

    is_shim
}

/// Checks if a module is a fixup module that wires up the shim module's table.
///
/// Fixup modules have these characteristics:
/// 1. Import a table named "$imports"
/// 2. Import functions (the actual canon lower functions)
/// 3. Have element sections that populate the table
pub fn is_fixup_module(module: &ParsedModule) -> bool {
    log::trace!(target: "shim-bypass",
        "Checking if module is fixup module. Imports: {:?}",
        module.module.imports.iter().map(|i| (&i.module, &i.field)).collect::<Vec<_>>()
    );

    // Check for table import named "$imports"
    let has_imports_table = module.module.imports.iter().any(|import| {
        let is_imports_table = import.module.is_empty() && import.field == "$imports";
        if is_imports_table {
            log::trace!(target: "shim-bypass", "Found $imports table import");
        }
        is_imports_table
    });

    log::debug!(target: "shim-bypass", "Module is fixup: {}", has_imports_table);
    has_imports_table
}

/// Extracts the mapping from shim function names to their indices in the indirect call table
pub fn extract_shim_mappings(shim_module: &ParsedModule) -> FxHashMap<String, u32> {
    let mut mappings = FxHashMap::default();

    // The shim module exports functions like "indirect-miden:cross-ctx-account-word/foo@1.0.0-process-word"
    // Each function does a call_indirect with a specific table index
    for (export_name, entity) in &shim_module.module.exports {
        if export_name.starts_with("indirect-")
            && matches!(entity, crate::module::types::EntityIndex::Function(_))
        {
            // Extract the original import name from the shim function name
            // "indirect-miden:cross-ctx-account-word/foo@1.0.0-process-word" -> "miden:cross-ctx-account-word/foo@1.0.0"
            let import_name = export_name
                .strip_prefix("indirect-")
                .and_then(|s| {
                    // Find the last '-' which separates the module name from the function name
                    s.rfind('-').map(|pos| &s[..pos])
                })
                .unwrap_or(export_name);

            // Map the import name to its function index
            // This assumes the shim module's function indices correspond directly to the imports
            let func_idx = entity.unwrap_func();
            mappings.insert(import_name.to_string(), func_idx.as_u32());
        }
    }

    mappings
}

/// Information about how to bypass shim modules
#[derive(Debug, Default)]
pub struct ShimBypassInfo {
    /// Indices of modules that are shim modules and should be skipped (using ModuleIndex values)
    pub shim_module_indices: Vec<u32>,
    /// Indices of modules that are fixup modules and should be skipped (using ModuleIndex values)
    pub fixup_module_indices: Vec<u32>,
    /// Static module indices that are shim modules (using StaticModuleIndex values)
    pub shim_static_modules: Vec<u32>,
    /// Static module indices that are fixup modules (using StaticModuleIndex values)
    pub fixup_static_modules: Vec<u32>,
    /// Set of module instance indices that are shim instances
    pub shim_instance_indices: Vec<u32>,
}
