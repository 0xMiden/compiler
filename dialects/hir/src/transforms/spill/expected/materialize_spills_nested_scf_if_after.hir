public builtin.function @test::spill_nested_scf_if(v0: ptr<element, u8>) -> u32 {
^block1(v0: ptr<element, u8>):
    v2 = hir.ptr_to_int v0 : u32;
    v3 = arith.constant 32 : u32;
    v4 = arith.add v2, v3 : u32 #[overflow = unchecked];
    v5 = hir.int_to_ptr v4 : ptr<element, u128>;
    v6 = hir.load v5 : u128;
    v7 = arith.constant 64 : u32;
    v8 = arith.add v2, v7 : u32 #[overflow = unchecked];
    v9 = hir.int_to_ptr v8 : ptr<element, u128>;
    v10 = hir.load v9 : u128;
    v11 = arith.constant 1 : u64;
    hir.store_local v5 #[local = lv0];
    v12 = hir.exec @test/example(v9, v6, v10, v10, v11) : u32
    v13 = arith.constant 0 : u32;
    v14 = arith.eq v12, v13 : i1;
    v15 = scf.if v14 : u32 {
    ^block3:
        v18 = hir.load_local  : ptr<element, u128> #[local = lv0];
        hir.store v18, v4;
        scf.yield v12;
    } else {
    ^block4:
        v19 = hir.load_local  : ptr<element, u128> #[local = lv0];
        hir.store v19, v4;
        scf.yield v12;
    };
    cf.br ^block2(v15);
^block2(v1: u32):
    builtin.ret v1;
};