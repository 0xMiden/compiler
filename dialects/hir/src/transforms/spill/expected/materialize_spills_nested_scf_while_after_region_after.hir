public builtin.function @test::spill_nested_scf_while(v0: ptr<element, u8>) -> u32 {
^block1(v0: ptr<element, u8>):
    v2 = hir.ptr_to_int v0 : u32;
    v3 = arith.constant 32 : u32;
    v4 = arith.add v2, v3 : u32 #[overflow = unchecked];
    v5 = hir.int_to_ptr v4 : ptr<element, u128>;
    v6 = hir.load v5 : u128;
    v7 = arith.constant 64 : u32;
    v8 = arith.add v2, v7 : u32 #[overflow = unchecked];
    v9 = hir.int_to_ptr v8 : ptr<element, u128>;
    v10 = hir.load v9 : u128;
    v11 = arith.constant 1 : u64;
    v12 = hir.exec @test/example(v9, v6, v10, v10, v11) : u32
    v13 = arith.constant 0 : u32;
    v14 = arith.eq v12, v13 : i1;
    scf.while {
    ^block3:
        scf.condition v14;
    } do {
    ^block4:
        v15 = arith.constant 72 : u32;
        v16 = arith.add v2, v15 : u32 #[overflow = unchecked];
        hir.store v5, v4;
        hir.store v5, v16;
        scf.yield ;
    };
    cf.br ^block2(v12);
^block2(v1: u32):
    builtin.ret v1;
};